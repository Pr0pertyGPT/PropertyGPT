SpecHash,SpecIndex,Type,Name,StartLine,EndLine,MethodsInRule,RuleContent,RelatedFunctions,FunctionBodies,FilePath,ContractCode,StateVarAssignment,RuleContentNL
005b6ddff4b8e17b64f187f8704dfbbf,2291 | 2293 | 2294,rule,sameReturnOfSplitAndSplitResults,311,347,split | _setSplits | _assertSplitsValid,"rule sameReturnOfSplitAndSplitResults() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    require userA_Id != userB_Id;   require userA_Id != userC_Id;   require userB_Id != userC_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require length == 2;
    require index1 != index2;
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 > 0;
    require weight2 > 0;
    require weight1 + weight2 <= 1000000;  // safe assumptions
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we force the receivers to be only two, therefore totalWeight = weight1 + weight2
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // calling splitResults() upon userA with amount = userA.splittable
    uint128 userA_splitAmt_splitResults; uint128 userA_collectableAmt_splitResults;
    userA_collectableAmt_splitResults, userA_splitAmt_splitResults = splitResults(e, userA_Id, true, userA_splittableBefore);
    
    // calling split() on userA
    uint128 userA_collectableAmt_split; uint128 userA_splitAmt_split;
    userA_collectableAmt_split, userA_splitAmt_split = split(e, userA_Id, assetId, true);
    assert userA_collectableAmt_split == userA_collectableAmt_splitResults;
    assert userA_splitAmt_split == userA_splitAmt_splitResults;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
00855ecd93ee4c0c11781cfdefe45ac9,2356,rule,unrelatedUserBalanceNotChangingParametric,513,562,_dripsState,"rule unrelatedUserBalanceNotChangingParametric(
        method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
    env e; env eB; env eF;
    calldataarg args;

    // step 1 - balance before of receiverId
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
    uint256 userId1; uint256 config1;
    uint256 userId2; uint256 config2;
    uint256 userId3; uint256 config3;
    userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
    DH.DripsReceiver argsReceiver1;
    require argsReceiver1.userId == userId1;
    require argsReceiver1.config == config1;
    DH.DripsReceiver argsReceiver2;
    require argsReceiver2.userId == userId2;
    require argsReceiver2.config == config2;
    DH.DripsReceiver argsReceiver3;
    require argsReceiver3.userId == userId3;
    require argsReceiver3.config == config3;
    require argsReceiver1.userId != receiverId;
    require argsReceiver2.userId != receiverId;
    require argsReceiver3.userId != receiverId;
    f(e, args);
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
    //assert false;
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHubBackup.spec,,Yes,
008d968f71dbd1a067728b60378ee86d,1420 | 1421,rule,transferMethodsRevertWhenPaused,24,28,safeTransferFrom | safeBatchTransferFrom,"rule transferMethodsRevertWhenPaused (method f)
filtered {
    f -> f.selector == safeTransferFrom(address,address,uint256,uint256,bytes).selector
      || f.selector == safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
","safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155Pausable.spec,,Yes,
010445e39eaa71f2e4d984c3296ae5da,2194,invariant,empty_pool_state,150,156,collectProtocolFees,"    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
0136f74455fd5a71136c61aaa8a1e293,2469 | 2470 | 2471 | 2472,rule,op_tokenIncentivesBalanceUnchange,751,764,withdrawIncentives | emergencyWithdraw | allowEmergencyWithdraw | initialize,"rule op_tokenIncentivesBalanceUnchange(method f, env e){
    require pair() == 0;                    // withdrawIncentives()
    requireInvariant op_not_stopped();      // emergencyWithdraw()
invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
    requireInvariant isInitialized();       // initialize()
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
    {
        preserved{
            requireInvariant notStoppedIfNonInitialized();
        }
    }
    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();
    assert tokenIncentivesBalanceBefore == tokenIncentivesBalanceAfter, ""tokenIncentivesBalance was changed"";
}
","withdrawIncentives (Lines 473-491),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
01adaa8f05c8d61bed3cb8e9aaf9924e,2218,rule,empty_pool_zero_totalSupply,381,386,collectProtocolFees,"///// rule empty_pool_zero_totalSupply()
////  verifies that pool is empty IFF totalSupply == 0
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  collectProtocolFees() - it breakes the rule
rule empty_pool_zero_totalSupply(method f, address to)
filtered { f -> excludeCallback(f) }{
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
028f3b83f905d744d2450dcd6fbf4e4a,1629 | 1631 | 1632,rule,delegates_safe,167,169,delegate | delegateBySig | _delegate,"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
","delegate (Lines 95-98),  | delegateBySig (Lines 103-120),  | _delegate (Lines 127-133), ","    function delegate(address delegatee) public virtual override {
        address account = _msgSender();
        _delegate(account, delegatee);
    }
 |     function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= expiry, ""Votes: signature expired"");
        address signer = ECDSA.recover(
            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),
            v,
            r,
            s
        );
        require(nonce == _useNonce(signer), ""Votes: invalid nonce"");
        _delegate(signer, delegatee);
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
02c2786803dc8418e6fad9709e745c2f,931,rule,nonExecutableWithInitializedSender,461,473,registry.isValidCaller,"rule nonExecutableWithInitializedSender(method f) {
    require !isHandler();
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;

    arbitrary(f);
    assert ethBalance(currentContract) == 0;
}
    require !f.isView; // only non-view functions, that may modify the state, are interesting.
    require getSender() != 0; // sender is initialized
    env e;
    bool isGoodCaller = registry.isValidCaller(e, e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    assert (f.isFallback && !isGoodCaller) => lastReverted; // only valid callers should execute in fallback successfully (would violate since certora prover cannot distinguish between receive and fallback for now)
    assert (f.selector == execs(address[],bytes32[],bytes[]).selector && e.msg.sender != currentContract) => lastReverted; // `execs` is allowed to be called by proxy itself after initialized
    assert (!f.isFallback && f.selector != execs(address[],bytes32[],bytes[]).selector) => lastReverted; // all non-view functions other than above ones should revert if sender is already initialized
","isValidCaller (Lines 133-137), ","    function isValidCaller(
        address caller
    ) external view override returns (bool) {
        return callers[caller] != 0 && callers[caller] != DEPRECATED;
    }
",./furucombo/specs/proxy.spec,,Yes,
02ca98dfad2c23841fca242854819613,1737 | 1738 | 1739,rule,successOfAddCollateral,101,123,addShort | addLong | addCollateral,"rule successOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	require x > 0;
	require index < MAXINT();
	// require index <= collateralAmountLength();
	if (index < collateralAmountLength()) {
		require asset == getCollateralAsset(index);
		require getCollateralAmount(index) + x < MAXINT();

		invoke addCollateral(asset, x, index);
		assert !lastReverted, ""addCollateral may revert when precondition holds"";
	else if ((index == collateralAmountLength())) {
	else {
		assert lastReverted, ""addCollateral may not revert when precondition not holds"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
032167bdba6fbf63a8097a8c6db64d03,957 | 958,rule,banningIsReversible,88,102,ban | unban,"rule banningIsReversible(address agent, method f) {
    require owner() != 0;
    env e;
    ban(e, agent);

    // call some function for covering more cases
    require f.selector != unban(address).selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    unban@withrevert(e2, agent);
    assert !lastReverted, ""Unbanning should succeed"";
}
","ban (Lines 106-109),  | unban (Lines 114-117), ","    function ban(address agent) external isNotBanned(agent) onlyOwner {
        bannedAgents[agent] = 1;
        emit Banned(agent);
    }
 |     function unban(address agent) external isBanned(agent) onlyOwner {
        bannedAgents[agent] = 0;
        emit Unbanned(agent);
    }
",./furucombo/specs/registry.spec,,Yes,
035afa2d61258cc3cf216c9998a162af,1019 | 1020,rule,disallowedFunctionalities,133,151,updateDiscountDistribution | rebalanceUserDiscountPercent,"use rule disallowedFunctionalities

/**
* @title proves that a user's discount rate can be updated only by calling rebalanceUserDiscountPercent
* This rule fails since updateDiscountDistribution, mint and burn can recalculate and update the user discount rate
**/
// rule onlyRebalanceCanUpdateUserDiscountRate(method f) {
// 	address user;
// 	uint256 discRateBefore = getUserDiscountRate(user);
// 	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	env e;
// 	calldataarg args;
// 	f(e,args);
// 	uint256 discRateAfter = getUserDiscountRate(user);
// 	assert(discRateAfter != discRateBefore => f.selector == rebalanceUserDiscountPercent(address).selector);
// }
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
03a901f0ba4251476606c302893e2f4b,1505,rule,noTransferEffectOnApproval,385,398,safeTransferFrom,"rule noTransferEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256 id; uint256 amount; 
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeTransferFrom(e, from, to, id, amount, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
","safeTransferFrom (Lines 117-129), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
044344c9621080c582443c45d4ccd349,2413 | 2414 | 2415,invariant,op_avax_alloc_zero,412,432,createPair | allowEmergencyWithdraw | initialize,"invariant op_avax_alloc_zero()
    pair() == 0 => avaxAllocated() == 0

// STATUS - verified
//  - lpSupply is 0
invariant op_lp_supply_zero()
    pair() == 0 => lpSupply() == 0
// createPair() violates the property: https://vaas-stg.certora.com/output/3106/6453fa43e1396eb864ad/?anonymousKey=c6322b9a791cdbea942221268091c2c963405500
// - pair.balanceOf(address(this)) == 0
invariant opPairBalanceIsZero()
    pair() == 0 => getPairBalanceOfThis() == 0
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
046f05ee6551a1620728f9a265146e22,1117,rule,handleRepayment_after_transferUnderlyingTo,109,126,transferUnderlyingTo,"// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;

// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
","transferUnderlyingTo (Lines 156-158), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
",./gho-core/ghoAToken.spec,,Yes,
050a1318d8f5f1f966d841830505720e,1956,rule,onlyValidOtoken,274,293,smallVault,"rule onlyValidOtoken(address owner, uint256 vaultId, uint256 index, address otoken, method f) {
    links();
    require shortOtoken.underlyingAsset() == underlying;
    require longOtoken.underlyingAsset() == underlying;
    require shortOtoken.strikeAsset() == strike;
    require longOtoken.strikeAsset() == strike;
    require shortOtoken.collateralAsset() == collateralToken;
    require longOtoken.collateralAsset() == collateralToken;
    require smallVault(owner, vaultId, 1);
    require (otoken == shortOtoken || otoken == longOtoken );
    require ( getVaultShortOtoken(owner, vaultId, index) == otoken || getVaultLongOtoken(owner, vaultId, index) == otoken) 
            => whitelist.isWhitelistedOtoken(otoken);
    uint256 before = pool.getStoredBalance(otoken);
    uint256 totalSupplyBefore = assetTotalSupply(otoken);
    require !whitelist.isWhitelistedCollateral(otoken);
    callFunctionWithParameters(f, owner, vaultId, index);
    uint256 after = pool.getStoredBalance(otoken);
    uint256 totalSupplyAfter = assetTotalSupply(otoken);
    assert ( before != after || totalSupplyBefore != totalSupplyAfter) => whitelist.isWhitelistedOtoken(otoken);
}
","smallVault (Lines 53-66), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
0567294d237aab42e4368f373490459b,954,rule,unregisterHandlerIsPermanent2,72,78,unregister,"rule unregisterHandlerIsPermanent2(method f, address handler) {
rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
    require handlers(handler) == deprecated();
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,,Yes,
059592ec74f63bea30abb9ca75fc8e1a,1552 | 1555 | 1557,rule,possibleTotalVotes,116,139,execute | castVote | proposalVotes,"rule possibleTotalVotes(uint256 pId, uint8 sup, env e, method f) {

    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));
    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
","execute (Lines 96-104),  | castVote (Lines 413-416),  | proposalVotes (Lines 50-62), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {
        address voter = _msgSender();
        return _castVote(proposalId, voter, support, """");
    }
 |     function proposalVotes(uint256 proposalId)
        public
        view
        virtual
        returns (
            uint256 againstVotes,
            uint256 forVotes,
            uint256 abstainVotes
        )
    {
        ProposalVote storage proposalvote = _proposalVotes[proposalId];
        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);
    }
",./openzepplin/specs/RulesInProgress.spec,,Yes,
06f4591b7c5302174fab9bad22859e7f,2166,rule,burnDoesNotIncreaseBalance,188,197,changeSupply,"rule burnDoesNotIncreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, amount);
	uint after = balanceOf(burned);
	assert before >= after;
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
0765b034c3629cf2fdf39501affaa88a,2541,rule,hl_onlyOwnerSwitch,197,206,allowEmergencyWithdraw,"rule hl_onlyOwnerSwitch(method f, env e){
    require !stopped();

    calldataarg args;
    allowEmergencyWithdraw(e);
    bool isStopped = stopped();
    assert isStopped => e.msg.sender == getOwner(), ""stopped was switch by wrong method"";
}
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
082d9e27f9db703fd254e9be3ecd63ff,1698 | 1700,rule,cooldown,266,279,isOperationReady | schedule,"rule cooldown(method f, env e, env e2){
    bytes32 id;
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    uint256 minDelay = getMinDelay();

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    calldataarg args;
    f(e, args);
    assert isOperationReady(e2, id) => (e2.block.timestamp - e.block.timestamp >= minDelay), ""No rush! When I'm ready, I'm ready"";
}
","isOperationReady (Lines 148-151),  | schedule (Lines 214-225), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
 |     function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
08ed2ec1a9f33a399adf705dabed85ea,1539,rule,transfersHaveSameLengthInputArrays,861,878,safeBatchTransferFrom,"rule transfersHaveSameLengthInputArrays {
    env e;

    address recipient; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    uint max_int = 0xffffffffffffffffffffffffffffffff;
    require tokens.length >= 0 && tokens.length <= max_int;
    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;
    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);
    uint256 tokensLength = tokens.length;
    uint256 transferAmountsLength = transferAmounts.length;
    assert tokens.length == transferAmounts.length, 
        ""If transfer methods do not revert, the input arrays must be the same length"";
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
0945a51c6b396bbb7744303d2ce5b6a2,1499 | 1500,rule,transferBatchBalanceFromEffect,300,321,balanceOf | safeBatchTransferFrom,"rule transferBatchBalanceFromEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != to;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert from != other => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
09961ed97c1b3fd554fc854fbe72872a,2632,rule,toBaseIsMonotone,48,56,toBase,"rule toBaseIsMonotone {
    bool roundUp;
    uint x;
    uint y;
    require x < y;
    uint xToBase = toBase(x, roundUp);
    uint yToBase = toBase(y, roundUp);
    assert xToBase <= yToBase; 
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
09b731befc3e794b73c3d83ff44d2b98,2506,rule,hl_noDepositFrontRun,1237,1254,depositAVAX,"rule hl_noDepositFrontRun(method f, env e, env e2){
    require e.msg.sender != e2.msg.sender;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, ""frontrun on Deposit"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
0a5c17524fb37ed7f28eb74527c49da0,1224,rule,totalAssetsPreserved,215,225,seizeBond,"rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
0ab50333e9e0f234a3fc8d7851508941,2150 | 2153,rule,mintDoesNotDecreaseBalance,143,152,mint | changeSupply,"rule mintDoesNotDecreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	mint(e, burned, amount);
	uint after = balanceOf(burned);
	assert after >= before;
","mint (Lines 42-87),  | changeSupply (Lines 472-507), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
0b96cb242633f7cfe4c1bfac5d1bcd84,963,rule,executeDelegatesOnlyToAllowedAddresses,65,73,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(BACTIONS()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hbalancer.spec,,Yes,
0b98e96bc072889dd6362ca32821031f,418 | 419,rule,burnNoChangeToOther,271,287,balanceOf | burn,"rule burnNoChangeToOther(address user, address recieverOfUnderlying, uint256 amount, uint256 index, address other) 
{
  
	require other != user && other != recieverOfUnderlying;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, recieverOfUnderlying, amount, index);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,,Yes,
0bd3852a73d6b3f83a0575d529735d41,1449 | 1450 | 1451,rule,we,281,293,queue | execute | __acceptAdmin," // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","queue (Lines 90-107),  | execute (Lines 96-104),  | __acceptAdmin (Lines 168-170), ","    function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,,Yes,
0c4d061b17506aa71a5dcf237c7ac35c,1613 | 1617,rule,delegate_no_frontrunning,236,271,balanceOf | _delegate,"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
}","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,,Yes,
0c6606566087fa6636e8ad8630a1b72e,1403 | 1404,rule,depositsMustIncreaseCashBalance,3,10,deposit | getCashBalance,"rule depositsMustIncreaseCashBalance(address account, uint256 depositAmount) {
    env e;
    int256 cashBalance = getCashBalance(account);
    deposit(e, account, depositAmount);
    // check balanceOf ERC20 on account and contract

    assert cashBalance + depositAmount == getCashBalance(account);
}
","deposit (Lines 34-37),  | getCashBalance (Lines 80-84), ","    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
 |     function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
",./notional_finance_v2/certora/accountContext/Balances.spec,,Yes,
0ca81f9040073d2fec1a97d9de6c9e83,343 | 347 | 350,rule,integirtyBalanceOfTotalSupplyOnBurn,62,101,balanceOf | burn | if,"rule integirtyBalanceOfTotalSupplyOnBurn(address a, uint256 x)
rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	
	uint256 averageStableRateBefore = sinvoke getAverageStableRate(e);
	uint256 debtSupplyBefore = sinvoke rayWadMul(e, averageStableRateBefore, totalSupplyBefore);
	uint256 stableRateA = sinvoke getUserStableRate(e, a);
	uint256 repaidDebtA = sinvoke rayWadMul(e, stableRateA, x);
	sinvoke burn(e, a, x); 
	if(totalSupplyBefore > x) {
	    /* The amount being burned (x) is smaller than the total supply */
		if(repaidDebtA >= debtSupplyBefore) {
			/*
			The user debt being repaid is at least the debt supply.
			The total supply becomes 0.
			*/
			assert(totalSupplyAfter == 0);
		}
		else {
			assert(balanceAAfter != balanceABefore  =>
			(balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
	}
	else {
	/* The amount being burned (x) is at least the total supply.
	   The total supply becomes 0.
	*/
		assert (totalSupplyAfter == 0);
","balanceOf (Lines 106-115),  | burn (Lines 197-257),  | if (Lines 232-290), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
 |    * user calling the function if he wants to reduce/remove his own debt, or the address of any other
   * other borrower whose debt should be removed
   * @return The final amount repaid
   **/
  function repay(
    address asset,
    uint256 amount,
    uint256 rateMode,
    address onBehalfOf
  ) external override whenNotPaused returns (uint256) {
    DataTypes.ReserveData storage reserve = _reserves[asset];

    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);

    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);

    ValidationLogic.validateRepay(
      reserve,
      amount,
      interestRateMode,
      onBehalfOf,
      stableDebt,
      variableDebt
    );

    uint256 paybackAmount =
      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;

    if (amount < paybackAmount) {
      paybackAmount = amount;
    }

    reserve.updateState();

    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {
      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);
    } else {
      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(
        onBehalfOf,
        paybackAmount,
        reserve.variableBorrowIndex
      );
    }

    address aToken = reserve.aTokenAddress;
    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);

    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {
      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);
    }

    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);

    IAToken(aToken).handleRepayment(msg.sender, paybackAmount);

    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);

    return paybackAmount;
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
0d6904cd3ffe9cfd294659decc320b06,2274,rule,correctnessOfHashSplits,118,133,hashSplits,"rule correctnessOfHashSplits() {
    env e; uint256 index; uint256 length1; uint256 length2;  
    uint256 userId1; uint32 weight1; uint256 userId2; uint32 weight2;
    bytes32 receiversHash1; bytes32 receiversHash2;

    length1 = getCurrSplitsReceiverLocaLength(e, true);
    length2 = getCurrSplitsReceiverLocaLength(e, false);
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index);
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, false, index);
    receiversHash1 = hashSplits(e, true);
    receiversHash2 = hashSplits(e, false);
    assert (receiversHash1 == receiversHash2) => ((length1 == length2) && (userId1 == userId2) && (weight1 == weight2));
}
","hashSplits (Lines 523-529), ","    function hashSplits(SplitsReceiver[] memory receivers)
        public
        pure
        returns (bytes32 receiversHash)
    {
        return Splits._hashSplits(receivers);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
0ec9a139fed5b159ecca1537d0d4c4bd,715,rule,verifies,110,123,getPendingWithdrawalsIndex," * This rule verifies the Certora Prover is correctly modeling the behavior of GoldToken._transfer.
 */
rule withdraw(uint256 index) {
	env e;
	uint256 _balance = sinvoke ercBalanceOf(e.msg.sender);
	uint256 val = sinvoke getPendingWithdrawalsIndex(e.msg.sender, index);
	sinvoke withdraw(e, index);
	require (e.msg.sender != currentContract);
	uint256 balance_ = sinvoke ercBalanceOf(e.msg.sender);
	assert(
    _balance + val == balance_,
    ""Withdraw balance not updated""
  );
}
","getPendingWithdrawalsIndex (Lines 22-29), ","  function getPendingWithdrawalsIndex(address account, uint256 index) public returns (uint256) {
    require(getAccounts().isAccount(account), ""Unknown account"");
    require(
      index < balances[account].pendingWithdrawals.length,
      ""Index cannot exceed pending withdrawals length""
    );
    return balances[account].pendingWithdrawals[index].value;
  }
",./celo_governance/specs/lockedGold.spec,,Yes,
0eca4799213831ac2a589eb398a724fb,1414,invariant,balanceOfZeroAddressIsZero,56,71,balanceOf,"invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,,Yes,
0ee866cf04b0e092a596b6ba5fb20c1b,104 | 105,rule,noIncarnations2,199,204,execute | getCurrentState,"rule noIncarnations2(uint256 actionsSetId)
{
	env e;
	execute(e, actionsSetId);
	assert getCurrentState(e, actionsSetId) != 0;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
0f2649fd976a6fd8dbf72e46bb229ed1,274 | 275,rule,getClaimableRewards_stable_after_atoken_transferFrom,560,575,_AToken.transferFrom | initialize,"rule getClaimableRewards_stable_after_atoken_transferFrom()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","transferFrom (Lines 99-121),  | initialize (Lines 68-87), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
0fa945867afa6a3aac84681657b453de,2461 | 2462,rule,op_balanceChangeByDepositOrWithdraw,697,708,depositAVAX | withdrawAVAX,"rule op_balanceChangeByDepositOrWithdraw(method f, env e){     
    address user;

    uint256 balanceBefore = getUserBalance(user);
    calldataarg args;
    f(e, args);
    uint256 balanceAfter = getUserBalance(user);
    assert balanceBefore != balanceAfter <=> (e.msg.sender == user && (f.selector == depositAVAX().selector || f.selector == withdrawAVAX(uint256).selector)), ""pair was changed by wrong method"";
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
102ab15f7889b3b711c724608fba9f17,945,rule,executeDelegatesOnlyToAllowedAddresses,59,67,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(getProxyActions()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hmaker.spec,,Yes,
11af76f89f8ed9916919a17956af0eb9,2341 | 2343 | 2344,rule,cannotFrontRunSplitThreeSameUsers,164,206,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,,Yes,
124a439d5ddf3f04341d81deabc44736,1604 | 1608,rule,sanity,200,217,balanceOf | _delegate,"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,,Yes,
128f7992885aeaf61914ff90925752e5,765,rule,cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy,290,294,authorizeSignerWithSignature,"rule cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
} {
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,,Yes,
136c7125c667a5318d75cb0c17bfbc38,2213,rule,totalSupply_vs_positionAmounts,323,346,position_Liquidity,"///// rule totalSupply_vs_positionAmounts()
////  verifies that totalSupply before applying f() greater than totalSupply after implies posistion 
////  liquidity before is greater than position liquidity after minus last compound liquidity
rule totalSupply_vs_positionAmounts(method f){
   env e;

   uint256 totalSupplyBefore = totalSupply();
   uint256 posLiquidityBefore = position_Liquidity();
    require governance() != currentContract;
    require governance() != pool;
   require lastCompoundLiquidity(e) == 0;
   calldataarg args;
	f(e,args);
   uint256 totalSupplyAfter = totalSupply();
   uint256 posLiquidityAfter = position_Liquidity();   
   uint256 compoundAfter = lastCompoundLiquidity(e);
    assert totalSupplyAfter < totalSupplyBefore =>
            posLiquidityAfter - compoundAfter < posLiquidityBefore;
}
","position_Liquidity (Lines 692-695), ","    function position_Liquidity() public returns (uint128){
        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
        return liquidity;
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
139286964f1450f902d49e41aa564621,787,rule,no_promoting_without_upvotes,55,74,dequeueProposalsIfReady,"rule no_promoting_without_upvotes(uint256 p, uint256 index) {
	// Can a proposal be promoted with 0 votes? 
	env _e;
	env eF;
	env e_;
	
	/* would actually want forall index. inrange(index) => dequeued[index] != p but here its suffice to 'pre-guess' the index of the proposal we dequeue */
	// a utility rule for figuring out which methods could dequeue and whether it's all due to dequeueProposalsIfReady calls.

	// require index to be valid and to be empty
	require index >= 0;
	uint256 queueLength = getDequeuedLength();
	require index <= queueLength || index == queueLength+1; // either an empty index or the next one we push
	// if it's an empty index in the range, then it's empty
	require index <= queueLength => getFromDequeued(index) == 0;
	callArbitrary(f);
	uint256 newValueInDequeued = getFromDequeued(index);
	assert newValueInDequeued == 0, ""Method caused a dequeue of proposal $newValueInDequeued to index $index"";	
}
rule promote_proposal(method f, uint256 p, uint256 index) filtered { f -> !f.isView } {
	require p > 0; // proposal 0 is not legal, and cannot happen (we check it)
	uint256 _upvotes = getUpvotes(p);
	dequeueProposalsIfReady(eF);
	assert getFromDequeued(index) == p => _upvotes > 0, ""Cannot dequeue (promote) proposal $p to index $index unless had some upvotes"";
}","dequeueProposalsIfReady (Lines 1222-1258), ","  function dequeueProposalsIfReady() public {
    // solhint-disable-next-line not-rely-on-time
    if (now >= lastDequeue.add(dequeueFrequency)) {
      uint256 numProposalsToDequeue = Math.min(concurrentProposals, queue.list.numElements);
      uint256[] memory dequeuedIds = queue.popN(numProposalsToDequeue);

      bool wasAnyProposalDequeued = false;
      for (uint256 i = 0; i < numProposalsToDequeue; i = i.add(1)) {
        uint256 proposalId = dequeuedIds[i];
        Proposals.Proposal storage proposal = proposals[proposalId];
        if (_isQueuedProposalExpired(proposal)) {
          emit ProposalExpired(proposalId);
          continue;
        }
        refundedDeposits[proposal.proposer] = refundedDeposits[proposal.proposer].add(
          proposal.deposit
        );
        // solhint-disable-next-line not-rely-on-time
        proposal.timestamp = now;
        if (emptyIndices.length != 0) {
          uint256 indexOfLastEmptyIndex = emptyIndices.length.sub(1);
          dequeued[emptyIndices[indexOfLastEmptyIndex]] = proposalId;
          delete emptyIndices[indexOfLastEmptyIndex];
          emptyIndices.length = indexOfLastEmptyIndex;
        } else {
          dequeued.push(proposalId);
        }
        // solhint-disable-next-line not-rely-on-time
        emit ProposalDequeued(proposalId, now);
        wasAnyProposalDequeued = true;
      }
      if (wasAnyProposalDequeued) {
        // solhint-disable-next-line not-rely-on-time
        lastDequeue = now;
      }
    }
  }
",./celo_governance/specs/goverance_with_dequeue.spec,,Yes,
13cbf3ddc9932f6a669ae88c393a9252,621 | 622,rule,burnNoChangeToOther,213,225,balanceOf | burn,"rule burnNoChangeToOther(address user, uint256 amount, uint256 index, address other) {
  
	require other != user;
	
	env e;
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, amount, index);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
13fea1ece0eb313798889889295526d2,1501 | 1502,rule,transferBatchBalanceToEffect,326,347,balanceOf | safeBatchTransferFrom,"rule transferBatchBalanceToEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != from;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
146389912a7f6292a03b4b8ba18cef46,32 | 33,rule,noIncarnations2,198,203,execute | getCurrentState,"rule noIncarnations2(uint256 actionsSetId)
{
	env e;
	execute(e, actionsSetId);
	assert getCurrentState(e, actionsSetId) != 0;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
14cf6320047978a642f36687a56bc865,2538 | 2539,rule,hl_noWithdrawLiquidityFrontRun,155,178,withdrawLiquidity | pairBalance,"rule hl_noWithdrawLiquidityFrontRun(method f, env e, env e2){
    require e.msg.sender != e2.msg.sender;
    require e.msg.sender != currentContract;
    require e2.msg.sender != currentContract;
    require closed();
    safeAssumptions(e);

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getPairBalance(e.msg.sender);
    uint256 whatShouldGet1 = pairBalance(e, e.msg.sender);
    withdrawLiquidity(e);
    uint256 userBalanceAfter1 = getPairBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 whatShouldGet2 = pairBalance(e, e.msg.sender);
    uint256 userBalanceAfter2 = getPairBalance(e.msg.sender);
    assert whatShouldGet1 == whatShouldGet2, ""should get differs"";
    assert userBalanceBefore + whatShouldGet1 == userBalanceAfter1 && userBalanceBefore + whatShouldGet2 == userBalanceAfter2, ""frontrun on WithdrawLiquidity"";
}
","withdrawLiquidity (Lines 453-470),  | pairBalance (Lines 623-632), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
14f64ff4da3c2454264de5bbcc9f4319,1029 | 1030,rule,onlyCertainFunctionsCanModifyScaledBalance,225,245,updateDiscountDistribution | rebalanceUserDiscountPercent,"rule onlyCertainFunctionsCanModifyScaledBalance(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = scaledBalanceOf(user);
	uint256 balanceAfterOp = scaledBalanceOf(user);
	assert(balanceAfterOp != balanceBeforeOp => (
		(f.selector == mint(address ,address ,uint256 ,uint256).selector) ||
		(f.selector == burn(address ,uint256 ,uint256).selector) ||
		(f.selector == updateDiscountDistribution(address ,address ,uint256 ,uint256 ,uint256).selector) ||
		(f.selector == rebalanceUserDiscountPercent(address).selector)));
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
15a880ab42e336b40741cbed721b28d0,2271,rule,correctnessOfGive,86,95,give,"rule correctnessOfGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint128 splittableBefore; uint128 splittableAfter;

    splittableBefore = splittable(e, receiver, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, receiver, assetId);
    assert splittableAfter == splittableBefore + amt;
}
","give (Lines 65-72), ","    function give(
        uint256 receiver,
        IERC20 erc20,
        uint128 amt
    ) public {
        _transferFromCaller(erc20, amt);
        dripsHub.give(calcUserId(msg.sender), receiver, erc20, amt);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
167a69be889b9a08f5691e704616a1e9,615 | 616,rule,integrityMint,182,199,mint | balanceOf,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	uint256 index = gRNVB();
	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e, delegatedUser, a, x, index);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);

	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
    assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
    // assert balanceAfter == balancebefore+x;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
172b126d74fd4b7f46a10cdaadc8bd21,2140 | 2141,rule,changesRebaseState,79,90,rebaseOptIn | rebaseOptOut,"rule changesRebaseState(method f) {
	address who;
	
	uint8 _rebaseState = rebaseState(who);
	executeAFunction(f);
	uint8 rebaseState_ = rebaseState(who);
	assert _rebaseState == rebaseState_ 
			|| f.selector == rebaseOptIn().selector 
			|| f.selector == rebaseOptOut().selector;
}
","rebaseOptIn (Lines 424-445),  | rebaseOptOut (Lines 450-464), ","    function rebaseOptIn() public nonReentrant {
        require(_isNonRebasingAccount(msg.sender), ""Account has not opted out"");

        // Convert balance into the same amount at the current exchange rate
        uint256 newCreditBalance = _creditBalances[msg.sender]
            .mul(rebasingCreditsPerToken)
            .div(_creditsPerToken(msg.sender));

        // Decreasing non rebasing supply
        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));

        _creditBalances[msg.sender] = newCreditBalance;

        // Increase rebasing credits, totalSupply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.add(_creditBalances[msg.sender]);

        rebaseState[msg.sender] = RebaseOptions.OptIn;

        // Delete any fixed credits per token
        delete nonRebasingCreditsPerToken[msg.sender];
    }
 |     function rebaseOptOut() public nonReentrant {
        require(!_isNonRebasingAccount(msg.sender), ""Account has not opted in"");

        // Increase non rebasing supply
        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));
        // Set fixed credits per token
        nonRebasingCreditsPerToken[msg.sender] = rebasingCreditsPerToken;

        // Decrease rebasing credits, total supply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.sub(_creditBalances[msg.sender]);

        // Mark explicitly opted out of rebasing
        rebaseState[msg.sender] = RebaseOptions.OptOut;
    }
",./ousd/spec/ousd.spec,,Yes,
186d1216c00af5831102e098398b90a7,1971,rule,redeem,74,99,redeemA,"rule redeem (address oToken, address to, address collateral, uint256 amount) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;

    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
}
","redeemA (Lines 344-347), ","  function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
",./opyn_gamma_protocol/specs/controller.spec,,Yes,
188b9e61449b74e385bce0db920a8a2f,555,rule,setSiloedBorrowingIntegrity,109,112,setSiloedBorrowing,"rule setSiloedBorrowingIntegrity(bool siloed) {
    setSiloedBorrowing(siloed);
    assert getSiloedBorrowing() == siloed;
}
","setSiloedBorrowing (Lines 268-284), ","  function setSiloedBorrowing(
    address asset,
    bool newSiloed
  ) external override onlyRiskOrPoolAdmins {
    if (newSiloed) {
      _checkNoBorrowers(asset);
    }
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);

    bool oldSiloed = currentConfig.getSiloedBorrowing();

    currentConfig.setSiloedBorrowing(newSiloed);

    _pool.setConfiguration(asset, currentConfig);

    emit SiloedBorrowingChanged(asset, oldSiloed, newSiloed);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
189f573e83cb2b48e5cb2ae125c48e1e,988,rule,getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity,323,331,setFacilitatorBucketCapacity,"rule getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	assert getFacilitatorBucketCapacity(facilitator) == newCapacity;
}
","setFacilitatorBucketCapacity (Lines 111-121), ","  function setFacilitatorBucketCapacity(
    address facilitator,
    uint128 newCapacity
  ) external onlyRole(BUCKET_MANAGER) {
    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');

    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;
    _facilitators[facilitator].bucketCapacity = newCapacity;

    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);
  }
",./gho-core/ghoToken.spec,,Yes,
18b1fd04e5c050a349d5730e139ac42b,1129 | 1130,rule,feeSimulationEqualsActualFee,134,155,flashLoan | flashFee,"rule feeSimulationEqualsActualFee(address receiver, address token, uint256 amount, bytes data){
    env e;
    uint256 feeSimulationResult = flashFee(e, token, amount);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    
    flashLoanReqs(e);
    require atoken.getGhoTreasury() != currentContract;
    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, e.msg.sender, atoken);
    // Excluding call to distributeFeesToTreasury & calling another flashloan (which will generate another fee in recursion)
    require flashBorrower.action() != 1 && flashBorrower.action() != 0;
    // Because we calculate the actual fee by balance difference of the minter, we assume no extra money is being sent to the minter.
    require flashBorrower._transferTo() != currentContract;
    flashLoan(e, receiver, token, amount, data);

    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 actualFee = facilitatorBalance_ - _facilitatorBalance;
    assert feeSimulationResult == actualFee;
}
","flashLoan (Lines 68-90),  | flashFee (Lines 127-130), ","  function flashLoan(
    IERC3156FlashBorrower receiver,
    address token,
    uint256 amount,
    bytes calldata data
  ) external override returns (bool) {
    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');

    uint256 fee = ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);
    GHO_TOKEN.mint(address(receiver), amount);

    require(
      receiver.onFlashLoan(msg.sender, address(GHO_TOKEN), amount, fee, data) == CALLBACK_SUCCESS,
      'FlashMinter: Callback failed'
    );

    GHO_TOKEN.transferFrom(address(receiver), address(this), amount + fee);
    GHO_TOKEN.burn(amount);

    emit FlashMint(address(receiver), msg.sender, address(GHO_TOKEN), amount, fee);

    return true;
  }
 |   function flashFee(address token, uint256 amount) external view override returns (uint256) {
    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');
    return ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);
  }
",./gho-core/flashMinter.spec,,Yes,
1a45f8a5d1331c57ccb23e4ab81cf513,144 | 145,rule,integrityOfExecuteEmergencyAction,244,255,areAllReservesBacked | executeEmergencyAction,"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     aggregator.initFlags(rand);
//     require configurator.freezeWasCalled() == false;
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool freezeReserveWasCalled = configurator.freezeWasCalled();
//     assert !allReservesBacked => freezeReserveWasCalled;
//     assert allReservesBacked => !freezeReserveWasCalled;
// }
","areAllReservesBacked (Lines 87-97),  | executeEmergencyAction (Lines 70-92), ","  function areAllReservesBacked() external view returns (bool) {
    if (_assets.length == 0) {
      return true;
    }

    (bool areReservesBacked, ) = _proofOfReserveAggregator.areAllReservesBacked(
      _assets
    );

    return areReservesBacked;
  }
 |   function executeEmergencyAction() external override {
    (
      bool areReservesBacked,
      bool[] memory unbackedAssetsFlags
    ) = _proofOfReserveAggregator.areAllReservesBacked(_assets);

    if (!areReservesBacked) {
      _disableBorrowing();

      uint256 assetsLength = _assets.length;

      for (uint256 i = 0; i < assetsLength; ++i) {
        if (unbackedAssetsFlags[i]) {
          // freeze reserve
          _configurator.freezeReserve(_assets[i]);

          emit AssetIsNotBacked(_assets[i]);
        }
      }

      emit EmergencyActionExecuted();
    }
  }
",./aave_proof_of_reserve/specs/executorV3.spec,,Yes,
1a4a25f8935719ca1c8b9109f331782d,99 | 101,rule,executeCannotCancel,163,176,execute | getCurrentState,"rule executeCannotCancel()
{
	env e;
	calldataarg args;
	uint256 calledSet;
	uint256 canceledSet;

	require getCurrentState(e, canceledSet) != 2;
	require getGuardian() != _mock(e);
	
	execute(e, calledSet);
	assert getCurrentState(e, canceledSet) != 2;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
1a75d08adb77634e15df9b13ecd29a61,457 | 458 | 459 | 461 | 463,invariant,integrityOfisBorrowingOne,113,122,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
1ac5088528f51eafddbd91fc9a7eb290,1215 | 1216 | 1217 | 1218 | 1221,rule,assetsLessThanEverDepositedAsRule,183,200,createBond | reassignBond | freeBond | seizeBond | bondAmount,"rule assetsLessThanEverDepositedAsRule(address operator, method f, mathint t, address holder, uint256 referenceID ) {
    env e;
    calldataarg args;
    require t == totalLockedBonds(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require totalLockedBonds(operator) >= bondAmount(operator, e.msg.sender, referenceID);
    require safeAdd(unbondedValue(operator), totalLockedBonds(operator));
    require everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
    require f.selector==init_state().selector => totalLockedBonds(operator)==0;
    uint256 before = bondAmount(operator, e.msg.sender, referenceID);
    f(e, args);
    require (f.selector==freeBond(address,uint256).selector                             ||
             f.selector==seizeBond(address,uint256,uint256,address).selector            ||
             f.selector==createBond(address,address,uint256,uint256,address).selector   ||
             f.selector==reassignBond(address, uint256, address, uint256).selector )    =>
             before != bondAmount(operator, e.msg.sender, referenceID);
    assert safeAdd(unbondedValue(operator), totalLockedBonds(operator)) &&
            everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
   }
","createBond (Lines 136-169),  | reassignBond (Lines 192-214),  | freeBond (Lines 222-232),  | seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function reassignBond(
        address operator,
        uint256 referenceID,
        address newHolder,
        uint256 newReferenceID
    ) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(lockedBonds[bondID] > 0, ""Bond not found"");

        bytes32 newBondID = getBondID(operator, newHolder, newReferenceID);

        require(
            lockedBonds[newBondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        lockedBonds[newBondID] = lockedBonds[bondID];
        lockedBonds[bondID] = 0;

        emit BondReassigned(operator, referenceID, newHolder, newReferenceID);
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
1adad19c8ea189e760a3480b59dc3d24,142 | 143,rule,integrityOfExecuteEmergencyAction,235,246,areAllReservesBacked | executeEmergencyAction,"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     require _disableBorrowingCalled() == false;
//     aggregator.initFlags(rand);
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool disableBorrowingCalled = _disableBorrowingCalled();
//     assert !allReservesBacked => disableBorrowingCalled;
//     assert allReservesBacked => !disableBorrowingCalled;
// }
","areAllReservesBacked (Lines 87-97),  | executeEmergencyAction (Lines 70-92), ","  function areAllReservesBacked() external view returns (bool) {
    if (_assets.length == 0) {
      return true;
    }

    (bool areReservesBacked, ) = _proofOfReserveAggregator.areAllReservesBacked(
      _assets
    );

    return areReservesBacked;
  }
 |   function executeEmergencyAction() external override {
    (
      bool areReservesBacked,
      bool[] memory unbackedAssetsFlags
    ) = _proofOfReserveAggregator.areAllReservesBacked(_assets);

    if (!areReservesBacked) {
      _disableBorrowing();

      uint256 assetsLength = _assets.length;

      for (uint256 i = 0; i < assetsLength; ++i) {
        if (unbackedAssetsFlags[i]) {
          // freeze reserve
          _configurator.freezeReserve(_assets[i]);

          emit AssetIsNotBacked(_assets[i]);
        }
      }

      emit EmergencyActionExecuted();
    }
  }
",./aave_proof_of_reserve/specs/executorV2.spec,,Yes,
1b5d5c81c4f36f7d513ab83a0e779c11,562,rule,setBorrowCapIntegrity,133,136,setBorrowCap,"rule setBorrowCapIntegrity(uint256 borrowCap) {
    setBorrowCap(borrowCap);
    assert getBorrowCap() == borrowCap;
}
","setBorrowCap (Lines 287-296), ","  function setBorrowCap(
    address asset,
    uint256 newBorrowCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldBorrowCap = currentConfig.getBorrowCap();
    currentConfig.setBorrowCap(newBorrowCap);
    _pool.setConfiguration(asset, currentConfig);
    emit BorrowCapChanged(asset, oldBorrowCap, newBorrowCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
1bad7daf2b739dbd96e5ed2a3c31f9d5,26 | 28,rule,executeCannotCancel,162,175,execute | getCurrentState,"rule executeCannotCancel()
{
	env e;
	calldataarg args;
	uint256 calledSet;
	uint256 canceledSet;

	require getCurrentState(e, canceledSet) != 2;
	require getGuardian() != _mock(e);
	
	execute(e, calledSet);
	assert getCurrentState(e, canceledSet) != 2;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
1bf99931e9a4076cae997b43d8c98e58,570,rule,setUnbackedMintCapIntegrity,157,160,setUnbackedMintCap,"rule setUnbackedMintCapIntegrity(uint256 unbackedMintCap) {
    setUnbackedMintCap(unbackedMintCap);
    assert getUnbackedMintCap() == unbackedMintCap;
}
","setUnbackedMintCap (Lines 398-407), ","  function setUnbackedMintCap(
    address asset,
    uint256 newUnbackedMintCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldUnbackedMintCap = currentConfig.getUnbackedMintCap();
    currentConfig.setUnbackedMintCap(newUnbackedMintCap);
    _pool.setConfiguration(asset, currentConfig);
    emit UnbackedMintCapChanged(asset, oldUnbackedMintCap, newUnbackedMintCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
1f09eb7d3bf45832714bdef157379f22,1257,rule,inverseOfDepositAndWithdraw,419,438,deposit,"rule inverseOfDepositAndWithdraw(address operator, address owner, address beneficiary, uint256 x) {
    require (ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary);
    require (beneficiary != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 u = unbondedValue(operator);
    uint256 b = balanceOf(currentContract);
    // successful deposit
    env eDeposit;
    require eDeposit.msg.value == x;
    require (eDeposit.msg.sender != currentContract);
    deposit(eDeposit, operator);
    env eWithdraw;
    require eWithdraw.msg.sender == operator || eWithdraw.msg.sender == owner;
    require eWithdraw.msg.value == 0;
    require _hasDelegationLockPassed(eWithdraw, operator);
    require safeAdd(balanceOf(beneficiary), x);
    invoke withdraw(eWithdraw, x, operator);
    bool success = !lastReverted;
    // verify that succeeded and the the value is as expected
    assert success &&  u  == unbondedValue(operator) && b == balanceOf(currentContract);
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
1f13d0617b40090d6b6dc2a0541c72d8,148 | 149,rule,PoRFeedChange,35,54,enableProofOfReserveFeed | enableProofOfReserveFeedWithBridgeWrapper,"rule PoRFeedChange(address asset, address PoRFeed, address wrapper){
    
    address feedBefore = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperBefore = getBridgeWrapperForAsset(asset);
    method f; env e;
    call_f_with_params(f, e, asset, PoRFeed, wrapper);

    address feedAfter = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperAfter = getBridgeWrapperForAsset(asset);
    assert f.selector == enableProofOfReserveFeed(address, address).selector => (feedAfter != 0 && feedAfter == PoRFeed);
    assert f.selector == enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector => 
                        (feedAfter != 0 && feedAfter == PoRFeed && bridgeWrapperAfter != 0 && bridgeWrapperAfter == wrapper);
    assert f.selector == disableProofOfReserveFeed(address).selector => feedAfter == 0 && bridgeWrapperAfter == 0;
    assert (f.selector != enableProofOfReserveFeed(address, address).selector && 
            f.selector != disableProofOfReserveFeed(address).selector &&
            f.selector != enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector) => 
                        feedBefore == feedAfter && bridgeWrapperBefore == bridgeWrapperAfter;
}
","enableProofOfReserveFeed (Lines 42-57),  | enableProofOfReserveFeedWithBridgeWrapper (Lines 60-79), ","  function enableProofOfReserveFeed(address asset, address proofOfReserveFeed)
    external
    onlyOwner
  {
    require(asset != address(0), 'INVALID_ASSET');
    require(proofOfReserveFeed != address(0), 'INVALID_PROOF_OF_RESERVE_FEED');
    require(_proofOfReserveList[asset] == address(0), 'FEED_ALREADY_ENABLED');

    _proofOfReserveList[asset] = proofOfReserveFeed;
    emit ProofOfReserveFeedStateChanged(
      asset,
      proofOfReserveFeed,
      address(0),
      true
    );
  }
 |   function enableProofOfReserveFeedWithBridgeWrapper(
    address asset,
    address proofOfReserveFeed,
    address bridgeWrapper
  ) external onlyOwner {
    require(asset != address(0), 'INVALID_ASSET');
    require(proofOfReserveFeed != address(0), 'INVALID_PROOF_OF_RESERVE_FEED');
    require(bridgeWrapper != address(0), 'INVALID_BRIDGE_WRAPPER');
    require(_proofOfReserveList[asset] == address(0), 'FEED_ALREADY_ENABLED');

    _proofOfReserveList[asset] = proofOfReserveFeed;
    _bridgeWrapperList[asset] = bridgeWrapper;

    emit ProofOfReserveFeedStateChanged(
      asset,
      proofOfReserveFeed,
      bridgeWrapper,
      true
    );
  }
",./aave_proof_of_reserve/specs/aggregator.spec,,Yes,
1f149302756eeefb9f6ae2f3f7a6b610,2398,invariant,factoryGetPairCorrelationCurrentVals,153,160,initialize,"invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
    {
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
        }
    }
","initialize (Lines 28-35), ","    function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
1fbc60ad5ad5565b9d097481f0331cc2,2201,invariant,zero_totalSupply_zero_owed,206,213,collectProtocolFees,"    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    } 
    }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
204e75416bad1544302a9bf93bca9164,361 | 363,rule,additiveBurn,155,167,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x);
	sinvoke burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
20c354802c34b0b2fc761f7588871f46,2530,rule,cl_hasWithdrawnIncentivesOnlyChange,340,349,withdrawIncentives,"rule cl_hasWithdrawnIncentivesOnlyChange(method f, env e){
    bool hasWIncenBefore = userHasWithdrawnIncentives(e.msg.sender);

    calldataarg args;
    f(e, args);
    bool hasWIncenAfter = userHasWithdrawnIncentives(e.msg.sender);
    assert hasWIncenBefore != hasWIncenAfter => f.selector == withdrawIncentives().selector, ""hasWithdrawnIncentives was changed by wrong method"";
}
","withdrawIncentives (Lines 473-491), ","    function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
2173e9563b0ef17a136246e536e1c92a,1522,rule,burnAdditivity,605,621,balanceOf,"rule burnAdditivity(env e){
    address from; uint256 id; uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    burn(e, from, id, amount);
    uint256 balanceAfterSingleTransaction = balanceOf(from, id);
    burn(e, from, id, amount1) at initialStorage;
    burn(e, from, id, amount2);
    uint256 balanceAfterDoubleTransaction = balanceOf(from, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
219ed11f9069ce91f049ddef26842965,24 | 25,rule,queueCannotCancel,150,159,processMessageFromRoot | getCurrentState,"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
21cf88eede76c8185d7fd5c5375f9b65,579 | 580,rule,integrityMint,153,163,mint | balanceOf,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e,a);
	mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
21d9c3b44533dd7b2f54ea2f42689a71,2244,rule,ifTheOnlyOneDripperStopsReceivableDripsCanNotIncrease,661,669,_receivableDrips,"// rule ifTheOnlyOneDripperStopsReceivableDripsCanNotIncrease()
// {
//     // make sure there is only one sender and one receiver
//     // make sure the sender is dripping to the receiver
//     // calculate the _receivableDrips(receiver) before dripping stops
//     // stop the dripping
//     // calculate the _receivableDrips(receiver) after dripping stops
//     // after == before
// }
","_receivableDrips (Lines 224-236), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
21da3e9db3aa72f96a01739921df97ce,2425 | 2426 | 2427 | 2428,invariant,initially,483,494,currentPhase | createPair | allowEmergencyWithdraw | initialize,"// STATUS - in progress. (need preserved block for createPair() that invariant initially is true like require in a rule)
// run without preserved block: 
// run with preserved block: 
// run: https://vaas-stg.certora.com/output/3106/9d1479ffd6d7489f4c84/?anonymousKey=92f17079fc91748fdd970538af733779da8888c1
invariant clWavaxCorrelation(env e)
    pair() != 0 => (getWAVAXbalanceOfThis() == avaxReserve() && avaxReserve() == 0)
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
            require currentPhase(e2) == PhaseThree();
","currentPhase (Lines 319-330),  | createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
2208c6d831ea378cf3078e18630e99e9,2527 | 2528,rule,cl_hasWithdrawnPair_pairBalance_OnlyChangeUser,280,296,withdrawLiquidity | pairBalance,"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeUser(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user != issuer();

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    uint256 possiblePairBalance = pairBalance(e, user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + possiblePairBalance) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
","withdrawLiquidity (Lines 453-470),  | pairBalance (Lines 623-632), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
2223fbb44f021600cce9484f9365b865,1016,invariant,discountCantExceed100Percent,121,127,updateDiscountDistribution,"invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
225c75f9626c9b8bb109f4ff7cc48b6e,2532,rule,hl_depositAdditivity,46,62,depositAVAX,"rule hl_depositAdditivity(env e, env e2){
    require e.msg.value > 0;
    require e.msg.value == 2 * e2.msg.value;
    require e.msg.sender != e2.msg.sender;

    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);
    
    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);
    require userOneBalanceBefore == userTwoBalanceBefore;
    depositAVAX(e2);
    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);
    assert userOneBalanceAfter == userTwoBalanceAfter, ""deposit is not additive"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
22b972732b1a264062ba062653d11621,1508,rule,noTransferBatchEffectOnApproval,403,416,safeBatchTransferFrom,"rule noTransferBatchEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256[] ids; uint256[] amounts;
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
236167c16e7e7307b4deb55ee73eafc8,1866 | 1867 | 1868 | 1877,rule,additiveAddLong,251,270,addShort | addLong | addCollateral | totalLongAmount,"rule additiveAddLong(address longOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addLong(longOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addLong(longOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 longAmountScenario1 = totalLongAmount();
	invoke addLong(longOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 longAmountScenario2 = totalLongAmount();
	assert (call1 && call2) <=> call3, ""addLong is not additive, one scenario reverts"" ;
	assert call3 => longAmountScenario1 == longAmountScenario2, ""addLong is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
23fb75dd57ff84fbd849dcb0e7d7b71a,2533,rule,hl_withdrawAdditivity,67,83,withdrawAVAX,"rule hl_withdrawAdditivity(env e){
    uint256 single; uint256 doubleOne; uint256 doubleTwo;
    require single > 0 && doubleOne > 0 && doubleTwo > 0;
    require single == doubleOne + doubleTwo;

    storage initialStorage = lastStorage;
    withdrawAVAX(e, single);
    uint256 userBalanceAfterSingle = getUserBalance(e.msg.sender);
    withdrawAVAX(e, doubleOne) at initialStorage;
    withdrawAVAX(e, doubleTwo);
    uint256 userBalanceAfterDouble = getUserBalance(e.msg.sender);
    assert userBalanceAfterSingle == userBalanceAfterDouble, ""withdraw is not additive"";
}
","withdrawAVAX (Lines 374-398), ","    function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
244d2d86df57560bf0afb26c7e6c3cce,261,rule,totalClaimableRewards_stable,332,333,initialize,"rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
25c1cb7eede8d1695a16c8fd79ca58f7,44 | 46,rule,queuedStateConsistency,264,272,processMessageFromRoot | getCurrentState,"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, id) == 0;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
261ee3c4b34293a73a7e6204d4ed041e,1307 | 1308 | 1309,invariant,portfolioIsAlwaysSorted,219,250,getNetCashGroupValue | checkPortfolioSorted | getPortfolioCurrencyIdAtIndex,"invariant portfolioIsAlwaysSorted (address account)
    // Get portfolio from harness and test if assets are sorted, do this
    // inside a harness
    checkPortfolioSorted(account)

// TODO: below here I'm not sure how we actually do this
// Set up a portfolio such that every asset's value is equal to 1e8 and then assert
rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02
    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
","getNetCashGroupValue (Lines 219-274),  | checkPortfolioSorted (Lines 122-133),  | getPortfolioCurrencyIdAtIndex (Lines 135-145), ","    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
 |     function checkPortfolioSorted(address account) external view returns (bool) {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        for (uint256 i; i < assets.length; i++) {
            if (i == 0) continue;
            assert(assets[i - 1].currencyId <= assets[i].currencyId);
            assert(assets[i - 1].maturity <= assets[i].maturity);
            assert(assets[i - 1].assetType <= assets[i].assetType);
        }
    }
 |     function getPortfolioCurrencyIdAtIndex(address account, uint256 index)
        external
        view
        returns (uint256)
    {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        return assets[index].currencyId;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
2686a2d05949073ce79d831e9c12b000,606,rule,integrityDelegationWithSig,111,116,delegationWithSig,"rule integrityDelegationWithSig(address delegator, address delegatee, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) {
    env e;
    uint256 oldNonce = nonces(e, delegator);
    delegationWithSig(e, delegator, delegatee, value, deadline, v, r, s);
    assert nonces(e, delegator) == oldNonce + 1 && borrowAllowance(e, delegator, delegatee) == value;
}
","delegationWithSig (Lines 43-68), ","  function delegationWithSig(
    address delegator,
    address delegatee,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external {
    require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[delegator];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(
          abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline)
        )
      )
    );
    require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[delegator] = currentValidNonce + 1;
    _approveDelegation(delegator, delegatee, value);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
27e34698fef9789101236824fbbf21e7,567,rule,setDebtCeilingIntegrity,145,148,setDebtCeiling,"rule setDebtCeilingIntegrity(uint256 ceiling) {
    setDebtCeiling(ceiling);
    assert getDebtCeiling() == ceiling;
}
","setDebtCeiling (Lines 247-265), ","  function setDebtCeiling(
    address asset,
    uint256 newDebtCeiling
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);

    uint256 oldDebtCeiling = currentConfig.getDebtCeiling();
    if (oldDebtCeiling == 0) {
      _checkNoSuppliers(asset);
    }
    currentConfig.setDebtCeiling(newDebtCeiling);
    _pool.setConfiguration(asset, currentConfig);

    if (newDebtCeiling == 0) {
      _pool.resetIsolationModeTotalDebt(asset);
    }

    emit DebtCeilingChanged(asset, oldDebtCeiling, newDebtCeiling);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
27face4d5c5724191d8ed37da80b863d,74,rule,processMessageFromRootReachability,504,510,processMessageFromRoot,"rule processMessageFromRootReachability()
{
	env e; calldataarg args;

	processMessageFromRoot(e, args);
	assert false;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
28cad6aafbbf352327b1ba4df3d94fdb,2574,invariant,zeroStrategy,94,146,_tokenBalanceOf,"invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
	
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)

// Rules
/**
 * solvency:
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	require straToken == strategy(token);
	//proven in zeroStrategy
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,,Yes,
2950c202bcbdebfd8a2c94e9618e91e9,265,rule,getClaimableRewards_stable,453,458,initialize,"rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
29ab659edc48da3f1ccfd57291c9b148,1493,rule,cannotTransferMoreSingle,226,233,balanceOf,"rule cannotTransferMoreSingle(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;
    uint256 balanceBefore = balanceOf(from, id);

    safeTransferFrom@withrevert(e, from, to, id, amount, data);
    assert amount > balanceBefore => lastReverted, ""Achtung! Scammer!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
29b19cdda4094152b8f93f3c4753130e,628,rule,positiveSupply_imply_positiveAssets_other,159,167,initialize,"rule positiveSupply_imply_positiveAssets_other(method f) filtered {f ->
        f.selector != initialize(address,uint256,string,string,uint256).selector &&
        !harnessOnlyMethods(f) &&
        !f.isView &&
        !is_deposit_method(f) &&
        !is_mint_method(f) &&
        !is_withdraw_method(f) &&
        !is_redeem_method(f) 
        }
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/positiveSupply_imply_positiveAssets.spec,,Yes,
29e34d2da68f8eb527ac2d29a4ac129f,812 | 814 | 816,rule,no_double_upvote,80,97,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
2aa28fb83cdf50ccd8b889f6919a2d1e,2496,rule,cl_hasWithdrawnIncentivesOnlyChange,989,998,withdrawIncentives,"rule cl_hasWithdrawnIncentivesOnlyChange(method f, env e){
    bool hasWIncenBefore = userHasWithdrawnIncentives(e.msg.sender);

    calldataarg args;
    f(e, args);
    bool hasWIncenAfter = userHasWithdrawnIncentives(e.msg.sender);
    assert hasWIncenBefore != hasWIncenAfter => f.selector == withdrawIncentives().selector, ""hasWithdrawnIncentives was changed by wrong method"";
}
","withdrawIncentives (Lines 473-491), ","    function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
2af1bc5d3f9a9da5b0aaa7f9e4339e77,247,invariant,inv_atoken_balanceOf_leq_totalSupply_redeem,162,164,redeem,"invariant inv_atoken_balanceOf_leq_totalSupply_redeem(address user)
invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
    filtered { f -> f.selector == redeem(uint256,address,address,bool).selector}
","redeem (Lines 469-478), ","  function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
2af8a8239d9757533c0b3fd8205166b5,1011,rule,address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address,523,531,removeFacilitator,"rule address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address(address facilitator){
rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
	require facilitator == 0;
	
","removeFacilitator (Lines 94-108), ","  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {
    require(
      bytes(_facilitators[facilitatorAddress].label).length > 0,
      'FACILITATOR_DOES_NOT_EXIST'
    );
    require(
      _facilitators[facilitatorAddress].bucketLevel == 0,
      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'
    );

    delete _facilitators[facilitatorAddress];
    _facilitatorsList.remove(facilitatorAddress);

    emit FacilitatorRemoved(facilitatorAddress);
  }
",./gho-core/ghoToken.spec,,Yes,
2b7cc4ca0087210de350b81670679aae,899,rule,no_weight_changing_when_voting,44,61,isVoting,"rule no_weight_changing_when_voting(method f, address account) {
	env _e;
	uint256 _accountWeight = sinvoke _weight(_e,account);
	
	bool isAccountVoting = sinvoke isVoting(_e,account);
	env eF;
	calldataarg arg;
	invoke f(eF,arg);
	env e_;
	uint256 accountWeight_ = sinvoke _weight(e_,account);
	assert(
    isAccountVoting => _accountWeight == accountWeight_,
    ""Method changed weight of account if voting""
  );
}","isVoting (Lines 986-995), ","  function isVoting(address account) external view returns (bool) {
    Voter storage voter = voters[account];
    uint256 upvotedProposal = voter.upvote.proposalId;
    bool isVotingQueue = upvotedProposal != 0 &&
      isQueued(upvotedProposal) &&
      !isQueuedProposalExpired(upvotedProposal);
    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];
    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);
    return isVotingQueue || isVotingReferendum;
  }
",./celo_governance/specs/locked_gold_linked.spec,,Yes,
2baede620cfd4bb69c64af2517f85803,2490,rule,cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer,942,958,withdrawLiquidity,"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user == issuer();
    require token() == SymbERC20A || token() == SymbERC20B;

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
","withdrawLiquidity (Lines 453-470), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
2c44760d7203f2595948aa2e68337e84,2210,rule,zeroCharacteristicOfWithdraw,278,293,withdraw,"///// rule zeroCharacteristicOfWithdraw()
////  verifies that if withraw returns amount0 == 0 and amount1 == 0 then necessarily shares == 0
rule zeroCharacteristicOfWithdraw(uint256 shares, address to){
    env e;
    uint256 amount0;
    uint256 amount1;

    require governance() != currentContract;
    require governance() != pool;
    require to != currentContract && to != pool && to != governance();
    require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
    amount0,amount1 =  withdraw(e,shares, to);
    assert (amount0 == 0 && amount1 == 0 => shares == 0);
}
","withdraw (Lines 59-63), ","    function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
2cf9c49305d1f5840dd749a824582abd,56,rule,holdYourHorses,328,338,processMessageFromRoot,"rule holdYourHorses()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	
	uint256 delay = getDelay();
	processMessageFromRoot(e, args);
	execute@withrevert(e, actionsSetId);
	assert delay > 0 => lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
2d2ef8ef4cbb9344353c8041a70c3b20,1510,rule,mintAdditivity,427,443,balanceOf,"rule mintAdditivity(env e){
    address to; uint256 id; uint256 amount; uint256 amount1; uint256 amount2; bytes data;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    mint(e, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    mint(e, to, id, amount1, data) at initialStorage;
    mint(e, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
2d7d850ef915c10e5c8af442ac7d845e,1514,rule,mintBatchCorrectWork,488,516,balanceOf,"rule mintBatchCorrectWork(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    bytes data;

    require ids.length == 3; 
    require amounts.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(to, id1);
    uint256 otherBalanceBefore2 = balanceOf(to, id2);
    uint256 otherBalanceBefore3 = balanceOf(to, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(to, id1);
    uint256 otherBalanceAfter2 = balanceOf(to, id2);
    uint256 otherBalanceAfter3 = balanceOf(to, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 - amount1
            && otherBalanceBefore2 == otherBalanceAfter2 - amount2
            && otherBalanceBefore3 == otherBalanceAfter3 - amount3
            , ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
2dc81b2563fd1ccf11228b5f8066c8a9,1677 | 1678,rule,unsetPendingTransitionMethods,91,101,schedule | scheduleBatch,"rule unsetPendingTransitionMethods(method f, env e){
    bytes32 id;

    require !isOperation(id);
    calldataarg args;
    f(e, args);
    assert isOperationPending(id) => (f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector 
                                || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector), ""Why do we need to follow the schedule?"";
}
","schedule (Lines 214-225),  | scheduleBatch (Lines 236-252), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
 |     function scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata payloads,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == payloads.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
        _schedule(id, delay);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);
        }
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
2dc9eeb128ec937be8fff8601bebfddb,1703,rule,executeChange,300,310,execute,"rule executeChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt;
    uint256 otherIdTimestampBefore = getTimestamp(otherId);

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    execute(e, target, value, data, predecessor, salt);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
2ea6cd307cf56934d0ec505ce2d623c5,1570,rule,depositForSpecBasic,44,63,depositFor,"rule depositForSpecBasic(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    depositFor(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert wrapperTotalBefore == wrapperTotalAfter - amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
    assert underlyingThisBalanceBefore == underlyingThisBalanceAfter - amount, ""underlying this balance wrong update"";
}
","depositFor (Lines 39-43), ","    function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
2ec666caa49ec8d5382ab9e7a4c51a0e,233,rule,If,72,147,deposit,"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceBefore - senderATokenBalanceAfter - amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,,Yes,
307a50770d05ba8ee0f24f69d31e87ab,2381 | 2382,rule,longer_stake_greater_return,226,249,pendingRJoe | deposit,"rule longer_stake_greater_return() { // passes

    storage init = lastStorage; 
    uint256 amount;
    require amount > 0;
    env e0;
    env e1; 
    env e2; 
    // accessing the same account, not current contract
    require e0.msg.sender != currentContract && e1.msg.sender == e0.msg.sender && e2.msg.sender == e0.msg.sender;
    // account 2 stakes longer than account 1, which stakes more than 0 seconds
    require e1.block.timestamp > e0.block.timestamp && e2.block.timestamp > e1.block.timestamp;
    
    deposit(e0, amount);
    uint256 rJoe1 = pendingRJoe(e1, e0.msg.sender);
    deposit(e0, amount) at init;
    uint256 rJoe2 = pendingRJoe(e2, e0.msg.sender);
    // assert rJoe2 > rJoe1; 
    assert exists uint256 dt. e2.block.timestamp - e1.block.timestamp >= dt => rJoe2 > rJoe1;
}
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
30c9824cebc813125783c38049e611c2,757,rule,address_can_authorize_two_addresses,125,149,authorizeSignerWithSignature,"rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,,Yes,
30e064abc6cb88cd2e83f83abbcc4556,635,rule,getCLMFees_LEQ_ATokenBAL_RW,201,207,withdrawFees,"rule getCLMFees_LEQ_ATokenBAL_RW(method f) filtered {f ->
        !harnessOnlyMethods(f) &&
        !f.isView &&
        (is_withdraw_method(f) || is_redeem_method(f) ||
         f.selector == withdrawFees(address,uint256).selector
        )
}
","withdrawFees (Lines 420-431), ","    function withdrawFees(address to, uint256 amount) public override onlyOwner {
        _accrueYield();
        require(amount <= _s.accumulatedFees, ""INSUFFICIENT_FEES""); // will underflow below anyway, error msg for clarity

        _s.accumulatedFees -= uint128(amount);

        ATOKEN.transfer(to, amount);

        _s.lastVaultBalance = uint128(ATOKEN.balanceOf(address(this)));

        emit FeesWithdrawn(to, amount, _s.lastVaultBalance, _s.accumulatedFees);
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,,Yes,
31710ec9726375d0270e04e557922060,2241,rule,whoChangedBalanceOfUserId,567,605,_dripsState,"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    require requireValidSlots();
    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
326d46dbca34a6f6e0277731055479f6,1325 | 1326,rule,netCashGroupValueAccountsForAllAssets,226,250,getNetCashGroupValue | getPortfolioCurrencyIdAtIndex,"rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02

    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
","getNetCashGroupValue (Lines 219-274),  | getPortfolioCurrencyIdAtIndex (Lines 135-145), ","    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
 |     function getPortfolioCurrencyIdAtIndex(address account, uint256 index)
        external
        view
        returns (uint256)
    {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        return assets[index].currencyId;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
32d202a5d42940d3ddd3ea1a426af50b,905,rule,executeDelegatesOnlyToAllowedAddresses,59,67,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(FCOMPOUND_ACTIONS()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hscompound.spec,,Yes,
32f2adaa07cc70a4cdecd9344f8db08c,1466,rule,holds,49,71,balanceOf,"/// This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule sequentialBurnsEquivalentToSingleBurnOfSum {
    storage beforeBurns = lastStorage;
    env e;

    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;
    require sumBurn == firstBurn + secondBurn;
    // sequential burns
    burn(e, holder, token, firstBurn) at beforeBurns;
    burn(e, holder, token, secondBurn);
    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);
    // burn of sum of sequential burns
    burn(e, holder, token, sumBurn) at beforeBurns;
    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, 
        ""Sequential burns must be equivalent to a burn of their sum"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
33c932d0e1757f2a8595ccd730e08402,950,rule,changesCaller,38,44,unregisterCaller,"rule changesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != registerCaller(address,bytes32).selector && f.selector != unregisterCaller(address).selector) 
        => _regState == regState_, ""method unexpectedly changes caller info"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,,Yes,
349bca8cb526de1d77091541cc2e8d49,654 | 658,rule,checks,172,195,previewWithdraw | _maxAssetsSuppliableToAave,"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewDeposit_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewDeposit(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewDeposit(e2, assets);
    assert (previewShares1 == previewShares2);
","previewWithdraw (Lines 393-396),  | _maxAssetsSuppliableToAave (Lines 571-600), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function _maxAssetsSuppliableToAave() internal view returns (uint256) {
        // returns 0 if reserve is not active, frozen, or paused
        // returns max uint256 value if supply cap is 0 (not capped)
        // returns supply cap - current amount supplied as max suppliable if there is a supply cap for this reserve

        AaveDataTypes.ReserveData memory reserveData = AAVE_POOL.getReserveData(address(UNDERLYING));

        uint256 reserveConfigMap = reserveData.configuration.data;
        uint256 supplyCap = (reserveConfigMap & ~AAVE_SUPPLY_CAP_MASK) >> AAVE_SUPPLY_CAP_BIT_POSITION;

        if (
            (reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) ||
            (reserveConfigMap & ~AAVE_FROZEN_MASK != 0) ||
            (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)
        ) {
            return 0;
        } else if (supplyCap == 0) {
            return type(uint256).max;
        } else {
            // Reserve's supply cap - current amount supplied
            // See similar logic in Aave v3 ValidationLogic library, in the validateSupply function
            // https://github.com/aave/aave-v3-core/blob/a00f28e3ad7c0e4a369d8e06e0ac9fd0acabcab7/contracts/protocol/libraries/logic/ValidationLogic.sol#L71-L78
            uint256 currentSupply = WadRayMath.rayMul(
                (ATOKEN.scaledTotalSupply() + uint256(reserveData.accruedToTreasury)),
                reserveData.liquidityIndex
            );
            uint256 supplyCapWithDecimals = supplyCap * 10 ** decimals();
            return supplyCapWithDecimals > currentSupply ? supplyCapWithDecimals - currentSupply : 0;
        }
    }
",./aave_vault/specs/erc4626.spec,,Yes,
34abe06e6ad3fdef0c1c59516bf3ec68,437 | 438 | 439 | 441 | 443,invariant,integrityOfisUsingAsCollateralOne,91,101,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
34b04b9b51b850184861d2ebf0d20845,161 | 165,invariant,does,6,30,stakeWithPermit | returnFunds,"                  summarization is because the invariant does not claim anything about rewards.
    @Link: https://prover.certora.com/output/40577/370f63ee225743daba41087449111d8b/?anonymousKey=717499ff4fdcce2c8131025b4e00ade0e3a14200
*/
invariant allSharesAreBacked()
    previewRedeem(totalSupply()) <= stake_token.balanceOf(currentContract)
    {
        preserved stake(address to, uint256 amount) with (env e2)
        {
            require e2.msg.sender != currentContract;
        }
        preserved stakeWithPermit(address from, uint256 amount, uint256 deadline,
            uint8 v, bytes32 r, bytes32 s) with (env e3)
            require from != currentContract;
        preserved returnFunds(uint256 amount) with (env e4)
            require e4.msg.sender != currentContract;
        preserved initialize(address slashingAdmin, address cooldownPauseAdmin, address claimHelper,
                            uint256 maxSlashablePercentage, uint256 cooldownSeconds) with (env e5)
            require getExchangeRate() == INITIAL_EXCHANGE_RATE();
    }
","stakeWithPermit (Lines 103-121),  | returnFunds (Lines 299-308), ","  function stakeWithPermit(
    address from,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external override {
    IERC20WithPermit(address(STAKED_TOKEN)).permit(
      from,
      address(this),
      amount,
      deadline,
      v,
      r,
      s
    );
    _stake(from, from, amount);
  }
 |   function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/propertiesWithSummarizations.spec,,Yes,
35173fbb4cd976f409e46c8e2e7a2093,1123,rule,integrityOfFeeSet,88,93,updateFee,"rule integrityOfFeeSet(uint256 new_fee){
    env e;
    updateFee(e, new_fee);
    uint256 fee_ = getFee(e);
    assert fee_ == new_fee;
}
","updateFee (Lines 100-105), ","  function updateFee(uint256 newFee) external override onlyPoolAdmin {
    require(newFee <= MAX_FEE, 'FlashMinter: Fee out of range');
    uint256 oldFee = _fee;
    _fee = newFee;
    emit FeeUpdated(oldFee, newFee);
  }
",./gho-core/flashMinter.spec,,Yes,
35329bb83e3bac3b14314af37741a763,692 | 693 | 694 | 697,rule,totalNonVotingGEAccountNonVoting,27,41,incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | unlock | slash,"rule totalNonVotingGEAccountNonVoting(address a, method f) {
	require(sinvoke getNonvotingLockedGold()  >= sinvoke getAccountNonvotingLockedGold(a));
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector
  );
	env eF; 
    (f.selector != unlock(uint256).selector || eF.msg.sender == a) &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
	calldataarg arg;
	sinvoke f(eF,arg);
	assert(sinvoke getNonvotingLockedGold() >= sinvoke getAccountNonvotingLockedGold(a));
}
","incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | unlock (Lines 62-64),  | slash (Lines 74-84), ","  function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function unlock(uint256 value) external {
    accountTotalLockedGold[msg.sender] = accountTotalLockedGold[msg.sender].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,,Yes,
353a1369e69ed6d271f792a0ccad84bb,538,rule,setLtvIntegrity,61,64,setLtv,"rule setLtvIntegrity(uint256 ltv) {
    setLtv(ltv);
    assert getLtv() == ltv;
}
","setLtv (Lines 73-77), ","  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);

    self.data = (self.data & LTV_MASK) | ltv;
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
35a5ebc4fb4b2dc3301c758b625a877c,643,rule,must_not_revert_unless_large_input__convertToAssets,114,124,previewWithdraw,"rule must_not_revert_unless_large_input__convertToAssets() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 shares;
    require (shares <= maxUint128());
    
    convertToAssets@withrevert(e, shares);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
35c9ff78c9a1ddd93a2de12d0010aaa3,374 | 376 | 377,rule,integirtyBalanceOfTotalSupplyOnBurn,46,60,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupplyOnBurn(address a)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke burn(e, a, x, index); 
	assert (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
36053441f6f621827da74129aab292e2,807 | 809 | 811,rule,upvotesConsistency,62,62,getUpvotedProposal | upvote | getUpvoteRecord,"rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
3636124e7393cd91814d234bf7aaae1f,2229,rule,integrityOfMulDivNoOverflow,2,19,callMulDiv,"rule integrityOfMulDivNoOverflow(uint256 a,
rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
    require(denominator > 0x0 && a*b <= max_uint256);
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    /*
    assert ((denominator > 0 &&
    (denominator < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) => (result == truncated/denominator));
    */
    assert (result == a*b/denominator);
","callMulDiv (Lines 8-13), ","    function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,,Yes,
36837de6d6f836fb6b03f06a841e1e83,49 | 50 | 53,rule,onlyCancelCanCancel,288,300,processMessageFromRoot | cancel | getCurrentState,"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","processMessageFromRoot (Lines 70-89),  | cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
37ba3a47b63862d8cfbc1103ec6f4c36,54 | 55,rule,cancelExclusive,303,311,cancel | getCurrentState,"rule cancelExclusive(uint actionsSetId1, uint actionsSetId2)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId2);
		cancel(e, actionsSetId1);
	uint8 stateAfter = getCurrentState(e, actionsSetId2);

	assert actionsSetId1 != actionsSetId2 => stateBefore == stateAfter;
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
38790d06057378f6c391e5c3046dd295,985,rule,facilitator_in_list_after_setFacilitatorBucketCapacity,305,318,setFacilitatorBucketCapacity,"rule facilitator_in_list_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant addr_in_set_list_iff_in_map(facilitator);
invariant addr_in_set_list_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)
		requireInvariant addressSetInvariant();
		requireInvariant length_leq_max_uint160();
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
","setFacilitatorBucketCapacity (Lines 111-121), ","  function setFacilitatorBucketCapacity(
    address facilitator,
    uint128 newCapacity
  ) external onlyRole(BUCKET_MANAGER) {
    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');

    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;
    _facilitators[facilitator].bucketCapacity = newCapacity;

    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);
  }
",./gho-core/ghoToken.spec,,Yes,
38a24d91060ed776fb7366af573dfb12,1060,rule,times,387,435,rebalanceUserDiscountPercent,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	env e = envAtTimestamp(ts2);
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
}
/**
* @title proves that a user can't decrease the ovelall interest of his position by taking more loans, compared to another user with the same initial position.
* This rule times out.
**/
// rule integrityOfMint_cantDecreaseInterestWithMint() {
// 	address user1;
// 	uint256 ts1;
// 	env e1 = envAtTimestamp(ts1);
// 	uint256 ts2;
// 	require(ts2 >= ts1);
// 	env e2 = envAtTimestamp(ts2);
// 	uint256 ts3;
// 	require(ts3 >= ts2);
// 	env e3 = envAtTimestamp(ts3);
// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));
// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
393035f48fc830084fddfb8c4b026cc1,629 | 630 | 631,invariant,inv_sumAllBalance_eq_totalSupply__underline,56,148,depositATokensWithSig | mintWithATokensWithSig | getClaimableFees,"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
// ******************************************************************************
// The following invariant is proved in lastVaultBalance_OK.spec
invariant lastVaultBalance_OK()
    getLastVaultBalance() <= _AToken.balanceOf(currentContract)
    
// Proving the solvency rule:
//           getClaimableFees() <= ATOKEN.balanceOf(theVault).
// We do it by proving the stronger invariant:
//           max_possible_fees() <= _AToken.balanceOf(currentContract)
// 
// In this file we prove all method exept the following
// withraw*\redeem*\withdrawFees. (those methods are treated in fee_LEQ_ATokenBal-RW.spec
// Note: the reason for the seperation is that different methods require different summarizations.
//
// Status: pass for all methods that are checked in this file, but FAIL of the others.
//         See in fee_LEQ_ATokenBal-RW.spec
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
function getCLMFees_LEQ_ATokenBAL_1(method f) {
    env e;
    require e.msg.sender != currentContract;
    require getFee() <= SCALE();  // SCALE is 10^18
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require totalSupply() <= maxUint128();
    require Underlying.totalSupply() <= maxUint128();
    require _AToken.scaledTotalSupply() <= maxUint128();
    requireInvariant inv_sumAllBalance_eq_totalSupply__underline(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply__atoken(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply();
    requireInvariant lastVaultBalance_OK();
    uint256 ind = _SymbolicLendingPoolL1.getLiquidityIndex();
    uint256 s_bal = _AToken.scaledBalanceOf(currentContract);
    // The following require means: (s_bal - ass/ind)*ind == s_bal*ind - ass
    require (forall uint256 ass.
             rayMul_g(to_uint256(s_bal-rayDiv_g(ass,ind)),ind) == to_uint256(rayMul_g(s_bal,ind)-ass)
            );
    // The following require means: (x/ind+z)*ind == x+z*ind 
    require (forall uint256 x. forall uint256 ind. forall uint256 z.
             rayMul_g(to_uint256(rayDiv_g(x,ind)+z),ind) == to_uint256(x+rayMul_g(z,ind))
    require(max_possible_fees() <= _AToken.balanceOf(currentContract));
    if (f.selector == depositATokensWithSig(uint256,address,address,
                                            (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 assets; address receiver; address depositor;
        _ATokenVaultHarness.EIP712Signature sig;
        
        require depositor != currentContract;
        depositATokensWithSig(e,assets,receiver,depositor,sig);
    }
    else if (f.selector == mintWithATokensWithSig(uint256,address,address,
                                             (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 shares; address receiver; address depositor;
        mintWithATokensWithSig(e, shares, receiver, depositor, sig);
    else {
        calldataarg args;
        f(e,args);
    //    require Underlying.totalSupply() <= maxUint128();
    //require _AToken.scaledTotalSupply() <= maxUint128();
    assert(max_possible_fees() <= _AToken.balanceOf(currentContract));
}
","depositATokensWithSig (Lines 141-167),  | mintWithATokensWithSig (Lines 202-228),  | getClaimableFees (Lines 466-478), ","    function depositATokensWithSig(
        uint256 assets,
        address receiver,
        address depositor,
        EIP712Signature calldata sig
    ) public override returns (uint256) {
        unchecked {
            MetaTxHelpers._validateRecoveredAddress(
                MetaTxHelpers._calculateDigest(
                    keccak256(
                        abi.encode(
                            DEPOSIT_ATOKENS_WITH_SIG_TYPEHASH,
                            assets,
                            receiver,
                            depositor,
                            _sigNonces[depositor]++,
                            sig.deadline
                        )
                    ),
                    _domainSeparatorV4()
                ),
                depositor,
                sig
            );
        }
        return _handleDeposit(assets, receiver, depositor, true);
    }
 |     function mintWithATokensWithSig(
        uint256 shares,
        address receiver,
        address depositor,
        EIP712Signature calldata sig
    ) public override returns (uint256) {
        unchecked {
            MetaTxHelpers._validateRecoveredAddress(
                MetaTxHelpers._calculateDigest(
                    keccak256(
                        abi.encode(
                            MINT_WITH_ATOKENS_WITH_SIG_TYPEHASH,
                            shares,
                            receiver,
                            depositor,
                            _sigNonces[depositor]++,
                            sig.deadline
                        )
                    ),
                    _domainSeparatorV4()
                ),
                depositor,
                sig
            );
        }
        return _handleMint(shares, receiver, depositor, true);
    }
 |     function getClaimableFees() public view override returns (uint256) {
        uint256 newVaultBalance = ATOKEN.balanceOf(address(this));

        // Skip computation if there is no yield
        if (newVaultBalance <= _s.lastVaultBalance) {
            return _s.accumulatedFees;
        }

        uint256 newYield = newVaultBalance - _s.lastVaultBalance;
        uint256 newFees = newYield.mulDiv(_s.fee, SCALE, MathUpgradeable.Rounding.Down);

        return _s.accumulatedFees + newFees;
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,,Yes,
39c3a9fccc4fb5b981ef0f2785f0a014,1882 | 1883 | 1884 | 1885 | 1894,rule,inverseAddRemoveLong,275,282,addShort | addLong | removeLong | addCollateral | totalLongAmount,"rule inverseAddRemoveLong(address longOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	invoke removeLong(longOtoken, x, index);
	assert !lastReverted && totalLongAmount() == longAmountBefore, ""removeLong is not inverse of addLong""; 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | removeLong (Lines 142-158),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function removeLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed long oToken exists in the vault at the specified index
        require(_index < _vault.longOtokens.length, ""V5"");
        require(_vault.longOtokens[_index] == _longOtoken, ""V6"");

        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);

        if (newLongAmount == 0) {
            delete _vault.longOtokens[_index];
        }
        _vault.longAmounts[_index] = newLongAmount;
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
3aacc8cd5cf302c6ba77e1e141a3ac27,2197,invariant,empty_pool_state_reverse,176,183,collectProtocolFees,"    ///// invariant empty_pool_state_reverse()
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    ////  verifies that pool liquidity == 0 IFF pool balance - pool owed == 0
    ////  following function are excluded:
    invariant empty_pool_state_reverse()
    pool.liquidity() == 0 <=> (pool.balance0() - pool.owed0() == 0 && pool.balance1() - pool.owed1() == 0)
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
3ad2a8378261e379ed62392d65de0601,1817 | 1818 | 1819 | 1824,rule,additiveAddShort,201,220,addShort | addLong | addCollateral | totalShortAmount,"rule additiveAddShort(address shortOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addShort(shortOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addShort(shortOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 shortAmountScenario1 = totalShortAmount();
	invoke addShort(shortOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 shortAmountScenario2 = totalShortAmount();
	assert (call1 && call2) <=> call3, ""addShort is not additive, one scenario reverts"" ;
	assert call3 => shortAmountScenario1 == shortAmountScenario2, ""addShort is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
3ad8b66130807da0536c9116302c52e3,1461,rule,onlyHolderOrApprovedCanReduceBalance,8,20,balanceOf,"rule onlyHolderOrApprovedCanReduceBalance(method f) 
{
    address holder; uint256 token; uint256 amount;
    uint256 balanceBefore = balanceOf(holder, token);

    env e; calldataarg args;
    f(e, args);
    uint256 balanceAfter = balanceOf(holder, token);
    assert balanceAfter < balanceBefore => e.msg.sender == holder || isApprovedForAll(holder, e.msg.sender), 
        ""An account balance may only be reduced by the holder or a holder-approved agent"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
3b287718f21df196cbe7e912e1f53aff,700 | 701 | 702 | 704,rule,totalPreserved,46,75,getPendingWithdrawalsLength | incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | slash,"rule totalPreserved(address account, method f) {
	// We assume the sender is not the currentContract
	require(account != currentContract);
	uint256 _ercBalance = sinvoke ercBalanceOf(account); 
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(account);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(account);
	// We limit the amount of pending records due to loop handling 
	require sinvoke getPendingWithdrawalsLength(account) <= 1;
	env eF;
	require(eF.msg.sender == account);
	// These three function are exceptions to the rule (they are designed to affect total)
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	calldataarg arg;
	sinvoke f(eF,arg);
	uint length = sinvoke getPendingWithdrawalsLength(account);
	require(length <= 1);
	uint256 ercBalance_ = sinvoke ercBalanceOf(account);
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(account);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(account);
  assert(
    _ercBalance + _accountNonVoting + _accountTotalPendingWithdrawals ==
    ercBalance_ + accountNonVoting_ + accountTotalPendingWithdrawals_,
    ""Total of tokens not preserved""
}
","getPendingWithdrawalsLength (Lines 51-54),  | incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | slash (Lines 74-84), ","  function getPendingWithdrawalsLength(address account) external view returns (uint256) {
    uint256 length = balances[account].pendingWithdrawals.length;
    return length;
  }
 |   function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,,Yes,
3b46de187a09f7f67a6debd54638f799,1474,rule,burnBatchOnEmptyArraysChangesNothing,142,160,balanceOf,"rule burnBatchOnEmptyArraysChangesNothing {
    uint256 token; address nonHolderA; address nonHolderB;

    uint256 startingBalance = balanceOf(nonHolderA, token);
    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;
    require noTokens.length == 0; require noBurnAmounts.length == 0;
    burnBatch(e, holder, noTokens, noBurnAmounts);
    
    uint256 endingBalance = balanceOf(nonHolderA, token);
    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    assert startingBalance == endingBalance, 
        ""burnBatch must not change token balances if passed empty arrays"";
    assert startingPermission == endingPermission, 
        ""burnBatch must not change account permissions if passed empty arrays"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
3b6954985c0026065cb8c65c1dd633a9,2208,invariant,liquidity_GE_poolBalance0,246,252,collectProtocolFees,"    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
    filtered { f -> excludeCallback(f) }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
3b7e7eb6d34a3481bde8a72789b33ed0,2366 | 2367 | 2368 | 2369,rule,hl_moreDepositMoreGet,25,55,depositAVAX | createPair | getIncentives | pairBalance,"rule hl_moreDepositMoreGet(method f, env e, env e2, env e3, env e4, env e5){
    require e.msg.sender != e2.msg.sender;
    require e.msg.sender != e3.msg.sender;
    require e2.msg.sender != e3.msg.sender;
    require e.msg.sender != issuer();
    require e2.msg.sender != issuer();
    require e.msg.sender != currentContract;
    require e2.msg.sender != currentContract;
    require e3.msg.sender != currentContract;
    require e.msg.value > e2.msg.value;
    require e.msg.sender == e4.msg.sender;  // need two more envs because depositAVAX() is payble but pairBalance() and getIncentives() aren't thus need the same addresses but different e.msg.value == 0 and != 0
    require e2.msg.sender == e5.msg.sender;
    require !userHasWithdrawnIncentives(e.msg.sender);
    require !userHasWithdrawnIncentives(e2.msg.sender);

    require open();
    depositAVAX(e);
    depositAVAX(e2);
    createPair(e3);
    uint256 incentivesBalanceOne = getIncentives(e4, e4.msg.sender);
    uint256 incentivesBalanceTwo = getIncentives(e5, e5.msg.sender);
    uint256 pairBalanceOne = pairBalance(e4, e4.msg.sender);
    uint256 pairBalanceTwo = pairBalance(e5, e5.msg.sender);
    
    assert exists uint256 dt. e.msg.value - e2.msg.value > dt => incentivesBalanceOne > incentivesBalanceTwo;
    // assert exists uint256 dt. e.msg.value - e2.msg.value > dt => pairBalanceOne > pairBalanceTwo;
}
","depositAVAX (Lines 333-370),  | createPair (Lines 402-450),  | getIncentives (Lines 591-605),  | pairBalance (Lines 623-632), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function getIncentives(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];

        if (user.hasWithdrawnIncentives) {
            return 0;
        }

        if (_user == issuer) {
            if (address(pair) == address(0)) return 0;
            return tokenIncentiveIssuerRefund + tokenReserve;
        } else {
            if (avaxAllocated == 0) return 0;
            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;
        }
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LEInProgress.spec,,Yes,
3c193d5534d23c852fd46919f5542e64,589 | 590,rule,additiveMint,242,258,mint | balanceOf,"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	mint(e, delegatedUser, a, x, index);
	mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	
	uint256 t = x + y;
	mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
3c234b5983644ac421d72d63c8920cd0,1417,rule,held_tokens_should_exist,60,71,balanceOf,"rule held_tokens_should_exist {
    address user; uint256 token;

    requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0
/// If a user has a token, then the token should exist.
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,,Yes,
3c5fd16f00319ff72145f96bcb547c3c,2390 | 2391 | 2392,rule,verify_withdraw,374,391,pendingRJoe | withdraw | updatePool,"rule verify_withdraw() {
    env e;
    require e.msg.sender != currentContract;
    uint256 amount; 

    uint256 balance_pre = userJoeStaked(e.msg.sender);
    uint256 reward_debt_pre = userRewardDebt(e.msg.sender);
    uint256 total_pre = totalJoeStaked();
    withdraw(e, amount);
    uint256 balance_post = userJoeStaked(e.msg.sender);
    uint256 reward_debt_post = userRewardDebt(e.msg.sender);
    uint256 total_post = totalJoeStaked();
    assert total_post == total_pre - amount, ""totalJoeStaked not updated properly"";
    assert balance_pre - amount == balance_post, ""improper amount withdrawn"";
    assert (e.block.timestamp > lastRewardTimestamp() => reward_debt_post > reward_debt_pre) || userJoeStaked(e.msg.sender) == 0, ""reward debt not increased"";
    assert pendingRJoe(e, e.msg.sender) == 0, ""user has unclaimed rewards"";
// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
}
","pendingRJoe (Lines 91-102),  | withdraw (Lines 130-151),  | updatePool (Lines 179-194), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount -= _amount;
        totalJoeStaked -= _amount;

        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        if (pending > 0) _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }
 |     function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
3c7675cafe2f8abdcb3651dc5a393e8a,943,rule,is,568,577,registry.isValidCaller,"// the rule is usually expected to fail, because handler functions do not check who calls them (it's usually the sender via the proxy delegatecall).
rule onlyValidCaller(method f) {
    env e;
    bool isGoodCaller = registry.isValidCaller(e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    bool succeeded = !lastReverted;

    assert !isGoodCaller => !succeeded, ""function can be called even if the sender is not an allowed caller"";
}
","isValidCaller (Lines 133-137), ","    function isValidCaller(
        address caller
    ) external view override returns (bool) {
        return callers[caller] != 0 && callers[caller] != DEPRECATED;
    }
",./furucombo/specs/proxy.spec,,Yes,
3d84e31cc38d2b2b5a0d53a31a34ec7a,290,rule,getClaimableRewardsBefore_leq_claimed_claimRewardsOnBehalf,657,673,claimRewardsOnBehalf,"rule getClaimableRewardsBefore_leq_claimed_claimRewardsOnBehalf(method f)
{   
    env e;
    address onBehalfOf;
    address receiver; 
    address my_reward;
    address[] rewards;
    //setup(e, onBehalfOf, receiver);   
    
    mathint balanceBefore = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint claimableRewardsBefore = getClaimableRewards(e, onBehalfOf, my_reward);
    claimRewardsOnBehalf(e, onBehalfOf, receiver, rewards);
    mathint balanceAfter = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint deltaBalance = balanceAfter - balanceBefore;
   
    assert deltaBalance <= claimableRewardsBefore;
}
","claimRewardsOnBehalf (Lines 280-291), ","  function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
3ded8f364c58fc26f378cfa2fc76f8b7,2281 | 2283 | 2284,rule,assetsDoNotInterfereEachOther,216,260,split | _setSplits | _assertSplitsValid,"rule assetsDoNotInterfereEachOther() {
    env e; uint256 assetId1; uint256 assetId2; uint256 userA_Id; uint256 userB_Id;

    // make sure the users/assets are not the same
    require userA_Id != userB_Id;
    require assetId1 != assetId2;
    // recording the state before split()
    uint128 userA_splittableAssetId1_Before = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_Before = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_Before = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_Before = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_Before = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_Before = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_Before = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_Before = collectable(e, userB_Id, assetId2);
    // calling the split() for userA over assertId1
    uint128 userA_collectableAmtAssetId1; uint128 userA_splitAmtAssetId1;
    userA_collectableAmtAssetId1, userA_splitAmtAssetId1 = split(e, userA_Id, assetId1, true);
    // recording the state after split()
    uint128 userA_splittableAssetId1_After = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_After = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_After = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_After = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_After = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_After = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_After = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_After = collectable(e, userB_Id, assetId2);
    // the expectation:
    // splittable and collectable for any user's assetId2 stays the same
    assert userA_splittableAssetId2_After == userA_splittableAssetId2_Before;
    assert userA_collectableAssetId2_After == userA_collectableAssetId2_Before;
    assert userB_splittableAssetId2_After == userB_splittableAssetId2_Before;
    assert userB_collectableAssetId2_After == userB_collectableAssetId2_Before;
    // the collectable of userB's assetId1 should not be affected by the split
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_collectableAssetId1_After == userB_collectableAssetId1_Before;
    // the splittable of userB's assetId1 should not decrease
    assert userB_splittableAssetId1_After >= userB_splittableAssetId1_Before;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
3df0ec5f0a94afef817b05f9d330cb18,2396 | 2397,rule,stake_duration_correlates_return,445,468,pendingRJoe | deposit,"// rule stake_duration_correlates_return() { // passes

//     storage init = lastStorage; 
//     uint256 amount;
//     require amount > 0;
//     env e0;
//     env e1; 
//     env e2; 
//     // accessing the same account, not current contract
//     require e0.msg.sender != currentContract && e1.msg.sender == e0.msg.sender && e2.msg.sender == e0.msg.sender;
//     // account 2 stakes longer than account 1, which stakes more than 0 seconds
//     require e1.block.timestamp > e0.block.timestamp && e2.block.timestamp > e1.block.timestamp;
    
//     deposit(e0, amount);
//     uint256 rJoe1 = pendingRJoe(e1, e0.msg.sender);
//     deposit(e0, amount) at init;
//     uint256 rJoe2 = pendingRJoe(e2, e0.msg.sender);
//     // assert rJoe2 > rJoe1; 
//     assert e2.block.timestamp > e1.block.timestamp <=> rJoe2 >= rJoe1;
// }
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
3e0697cfaa867b0fa785a2bcec4afbb0,2104 | 2105,rule,putOptionsPreExpiryCase3StartingWithAllCasesNoCode,600,692,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase3StartingWithAllCasesNoCode(
rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
     require shortPrice != longPrice; // <============= make sure this is a valid requirement ADD rule
    //everything changed beside:
    // 1. total supply of long (it changes only when minting - adding as short) 
    require totalSupplyLongOtoken_ == _totalSupplyLongOtoken;
    // 2.  pool holding of short (it changes only when adding as long) 
    require poolShortOtokenBalance_  == _poolShortOtokenBalance;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
3edc675e26f6df969ebaab972be9d2c9,201,rule,integrityOfReturnFunds,184,200,returnFunds,"rule integrityOfReturnFunds(uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract);

    uint256 balanceStakeTokenSenderBefore = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenSenderBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    returnFunds(e, amount);
    uint256 balanceStakeTokenSenderAfter = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenVaultAfter > 0);
    assert balanceStakeTokenSenderAfter == balanceStakeTokenSenderBefore - amount;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore + amount;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
3f5b2aa80e0c2eda650a4fc543aebf25,514,rule,integrityOfisBorrowingOne,107,111,isBorrowing,"// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
// }
","isBorrowing (Lines 87-95), ","  function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
3f8558e6651d209c2dd9ce496276fc1c,251,rule,totalAssets_stable,281,284,claimRewardsOnBehalf,"rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
","claimRewardsOnBehalf (Lines 280-291), ","  function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
3fadea93da0abc22743706ea48972a0c,1095 | 1096,rule,integrityOfRebalanceUserDiscountPercent_updateIndex,622,628,updateDiscountDistribution | rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_updateIndex() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	assert(getUserCurrentIndex(user) == index);
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
41259f74d90666460170f6c3f7cde3b8,1497 | 1498,rule,transferBalanceIncreaseEffect,281,295,balanceOf | safeTransferFrom,"rule transferBalanceIncreaseEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require from != other;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
416fc93381a0c0b0e278f5938f4bc495,2482,rule,tr_initializedOnlyChange,835,845,initialize,"rule tr_initializedOnlyChange(method f){     
    bool initBefore = initialized();

    env e;
    calldataarg args;
    f(e, args);
    bool initAfter = initialized();
    assert initBefore != initAfter <=> f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector, ""initialized was changed by wrong method"";
}
","initialize (Lines 28-35), ","    function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
416fe8e50d23269d127c38d71950a3ca,234 | 235,rule,that,102,165,initialize | BRIDGE_L2.deposit,"    // If any rule that count on the reward token balance, calls this method a `require RewardsVault != to` make sense to add
    //claimRewards(address[], uint256, address) returns (uint256) => DISPATCHER(true)
    getRewardsBalance(address[], address) returns (uint256) => DISPATCHER(true)

/***************************
 *     BridgeL2Harness     *
 ***************************/
    BRIDGE_L2.l2RewardsIndexSetter(uint256)
    BRIDGE_L2.deposit(address, uint256, address) 
    BRIDGE_L2.initiateWithdraw(address, uint256, address, address, bool)
    BRIDGE_L2.bridgeRewards(address, address, uint256)
    BRIDGE_L2.claimRewards(address, address)
    BRIDGE_L2.l2RewardsIndex() returns (uint256) envfree
    BRIDGE_L2.getStaticATokenAddress(address) returns (address) envfree
    BRIDGE_L2.address2uint256(address) returns (uint256) envfree
    l1ToL2MessageNonce() returns (uint256) => NONDET
/******************
 *     Tokens     *
 ******************/
    UNDERLYING_ASSET_ADDRESS() returns (address) => DISPATCHER(true)
    ATOKEN_A.UNDERLYING_ASSET_ADDRESS() returns (address) envfree
    ATOKEN_B.UNDERLYING_ASSET_ADDRESS() returns (address) envfree  
    claimRewards(address) returns (uint256) => DISPATCHER(true)
    getRewTokenAddress() returns (address) => rewardToken()
 *     Ray Math   *
 // See also notes at bottom of file (under ""Summarizations"")
 // Comment out the next two lines to remove the simplification,
 // and let the prover use the original library functions.
   // rayMul(uint256 a, uint256 b) returns (uint256) => rayMulConst(a, b)
   // rayDiv(uint256 a, uint256 b) returns (uint256) => rayDivConst(a, b)
}
////////////////////////////////////////////////////////////////////////////
//                       Definitions                                      //
// Definition of RAY unit
definition RAY() returns uint256 = 10^27;
definition MAX_ARRAY_LENGTH() returns uint256 = max_uint;
// Used for the Ray math summarization.
// Effectively sets the liquidity index in L1 to be a constant, given
// by the following value.
// Note: if the summarization is not used, i.e. they are commented out,
// this value has no use.
definition myConstRayValue() returns uint256 = (10*RAY())/2;
// The following definition shall be used later in some invariants,
// by filtering out the 'initialize' function.
definition excludeInitialize(method f) returns bool =
    f.selector != 
    initialize(uint256, address, address, address[], uint256[], uint256[]).selector; 
// A filter for parametric rules.
// The functions receiveRewards and withdraw should not be called by an external user
// Unless a message was already sent, which we mock through the additional functions that
// call the L2 interface.
// Using this filter via:
// filtered{f -> messageSentFilter(f)} will reduce running time, by skipping the analysis
","initialize (Lines 53-71),  | deposit (Lines 74-140), ","    function initialize(
        uint256 l2Bridge,
        address messagingContract,
        address incentivesController,
        address[] calldata l1Tokens,
        uint256[] calldata l2Tokens,
        uint256[] calldata ceilings
    ) external virtual onlyValidL2Address(l2Bridge) initializer {
        require(
            address(incentivesController) != address(0),
            Errors.B_INVALID_INCENTIVES_CONTROLLER_ADDRESS
        );
        _messagingContract = IStarknetMessaging(messagingContract);
        _l2Bridge = l2Bridge;
        _incentivesController = IAaveIncentivesController(incentivesController);
        _rewardToken = IERC20(_incentivesController.REWARD_TOKEN());

        _approveBridgeTokens(l1Tokens, l2Tokens, ceilings);
    }
 |     function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/setup.spec,,Yes,
4227f00ee484759743eac597f2a71ae8,2263,rule,correctnessOfSplitResults,26,32,split,"rule correctnessOfSplitResults() {
rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
    env e; uint256 userId; uint128 amount; uint128 collectableAmt; uint128 splitAmt;
    collectableAmt, splitAmt = splitResults(e, userId, true, amount);
    assert amount == collectableAmt + splitAmt;
","split (Lines 343-349), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
426f1198739c486be1336d6b8277c132,2402,invariant,noIssuerForNonInitialized,192,224,allowEmergencyWithdraw,"invariant noIssuerForNonInitialized()
    !initialized() => issuer() == 0

// STATUS - verified
invariant noAllocationIfNonInitialized(address user)
    !initialized() => getUserAllocation(user) == 0
invariant noBalanceIfNonInitialized(address user)
    !initialized() => getUserBalance(user) == 0
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/f186e56361246ec8fd72/?anonymousKey=f862b3d27b1ace55116959f9788d3e2a6e5d56c1
invariant notStoppedIfNonInitialized()
    !initialized() => !stopped()
// STATUS - 
invariant noAuctionStartIfNonInitialized()
    !initialized() => auctionStart() == 0
// ALWAYS
// - getUI[issuer].allocation == 0
invariant al_issuer_allocation_zero(address user)
    getUserAllocation(issuer()) == 0
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
432ef9f3ac5b304e3d2889caca3ac4c9,231,invariant,alwaysUnSent,17,63,deposit,"use invariant alwaysUnSent // Imports the invariant alwaysUnSent
use invariant ATokenAssetPair // Imports the invariant ATokenAssetPair

////////////////////////////////////////////////////////////////////////////
//                       Rules                                            //
// A call to deposit and a subsequent call to withdraw with the same amount of 
// staticATokens received, should yield the same original balance for the user.
// For underlying tokens, the condition is modified by a bound, since staticToDynamic is not inversible with dyanmicToStatic.
rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset
    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,,Yes,
43629d13110e25cce99299a81b48fdc5,2142 | 2143 | 2146,rule,reverseOptInThenOut,96,119,rebaseOptIn | rebaseOptOut | changeSupply,"rule reverseOptInThenOut(address u) {
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0(); // had typo, TODO rerun
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	env eF;
	require eF.msg.sender == u;
	uint256 _nonRebasingSupply = nonRebasingSupply();
	uint256 _rebasingCredits = rebasingCredits();
	uint256 _balance = balanceOf(u);
	uint256 _nonRebasingCreditsPerToken = nonRebasingCreditsPerToken(u);
	// assume currently not opt-in // TODO: Strengthen - should be explicity it's opt-out or require that it is not rebasing at the moment it's run
	require rebaseState(u) != OPT_IN();
	sinvoke rebaseOptIn(eF);
	sinvoke rebaseOptOut(eF);
	uint256 nonRebasingSupply_ = nonRebasingSupply();
	assert _nonRebasingSupply == nonRebasingSupply_, ""non rebasing supply must be preserved when opting-in and immediately opting-out"";
	uint256 rebasingCredits_ = rebasingCredits();
	assert _rebasingCredits == rebasingCredits_, ""rebasing credits must be preserved when opting-in and immediately opting-out"";
	uint256 balance_ = balanceOf(u);
	assert _balance == balance_, ""balance of user must be preserved if user opts-in and immediately opts-out"";
","rebaseOptIn (Lines 424-445),  | rebaseOptOut (Lines 450-464),  | changeSupply (Lines 472-507), ","    function rebaseOptIn() public nonReentrant {
        require(_isNonRebasingAccount(msg.sender), ""Account has not opted out"");

        // Convert balance into the same amount at the current exchange rate
        uint256 newCreditBalance = _creditBalances[msg.sender]
            .mul(rebasingCreditsPerToken)
            .div(_creditsPerToken(msg.sender));

        // Decreasing non rebasing supply
        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));

        _creditBalances[msg.sender] = newCreditBalance;

        // Increase rebasing credits, totalSupply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.add(_creditBalances[msg.sender]);

        rebaseState[msg.sender] = RebaseOptions.OptIn;

        // Delete any fixed credits per token
        delete nonRebasingCreditsPerToken[msg.sender];
    }
 |     function rebaseOptOut() public nonReentrant {
        require(!_isNonRebasingAccount(msg.sender), ""Account has not opted in"");

        // Increase non rebasing supply
        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));
        // Set fixed credits per token
        nonRebasingCreditsPerToken[msg.sender] = rebasingCreditsPerToken;

        // Decrease rebasing credits, total supply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.sub(_creditBalances[msg.sender]);

        // Mark explicitly opted out of rebasing
        rebaseState[msg.sender] = RebaseOptions.OptOut;
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
43d0714ea3d88400a5cdb54353af5fd8,1365 | 1367,rule,impliedRateSlippageDoesNotChangeWithTime,237,261,getRateScalar | executeTrade,"rule impliedRateSlippageDoesNotChangeWithTime(
    int256 fCashToAccount,
    uint256 timeDelta
) {
    env e;
    // Ensure that the block time is within the tradeable region
    require timeDelta <= QUARTER() && e.block.timestamp + timeDelta < MATURITY();
    require fCashToAccount != 0;
    uint256 timeToMaturity_first = MATURITY() - e.block.timestamp;
    uint256 timeToMaturity_second = MATURITY() - e.block.timestamp - timeDelta;
    require getRateScalar(timeToMaturity_first) > 0;
    require getRateScalar(timeToMaturity_second) > 0;

    storage initStorage = lastStorage;
    executeTrade(timeToMaturity_first, fCashToAccount);
    uint256 lastImpliedRate_first = getLastImpliedRate();
    executeTrade(timeToMaturity_second, fCashToAccount) at initStorage;
    uint256 lastImpliedRate_second = getLastImpliedRate();
    require lastImpliedRate_first < 1000000 && lastImpliedRate_second < 1000000;
    assert absDiff(lastImpliedRate_first, lastImpliedRate_second) < basisPoint(),
        ""Last implied rate slippage increases with time"";
}
","getRateScalar (Lines 39-53),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
4492ae36303c48e811fd9b38a8d238a1,1546 | 1549 | 1551,invariant,for,118,156,execute | castVote | proposalVotes,"    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));

    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
","execute (Lines 96-104),  | castVote (Lines 413-416),  | proposalVotes (Lines 50-62), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {
        address voter = _msgSender();
        return _castVote(proposalId, voter, support, """");
    }
 |     function proposalVotes(uint256 proposalId)
        public
        view
        virtual
        returns (
            uint256 againstVotes,
            uint256 forVotes,
            uint256 abstainVotes
        )
    {
        ProposalVote storage proposalvote = _proposalVotes[proposalId];
        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);
    }
",./openzepplin/specs/RulesInProgress.spec,,Yes,
45525100b586c92f5f0ca2143f7b4cc8,2182,rule,checkBurnExactLiquidity,29,45,callBurnExactLiquidity,"rule checkBurnExactLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity
    ){
        env e;
        require to == e.msg.sender;
        uint256 amount0;
        uint256 amount1;
        amount0, amount1 = callBurnExactLiquidity(e,
            tickLower,
            tickUpper,
            liquidity,
            e.msg.sender);
        assert liquidity == 0 => amount0 == 0 && amount1 == 0;
        assert liquidity > 0 => amount0 > 0 || amount1 > 0;// && (amount0 <= liquidity || amount1 <= liquidity);
}
","callBurnExactLiquidity (Lines 33-41), ","    function callBurnExactLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity,
        address to
    ) external returns (uint256 amount0, uint256 amount1) {
        
        (amount0 , amount1) = PoolActions.burnExactLiquidity(pool, tickLower, tickUpper, liquidity, to);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,,Yes,
45b72e5e6fd0c8a975a7ebba8ade9d6a,777 | 778,rule,gettersInAgreement,404,431,getLegacySigner | getDefaultSigner,"rule gettersInAgreement() {
	address account;
	require account != 0;
	bytes32 role;
	address indexedSigner = getIndexedSigner(account, role);
	address defaultSigner = getDefaultSigner(account, role);
	address legacySigner = getLegacySigner(account, role);
	address voteSigner = getVoteSigner(account);
	address validatorSigner = getValidatorSigner(account);
	address attestationSigner = getAttestationSigner(account);

	if (role == _getVoteRole()) {
		assert indexedSigner == legacySigner && indexedSigner == voteSigner, ""indexed signer agrees with legacy signer for vote role"";
	} else if (role == _getValidatorRole()) {
		assert indexedSigner == legacySigner && indexedSigner == validatorSigner, ""indexed signer agrees with legacy signer for validator role"";
	} else if (role == _getAttestationRole()) {
		assert indexedSigner == legacySigner && indexedSigner == attestationSigner, ""indexed signer agrees with legacy signer for attestation role"";
	} else {
		assert indexedSigner == defaultSigner, ""for any non legacy role indexed signer is default signer"";
	}
	assert indexedSigner != 0 && defaultSigner != 0 && legacySigner != 0 
		&& voteSigner != 0 && validatorSigner != 0 && attestationSigner != 0, ""signer is never address 0"";
	// original assertion is wrong
	//assert indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
	assert !isLegacyRole(role) && indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
}
","getLegacySigner (Lines 815-829),  | getDefaultSigner (Lines 837-840), ","  function getLegacySigner(address _account, bytes32 role) public view returns (address) {
    require(isLegacyRole(role), ""Role is not a legacy signer"");

    Account storage account = accounts[_account];
    address signer;
    if (role == ValidatorSigner) {
      signer = account.signers.validator;
    } else if (role == AttestationSigner) {
      signer = account.signers.attestation;
    } else if (role == VoteSigner) {
      signer = account.signers.vote;
    }

    return signer == address(0) ? _account : signer;
  }
 |   function getDefaultSigner(address account, bytes32 role) public view returns (address) {
    address defaultSigner = defaultSigners[account][role];
    return defaultSigner == address(0) ? account : defaultSigner;
  }
",./celo_governance/specs/accounts.spec,,Yes,
4622ab7641b781fb1314bb8cca221c4c,619 | 620,rule,burnZeroDoesntChangeBalance,202,208,balanceOf | burn,"rule burnZeroDoesntChangeBalance(address u, uint256 index) {
	env e;
	uint256 balanceBefore = balanceOf(u);
	invoke burn(e, u, 0, index);
	uint256 balanceAfter = balanceOf(u);
	assert balanceBefore == balanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
466147d681a7443c369915dd2914ed64,915,rule,noOverwrite,370,381,postProcess,"rule noOverwrite(method f, uint slot) {
    require getStackLength() < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthBefore = getStackLength();

    arbitrary(f);
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
}
    uint oldValue = getSlot(slot);
    uint newValue = getSlot(slot);
    
    // slot 0 is stack length, postProcess() may nullify it and it's fine, and execs() can increase it
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;
    assert ethBalance(currentContract) == 0;
    assert oldValue != 0 => (newValue == oldValue 
            || slot == getStackLengthSlot()), ""Slot $slot changd during this execution"";
","postProcess (Lines 334-344), ","    function postProcess() external payable override {
        bytes4 sig = stack.getSig();
        // selector of openLockETHAndDraw(uint256,address,address,bytes32,uint256)
        // and openLockGemAndDraw(address,address,bytes32,uint256,uint256)
        if (sig == 0x5481e4a4 || sig == 0x73af24e7) {
            _transferCdp(uint256(stack.get()));
            uint256 amount = IERC20(DAI_TOKEN).balanceOf(address(this));
            if (amount > 0)
                IERC20(DAI_TOKEN).safeTransfer(_getSender(), amount);
        } else revert(""Invalid post process"");
    }
",./furucombo/specs/proxy.spec,,Yes,
4727fab67f7fc19673fcc5577ffb230f,2230,rule,integrityOfMulDiv,22,38,callMulDiv,"rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
","callMulDiv (Lines 8-13), ","    function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,,Yes,
4879ee50b1caf11afce7225570d289b6,674,rule,to,273,302,previewWithdraw,"// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
49a3f5a95b99d82d25e19278dac469be,1950 | 1952,rule,cantSettleUnexpiredVault,242,251,smallVault | settleVault,"rule cantSettleUnexpiredVault(address owner, uint256 vaultId)
{
    links();
    env e;
    require !isVaultExpired(e, owner, vaultId);
    require smallVault(owner, vaultId, 1);
    address whoever;
    sinvoke settleVault(e, owner, vaultId, whoever);
    assert false; // will pass because cannot sinvoke settleVault when dealing with a non-expired vault
}
","smallVault (Lines 53-66),  | settleVault (Lines 360-367), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
49cbf0bbe3ea148d0728ba8ed871b3a3,37,rule,executedForever,224,231,getCurrentState,"rule executedForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 1;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 1;
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
4ab50f0aab632ef906f191e4844d9720,2258 | 2260 | 2261,invariant,of,267,303,split | _setSplits | _assertSplitsValid,"/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
4ae922ad792edd020b114056640e7d5a,1229,rule,totalAssetsPreservedOnWithdraw,236,244,seizeBond,"rule totalAssetsPreservedOnWithdraw(address operator, address owner, address beneficiary, uint256 amount) {
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
     env e;
     require beneficiaryOf(operator) == beneficiary;
     require beneficiary != currentContract;
     mathint totalAssets = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary);
     withdraw(e, amount, operator);
     assert totalAssets == totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary),
     ""withdraw can change the total assets of an operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
4b38832ee95c4814758b06189b7a4033,1707 | 1708 | 1709,invariant,validVault,39,66,addShort | addLong | addCollateral,"invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
4b64abcbac1abba4a89abd58adb082d2,2136,rule,totalSupplyIntegrity,54,62,changeSupply,"rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
4bd533864b70599a860629e3974e5edb,467 | 468 | 469 | 471 | 473,invariant,integrityOfisBorrowingAny,124,132,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()

// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
4bd6efb816b95b42fd98e1ac04702afb,76,rule,cancelPriviliged,523,532,cancel,"rule cancelPriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	cancel(e1, args1);
	cancel@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","cancel (Lines 110-132), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
4c159c21e7a59af1463f4d50a3c91157,2173,rule,transferCheckPreconditions,214,227,transfer,"rule transferCheckPreconditions(env e, address to, uint256 value)
{
	require to != 0;
	require value != 0;
	
	address from = e.msg.sender;
	bool precondition = balanceOf(from) >= value;

	bool result = transfer@withrevert(e, to, value);
	bool transferReverted = lastReverted; // loading transferReverted
	// The transfer function must meet the precondition, or to revert.
	assert !precondition => (transferReverted || !result), ""If transfer() precondition does not hold, must either revert or return 0"";
}
","transfer (Lines 109-121), ","    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Transfer to zero address"");
        require(
            _value <= balanceOf(msg.sender),
            ""Transfer greater than balance""
        );

        _executeTransfer(msg.sender, _to, _value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }
",./ousd/spec/ousd.spec,,Yes,
4c4f5c4d93c32aa5dbcae1eccc5aac54,1282,rule,validChangeToEverDeposited,550,560,deposit,"rule validChangeToEverDeposited(address o,  method f) {
    env e;
    calldataarg args;
    uint256 before = everDeposited(o);
    f(e, args);
    uint256 after = everDeposited(o);
    assert after == before ||
           ( ( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
               f.selector==delegate(address, address, address).selector ) &&
               after == before + e.msg.value );
}
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
4c9bcbb4e03d18334497bdd05364825a,1234,rule,totalAssetsPreservedOnSeizeBond,254,263,seizeBond,"rule totalAssetsPreservedOnSeizeBond(address operator, address owner, uint256 referenceID,
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
            uint256 amount, address destination) {
    require destination == otherBeneficiary;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    seizeBond(e, operator, referenceID, amount, destination);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    assert  totalAssetsBefore == totalAssetsAfter,
        ""seizeBond can change the total assets of operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
4d593c910fdf96790b413f35eed43274,337,rule,balanceOfChange,21,36,balanceOf,"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a!=b;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter );
}
","balanceOf (Lines 106-115), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
4e66823ad45575caac88bbc2b75ae2d6,5 | 12,invariant,minDelayLtMaxDelay,81,112,processMessageFromRoot | getCurrentState,"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
50299db1cddda6698e2c0623efa8b49c,2416 | 2417,invariant,opPairAndTotalSupplyCorrelation,437,444,allowEmergencyWithdraw | initialize,"invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
50a9fca8da61c5821b9b15f58b551b72,1472,rule,multipleTokenBurnBurnBatchEquivalence,102,138,balanceOf,"rule multipleTokenBurnBurnBatchEquivalence {
    storage beforeBurns = lastStorage;
    env e;

    address holder;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalanceA = balanceOf(holder, tokenA);
    mathint startingBalanceB = balanceOf(holder, tokenB);
    mathint startingBalanceC = balanceOf(holder, tokenC);
    require tokens.length == 3; require burnAmounts.length == 3;
    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;
    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;
    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;
    // burning via burn
    burn(e, holder, tokenA, burnAmountA) at beforeBurns;
    burn(e, holder, tokenB, burnAmountB);
    burn(e, holder, tokenC, burnAmountC);
    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;
    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    assert burnBalanceChangeA == burnBatchBalanceChangeA
        && burnBalanceChangeB == burnBatchBalanceChangeB
        && burnBalanceChangeC == burnBatchBalanceChangeC, 
        ""Burning multiple tokens via burn or burnBatch must be equivalent"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
50ff229184cf4e472df89b28102a81ab,420 | 421,rule,mintNoChangeToOther,292,306,mint | balanceOf,"rule mintNoChangeToOther(address user, uint256 amount, uint256 index, address other)
{
	require other != user;

	env e;
	uint128 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	address caller; 
	mint(e, caller, user, amount, index);
	uint128 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
510e4c7b63ea5358de0d810e6fcc4262,582,rule,integrityDelegationWithSig,176,181,delegationWithSig,"rule integrityDelegationWithSig(address delegator, address delegatee, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) {
    env e;
    uint256 oldNonce = nonces(e, delegator);
    delegationWithSig(e, delegator, delegatee, value, deadline, v, r, s);
    assert nonces(e, delegator) == oldNonce + 1 && borrowAllowance(e, delegator, delegatee) == value;
}
","delegationWithSig (Lines 43-68), ","  function delegationWithSig(
    address delegator,
    address delegatee,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external {
    require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[delegator];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(
          abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline)
        )
      )
    );
    require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[delegator] = currentValidNonce + 1;
    _approveDelegation(delegator, delegatee, value);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
512a4fbcaafc8e04288ecaae97ea81a9,1934 | 1935 | 1941 | 1942 | 1943 | 1944 | 1945 | 1946,rule,validBalanceTotalCollateralPostExpiry,217,240,smallVault | isValidVault | depositCollateral | withdrawCollateral | redeemA | redeemB | settleVault | getProceed,"// rule validBalanceTotalCollateralPostExpiry(address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
    // env e;
    // require oToken == shortOtoken;
    // require collateral == collateralToken;
    // require isValidVault(owner, vaultId); 
    // require getVaultShortOtoken(owner, vaultId, index) == oToken;
    // require getVaultCollateralAsset(owner, vaultId, index) == collateral;
    // uint256 collateralVaultBefore = getProceed(owner, vaultId);
    // uint256 supplyBefore = shortOtoken.totalSupply();
    // // uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);

    // sinvoke settleVault(e, owner, vaultId, to);
    // uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    // uint256 supplyAfter = shortOtoken.totalSupply();
    // // uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);
    // assert shortVaultAfter == 0;
    // assert supplyAfter == supplyBefore;
    // // assert collateralBalanceBefore - collateralBalanceAfter == collateralVaultBefore;
    
    // 1. in a single tx only 1 vault can be modified 
    // 
// }
","smallVault (Lines 53-66),  | isValidVault (Lines 79-88),  | depositCollateral (Lines 230-247),  | withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function isValidVault(address owner, uint256 vaultId) external view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    (, bool isValidVault) = calculator.getExcessCollateral(
      _vault.shortAmounts[0],
      _vault.longAmounts[0],
      _vault.collateralAmounts[0],
      vaultType[owner][vaultId]
    );
    return isValidVault;
  }
 |   function depositCollateral(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _depositCollateral(args);
  }
 |   function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
519aa6bac8de24bdc4241ee39522119a,2393,rule,verify_updateEmissionRate,393,398,updateEmissionRate,"rule verify_updateEmissionRate {
    env e; 
    uint256 emissionRate;
    updateEmissionRate(e, emissionRate);
    assert rJoePerSec() == emissionRate, ""emission rate not updated"";
}
","updateEmissionRate (Lines 168-176), ","    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        require(
            _rJoePerSec <= MAX_EMISSION_RATE,
            ""RocketJoeStaking: emission rate too high""
        );
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
51b1f1455f13f4b8140c12cbb9b998b6,1195 | 1199,invariant,validOperator,104,150,seizeBond | bondAmount,"invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )

/**
    @title Valid state of an operator .
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();
    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
            ( ownerOf(o)  0  beneficiaryOf(o)  0  authorizerOf(o)  0 )
rule validState(address operator, uint unbonded, uint totalLocked) {
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
52050103a2314e86b888effcb277d987,2521,rule,op_tokenIncentiveIssuerRefundUnchange,153,163,createPair,"rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){// createPair()

    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();
    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, ""tokenIncentiveIssuerRefund was changed"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
520c1ea3bc22b21cfd9a92829cc305e1,1297 | 1298 | 1299,rule,like,37,50,getCashBalance | getAmountToSettle | settleAccount,"// The intent of a rule like this is to ensure that when we settle fCash or liquidity tokens
// we do the correct calculation to return the settlement balance. The settlement balance for fCash
// will simply be an asset cash amount based on the settlement rate. The settlement logic for liquidity
// tokens has two potential outcomes. We may want to have three separate rules for this.
// rule assetsConvertToCashAtSettlementRate(address account, uint256 currencyId) {
//     env e;
//     int256 cashBefore = getCashBalance(currencyId, account);
//     // This should get the amount of cash back, would we really be proving anything
//     // with this approach? It's quite circular if we need to write another harness...
//     int256 amountToSettle = getAmountToSettle(currencyId, account, e.block.timestamp);
//     settleAccount(e, account);
//     int256 cashAfter = getCashBalance(currencyId, account);
//     assert cashAfter - cashBefore == amountToSettle;
// }
","getCashBalance (Lines 80-84),  | getAmountToSettle (Lines 67-83),  | settleAccount (Lines 34-40), ","    function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
 |     function getAmountToSettle(
        uint256 currencyId,
        address account,
        uint256 blockTime
    ) external view returns (int256) {
        int256 amountToSettle;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            // TODO: incomplete, but is this even the right approach?
            if (assets[i].getSettlementDate() <= blockTime && assets[i].currencyId == currencyId) {
                // AssetRate memory ar = AssetRate.buildSettlementRateView(currencyId, maturity);
            }
        }

        return amountToSettle;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,,Yes,
529d6a10e44c73ba00411bbbff1bc774,1045,rule,times,283,322,updateDiscountDistribution,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));

	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
/***************************************************************
* Integrity of Mint
***************************************************************/
* @title proves that after calling mint, the user's discount rate is up to date
rule integrityOfMint_updateDiscountRate() {
	address user1;
	address user2;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	mint(e, user1, user2, amount, index);
	uint256 debtBalance = balanceOf(e, user2);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user2);
	uint256 discountRate = getUserDiscountRate(user2);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
53351ec08b433d2bbb6f664070cbd913,602 | 603 | 604,rule,inverseMintBurn,102,109,mint | balanceOf | burn,"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 index) {
	env e;
	uint256 balancebefore = balanceOf(a);
	mint(e, delegatedUser, a, amount, index);
	burn(e, a, amount, index);
	uint256 balanceAfter = balanceOf(a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
5361a18372eabd106947b6ce8348610a,1518,rule,cantMintOtherBalances,558,569,balanceOf,"rule cantMintOtherBalances(env e){
    address to; uint256 id; uint256 amount; bytes data;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
5469a2ca6f387e7ad4f58768baa6ed6b,245,rule,If,375,450,deposit,"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
5482195dc811971ad08ec18f89a78ecd,1599 | 1603,rule,sanity,181,198,balanceOf | _delegate,"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,,Yes,
54b857c4706c889257933f670394ab53,1752 | 1753 | 1754 | 1755,rule,integrityOfAddCollateral,133,140,addShort | addLong | addCollateral | totalCollateral,"rule integrityOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	assert totalCollateral() == collateralBefore + x, ""integirty break of addCollateral"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
54e7fae8a4ca77f72c55d0cfa7524228,2540,rule,hl_stoppedOnlySwitch,183,192,allowEmergencyWithdraw,"rule hl_stoppedOnlySwitch(method f, env e){
    require !stopped();

    calldataarg args;
    f(e, args);
    bool isStopped = stopped();
    assert isStopped => f.selector == allowEmergencyWithdraw().selector, ""stopped was switch by wrong method"";
}
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
5580f1ebc1ec98391171bafc1a981970,1646,rule,sanity,219,234,_delegate,"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","_delegate (Lines 127-133), ","    function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
559e8f53cbd85ad6dfcd5310cd05c816,178 | 179,invariant,cooldownAmountNotGreaterThanBalance,51,71,transfer | transferFrom,"invariant cooldownAmountNotGreaterThanBalance(address user)
    balanceOf(user) >= cooldownAmount(user)
    {
        preserved with (env e1)
        {
            requireInvariant cooldownDataCorrectness(user, e1);
            requireInvariant totalSupplyGreaterThanUserBalance(user);
invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
            requireInvariant cooldownDataCorrectness(user, e2);
            requireInvariant cooldownDataCorrectness(user, e3);
","transfer (Lines 53-61),  | transferFrom (Lines 81-90), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
 |   function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external override returns (bool) {
    b[sender] = sub(b[sender], amount);
    b[recipient] = add(b[recipient], amount);
    a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
    return true;
  }
",./aave_staked_token/certora/specs/invariants.spec,,Yes,
55af934df981631a3b1ac7ac34970b2e,2406 | 2407,invariant,initPhaseTimesSet,301,323,currentPhase | createPair,"invariant initPhaseTimesSet()
    initialized() => ( PHASE_ONE_DURATION() == twoDays()
            && PHASE_ONE_NO_FEE_DURATION() == oneDay() && PHASE_TWO_DURATION() == oneDay())

// STATUS - verified
//  - `issuerTimelock` > `userTimelock`
invariant initTimelocksCorrelation()
    initialized() => issuerTimelock() > userTimelock()
// STATUS - verified (with invariant that is not finished and with Phases, otherwise createPair() causes a violation(violation as below))
// run: https://vaas-stg.certora.com/output/3106/2ae7324af16683029e39/?anonymousKey=7202818cb360a87ab732a0ccdd7b9b3fa8c34f50
// - `tokenIncentivesForUsers` == `tokenIncentivesBalance`
invariant initIncentivesCorrelation()
    initialized() => tokenIncentivesForUsers() == tokenIncentivesBalance()
    {
        preserved with (env e2){
            requireInvariant initNotStopped();
            require pair() == 0;
            require currentPhase(e2) == NotStarted();
        }
    }
","currentPhase (Lines 319-330),  | createPair (Lines 402-450), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
5627120e20d26fc4bf1d052eed2c8340,2512,invariant,cl_avaxAllocSumUserBalances,248,255,currentPhase,"invariant cl_avaxAllocSumUserBalances()
    closed() => avaxAllocated() == sum_of_users_balances()
    { 
        preserved with (env e2) { 
            require currentPhase(e2) == PhaseThree();
            safeAssumptions(e2); 
        } 
    }
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,,Yes,
56617b3880c82c42b356f92974aab50a,828 | 831 | 833 | 835,rule,cant_unvote,143,161,getUpvotedProposal | upvote | getVoteRecord | getUpvoteRecord,"rule cant_unvote(uint256 deqIndex, uint8 voteValue) {	
    env eF;
	uint256 NONE_ENUM = getNoneVoteEnum();
	// get the voting delegate
	address voterDelegate = accounts.getVoteSigner(eF.msg.sender);
	
	// check if voted
    uint256 p;
	uint256 recordValue;
    uint256 weight;
	p, recordValue, weight = getVoteRecord(voterDelegate,deqIndex);
	bool result = vote(eF,p,deqIndex,voteValue);
	uint256 recordValue_;
    uint256 weight_;
	_, recordValue_, weight_ = getVoteRecord(voterDelegate,deqIndex);
	assert voteValue == NONE_ENUM => (!result && recordValue_ == recordValue && weight_ == weight), ""Cannot vote for none: function either returns false and did not update the vote, or it reverted""; // not voting none. reverting is fine and is encoded by the safe invoke
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getVoteRecord (Lines 1102-1116),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getVoteRecord(address account, uint256 index)
    external
    view
    returns (uint256, uint256, uint256, uint256, uint256, uint256)
  {
    VoteRecord storage record = voters[account].referendumVotes[index];
    return (
      record.proposalId,
      uint256(record.deprecated_value),
      record.deprecated_weight,
      record.yesVotes,
      record.noVotes,
      record.abstainVotes
    );
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
568d3a9c49e60409c2162d6f542d23a6,2488 | 2489,rule,cl_hasWithdrawnPair_pairBalance_OnlyChangeUser,923,939,withdrawLiquidity | pairBalance,"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeUser(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user != issuer();

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    uint256 possiblePairBalance = pairBalance(e, user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + possiblePairBalance) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
","withdrawLiquidity (Lines 453-470),  | pairBalance (Lines 623-632), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
568f1c053d910601ac7880d98abeb0b3,510,rule,integrityOfisUsingAsCollateralOne,85,89,isUsingAsCollateral,"// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// }
","isUsingAsCollateral (Lines 103-111), ","  function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
570cc6cdb48dec953ee13ed87d311009,955,rule,unregisterCallerIsPermanent2,80,86,unregisterCaller,"rule unregisterCallerIsPermanent2(method f, address caller) {
rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
    require callers(caller) == deprecated();
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,,Yes,
57279cad5cd958e693560558b84af120,795 | 797 | 799,invariant,is,73,97,getUpvotedProposal | upvote | getUpvoteRecord,"    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
5760809d382e614b2e536ca6a6b7b0fe,951,rule,deprecatesCaller,46,52,unregisterCaller,"rule deprecatesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != unregisterCaller(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates caller"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,,Yes,
57f037ca40cdff3366648467b86dcc7f,1368 | 1369,rule,bitNumAndMaturitiesMustMatch,21,33,getMaturityFromBitNum | getBitNumFromMaturity,"rule bitNumAndMaturitiesMustMatch(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    uint256 bitNum;
    bool isExact;
    bitNum, isExact = getBitNumFromMaturity(blockTime, maturity);
    uint256 calculatedMaturity = getMaturityFromBitNum(blockTime, bitNum);

    // If the bitnum is not exact then the calculated maturity will not match
    assert isExact => maturity == calculatedMaturity, ""maturity does not match calculated maturity"";
}
","getMaturityFromBitNum (Lines 150-188),  | getBitNumFromMaturity (Lines 95-146), ","    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        internal
        pure
        returns (uint256)
    {
        require(bitNum != 0); // dev: cash group get maturity from bit num is zero
        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);
        uint256 firstBit;

        if (bitNum <= Constants.WEEK_BIT_OFFSET) {
            return blockTimeUTC0 + bitNum * Constants.DAY;
        }

        if (bitNum <= Constants.MONTH_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_DAY_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.WEEK);
            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;
        }

        if (bitNum <= Constants.QUARTER_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_WEEK_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.MONTH);
            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;
        }

        firstBit =
            blockTimeUTC0 +
            Constants.MAX_MONTH_OFFSET *
            Constants.DAY -
            (blockTimeUTC0 % Constants.QUARTER);
        return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;
    }
 |     function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        internal
        pure
        returns (uint256, bool)
    {
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);

        if (maturity % Constants.DAY != 0) return (0, false);
        if (blockTimeUTC0 >= maturity) return (0, false);

        // Overflow check done above
        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;

        // These if statements need to fall through to the next one
        if (daysOffset <= Constants.MAX_DAY_OFFSET) {
            return (daysOffset, true);
        }

        if (daysOffset <= Constants.MAX_WEEK_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_DAY_OFFSET +
                    (blockTimeUTC0 % Constants.WEEK) /
                    Constants.DAY;
            // Ensures that the maturity specified falls on the actual day, otherwise division
            // will truncate it
            return (Constants.WEEK_BIT_OFFSET + offset / 6, (offset % 6) == 0);
        }

        if (daysOffset <= Constants.MAX_MONTH_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_WEEK_OFFSET +
                    (blockTimeUTC0 % Constants.MONTH) /
                    Constants.DAY;

            return (Constants.MONTH_BIT_OFFSET + offset / 30, (offset % 30) == 0);
        }

        if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_MONTH_OFFSET +
                    (blockTimeUTC0 % Constants.QUARTER) /
                    Constants.DAY;

            return (Constants.QUARTER_BIT_OFFSET + offset / 90, (offset % 90) == 0);
        }

        // This is the maximum 1-indexed bit num
        return (256, false);
    }
",./notional_finance_v2/certora/asset/DateTime.spec,,Yes,
58a6a8906d2426b39b1127d638e4a6ed,425,rule,integrityBalanceOfTotalSupply,313,337,balanceOf,"// rule integrityBalanceOfTotalSupply(address a, address b, method f)
// {
// 	env e;
// 	require a!=b;
// 	uint256 balanceABefore = balanceOf(e,a);
// 	uint256 balanceBBefore = balanceOf(e,b);
// 	uint256 totalSupplyBefore = totalSupply(e);
	 
// 	calldataarg arg;
// 	sinvoke f(e, arg); 

// 	uint256 balanceAAfter = balanceOf(e,a);
// 	uint256 balanceBAfter = balanceOf(e,b);
// 	uint256 totalSupplyAfter = totalSupply(e);
// 	assert (balanceAAfter != balanceABefore && balanceBAfter != balanceBBefore) =>
// 	    ( (balanceAAfter - balanceABefore) + (balanceBAfter - balanceBBefore)  == totalSupplyAfter - totalSupplyBefore);
// 	require f.selector != transferFrom(address,address,uint256).selector &&
// 	        f.selector != transfer(address,uint256).selector &&
// 	        f.selector != transferOnLiquidation(address,address,uint256).selector;
// 	assert (balanceAAfter != balanceABefore &&  balanceBAfter == balanceBBefore ) =>
// 	    ( (balanceAAfter - balanceABefore)   == totalSupplyAfter - totalSupplyBefore);
		
// }
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
58a9465ac2c96e9af7f73bcc2742b4fc,339 | 342,rule,integirtyBalanceOfTotalSupply,42,56,balanceOf | burn,"rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
590e356532aac06ff9ba9fa1b8aa3fa3,2510,rule,hl_createPairAtLeastOnce,1309,1320,createPair,"rule hl_createPairAtLeastOnce(env e){
    require !stopped();

    // storage
    createPair(e);
    assert !lastReverted, ""createPair DoS"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
593e289ed837ac2cdb73525c2ee423fd,573,rule,setEModeCategoryIntegrity,163,166,setEModeCategory,"rule setEModeCategoryIntegrity(uint256 category) {
    setEModeCategory(category);
    assert getEModeCategory() == category;
}
","setEModeCategory (Lines 324-375), ","  function setEModeCategory(
    uint8 categoryId,
    uint16 ltv,
    uint16 liquidationThreshold,
    uint16 liquidationBonus,
    address oracle,
    string calldata label
  ) external override onlyRiskOrPoolAdmins {
    require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
    require(liquidationThreshold != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);

    // validation of the parameters: the LTV can
    // only be lower or equal than the liquidation threshold
    // (otherwise a loan against the asset would cause instantaneous liquidation)
    require(ltv <= liquidationThreshold, Errors.INVALID_EMODE_CATEGORY_PARAMS);
    require(
      liquidationBonus > PercentageMath.PERCENTAGE_FACTOR,
      Errors.INVALID_EMODE_CATEGORY_PARAMS
    );

    // if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment
    // a loan is taken there is enough collateral available to cover the liquidation bonus
    require(
      uint256(liquidationThreshold).percentMul(liquidationBonus) <=
        PercentageMath.PERCENTAGE_FACTOR,
      Errors.INVALID_EMODE_CATEGORY_PARAMS
    );

    address[] memory reserves = _pool.getReservesList();
    for (uint256 i = 0; i < reserves.length; i++) {
      DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(reserves[i]);
      if (categoryId == currentConfig.getEModeCategory()) {
        require(ltv > currentConfig.getLtv(), Errors.INVALID_EMODE_CATEGORY_PARAMS);
        require(
          liquidationThreshold > currentConfig.getLiquidationThreshold(),
          Errors.INVALID_EMODE_CATEGORY_PARAMS
        );
      }
    }

    _pool.configureEModeCategory(
      categoryId,
      DataTypes.EModeCategory({
        ltv: ltv,
        liquidationThreshold: liquidationThreshold,
        liquidationBonus: liquidationBonus,
        priceSource: oracle,
        label: label
      })
    );
    emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
5947b1a0a136479c1dbc3810dbd91a65,2626 | 2627 | 2628,rule,preserveTotalAssetsOfUser,226,265,transferMultiple | setStrategy | harvest,"rule preserveTotalAssetsOfUser(address token, address from, address to,
					    	   address user, uint256 amount, uint256 share,
							   method f) {
	env e;

	// verifying a simplified version
	require totalTokenAmount(token) == totalTokenShare(token);
	uint256 _userShares = balanceOf(token, user);
	// roundUp = true or false shouldn't matter as long as they are consistent
	mathint _userAssets = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true); 
	require user != currentContract &&  user == from && user == harnessFrom() && user == to;
	//for transfermultiple we assume that all transfer are to the same user
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint userAssets_ = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true);
	uint256 userShares_ = balanceOf(token, user);
	
	// transferMultiple transfer from user to some arbitrary other user so we expect assets to be preserved
	require  f.selector != transferMultiple(address,address,address[],uint256[]).selector; 
	// flash loan can reduce asset of user due to fee, and strategy can also reduce user assets due to negative profit
	if (f.selector != 0xf1676d37 && // hascode of flashLoan 
		f.selector != setStrategy(address,address).selector &&
		f.selector != harvest(address,bool,uint256).selector)
	{
		assert (_userAssets <= userAssets_,
			""total user assets not preserved"");
	}
	else  {
		// however on those functions, a user's share should not change
		assert (_userShares == userShares_,
}
","transferMultiple (Lines 42-51),  | setStrategy (Lines 1049-1082),  | harvest (Lines 26-33), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
 |     function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }
 |     function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
",./sushi_benttobox/spec/bentobox.spec,,Yes,
5990981935b4a7f4e51dab8559df3667,217,rule,returnFundsDecreaseExchangeRate,499,511,returnFunds,"rule returnFundsDecreaseExchangeRate(address receiver, uint256 amount) {
    env e;
    uint216 _ExchangeRate = getExchangeRate();

    // Currently, in the constructor, LOWER_BOUND = 10**decimals
    requireInvariant lowerBoundNotZero();
    returnFunds(e, amount);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ <= _ExchangeRate;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
59eebaaa170cc4aa596a032c8930aebc,1580,rule,recoverSpec,192,214,balanceOf,"rule recoverSpec(env e){
    address account; uint256 amount;

    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    mathint value = underlyingThisBalanceBefore - wrapperTotalBefore;
    _recover(e, account);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert wrapperTotalBefore == wrapperTotalAfter - value, ""wrapper total wrong update"";
    assert e.msg.sender == account => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - value, ""wrapper balances wrong update"";
    assert e.msg.sender != account => wrapperUserBalanceBefore == wrapperUserBalanceAfter - value
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
59f6b4127fa72f16d371ddaf860185f0,157,rule,LendIsBackedByAaveIncInitialize,42,61,"AAVE_ORIG.initialize, initialize","rule LendIsBackedByAaveIncInitialize(env e, method f){
invariant LendIsBackedByAave()
    ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract)
    {
        preserved with (env e){
            require e.msg.sender != LEND1;
            require e.msg.sender != AAVE1;
        }
    }
    require e.msg.sender != LEND1;
    require e.msg.sender != AAVE1;
    require ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
    
    if (f.selector == initialize(address, uint256, uint256, uint256).selector){
        address aaveMerkleDistributor; uint256 lendToMigratorAmount; uint256 lendToLendAmount; uint256 lendToAaveAmount;
        initialize(e, aaveMerkleDistributor, lendToMigratorAmount, lendToLendAmount, lendToAaveAmount);
        address lendToken = LEND1;
        address[] tokens; uint256[] amounts;
        env e2;
        AAVE_ORIG.initialize(e, tokens, amounts, aaveMerkleDistributor, lendToken, lendToAaveAmount);   
    else {
        calldataarg args;
        f(e, args);

    assert ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
}","initialize (Lines 1171-1181), ","  function initialize(address[] memory tokens, uint256[] memory amounts, address aaveMerkleDistributor, address lendToken, uint256 lendToAaveAmount) external initializer {
    // send tokens to distributor
    require(tokens.length == amounts.length, 'initialize(): amounts and tokens lengths inconsistent'); 
    for(uint i = 0; i < tokens.length; i++) {
      IERC20(tokens[i]).safeTransfer(aaveMerkleDistributor, amounts[i]);

      emit TokensRescued(tokens[i], aaveMerkleDistributor, amounts[i]);
    }

    IERC20(lendToken).safeTransfer(lendToken, lendToAaveAmount);
  }
",./aave_rescue_mission/specs/rescueLendMigrator.spec,,Yes,
5a0d8b2519b5fb0daee8ad4b681d1b8c,1101,rule,integrityOfBalanceOf_fullDiscount,651,660,updateDiscountDistribution,"rule integrityOfBalanceOf_fullDiscount() {
	address user;
	uint256 fullDiscountRate = 10000; //100%
	require(getUserDiscountRate(user) == fullDiscountRate);
	env e1;
	env e2;
	uint256 index1 = indexAtTimestamp(e1.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 index2 = indexAtTimestamp(e2.block.timestamp);
	assert(balanceOf(e1, user) == balanceOf(e2, user));
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
5a182d74a19204819c5e218591314b26,125 | 126,rule,executedValidTransition2,354,363,execute | getCurrentState,"rule executedValidTransition2(uint256 actionsSetId)
{
	env e;
	uint actionsSetId2;
	uint8 state1 = getCurrentState(e, actionsSetId);
		execute(e, actionsSetId2);
	uint8 state2 = getCurrentState(e, actionsSetId);

	assert actionsSetId2 == actionsSetId <=> state1 == 0 && state2 == 1;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
5a1d03cb925238e6374e30e6a280a510,2464 | 2465 | 2466 | 2467 | 2468,rule,op_tokenReserveUnchange,730,745,createPair | withdrawLiquidity | emergencyWithdraw | allowEmergencyWithdraw | initialize,"rule op_tokenReserveUnchange(method f, env e){
    require pair() == 0;                    // createPair() and withdrawLiquidity()
    requireInvariant pairAndGetPairCorrelation(e);   // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    requireInvariant op_not_stopped();      // emergencyWithdraw()
invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
    requireInvariant isInitialized();       // initialize()
    uint256 tokenReserveBefore = tokenReserve();
    calldataarg args;
    f(e, args);
    uint256 tokenReserveAfter = tokenReserve();
    assert tokenReserveBefore == tokenReserveAfter, ""tokenReserve was changed"";
}
","createPair (Lines 402-450),  | withdrawLiquidity (Lines 453-470),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
5a68d2714117ceaae69747fa7b42418a,2412,invariant,opTokenBalanceCheck,398,407,allowEmergencyWithdraw,"invariant opTokenBalanceCheck()
    pair() == 0 =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()
    {
        preserved with (env e2){
            requireInvariant op_not_stopped();
invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
            require token() == SymbERC20A || token() == SymbERC20B;
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
        preserved{
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant initIncentivesCorrelation();
    }  
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
5acbb5ad7fd15cd0514842f529f7edb4,1397 | 1398,rule,noChangeToOther,32,57,setAccountContext | getNextSettleTime,"rule noChangeToOther(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    address accountOther;
    require accountOther != account;
    require account != 0 && accountOther != 0;
    uint40 nextSettleTimeOther = getNextSettleTime(accountOther);
    uint8 hasDebtOther = getHasDebt(accountOther);
    uint8 assetArrayLengthOther = getAssetArrayLength(accountOther);
    uint16 bitmapCurrencyIdOther = getBitmapCurrency(accountOther);
    uint144 activeCurrenciesOther = getActiveCurrencies(accountOther);
        
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    
    assert getNextSettleTime(accountOther) == nextSettleTimeOther, ""next settle time does not match"";
    assert getHasDebt(accountOther) == hasDebtOther, ""has debt does not match"";
    assert getAssetArrayLength(accountOther) == assetArrayLengthOther, ""asset array length does not match"";
    assert getBitmapCurrency(accountOther) == bitmapCurrencyIdOther, ""bitmap currency id does not match"";
    assert getActiveCurrencies(accountOther) == activeCurrenciesOther, ""active currencies does not match"";
}
","setAccountContext (Lines 35-49),  | getNextSettleTime (Lines 393-396), ","    function setAccountContext(AccountContext memory accountContext, address account) internal {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data =
            (bytes32(uint256(accountContext.nextSettleTime)) |
                (bytes32(accountContext.hasDebt) >> 208) |
                (bytes32(uint256(accountContext.assetArrayLength)) << 48) |
                (bytes32(uint256(accountContext.bitmapCurrencyId)) << 56) |
                (bytes32(accountContext.activeCurrencies) >> 40));

        assembly {
            sstore(slot, data)
        }

        emit AccountContextUpdate(account);
    }
 |     function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {
        if (nToken.lastInitializedTime == 0) return 0;
        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;
    }
",./notional_finance_v2/certora/accountContext/SetAccountContext.spec,,Yes,
5b043ba29f63316fca2d8ddc2f1ed794,634,rule,getCLMFees_LEQ_ATokenBAL_DM_other,150,156,withdrawFees,"rule getCLMFees_LEQ_ATokenBAL_DM_other(method f) filtered {f ->
    !harnessOnlyMethods(f) &&
    !f.isView &&
    !is_withdraw_method(f) &&
    !is_redeem_method(f) &&
    f.selector != withdrawFees(address,uint256).selector
}
","withdrawFees (Lines 420-431), ","    function withdrawFees(address to, uint256 amount) public override onlyOwner {
        _accrueYield();
        require(amount <= _s.accumulatedFees, ""INSUFFICIENT_FEES""); // will underflow below anyway, error msg for clarity

        _s.accumulatedFees -= uint128(amount);

        ATOKEN.transfer(to, amount);

        _s.lastVaultBalance = uint128(ATOKEN.balanceOf(address(this)));

        emit FeesWithdrawn(to, amount, _s.lastVaultBalance, _s.accumulatedFees);
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,,Yes,
5b6710c4341e78f1615e26805e65fcc4,518 | 519 | 520 | 522 | 524,rule,integrityOfEmpty,128,132,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"// rule integrityOfEmpty(uint256 reserveIndex){
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
5c087f296552ff2cf5bd8a745882165c,1440 | 1441 | 1442 | 1444,rule,noStartBeforeCreation,230,242,propose | queue | execute | __acceptAdmin,"rule noStartBeforeCreation(uint256 pId) {
    uint256 previousStart = proposalSnapshot(pId);
    // This line makes sure that we see only cases where start date is changed from 0, i.e. creation of proposal
 // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
    // We proved in immutableFieldsAfterProposalCreation that once dates set for proposal, it cannot be changed
rule immutableFieldsAfterProposalCreation(uint256 pId, method f) {
    uint256 _voteStart = proposalSnapshot(pId);
    uint256 _voteEnd = proposalDeadline(pId);
    require proposalCreated(pId); // startDate > 0
    
    env e; calldataarg arg;
    f(e, arg);
    uint256 voteStart_ = proposalSnapshot(pId);
    uint256 voteEnd_ = proposalDeadline(pId);
    assert _voteStart == voteStart_, ""Start date was changed"";
    assert _voteEnd == voteEnd_, ""End date was changed"";
    require !proposalCreated(pId); // previousStart == 0;
    propose(e, args);
    uint256 newStart = proposalSnapshot(pId);
    // if created, start is after current block number (creation block)
    assert(newStart != previousStart => newStart >= e.block.number);
","propose (Lines 15-22),  | queue (Lines 90-107),  | execute (Lines 96-104),  | __acceptAdmin (Lines 168-170), ","    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public virtual override returns (uint256) {
        return super.propose(targets, values, calldatas, description);
    }
 |     function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,,Yes,
5c1eb3914f9849608311093a82e49318,318,rule,rewardsTotalDoesNotDeclineByDeposit,184,197,getTotalClaimableRewards,"rule rewardsTotalDoesNotDeclineByDeposit(uint256 assets) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	deposit(e, assets, e.msg.sender);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by deposit"";
}
","getTotalClaimableRewards (Lines 320-337), ","  function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/rewardPreserve.spec,,Yes,
5c51b33628edeeae8210a1c39c246e52,2221 | 2222 | 2224 | 2225,rule,withdraw_amount,423,456,deposit | withdraw | uniswapV3SwapCallback | collectProtocolFees,"// rule withdraw_amount(address to){
//     env e;

//     require governance() != currentContract;
//     require governance() != pool;
//     require (to!=governance() && to != pool && to != currentContract);
//     require e.msg.sender != pool && e.msg.sender != currentContract && e.msg.sender != governance();
//     require token0.balanceOf(currentContract) == 0 &&
//             token1.balanceOf(currentContract) == 0;
//             requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
//             requireInvariant zero_totalSupply_zero_owed();
    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    } 
    }
//             requireInvariant pool_balance_vs_owed();
    ///// invariant pool_balance_vs_owed()
    ////  verifies that pool balance greater equal to pool owed
    invariant pool_balance_vs_owed()
    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()
//             requireInvariant total_vs_protocol_Fees();
    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
//             requireInvariant liquidity_GE_poolBalance0();
    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
//             requireInvariant balance_contract_GE_protocolFees();
    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
//     uint256 shares;
//     uint256 amount0;
//     uint256 amount1;
//     uint256 totalsupply = totalSupply();
//     uint256 pool_balance0 = pool.balance0();
//     uint256 pool_owed0 = pool.owed0();
//             amount0,amount1 =  withdraw(e,shares, to);
    
//     // uint256 amount0_calc = (pool_balance0 - pool_owed0) * shares / totalsupply;
//     mathint amount0_calc = pool_balance0 * shares / totalsupply;
//     require amount0_calc >= 1;
//     assert  amount0 <= amount0_calc;
// }
","deposit (Lines 53-57),  | withdraw (Lines 59-63),  | uniswapV3SwapCallback (Lines 34-350),  | collectProtocolFees (Lines 2568-2585), ","    function deposit() external payable {
        // assume succeeds
        supply = supply.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
 |     function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
 |     function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
 |     function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
5c655d719ae080c15b2a709647a14e2e,668 | 672,rule,checks,241,264,previewWithdraw | _maxAssetsSuppliableToAave,"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewMint_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewMint(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewMint(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
","previewWithdraw (Lines 393-396),  | _maxAssetsSuppliableToAave (Lines 571-600), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function _maxAssetsSuppliableToAave() internal view returns (uint256) {
        // returns 0 if reserve is not active, frozen, or paused
        // returns max uint256 value if supply cap is 0 (not capped)
        // returns supply cap - current amount supplied as max suppliable if there is a supply cap for this reserve

        AaveDataTypes.ReserveData memory reserveData = AAVE_POOL.getReserveData(address(UNDERLYING));

        uint256 reserveConfigMap = reserveData.configuration.data;
        uint256 supplyCap = (reserveConfigMap & ~AAVE_SUPPLY_CAP_MASK) >> AAVE_SUPPLY_CAP_BIT_POSITION;

        if (
            (reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) ||
            (reserveConfigMap & ~AAVE_FROZEN_MASK != 0) ||
            (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)
        ) {
            return 0;
        } else if (supplyCap == 0) {
            return type(uint256).max;
        } else {
            // Reserve's supply cap - current amount supplied
            // See similar logic in Aave v3 ValidationLogic library, in the validateSupply function
            // https://github.com/aave/aave-v3-core/blob/a00f28e3ad7c0e4a369d8e06e0ac9fd0acabcab7/contracts/protocol/libraries/logic/ValidationLogic.sol#L71-L78
            uint256 currentSupply = WadRayMath.rayMul(
                (ATOKEN.scaledTotalSupply() + uint256(reserveData.accruedToTreasury)),
                reserveData.liquidityIndex
            );
            uint256 supplyCapWithDecimals = supplyCap * 10 ** decimals();
            return supplyCapWithDecimals > currentSupply ? supplyCapWithDecimals - currentSupply : 0;
        }
    }
",./aave_vault/specs/erc4626.spec,,Yes,
5c85eb443563087c5f36051ce4a6f982,2301 | 2303 | 2304,rule,equalSplitWeightsResultEqualSplittableIncrease,413,456,split | _setSplits | _assertSplitsValid,"rule equalSplitWeightsResultEqualSplittableIncrease() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;

    // all the 3 users are different
    require userA_Id != userB_Id; require userA_Id != userC_Id; require userB_Id != userC_Id;
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1; uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 2;            // only two split receivers
    require index1 != index2;       // different indexes sample different splitReceivers
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 == weight2;
    require weight1 <= 500000;      // safe assumption since MAX _TOTAL_SPLITS_WEIGHT == 1000000
    require weight1 > 0;            // safe assumption
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId); 
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    require userA_splittableBefore > 0; // there is a splittable amount to be split
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    // the splittable balances of userB and userC will increase by the same amount
    // in case of rounding - diffrence between amounts can be 1
    uint128 userB_splittableChange = userB_splittableAfter - userB_splittableBefore;
    uint128 userC_splittableChange = userC_splittableAfter - userC_splittableBefore;
    assert ((userC_splittableChange == userB_splittableChange) || 
            (userB_splittableChange == userC_splittableChange + 1) || 
            (userC_splittableChange == userB_splittableChange + 1));    
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
5ce0b2474c274690848c224da7ba774c,1911 | 1915 | 1916 | 1917 | 1918 | 1919,rule,validBalanceTotalCollateral,111,142,smallVault | depositCollateral | withdrawCollateral | redeemA | redeemB | settleVault,"rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
","smallVault (Lines 53-66),  | depositCollateral (Lines 230-247),  | withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositCollateral(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _depositCollateral(args);
  }
 |   function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
5d0434df4921334fa79ab8deef1791df,2554 | 2556,rule,integrityExit,88,105,exit | checkAplusBeqC,"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;

	uint256 strategyBalanceBefore = tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	
	env e;
	int256 amountAdded = exit(e, balance);
	uint256 strategyBalanceBAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	assert compareLTzero(amountAdded) => strategyBalanceBefore < balance , ""did not send all availaible tokens"";
}","exit (Lines 46-50),  | checkAplusBeqC (Lines 28-36), ","    function exit(uint256 balance) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		token.transfer(receiver, b);
		return safeSub(b, balance); 
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/strategy.spec,,Yes,
5d71b4f35b768c528454239a3254d2c4,609 | 610,rule,integrityOfBurn,122,135,balanceOf | burn,"rule integrityOfBurn(address u, uint256 amount) {
	env e;
	uint256 index = gRNVB();
	uint256 balanceBeforeUser = balanceOf(u);
	uint256 totalSupplyBefore = totalSupply(e); 

	burn(e, u, amount, index);
	
	uint256 balanceAfterUser = balanceOf(u);
	uint256 totalSupplyAfter = totalSupply(e);
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
5dcbaec95503c5fa730a8cd2b4c3cac6,1066,rule,times,417,457,rebalanceUserDiscountPercent,"// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));

// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
//pass
use rule integrityMint_atoken
/***************************************************************
* Integrity of Burn
***************************************************************/
/**
* @title proves that after calling burn, the user's discount rate is up to date
**/
rule integrityOfBurn_updateDiscountRate() {
	address user;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	burn(e, user, amount, index);
	uint256 debtBalance = balanceOf(e, user);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user);
	uint256 discountRate = getUserDiscountRate(user);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
5e04386fa8d2f79a3ea5cd6c0eb5c777,2231 | 2232 | 2233,rule,integrityOfSafeMulDiv,41,57,mul | div | callMulDiv,"rule integrityOfSafeMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0 && 
            mul(a , div(b , denominator)) <= max_uint256 &&
            mul(b , div(a , denominator)) <= max_uint256);
    env e;

    uint256 mul = a * b;
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator);
}
","mul (Lines 16-25),  | div (Lines 27-33),  | callMulDiv (Lines 8-13), ","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }
 |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;

        return c;
    }
 |     function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,,Yes,
5e2980675fb91c67cf912e3355455f1b,2411,invariant,opWavaxBalanceAndWavaxReserve,385,391,allowEmergencyWithdraw,"invariant opWavaxBalanceAndWavaxReserve()
    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()
    {
        preserved{
            requireInvariant op_not_stopped();
invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
        }
    }
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
5e4c08a1a3d1d715551381929a837a51,2395,rule,has,432,442,updatePool,"// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
","updatePool (Lines 179-194), ","    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
5ef46523db01c063e88661dc1f6ac3eb,412,rule,additiveTransfer,178,201,balanceOf,"rule additiveTransfer(address from1, address from2, address to1, address to2, uint256 x, uint256 y)
{
	env e1;
	env e2;
    uint256 indexRay = gRNI();
	require (from1 != from2 && to1 != to2 && from1 != to2 && from2 != to1 && 
	        (from1 == to1 <=> from2 == to2) &&
			 balanceOf(from1) == balanceOf(from2) && balanceOf(to1) == balanceOf(to2));

	require e1.msg.sender == from1;
	require e2.msg.sender == from2;
	transfer(e1, to1, x);
	transfer(e1, to1, y);
	uint256 balanceFromScenario1 = balanceOf(from1);
	uint256 balanceToScenario1 = balanceOf(to1);
	transfer(e2, to2, x+y);
	
	uint256 balanceFromScenario2 = balanceOf(from2);
	uint256 balanceToScenario2 = balanceOf(to2);
	assert 	bounded_error_eq(balanceFromScenario1, balanceFromScenario2, 3)  &&
	 		bounded_error_eq(balanceToScenario1, balanceToScenario2, 3), ""transfer is not additive"";
}
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
5f31cac0ec2512fbaf4dd3312ab8604d,2296 | 2298 | 2299,rule,fails,355,406,split | _setSplits | _assertSplitsValid,"/// Note: this rule fails!
/// In cases when userB weight is small, the calculation for the split
/// will be rounded down to zero, therefore the receiver will get nothing!
///
/// Possible abuse vector:
/// split is called every time when the splittable balance of userA is so low, 
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// so that rounding error will cause the splitReceiver userB to get zero
/// as a result userA will get all the splittable to himself
/// Severity: low
/// The one who will benefit the abuse is the splitter,
/// but he is also the one that in advance decided who
/// are going to be his splitReceivers
rule splitReceiverShouldGetMoneyUponSplit() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id;
    require userA_Id != userB_Id;
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userB_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;         // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    require userA_splittableBefore > 0;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    // the expectation: the splittable balance of userB should increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_splittableAfter > userB_splittableBefore;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
60186133244f5a189bb6ab2192425b52,2115,rule,mathOfChangeSupply,38,49,divPrecisely,"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= T || T2 == NR;
}
","divPrecisely (Lines 102-111), ","    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
",./ousd/spec/math.spec,,Yes,
60844a84c7080c8ea681e17fdee390b4,354 | 356,rule,additiveMint,126,142,balanceOf | mint,"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = sinvoke balanceOf(e, a);
	
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = sinvoke balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
60a92d4ae3562ab7b3b9a990eb4ec4e9,2463,rule,op_allocationChangeByDeposit,713,724,depositAVAX,"rule op_allocationChangeByDeposit(method f, env e){
    address user;

    uint256 allocationBefore = getUserAllocation(user);
    calldataarg args;
    f(e, args);
    uint256 allocationAfter = getUserAllocation(user);
    assert allocationBefore != allocationAfter => (f.selector == depositAVAX().selector && e.msg.sender == user), ""allocation was changed by wrong method"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
60f622a4fd2e6d446364b36503f0cbf1,552,rule,setBorrowableInIsolationIntegrity,103,106,setBorrowableInIsolation,"rule setBorrowableInIsolationIntegrity(bool borrowable) {
    setBorrowableInIsolation(borrowable);
    assert getBorrowableInIsolation() == borrowable;
}
","setBorrowableInIsolation (Lines 215-223), ","  function setBorrowableInIsolation(
    address asset,
    bool borrowable
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    currentConfig.setBorrowableInIsolation(borrowable);
    _pool.setConfiguration(asset, currentConfig);
    emit BorrowableInIsolationChanged(asset, borrowable);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
6150bfe8699e56ba558fa0c89564153e,901 | 902,rule,noThrow,6,19,getParams | getNumOfReferences,"rule noThrow(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		bytes32 x;
		require !isStatic(x);
		require getNumOfReferences(x) > 0;
		getParams@withrevert(e, x);
	} else {
		f@withrevert(e, arg);
	}
	assert !lastHasThrown;
}
","getParams (Lines 34-60),  | getNumOfReferences (Lines 14-23), ","    function getParams(
        bytes32 conf
    ) internal pure returns (uint256[] memory refs, uint256[] memory params) {
        require(!isStatic(conf), ""Static params"");
        uint256 n = REFS_LIMIT;
        while (conf & REFS_MASK == REFS_MASK && n > 0) {
            n--;
            conf = conf >> 8;
        }
        require(n > 0, ""No dynamic param"");
        refs = new uint256[](n);
        params = new uint256[](n);
        for (uint256 i = 0; i < n; i++) {
            refs[i] = uint256(conf & REFS_MASK);
            conf = conf >> 8;
        }
        uint256 locCount = 0;
        for (uint256 k = 0; k < PARAMS_SIZE_LIMIT; k++) {
            if (conf & PARAMS_MASK != 0) {
                require(locCount < n, ""Location count exceeds ref count"");
                params[locCount] = k * 32 + 4;
                locCount++;
            }
            conf = conf >> 1;
        }
        require(locCount == n, ""Location count less than ref count"");
    }
 | 	function getNumOfReferences(bytes32 conf) external returns (uint256) {
		// copied from getParams()
		uint256 n = 0;
        while (conf & REFS_MASK == REFS_MASK && n < REFS_LIMIT) {
            n++;
            conf = conf >> 8;
        }
        n = REFS_LIMIT - n;
		return n;
	}
",./furucombo/specs/libParam.spec,,Yes,
622ed51aac6bc0cfc3204fc4143a6a23,2372,invariant,rJoe_solvency,471,475,pendingRJoe,"// invariant rJoe_solvency(env e, address user)
//     rJoe.balanceOf(e, currentContract) >= pendingRJoe(e, user)
// { preserved with (env otherE) {
//     require otherE.msg.sender != currentContract;
// }}
","pendingRJoe (Lines 91-102), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
",./rocket_joe/spec/Staking.spec,,Yes,
625e6c8a5ca9716245b958d3140c1c3c,103,rule,to,178,194,getCurrentState,"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
63735affa191854ad22f1f53192ca7e6,2444 | 2445,invariant,cl_bal_this_zero,552,559,currentPhase | depositAVAX,"invariant cl_bal_this_zero()
    pair() != 0 => getWAVAXbalanceOfThis() == 0
    {
        preserved with (env e2){
            require currentPhase(e2) == PhaseThree();           // depositAVAX()
            // should I add invariants from open state?
        }
    }
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
63d28478f6a10aa50f0e4991d9d70f48,949,rule,deprecatesHandler,30,36,unregister,"rule deprecatesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != unregister(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates handler"";
}
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,,Yes,
64277ceeda0193f62412a99e472fed0e,368,rule,balanceOfChange,6,20,balanceOf,"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a != b;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter);
}
","balanceOf (Lines 106-115), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
64845f8efd52f59bd0979436c555f5b5,2183 | 2184,rule,checkBurnAllLiquidity,47,52,pool.positionLiquidity | callBurnAllLiquidity,"rule checkBurnAllLiquidity(int24 tickLower,
                        int24 tickUpper){
    callBurnAllLiquidity(tickLower, tickUpper);
    // uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
    // assert(liquidity ==0);
}","positionLiquidity (Lines 95-108),  | callBurnAllLiquidity (Lines 43-48), ","    function positionLiquidity(
        IUniswapV3Pool pool,
        int24 _tickLower,
        int24 _tickUpper
    ) internal view returns (uint128 liquidity) {
        //Compute position key
        bytes32 positionKey = PositionKey.compute(
            address(this),
            _tickLower,
            _tickUpper
        );
        //Get liquidity stored in position
        (liquidity, , , , ) = pool.positions(positionKey);
    }
 |     function callBurnAllLiquidity(
        int24 tickLower,
        int24 tickUpper
    ) external {
        PoolActions.burnAllLiquidity(pool, tickLower, tickUpper);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,,Yes,
648f8f3b325cc9f87a899458eb712bbc,2451 | 2452,invariant,hl_EqualityOfToken,1081,1090,depositAVAX | withdrawIncentives,"invariant hl_EqualityOfToken(env e) 
    getTokenBalanceOfThis() == tokenReserve() + tokenIncentivesBalance()
    {
        preserved with (env e2){
            require token() == SymbERC20A || token() == SymbERC20B;     // depositAVAX() and many more          // token != instead of ==
            require e2.msg.sender != currentContract;                   // withdrawIncentives()
            require e.msg.sender == e2.msg.sender;       
            // require e2.msg.sender == issuer();               
        }
    }
","depositAVAX (Lines 333-370),  | withdrawIncentives (Lines 473-491), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
650a8ad637770c08c9dff6bd1ba25058,1930 | 1931 | 1932,rule,validBalanceTotalShort,190,215,mintOtokenA | redeemA | settleVault,"rule validBalanceTotalShort(address owner, uint256 vaultId, uint256 index, address secondAddress, address oToken, method f, uint256 amount)
description ""$f breaks the validity of stored balance of short asset""
{
    links();
    env e;
    calldataarg arg;
    require oToken == shortOtoken;
    require !isVaultExpired(e, owner, vaultId);
    require getVaultShortOtoken(owner, vaultId, index) == oToken;
    uint256 shortVaultBefore = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyBefore = shortOtoken.totalSupply();
    // only test the cases before expiry
    if (f.selector == settleVault(address,uint256,address).selector) ||  (f.selector == redeemA(address,uint256).selector) {
        assert true;
    } else if (f.selector == mintOtokenA(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenA(e, owner, vaultId, secondAddress, index, amount);
	} else {
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyAfter = shortOtoken.totalSupply();
    assert shortVaultBefore != shortVaultAfter => (supplyAfter - supplyBefore ==  shortVaultAfter - shortVaultBefore);
    assert supplyAfter != supplyBefore => ( supplyAfter - supplyBefore  ==  shortVaultAfter - shortVaultBefore);
}
","mintOtokenA (Lines 268-285),  | redeemA (Lines 344-347),  | settleVault (Lines 360-367), ","  function mintOtokenA(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.MintArgs memory args = Actions.MintArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      otoken: anOtokenA,
      index: index,
      amount: amount
    });
    _mintOtoken(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
65111932145bbb0df029402de3cf10d4,393 | 394,rule,additiveBurn,143,156,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x, index);
	sinvoke burn(e, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
652ae898686e8d15e525ad4e0c8d31d9,2501 | 2502,rule,hl_moreDepositMoreGet,1149,1188,withdrawLiquidity | withdrawIncentives,"rule hl_moreDepositMoreGet(method f, env e, env e2){
    require e.msg.sender != e2.msg.sender;
    require e.msg.sender != issuer();
    require e2.msg.sender != issuer();
    require e.msg.sender != currentContract;
    require e2.msg.sender != currentContract;
    require lpSupply() >= avaxAllocated(); // assumption, need to double check
    require token() == SymbERC20A || token() == SymbERC20B;

    uint256 balanceOfuser1 = getUserBalance(e.msg.sender);
    uint256 balanceOfuser2 = getUserBalance(e2.msg.sender);
    require balanceOfuser2 > balanceOfuser1;
    require avaxAllocated() >= balanceOfuser2 + balanceOfuser1;
    uint256 pairOfuser1Before = getPairBalance(e.msg.sender);
    uint256 tokenOfuser1Before = getTokenBalance(e.msg.sender);
    uint256 pairOfuser2Before = getPairBalance(e2.msg.sender);
    uint256 tokenOfuser2Before = getTokenBalance(e2.msg.sender);
    require pairOfuser1Before == pairOfuser2Before;
    require tokenOfuser1Before == tokenOfuser2Before;
    withdrawLiquidity(e);
    withdrawIncentives(e);
    // check how much can I withdrawLiquidity or how much I withdrawn
    uint256 pairOfuser1After = getPairBalance(e.msg.sender);
    // check how much can I withdrawIncentives or how much I withdrawn
    uint256 tokenOfuser1After = getTokenBalance(e.msg.sender);
    withdrawLiquidity(e2);
    withdrawIncentives(e2);
    uint256 pairOfuser2After = getPairBalance(e2.msg.sender);
    uint256 tokenOfuser2After = getTokenBalance(e2.msg.sender);
    //assert
    assert pairOfuser1After < pairOfuser2After && tokenOfuser1After < tokenOfuser2After, ""more deposit doesn't guarantee more rewards"";
}
","withdrawLiquidity (Lines 453-470),  | withdrawIncentives (Lines 473-491), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
655103f9f0b4c260e5a6928b35ff315e,222 | 223,rule,slashAndReturnFundsOfZeroDoesntChangeExchangeRate,561,575,slash | returnFunds,"rule slashAndReturnFundsOfZeroDoesntChangeExchangeRate() {
    env e;
    address dest; uint256 amt = 0;
    uint216 _ER = getExchangeRate();
    storage initialStorage = lastStorage;

    slash(e, dest, amt);
    uint216 ER_AfterSlash = getExchangeRate();
    returnFunds(e, amt) at initialStorage;
    uint216 ER_AfterReturnFunds = getExchangeRate();
    assert(ER_AfterSlash == ER_AfterReturnFunds);
    assert(ER_AfterReturnFunds == _ER);
}
","slash (Lines 271-296),  | returnFunds (Lines 299-308), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
 |   function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
65bd1330ec0316177076c69a9d4886c9,2634,rule,named,86,103,toBase,"    Contributes to proof of rule named ""Identity"" in GDoc.
 */ 
rule toElasticAndToBaseAreInverse1down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 1; 
    assert only_slightly_larger_than(amount, amountToElasticToBase, error_margin1);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
66f2b20b65aa41d905a3c172269c3af9,2358 | 2359,rule,whoChangedUserState,61,81,addUser | removeUser,"rule whoChangedUserState(method f) {
    env e;
    calldataarg args;
    
    address userA;
    address userB;

    bool isUserBefore;
    bool isUserAfter;
    isUserBefore = getIsUser(e, userB);
    f(e,args);
    // addUser(userA);
    // removeUser(userA);
    // require userA != userB;
    isUserAfter = getIsUser(e, userB);
    assert isUserBefore == isUserAfter;
}
","addUser (Lines 242-245),  | removeUser (Lines 249-252), ","    function addUser(address user) public onlyOwner {
        isUser[user] = true;
        emit UserAdded(msg.sender, user);
    }
 |     function removeUser(address user) public onlyOwner {
        isUser[user] = false;
        emit UserRemoved(msg.sender, user);
    }
",./radicle_drips/specs/Reserve.spec,,Yes,
6708ab3b723a71d3083b49b993af40e5,1083,rule,integrityOfUpdateDiscountDistribution_discountRate,538,568,updateDiscountDistribution,"// rule integrityOfUpdateDiscountDistribution_discountRate() {
// 	address sender;
//     address recipient;
//     uint256 senderDiscountTokenBalanceBefore;
//     uint256 recipientDiscountTokenBalanceBefore;
//     uint256 amount;
// 	uint256 senderDiscountTokenBalanceAfter = senderDiscountTokenBalanceBefore - amount;
//     uint256 recipientDiscountTokenBalanceAfter = recipientDiscountTokenBalanceBefore + amount;
// 	env e0;
// 	env e;
// 	require(e.block.timestamp > e0.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	require(indexAtTimestamp(e.block.timestamp) >= indexAtTimestamp(e0.block.timestamp));
// 	require(indexAtTimestamp(e0.block.timestamp) == ray()); // reduces execution time
// 	require(getUserCurrentIndex(sender) == indexAtTimestamp(e0.block.timestamp));
// 	require(getUserCurrentIndex(recipient) == indexAtTimestamp(e0.block.timestamp));
// 	require(getBalanceOfDiscountToken(e0, sender) == senderDiscountTokenBalanceBefore);
// 	require(getBalanceOfDiscountToken(e0, recipient) == recipientDiscountTokenBalanceBefore);
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, sender), senderDiscountTokenBalanceBefore) == getUserDiscountRate(sender));
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, recipient), recipientDiscountTokenBalanceBefore) == getUserDiscountRate(recipient));
	
// 	require(getBalanceOfDiscountToken(e, sender) == senderDiscountTokenBalanceAfter);
// 	require(getBalanceOfDiscountToken(e, recipient) == recipientDiscountTokenBalanceAfter);
// 	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalanceBefore, recipientDiscountTokenBalanceBefore, amount);
// 	uint256 senderBalance = balanceOf(e, sender);
// 	uint256 recipientBalance = balanceOf(e, recipient);
// 	assert(discStrategy.calculateDiscountRate(senderBalance, senderDiscountTokenBalanceAfter) == getUserDiscountRate(sender));
// 	assert(discStrategy.calculateDiscountRate(recipientBalance, recipientDiscountTokenBalanceAfter) == getUserDiscountRate(recipient));
// }
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
67d858fe258efe047e01f75e3c3160ff,2511,invariant,oneStateOnly,117,136,withdrawLiquidity,"invariant oneStateOnly()
    open() && !closed() && !openStopped() && !closedStopped() ||
    !open() && closed() && !openStopped() && !closedStopped() ||
    !open() && !closed() && openStopped() && !closedStopped() ||
    !open() && !closed() && !openStopped() && closedStopped()

////////////////////////////////////////////////////////////////////////////
//                         Functions                                      //
function helperFunctionsForWithdrawLiquidity(method f, env e) {
	if (f.selector == withdrawLiquidity().selector) {
		withdrawLiquidity(e);
	} else {
        calldataarg args;
        f(e, args);
    }
}
","withdrawLiquidity (Lines 453-470), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LEPreset.spec,,Yes,
68c405f691ebca7a88d7a5625268efc7,1683,rule,pendingCancelledTransition,121,130,cancel,"rule pendingCancelledTransition(method f, env e){
    bytes32 id;

    require isOperationPending(id);
    calldataarg args;
    f(e, args);
    assert !isOperation(id) => f.selector == cancel(bytes32).selector, ""How you dare to cancel me?"";
}
","cancel (Lines 106-120), ","    function cancel(uint256 proposalId) public virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];

        require(
            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),
            ""GovernorBravo: proposer above threshold""
        );

        _cancel(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
6933eff4e13cc9ad6d72fa013dfbef2b,596 | 597,rule,mintNoChangeToOther,312,333,mint | balanceOf,"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 rate, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint128 userDataBefore = additionalData(user);
	uint128 otherDataBefore = additionalData(other);
	uint256 userBalanceBefore = balanceOf(e, user);
	uint256 otherBalanceBefore = balanceOf(e, other);
	mint(e, user, onBehalfOf, amount, rate);
  uint128 userDataAfter = additionalData(user);
	uint128 otherDataAfter = additionalData(other);
	uint256 userBalanceAfter = balanceOf(e, user);
	uint256 otherBalanceAfter = balanceOf(e, other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter && userDataBefore == userDataAfter; 
	}
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
69378398b8133fca749db4dfe0a432a4,2044 | 2045,invariant,also,679,698,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
function links() {
    require anOtokenA() == shortOtoken;
    require anOtokenB() == longOtoken;
    require dummyERC20C() == collateralToken;
}","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
693b7e03413bfaa928ac27ecbd00e41b,2638,rule,toElasticAndToBaseAreInverse1up,113,128,toBase,"rule toElasticAndToBaseAreInverse1up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 2; // ""base1/elastic1 + 1"":to
    assert only_slightly_smaller_than(amount, amountToElasticToBase, error_margin1);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
69e020cf7dad0b5ebb3042630602ec87,2508 | 2509,rule,hl_noWithdrawLiquidityFrontRun,1283,1304,withdrawLiquidity | pairBalance,"rule hl_noWithdrawLiquidityFrontRun(method f, env e, env e2){
    require e.msg.sender != e2.msg.sender;
    require e.msg.sender != currentContract;
    require e2.msg.sender != currentContract;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getPairBalance(e.msg.sender);
    uint256 whatShouldGet1 = pairBalance(e, e.msg.sender);
    withdrawLiquidity(e);
    uint256 userBalanceAfter1 = getPairBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 whatShouldGet2 = pairBalance(e, e.msg.sender);
    uint256 userBalanceAfter2 = getPairBalance(e.msg.sender);
    assert whatShouldGet1 == whatShouldGet2, ""should get differs"";
    assert userBalanceBefore + whatShouldGet1 == userBalanceAfter1 && userBalanceBefore + whatShouldGet2 == userBalanceAfter2, ""frontrun on WithdrawLiquidity"";
}
","withdrawLiquidity (Lines 453-470),  | pairBalance (Lines 623-632), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
6a36db9550a0f783945aef5f05c1e0bd,801 | 803 | 806,invariant,referendumVoteIDIsLessThanOrEqCounter,211,215,getUpvotedProposal | upvote | getUpvoteRecord,"invariant referendumVoteIDIsLessThanOrEqCounter(address v, uint p) votedFor(v,p) => p <= proposalCount() {
    preserved vote(uint256 _, uint256 indx, uint8 vr) with (env e) {
        requireInvariant dequeuedIsWithinRange(indx); 
invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    }
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
6ad466081a4377f21abe780a7723c52c,1571 | 1572,rule,depositForSpecWrapper,68,86,balanceOf | depositFor,"rule depositForSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    depositFor(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore 
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter 
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount, ""wrapper balances wrong update"";
    assert account != e.msg.sender => wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}
","balanceOf (Lines 70-73),  | depositFor (Lines 39-43), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
6b7def5c8c4132df2dcd5acea1bb4d65,2418 | 2419 | 2420 | 2421 | 2422 | 2423 | 2424,invariant,op_avax_reserve_sum_user_balances,450,480,currentPhase | depositAVAX | withdrawAVAX | createPair | emergencyWithdraw | allowEmergencyWithdraw | initialize,"invariant op_avax_reserve_sum_user_balances()
     pair() == 0 => avaxReserve() == sum_of_users_balances()

// CLOSED - phase three
// STATUS - in progress (allowEmergencyWithdraw() violation): https://vaas-stg.certora.com/output/3106/eca7dbb4b69c55f85043/?anonymousKey=44a9e39a1f83b15ab36662ee6d898cf1e147e43f
//  - isStopped is false
invariant cl_not_stopped()
    pair() != 0 => !stopped()
// STATUS - verified https://vaas-stg.certora.com/output/3106/0ec29a324e7bdb9f86d2/?anonymousKey=deab759d00c63862d1166abb8a17b91ac040118b
// run without preserved block: https://vaas-stg.certora.com/output/3106/cea4890e65f85e6d14eb/?anonymousKey=94c143aa0c1c85f0f961d154a6e60dafea974945
// run with preserved block: https://vaas-stg.certora.com/output/3106/8863dca9bb0617161eb3/?anonymousKey=14fee042e6c8821f002886c4e7e0861ca072990c
//  - avaxAllocated is  getUA[user].balance
invariant cl_avax_alloc_sum_user_balances()
    pair() != 0 => avaxAllocated() == sum_of_users_balances()
    {
        preserved with (env e2){
            requireInvariant cl_not_stopped();                          // emergencyWithdraw()
            require currentPhase(e2) == PhaseThree();                   // withdrawAVAX(uint256) and depositAVAX()
        }
        preserved createPair() with (env e3){
            requireInvariant pairAndGetPairCorrelation(e3);             // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
            requireInvariant factoryGetPairCorrelationCurrentVals(e3);  // createPair()
            require avaxReserve() == sum_of_users_balances();          // Not sure if it's safe
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398),  | createPair (Lines 402-450),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
6cba815f971eb840c0cfa029125938b9,427 | 428 | 429 | 431 | 433,invariant,isUsingAsCollateralOrBorrowing,81,89,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
6cc49ddfe758bf97a729f03ab0087da2,2537,rule,hl_noWithdrawFrontRun,133,150,withdrawAVAX,"rule hl_noWithdrawFrontRun(method f, env e, env e2){
    require open();
    require e.msg.sender != e2.msg.sender;
    uint256 amount;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    calldataarg args;

    storage initialStorage = lastStorage;
    f(e2, args);
    withdrawAVAX(e, amount);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    withdrawAVAX(e, amount) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore - amount == userBalanceAfter1 && userBalanceBefore - amount == userBalanceAfter2, ""frontrun on Withdraw"";
}
","withdrawAVAX (Lines 374-398), ","    function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
6d412d6f97f08b58a0ed8eba2121b198,34 | 36,rule,noIncarnations3,209,217,processMessageFromRoot | getCurrentState,"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
6dd5070c3d1c501df925e30e4b4b2489,1573,rule,depositForSpecUnderlying,91,114,depositFor,"rule depositForSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    depositFor(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount, ""underlying balances wrong update"";
    
    assert account != e.msg.sender && account == currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update"";
    assert account != e.msg.sender && account != currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter, ""underlying balances wrong update"";
}
","depositFor (Lines 39-43), ","    function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
6e2cc28a9fab7b5affbe264c25d9c4a4,2534 | 2535,rule,hl_twoSideInverse,88,104,depositAVAX | withdrawAVAX,"rule hl_twoSideInverse(env e, env e2){
    uint256 amount;
    require getUserBalance(e.msg.sender) > amount;
    require e.msg.sender == e2.msg.sender;  // need two envs because depositAVAX() is payble but withdrawAVAX() isn't, thus, only one e.msg.value causes issues

    storage initialStorage = lastStorage;
    depositAVAX(e);
    withdrawAVAX(e2, amount);
    uint256 balanceOfUser1 = getUserBalance(e.msg.sender);
    withdrawAVAX(e2, amount) at initialStorage;
    uint256 balanceOfUser2 = getUserBalance(e.msg.sender);
    assert balanceOfUser1 == balanceOfUser2, ""balances are different"";
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
6e87cf03c73c45468b74d527e58fafa9,1638 | 1642,rule,sanity,200,217,balanceOf | _delegate,"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
6ee30d94d797130cd74c6f55bc82d1be,246,invariant,inv_atoken_balanceOf_leq_totalSupply,151,153,redeem,"invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
","redeem (Lines 469-478), ","  function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
6f0a788c11d1de327d863a034e8efbe5,611 | 612,rule,additiveBurn,141,156,balanceOf | burn,"rule additiveBurn(address user1, address user2, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));
	require user1 != currentContract && user2 != currentContract;

    burn(e, user1, x, index);
	burn(e, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	burn(e, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
6f872af85baa8923798ee0d6cb35e3e1,278 | 279 | 280,rule,getClaimableRewards_stable_after_atoken_transferFrom_1,582,599,_AToken.transferFrom | initialize | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_atoken_transferFrom_1()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
rule getClaimableRewards_stable_after_atoken_transferFrom()
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
   // require isRegisteredRewardToken(reward); //todo: review the assumption
    setup(e, user);
","transferFrom (Lines 99-121),  | initialize (Lines 68-87),  | isRegisteredRewardToken (Lines 100-107), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
6fa423ce5729d813dd3dde9bfde81194,535 | 536,rule,accruToTreasury,229,244,mintToTreasury | flashLoan,"// rule accruToTreasury()
// {
// 	env e;
// 	calldataarg args;
// 	calldataarg args2;
// 	calldataarg args3;
// 	storage init = lastStorage;
// 	mintToTreasury(e, args);
// 	flashLoan(e, args2);
// 	//mintToTreasury(e, args);
// 	uint256 withMintBefore = getReserveNormalizedIncome(e, args3);
// 	flashLoan(e, args2) at init;
// 	uint256 withoutMintBefore = getReserveNormalizedIncome(e, args3);
// 	assert withoutMintBefore == withMintBefore;
// }","mintToTreasury (Lines 444-446),  | flashLoan (Lines 386-421), ","  function mintToTreasury(address[] calldata assets) external virtual override {
    PoolLogic.executeMintToTreasury(_reserves, assets);
  }
 |   function flashLoan(
    address receiverAddress,
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata interestRateModes,
    address onBehalfOf,
    bytes calldata params,
    uint16 referralCode
  ) public virtual override {
    DataTypes.FlashloanParams memory flashParams = DataTypes.FlashloanParams({
      receiverAddress: receiverAddress,
      assets: assets,
      amounts: amounts,
      interestRateModes: interestRateModes,
      onBehalfOf: onBehalfOf,
      params: params,
      referralCode: referralCode,
      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,
      flashLoanPremiumTotal: _flashLoanPremiumTotal,
      maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,
      reservesCount: _reservesCount,
      addressesProvider: address(ADDRESSES_PROVIDER),
      userEModeCategory: _usersEModeCategory[onBehalfOf],
      isAuthorizedFlashBorrower: IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(
        msg.sender
      )
    });

    FlashLoanLogic.executeFlashLoan(
      _reserves,
      _reservesList,
      _eModeCategories,
      _usersConfig[onBehalfOf],
      flashParams
    );
  }
",./aave_v3/specs/pool.spec,,Yes,
6fd5cce75786d7ead68351c53eb2f954,512 | 513,rule,integrityOfisUsingAsCollateralAny,97,101,isUsingAsCollateral | isUsingAsCollateralAny,"// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
// }
","isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135), ","  function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
7044f007afd47a13ef204db9f85e9fa2,138 | 141,rule,gracePeriodChangedAffectsExecution,534,550,execute | getCurrentState,"rule gracePeriodChangedAffectsExecution(uint256 actionsSetId)
{
	env e; env e2;
	uint period;
	// Assume queued action set.
	require getCurrentState(e, actionsSetId) == 0;
	
	storage initialStorage = lastStorage;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	// Allow execution (assume does not revert)
	execute(e, actionsSetId);
	// Now check whether changing the grace period could lead to revert.
	updateGracePeriod(e, period) at initialStorage;
	uint8 stateAfterUpdate = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	assert lastReverted <=> stateAfterUpdate == 3;
}*/","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
71637656ffd1b79750231b8ee301a89b,1850 | 1851 | 1852 | 1861,rule,integrityOfAddLong,238,246,addShort | addLong | addCollateral | totalLongAmount,"rule integrityOfAddLong(address longOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	assert totalLongAmount() == longAmountBefore + x &&
		getLongOtoken(index) == longOtoken, ""integirty break of addLong"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
71c79ae268e4e271bdc40ab9946cfbd6,2234,rule,checkMulDivRoundingUp,60,72,callMulDivRoundingUp,"rule checkMulDivRoundingUp(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0x0 && 
             a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
             b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    env e;
    uint256 result = callMulDivRoundingUp(e , a,
             b,
             denominator);
     assert ((a *b % denominator == 0) && result == (a*b)/denominator ||
              (a *b % denominator> 0) && result == (a*b)/denominator + 1);
}
","callMulDivRoundingUp (Lines 15-20), ","    function callMulDivRoundingUp(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDivRoundingUp(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,,Yes,
7241f26a605c235a7160dca67c904554,1418,rule,balancesUnchangedWhenPaused,8,21,balanceOf,"rule balancesUnchangedWhenPaused() {
    address user; uint256 token;
    uint256 balanceBefore = balanceOf(user, token);

    require paused();
    method f; calldataarg arg; env e;
    f(e, arg);
    uint256 balanceAfter = balanceOf(user, token);
    assert balanceBefore == balanceAfter, 
        ""Token balance for a user must not change in a paused contract"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Pausable.spec,,Yes,
72cfa390769c4fdec5227bfb1e8e2c87,1619,invariant,votes_solvency,69,71,_burn,"invariant votes_solvency()
    totalSupply() >= to_uint256(totalVotes())
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
filtered { f -> f.selector != _burn(address, uint256).selector}
","_burn (Lines 333-355), ","    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");

        address operator = _msgSender();
        uint256[] memory ids = _asSingletonArray(id);
        uint256[] memory amounts = _asSingletonArray(amount);

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, """");

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, ""ERC1155: burn amount exceeds balance"");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }

        emit TransferSingle(operator, from, address(0), id, amount);

        _afterTokenTransfer(operator, from, address(0), ids, amounts, """");
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
7332c670487e920fa3ca8cacf4743411,2608,rule,solvency,93,130,_tokenBalanceOf,"rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentobox.spec,,Yes,
734e363718c8ba5a0f2add8350e62d78,1313,rule,riskAdjustedPresentValueDecreasesForLongerMaturities,120,134,getRiskAdjustedPresentValue,"rule riskAdjustedPresentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturity,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getRiskAdjustedPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);

    // PV cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getRiskAdjustedPresentValue (Lines 76-104), ","    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
73689d9fc34026be926eb7e27b25c843,2148,rule,additiveMint,125,141,mint,"rule additiveMint(address minter, uint256 x, uint256 y) {
	env e;
    storage init = lastStorage;	

    mint(e, minter, x);
    mint(e, minter, y);
    uint b1 = balanceOf(minter);
    
    require x+y <= MAX_UINT256();
    uint sumXY = x+y;
    mint(e, minter, sumXY) at init;
    uint b2 = balanceOf(minter);
    assert b1 == b2, ""mint is not additive in balance of burned"";
}
","mint (Lines 42-87), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
",./ousd/spec/ousd.spec,,Yes,
73ad8110692226b827767bbca83f889c,2331 | 2333 | 2334,rule,cannotFrontRunSplitDifferentUsers,62,112,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,,Yes,
73e5880c4ba837dd1dc4bfa15f9c3f16,2387 | 2388 | 2389,rule,verify_deposit,355,372,pendingRJoe | deposit | updatePool,"rule verify_deposit() {
    env e;
    require e.msg.sender != currentContract;
    uint256 amount; 

    uint256 balance_pre = userJoeStaked(e.msg.sender);
    uint256 reward_debt_pre = userRewardDebt(e.msg.sender);
    uint256 total_pre = totalJoeStaked();
    deposit(e, amount);
    uint256 balance_post = userJoeStaked(e.msg.sender);
    uint256 reward_debt_post = userRewardDebt(e.msg.sender);
    uint256 total_post = totalJoeStaked();
    assert total_post == total_pre + amount, ""totalJoeStaked not updated properly"";
    assert balance_post - amount == balance_pre, ""improper amount deposited"";
    assert (e.block.timestamp > lastRewardTimestamp() => reward_debt_post > reward_debt_pre)  || userJoeStaked(e.msg.sender) == 0, ""reward debt not increased"";
    assert pendingRJoe(e, e.msg.sender) == 0, ""user has unclaimed rewards"";
// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
}
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126),  | updatePool (Lines 179-194), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
 |     function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
740e70dd3578dae8b90839289bdb1b5b,1978 | 1979 | 1980 | 1981 | 1982,rule,collateralWithdrawsRestricted,122,133,withdrawCollateral | redeemA | redeemB | settleVault | getProceed,"rule collateralWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, method f) {
    env e;
    uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);
    calldataarg arg;
    sinvoke f(e, arg);
    uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);

    assert collateralBalanceAfter < collateralBalanceBefore => (f.selector == settleVault(address,uint256,address).selector) 
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
                                                            || (f.selector == redeemB(address,uint256).selector)
rule redeem (address oToken, address to, address collateral, uint256 amount) {
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
                                                            || (f.selector == redeemA(address,uint256).selector)
                                                            || (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector);
","withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,,Yes,
7449eb9a1db24038a2c6628f316df369,1329 | 1331 | 1335,invariant,oracleRatesAreBlendedIntoTheRateWindow,36,98,getRateScalar | getStoredOracleRate | executeTrade,"invariant oracleRatesAreBlendedIntoTheRateWindow(env e)
    (e.block.timestamp - getPreviousTradeTime() > getRateOracleTimeWindow()) ?
        getMarketOracleRate() == getLastImpliedRate() :
        isBetween(
            getStoredOracleRate(e),
            getMarketOracleRate(),
            getLastImpliedRate()
        )

rule oracleRatesBlandedIntoRateWindow(method f){
env e;
uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","getRateScalar (Lines 39-53),  | getStoredOracleRate (Lines 56-75),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
74b110f6138c21f9b68a8a13ccdbd513,315 | 316,rule,rewardsTotalDoesNotDeclineByWithdraw,167,181,getTotalClaimableRewards | withdraw,"rule rewardsTotalDoesNotDeclineByWithdraw() {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	calldataarg args;
	withdraw(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by withdraw"";
}
","getTotalClaimableRewards (Lines 320-337),  | withdraw (Lines 443-453), ","  function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
",./aave_static_token/rewardPreserve.spec,,Yes,
75a800eab04298ae5e3ba15ab42c6409,109,rule,canceledForever,230,237,getCurrentState,"rule canceledForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 2;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
75b0c8fe9bd3fe4e73227b8675251537,75,rule,queuePriviliged,512,521,processMessageFromRoot,"rule queuePriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	processMessageFromRoot(e1, args1);
	processMessageFromRoot@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
75b64181d082cdfc1a38746b3922a272,1575,rule,withdrawToSpecBasic,119,134,withdrawTo,"rule withdrawToSpecBasic(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    withdrawTo(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    assert wrapperTotalBefore == wrapperTotalAfter + amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
}
","withdrawTo (Lines 48-52), ","    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
75c1bbea77034c10a732ea69fe4a649f,1382 | 1389 | 1390,rule,cashGroupGetterSetters,19,67,getLiquidityHaircut | getMaxMarketIndex | setCashGroupStorage,"rule cashGroupGetterSetters(
    uint256 currencyId,
    uint8 maxMarketIndex,
    uint8 rateOracleTimeWindowMin,
    uint8 totalFeeBPS,
    uint8 reserveFeeShare,
    uint8 debtBuffer5BPS,
    uint8 fCashHaircut5BPS,
    uint8 settlementPenaltyRate5BPS,
    uint8 liquidationfCashHaircut5BPS,
    uint8 liquidationDebtBuffer5BPS,
    uint8[] liquidityTokenHaircuts,
    uint8[] rateScalars,
    uint256 assetType
) {
    env e;
    require MIN_CURRENCY_ID() <= currencyId && currencyId <= MAX_CURRENCY_ID();
    require MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX();
    require MIN_MARKET_INDEX() + 1 <= assetType && assetType <= marketIndex + 1;

    setCashGroupStorage(
        e,
        currencyId,
        maxMarketIndex,
        rateOracleTimeWindowMin,
        totalFeeBPS,
        reserveFeeShare,
        debtBuffer5BPS,
        fCashHaircut5BPS,
        settlementPenaltyRate5BPS,
        liquidationfCashHaircut5BPS,
        liquidationDebtBuffer5BPS,
        liquidityTokenHaircuts,
        rateScalars
    );
    assert maxMarketIndex == getMaxMarketIndex(currencyId), ""max market index does not match"";
    assert rateOracleTimeWindowMin * 60 == getRateOracleTimeWindow(currencyId), ""rate oracle not returned in seconds"";
    assert totalFeeBPS * BASIS_POINTS() == getTotalFee(currencyId), ""total fee does not match""
    assert reserveFeeShare == getReserveFeeShare(currencyId), ""reserve fee share does not match""
    assert debtBuffer5BPS * 5 * BASIS_POINTS() == getDebtBuffer(currencyId), ""debt buffer does not match""
    assert fCashHaircut5BPS * 5 * BASIS_POINTS() == getfCashHaircut(currencyId), ""fCash haircut does not match""
    assert settlementPenaltyRate5BPS * 5 * BASIS_POINTS() == getSettlementPenalty(currencyId), ""settlement penalty does not match""
    assert liquidationfCashHaircut5BPS * 5 * BASIS_POINTS() == getLiquidationfCashHaircut(currencyId), ""liquidation fcash haircut does not match""
    assert liquidationDebtBuffer5BPS * 5 * BASIS_POINTS() == getLiquidationDebtBuffer(currencyId), ""liquidation debt buffer does not match""
    assert liquidityTokenHaircuts[assetType - 1] == getLiquidityHaircut(currencyId, assetType), ""liquidity token haircut does not match"";
    // rate scalars, todo, what do we want to test here?
}
","getLiquidityHaircut (Lines 73-83),  | getMaxMarketIndex (Lines 273-276),  | setCashGroupStorage (Lines 279-344), ","    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)
        internal
        pure
        returns (uint256)
    {
        require(assetType > 1); // dev: liquidity haircut invalid asset type
        uint256 offset =
            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);
        uint256 liquidityTokenHaircut = uint256(uint8(uint256(cashGroup.data >> offset)));
        return liquidityTokenHaircut;
    }
 |     function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        return uint8(data[31]);
    }
 |     function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)
        internal
    {
        bytes32 slot = keccak256(abi.encode(currencyId, Constants.CASH_GROUP_STORAGE_OFFSET));
        require(
            cashGroup.maxMarketIndex >= 0 &&
                cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,
            ""CG: invalid market index""
        );
        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.
        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month
        // fixed. It also complicates the logic in the nToken initialization method
        require(cashGroup.maxMarketIndex != 1, ""CG: invalid market index"");
        require(
            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,
            ""CG: invalid reserve share""
        );
        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);
        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);
        // This is required so that fCash liquidation can proceed correctly
        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);
        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);

        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve
        uint8 previousMaxMarketIndex = uint8(uint256(_getCashGroupStorageBytes(currencyId)));
        require(
            previousMaxMarketIndex <= cashGroup.maxMarketIndex,
            ""CG: market index cannot decrease""
        );

        // Per cash group settings
        bytes32 data =
            (bytes32(uint256(cashGroup.maxMarketIndex)) |
                (bytes32(uint256(cashGroup.rateOracleTimeWindowMin)) << RATE_ORACLE_TIME_WINDOW) |
                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |
                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |
                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |
                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |
                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<
                    LIQUIDATION_FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));

        // Per market group settings
        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) {
            require(
                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,
                ""CG: invalid token haircut""
            );

            data =
                data |
                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<
                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));
        }

        for (uint256 i; i < cashGroup.rateScalars.length; i++) {
            // Causes a divide by zero error
            require(cashGroup.rateScalars[i] != 0, ""CG: invalid rate scalar"");
            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));
        }

        assembly {
            sstore(slot, data)
        }
    }
",./notional_finance_v2/certora/governance/CashGroup.spec,,Yes,
75fdebaccf9425899feb022a4823a8de,2191,invariant,balance_contract_GE_protocolFees,120,126,uniswapV3SwapCallback,"    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","uniswapV3SwapCallback (Lines 34-350), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
765d062f773b220222c98521c3ba7ee9,294 | 296,rule,getClaimableRewards_stable_after_metaWithdraw,708,720,initialize | metaWithdraw,"rule getClaimableRewards_stable_after_metaWithdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    metaWithdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | metaWithdraw (Lines 182-224), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
76c29ccb27c5f54bbea876e7f43754b1,387 | 388,rule,additiveMint,108,121,balanceOf | mint,"rule additiveMint(address a, address delegatedUser, uint256 x, uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
76cef4ca824906ec6ca2097eee82e09d,384 | 385,rule,integrityMint,90,102,balanceOf | mint,"rule integrityMint(address u, address delegatedUser, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e,asset);
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 balanceDelegatedUBefore = balanceOf(e, delegatedUser);
	sinvoke mint(e, delegatedUser, u, x, index);
	
	uint256 balanceUAfter = balanceOf(e, u);
	uint256 balanceDelegatedUAfter = balanceOf(e, delegatedUser);
	assert balanceUAfter == balanceUBefore + x && (u != delegatedUser => (balanceDelegatedUAfter == balanceDelegatedUBefore));
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
7798a3fdc9ae53e39a087a9e6cfaf586,492 | 493 | 494,rule,setBorrowingNoChangeToOther,27,44,setBorrowing | isBorrowing | isUsingAsCollateral,"rule setBorrowingNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool borrowing)
rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
","setBorrowing (Lines 27-41),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111), ","  function setBorrowing(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool borrowing
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << (reserveIndex << 1);
      if (borrowing) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
7862bd01a93f7c3d41d1c533f704923b,996,rule,address_not_in_list_after_removeFacilitator,372,379,removeFacilitator,"rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
","removeFacilitator (Lines 94-108), ","  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {
    require(
      bytes(_facilitators[facilitatorAddress].label).length > 0,
      'FACILITATOR_DOES_NOT_EXIST'
    );
    require(
      _facilitators[facilitatorAddress].bucketLevel == 0,
      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'
    );

    delete _facilitators[facilitatorAddress];
    _facilitatorsList.remove(facilitatorAddress);

    emit FacilitatorRemoved(facilitatorAddress);
  }
",./gho-core/ghoToken.spec,,Yes,
7957cf7a0c367b6d664077d0b8c77797,935,rule,transferredTokensMeanThatStackIsUpdated,476,491,summaryInstance.getEthAddress,"rule transferredTokensMeanThatStackIsUpdated(method f) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someToken.allowance(currentContract, summaryInstance) == 0; // to make sure we're starting clean as implied by approvedTokensAreTemporary
rule approvedTokensAreTemporary(method f, address someAllowed) {
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
    uint256 balanceBefore = someToken.balanceOf(currentContract);
    uint256 stackLengthBefore = getStackLength();
    require stackLengthBefore < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
    uint256 balanceAfter = someToken.balanceOf(currentContract);
    assert (balanceAfter > balanceBefore) => stackLengthAfter > stackLengthBefore, 
        ""must push an entry to postprocess stack if transferring funds into proxy which are not eth"";
","getEthAddress (Lines 30-39), ","    function getEthAddress(address handler) external returns (address) {
        // either the handler defines a ETH_ADDRESS function or it does not. If it does not then just return address(0)
        address eth = address(0);
        try WithEthAddress(handler).ETH_ADDRESS() returns (address x) {
            eth = x;
        } catch {
            eth = address(0);
        }
        return eth;
    }
",./furucombo/specs/proxy.spec,,Yes,
79babcb50168a081a1363c7e57440b31,298 | 301,rule,getClaimableRewards_stable_after_withdraw,722,734,initialize | withdraw,"rule getClaimableRewards_stable_after_withdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    withdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | withdraw (Lines 443-453), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
79c524f8a84ddc64b50a9f4ca5c8812e,1705,rule,cancelChange,315,323,cancel,"rule cancelChange(env e){
    bytes32 id;  bytes32 otherId; 

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    cancel(e, id);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","cancel (Lines 106-120), ","    function cancel(uint256 proposalId) public virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];

        require(
            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),
            ""GovernorBravo: proposer above threshold""
        );

        _cancel(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
79c9aec6f0686cbc25a0242e49b76a72,2561,rule,ifExitedIsTrueThenMethodsRevertExceptOwner,101,113,claimOwnership,"rule ifExitedIsTrueThenMethodsRevertExceptOwner() {
	env e;

	require exited() == true;
	method f;
	calldataarg args;
	require !f.isView && f.selector != claimOwnership().selector;
	require e.msg.sender != owner();
	f@withrevert(e, args);
	
	assert(lastReverted, ""Methods didn't revert"");
}
","claimOwnership (Lines 386-396), ","    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }
",./sushi_benttobox/spec/compoundStrategy.spec,,Yes,
7a0e8380f35b696c56504691cf006d5a,1494,rule,cannotTransferMoreBatch,238,257,balanceOf,"rule cannotTransferMoreBatch(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    uint256 balanceBefore1 = balanceOf(from, idToCheck1);
    uint256 balanceBefore2 = balanceOf(from, idToCheck2);
    uint256 balanceBefore3 = balanceOf(from, idToCheck3);
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    safeBatchTransferFrom@withrevert(e, from, to, ids, amounts, data);
    assert (amountToCheck1 > balanceBefore1 || amountToCheck2 > balanceBefore2 || amountToCheck3 > balanceBefore3) => lastReverted, ""Achtung! Scammer!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
7a38d364b8803f7a048af5e27123090e,1293 | 1294,rule,settleAssetsDeletesSettleableAssets,13,17,getNumSettleableAssets | settleAccount,"rule settleAssetsDeletesSettleableAssets(address account) {
    env e;
    settleAccount(e, account);
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}
","getNumSettleableAssets (Lines 52-65),  | settleAccount (Lines 34-40), ","    function getNumSettleableAssets(address account, uint256 blockTime)
        external
        view
        returns (uint256)
    {
        uint256 numSettleableAssets;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            if (assets[i].getSettlementDate() <= blockTime) numSettleableAssets++;
        }

        return numSettleableAssets;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,,Yes,
7a417bb5962d5f5ba411f96555e38c26,2518 | 2519,rule,op_balanceChangeByDepositOrWithdraw,71,83,depositAVAX | withdrawAVAX,"rule op_balanceChangeByDepositOrWithdraw(method f, env e){     
    require open();
    
    address user;
    uint256 balanceBefore = getUserBalance(user);

    calldataarg args;
    f(e, args);
    uint256 balanceAfter = getUserBalance(user);
    assert balanceBefore != balanceAfter <=> (e.msg.sender == user && (f.selector == depositAVAX().selector || f.selector == withdrawAVAX(uint256).selector)), ""pair was changed by wrong method"";
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
7ab48f4282d8995e3853581d1cfd757a,61,rule,executeFailsIfExpired,369,376,getCurrentState,"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
7b01ff5e9521886eaef35dfa5601467f,1071,rule,integrityOfBurn_fixedIndex,475,491,updateDiscountDistribution,"rule integrityOfBurn_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	burn(e, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore - scaledAmount);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
7c0a0d1a5bedd3bc35df93346b47a0f2,1415,rule,token_totalSupply_independence,11,14,safeBatchTransferFrom,"rule token_totalSupply_independence(method f)
filtered {
    f -> f.selector != safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155Supply.spec,,Yes,
7ccd53de0d51531c564b6dcb2aad53f1,2188,invariant,balance_vs_protocol_Liquidity,92,99,uniswapV3SwapCallback,"    ///// invariant balance_vs_protocol_Liquidity()
    ////  verifies that if total supply is zero than all the assets of the system is the owned to governance 
    ////  uniswapV3SwapCallback() - meaningless outside of the swap context
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant balance_vs_protocol_Liquidity()
    (totalSupply() == 0) => token0.balanceOf(currentContract) == protocolFees0() //&&
                            //token1.balanceOf(currentContract) == protocolFees1()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","uniswapV3SwapCallback (Lines 34-350), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
7d6535af59d06cae937ec367dae45f6e,497 | 498 | 499,rule,setCollateralNoChangeToOther,54,71,setUsingAsCollateral | isBorrowing | isUsingAsCollateral,"rule setCollateralNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool usingAsCollateral)
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	setUsingAsCollateral(reserveIndex, usingAsCollateral);
rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
","setUsingAsCollateral (Lines 49-63),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111), ","  function setUsingAsCollateral(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool usingAsCollateral
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << ((reserveIndex << 1) + 1);
      if (usingAsCollateral) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
7de2e2745ee8cb49d9e20901a07d9499,2514,invariant,cl_AvaxCorrelation,352,360,currentPhase,"invariant cl_AvaxCorrelation()
    closed() => (getBalanceOfThis() == avaxReserve() && avaxReserve() == 0)
    { 
        preserved with (env e2) { 
            require currentPhase(e2) == PhaseThree();
            safeAssumptions(e2); 
            require currentContract != WAVAX();
        } 
    }   
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,,Yes,
7e9aac58bbbccc00c71b63c64ab4325f,2594,rule,validDecreaseToBalanceOf,198,213,transferMultiple,"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
","transferMultiple (Lines 42-51), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,,Yes,
7eb0e2b00764b010181008daff9b4e44,613 | 614,rule,additiveMint,162,176,mint | balanceOf,"rule additiveMint(address user1, address user2, address user3, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));

    mint(e, user3, user1, x, index);
	mint(e, user3, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	mint(e, user3, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
7eb4d0f3e010f270890222dad599856c,2346 | 2348 | 2349,rule,below,210,235,split | setSplits | hashSplits,"// the rule below still fails, probably because some of the split receivers can overflow too
rule revertCharacteristicsOfSplit() {
    env e; uint256 userA_Id; uint256 assetId;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;

    // allowing only valid splitReceivers because revert is not allowed
    bytes32 receiversHash = hashSplits(e, true);
    assertSplitsValid(e, true, receiversHash);
    setSplits(e, userA_Id, true);
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    require userA_splittableBefore + userA_collectableBefore < 2^128;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    //require userA_splittableAfter + userA_collectableAfter < 2^128;
    userA_collectableAmt, userA_splitAmt = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | setSplits (Lines 109-111),  | hashSplits (Lines 523-529), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function setSplits(SplitsReceiver[] calldata receivers) public {
        dripsHub.setSplits(calcUserId(msg.sender), receivers);
    }
 |     function hashSplits(SplitsReceiver[] memory receivers)
        public
        pure
        returns (bytes32 receiversHash)
    {
        return Splits._hashSplits(receivers);
    }
",./radicle_drips/specs/Splits2.spec,,Yes,
7f344830ce6d2c0440d7a8d2b0e3d4fa,2562 | 2564,rule,integrityHarvest,116,133,harvest | checkAplusBeqC,"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance, receiverInstance);
		
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 balanceAfter = tokenBalanceOf(tokenInstance, receiverInstance);
	
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","harvest (Lines 26-33),  | checkAplusBeqC (Lines 28-36), ","    function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/compoundStrategy.spec,,Yes,
7f48afc78d3ff0f3d08430966bd563f5,2485,rule,tr_incentiveIssuerRefundChanges,865,875,createPair,"rule tr_incentiveIssuerRefundChanges(method f){     
    uint256 incentivesBefore = tokenIncentiveIssuerRefund();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentiveIssuerRefund();
    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, ""tokenIncentiveIssuerRefund was changed by wrong method"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
7fdd0d548648197a95c1ceba571e0f0f,760 | 761,rule,createsAccount,181,185,setAccount | createAccount,"rule createsAccount(method f, address a) filtered { f ->
	!f.isView
		&& f.selector != createAccount().selector
		&& f.selector != setAccount(string,bytes,address,uint8,bytes32,bytes32).selector
} {
","setAccount (Lines 683-692),  | createAccount (Lines 198-207), ","  function setAccount(
    string calldata name,
    bytes calldata dataEncryptionKey,
    address walletAddress,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external onlyBeneficiaryAndNotRevoked {
    getAccounts().setAccount(name, dataEncryptionKey, walletAddress, v, r, s);
  }
 |   function createAccount() public returns (bool) {
    require(
      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),
      ""Account already exists or address is an authorized signer for another account""
    );
    Account storage account = accounts[msg.sender];
    account.exists = true;
    emit AccountCreated(msg.sender);
    return true;
  }
",./celo_governance/specs/accounts.spec,,Yes,
80be69ce13fbd406d8eaecb5f7af2cb0,59 | 60,rule,executedValidTransition2,357,366,execute | getCurrentState,"rule executedValidTransition2(uint256 actionsSetId)
{
	env e;
	uint actionsSetId2;
	uint8 state1 = getCurrentState(e, actionsSetId);
		execute(e, actionsSetId2);
	uint8 state2 = getCurrentState(e, actionsSetId);

	assert actionsSetId2 == actionsSetId <=> state1 == 0 && state2 == 1;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
80d890800992cfb32ecacbaa3ef05d9f,73,rule,actionDuplicate,493,501,processMessageFromRoot,"rule actionDuplicate()
{
	env e; 
	calldataarg args;

	processMessageFromRoot(e, args);
	processMessageFromRoot@withrevert(e, args);
	assert lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
8175e7f417c1a39d8d4ac967519a4c14,1374 | 1375 | 1376,rule,updateDepositParametersSetsProperly,19,31,getDepositParameters | getMaxMarketIndex | updateDepositParameters,"rule updateDepositParametersSetsProperly(
    uint16 currencyId,
    uint32[] _depositShares,
    uint32[] _leverageThresholds
) {
    env e;
    require getMaxMarketIndex() <= MAX_MARKET_INDEX();
    require _depositShares.length == getMaxMarketIndex();
    require _depositShares.length == _leverageThresholds.length;
    updateDepositParameters(currencyId, _depositShares, _leverageThresholds);
    // TODO: move the checking into solidity and return a bool on success.
    int256[] depositShares, int256[] leverageThresholds = getDepositParameters(currencyId)
}
","getDepositParameters (Lines 119-130),  | getMaxMarketIndex (Lines 273-276),  | updateDepositParameters (Lines 118-129), ","    function getDepositParameters(uint16 currencyId)
        external
        view
        override
        returns (int256[] memory depositShares, int256[] memory leverageThresholds)
    {
        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);
        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(
            currencyId,
            maxMarketIndex
        );
    }
 |     function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        return uint8(data[31]);
    }
 |     function updateDepositParameters(
        uint16 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) external override onlyOwner {
        require(
            depositShares.length == CashGroup.getMaxMarketIndex(currencyId),
            ""Invalid array length""
        );
        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);
        emit UpdateDepositParameters(currencyId);
    }
",./notional_finance_v2/certora/governance/GovernanceAction.spec,,Yes,
8191ca744c3f84549e6fec22b86ad9b0,639,rule,must_not_revert_unless_large_input__convertToShares,94,104,previewWithdraw,"rule must_not_revert_unless_large_input__convertToShares() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 assets;
    require (assets <= maxUint128());
    
    convertToShares@withrevert(e, assets);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
81bace8c38b864ad9b709e683d6f6fd6,2531,rule,cl_tokenIncentivesBalanceCanBeZero,374,387,emergencyWithdraw,"rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){
    requireInvariant alwaysInitialized();   
use invariant alwaysInitialized
use invariant oneStateOnly
use invariant factoryGetPairCorrelationCurrentVals
use invariant al_issuer_allocation_zero
use invariant al_balance_less_than_allocation
use invariant al_userAllocation_less_than_maxAllocation
use invariant initIssuerTimelockNonZero
use invariant initUserTimelockSeven
use invariant initTimelocksCorrelation
use invariant op_incentivesCorrelation
use invariant op_user_not_withdrawn_pair
use invariant op_user_not_withdrawn_incentives
use invariant opWavaxBalanceAndSumBalances
use invariant op_avax_alloc_zero
use invariant op_lp_supply_zero
use invariant opPairBalanceIsZero
// use invariant opPairAndTotalSupplyCorrelation
// use invariant cl_pairTotalZero
use invariant cl_avax_alloc_sum_user_balances
use invariant cl_avaxReservCheck
// use invariant cl_PhaseCheck
// use invariant cl_AvaxCorrelation
// use invariant cl_pair_bal_eq_lp_sum
// use invariant cl_incentivesCorrelation
// use invariant cl_nonzero_user_pair_bal
// use invariant cl_bal_this_zero
use invariant cl_pairAndGetPairCorrelation

// ALWAYS
// STATUS - verified
// - user allocation cannot be decreased
rule al_userAllocationNonDecreasing(method f, env e){     
    address user;
    uint256 allocationBefore = getUserAllocation(user);
    calldataarg args;
    f(e, args);
    uint256 allocationAfter = getUserAllocation(user);
    assert allocationBefore <= allocationAfter, ""allocation was decreased"";
}
    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();
    require tokenIncentivesBalanceBefore > 0;
    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();
    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, ""tokenIncentivesBalance is 0 unintentionally"";
","emergencyWithdraw (Lines 154-164), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
82c40e04f3e556bbdf4feac170959366,2266,rule,correctnessOfSplit,38,55,split,"rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
","split (Lines 343-349), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
835c513b44fd0be9723e8c5ac6e8c755,891 | 895,rule,no_double_vote_referendum_vote,4,55,propose | getVoteRecord,"rule no_double_vote_referendum_vote(address account, uint256 deqIndex) {
	/* A user that already has a vote record for a dequeued index, cannot make a transaction that will increase the weight of that choice */
	env eF; 
	env eFTime; // same time as eF;
	env e_;
	
	uint256 NONE_ENUM = getNoneVoteEnum();
	uint256 ABSTAIN = getAbstainVoteEnum();
	uint256 YES = getYesVoteEnum();
	uint256 NO = getNoVoteEnum();
	uint256 p; // a proposal - let's assume it already exists (required for propose() verification)
	uint256 recordValue;
	p, recordValue, _ = getVoteRecord(account,deqIndex);
	uint256 currentProposalCount = proposalCount();
	require currentProposalCount >= p;
	uint256 _yes; uint256 _no; uint256 _abstain;
	_yes,_no,_abstain = getVoteTotals(p);
	// if can't vote for NONE_ENUM, then necessarily if record vote is NONE_ENUM, all votes are zero currently
	require recordValue == NONE_ENUM => (_yes == 0 && _no == 0 && _abstain == 0);
	require accounts.voteSignerToAccount(eF.msg.sender) == account;
	uint256 someP; uint256 someIndex; uint8 someValue;
	uint256 pOfSomeIndex;
	pOfSomeIndex, _, _ = getVoteRecord(account,someIndex);
	require pOfSomeIndex == p => someIndex == deqIndex; // no duplicates in the dequeued array
	require someP == p => someIndex == deqIndex;
	vote(eF,someP,someIndex,someValue);
	uint256 yes_; uint256 no_; uint256 abstain_;
	yes_,no_,abstain_ = getVoteTotals(p);
	bool doesProposalExist_ = proposalExists(e_,p);
	// if p expires, then sum of votes is no longer relevant - happens in approve, vote, execute
	assert (recordValue != NONE_ENUM && doesProposalExist_) => (yes_ + no_ + abstain_) == (_yes + _no + _abstain), ""Total votes could not have changed if already voted"";
	assert recordValue == YES => yes_ <= _yes, ""Yes votes could not have increased if voted yes already"";
	assert recordValue == NO => no_ <= _no, ""No votes could not have increased if voted no already"";
	assert recordValue == ABSTAIN => abstain_ <= _abstain, ""Abstain votes could not have increased if voted abstain already"";
	assert recordValue == NONE_ENUM => (!doesProposalExist_ && yes_ == 0 && no_ == 0 && abstain_ == 0)// proposal no longer exists so everything is 0
									// or just one out of (yes,no,abstain) changed
									|| (yes_ == _yes && no_ == _no)
									|| (yes_ == _yes && abstain_ == _abstain)
									|| (no_ == _no && abstain_ == _abstain),
									""If previously did not vote, either this proposal was deleted, or only one kind of vote may change, and the other two are the same"";
}
","propose (Lines 467-485),  | getVoteRecord (Lines 1102-1116), ","  function propose(
    uint256[] calldata values,
    address[] calldata destinations,
    bytes calldata data,
    uint256[] calldata dataLengths,
    string calldata descriptionUrl
  ) external payable returns (uint256) {
    dequeueProposalsIfReady();
    require(msg.value >= minDeposit, ""Too small deposit"");

    proposalCount = proposalCount.add(1);
    Proposals.Proposal storage proposal = proposals[proposalCount];
    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);
    proposal.setDescriptionUrl(descriptionUrl);
    queue.push(proposalCount);
    // solhint-disable-next-line not-rely-on-time
    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);
    return proposalCount;
  }
 |   function getVoteRecord(address account, uint256 index)
    external
    view
    returns (uint256, uint256, uint256, uint256, uint256, uint256)
  {
    VoteRecord storage record = voters[account].referendumVotes[index];
    return (
      record.proposalId,
      uint256(record.deprecated_value),
      record.deprecated_weight,
      record.yesVotes,
      record.noVotes,
      record.abstainVotes
    );
  }
",./celo_governance/specs/governance_old_rules.spec,,Yes,
83eb795939717fa27ff8e948adf7eac7,1086,rule,integrityOfUpdateDiscountDistribution_updateIndex,573,584,updateDiscountDistribution,"rule integrityOfUpdateDiscountDistribution_updateIndex() {
	address sender;
	address recipient;
	uint256 senderDiscountTokenBalance;
    uint256 recipientDiscountTokenBalance;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	assert(scaledBalanceOf(sender) > 0 => getUserCurrentIndex(sender) == index);
	assert(scaledBalanceOf(recipient) > 0 => getUserCurrentIndex(recipient) == index);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
844170c24f9033f884842c9ce6dc4f5a,880 | 883 | 885,rule,check_initializer,366,381,getUpvotedProposal | upvote | getUpvoteRecord,"rule check_initializer {
	env _e;
	env eF;
	env e_;
	
	bool _isInitialized = initialized(_e);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	calldataarg arg;
	initialize@withrevert(eF,arg);
	bool successInit = !lastReverted;
	bool isInitialized_ = initialized(e_);
	assert _isInitialized => !successInit, ""initialize() must revert if already initialized"";
	assert successInit => isInitialized_, ""When initialize() succeeds, must set initialization field to true"";
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
84e795ba18832f76d8402f578e457060,358 | 360,rule,integrityBurn,144,153,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke burn(e,a,x);
	
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
857b9accdefcdde57fe15d6d4a236c7d,1530,rule,cantBurnOtherBalances,733,744,balanceOf,"rule cantBurnOtherBalances(env e){
    address from; uint256 id; uint256 amount;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != from => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
85ea85426e0fbbed91f41eef0e3e9ef8,1988 | 1989 | 1990 | 1991,rule,optionWithdrawsRestricted,135,152,withdrawLongB | burnOtokenB | settleVault | getProceed,"rule optionWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, address from, address amount, method f) {
    env e;
    // The pool cannot really call any of these functions
    require (e.msg.sender != pool);
    require (!whitelist.isWhitelistedCollateral(longOtoken));
    uint256 otokenBalanceBefore = longOtoken.balanceOf(pool);
    if (f.selector == burnOtokenB(address,uint256,address,uint256,uint256).selector) {
        require(owner != pool);
        sinvoke burnOtokenB(e, owner, vaultId, from, index, amount);
    } else {
        calldataarg arg;
        sinvoke f(e, arg);
    }
    uint256 otokenBalanceAfter = longOtoken.balanceOf(pool);
    // or settle vault 
    assert otokenBalanceAfter < otokenBalanceBefore => (f.selector == withdrawLongB(address, uint256, address, uint256, uint256).selector) 
                                                    || (f.selector == settleVault(address,uint256,address).selector);
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","withdrawLongB (Lines 212-228),  | burnOtokenB (Lines 325-342),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function withdrawLongB(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _withdrawLong(args);
  }
 |   function burnOtokenB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.BurnArgs memory args = Actions.BurnArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      otoken: anOtokenB,
      index: index,
      amount: amount
    });
    _burnOtoken(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,,Yes,
8744b9e874dbd54853aaebcc27d8c0f1,2286 | 2288 | 2289,rule,moneyNotLostOrCreatedDuringSplit,268,303,split | _setSplits | _assertSplitsValid,"rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
87e84c8405006bfb0d5c4ea0b51ab6d0,1327 | 1328,rule,ifCashNetPresentValueAccountsForAllAssets,252,261,getifCashNetPresentValue | getNumBitmapAssets,"rule ifCashNetPresentValueAccountsForAllAssets(address account) {
    env e;
    // TODO: need to make these asumptions in the code
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;

    // If each asset is valued at 1 then the total value should be the number of assets
    int256 underlyingPV = getifCashNetPresentValue(account, e.block.timestamp, true);
    assert underlyingPV == getNumBitmapAssets(account);
}
","getifCashNetPresentValue (Lines 196-231),  | getNumBitmapAssets (Lines 192-200), ","    function getifCashNetPresentValue(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime,
        uint256 blockTime,
        bytes32 assetsBitmap,
        CashGroupParameters memory cashGroup,
        bool riskAdjusted
    ) internal view returns (int256, bool) {
        int256 totalValueUnderlying;
        uint256 bitNum = 1;
        bool hasDebt;

        while (assetsBitmap != 0) {
            if (assetsBitmap & Constants.MSB == Constants.MSB) {
                uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);
                int256 pv =
                    getPresentValue(
                        account,
                        currencyId,
                        maturity,
                        blockTime,
                        cashGroup,
                        riskAdjusted
                    );
                totalValueUnderlying = totalValueUnderlying.add(pv);

                if (pv < 0) hasDebt = true;
            }

            assetsBitmap = assetsBitmap << 1;
            bitNum += 1;
        }

        return (totalValueUnderlying, hasDebt);
    }
 |     function getNumBitmapAssets(address account) external view returns (int256) {
        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(
            account,
            symbolicAccountContext.bitmapCurrencyId
        );

        // Return int256 for comparison
        return int256(assetsBitmap.totalBitsSet());
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
8817c3e3f94e6cb1fef12918c6792b78,2255,rule,unrelatedUserBalanceNotChangingParametric,929,978,_dripsState,"// rule unrelatedUserBalanceNotChangingParametric(
//         method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // step 1 - balance before of receiverId
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
//     uint256 userId1; uint256 config1;
//     uint256 userId2; uint256 config2;
//     uint256 userId3; uint256 config3;
//     userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
//     DH.DripsReceiver argsReceiver1;
//     require argsReceiver1.userId == userId1;
//     require argsReceiver1.config == config1;
//     DH.DripsReceiver argsReceiver2;
//     require argsReceiver2.userId == userId2;
//     require argsReceiver2.config == config2;
//     DH.DripsReceiver argsReceiver3;
//     require argsReceiver3.userId == userId3;
//     require argsReceiver3.config == config3;
//     require argsReceiver1.userId != receiverId;
//     require argsReceiver2.userId != receiverId;
//     require argsReceiver3.userId != receiverId;
//     f(e, args);
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
//     //assert false;
// }
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
88fa92046303ae3fec39f47242f20fee,989,rule,facilitator_in_list_after_addFacilitator,336,349,addFacilitator,"rule facilitator_in_list_after_addFacilitator(){

	env e;
	address facilitator;
	string label;
	uint128 capacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	
	addFacilitator(e,facilitator, label, capacity);
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
","addFacilitator (Lines 72-91), ","  function addFacilitator(
    address facilitatorAddress,
    string calldata facilitatorLabel,
    uint128 bucketCapacity
  ) external onlyRole(FACILITATOR_MANAGER) {
    Facilitator storage facilitator = _facilitators[facilitatorAddress];
    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');
    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');

    facilitator.label = facilitatorLabel;
    facilitator.bucketCapacity = bucketCapacity;

    _facilitatorsList.add(facilitatorAddress);

    emit FacilitatorAdded(
      facilitatorAddress,
      keccak256(abi.encodePacked(facilitatorLabel)),
      bucketCapacity
    );
  }
",./gho-core/ghoToken.spec,,Yes,
8971fb1874e7a89ff1c97e87fa8b565f,2127,invariant,optingInAndOutSyncdWithNonRebasingState,344,366,changeSupply,"invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
8a1555c9c53bac4a954abb8e656f8e62,1633 | 1637,rule,sanity,179,198,balanceOf | _delegate,"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    require lastIndex(delegatee) < 1000000;
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
8a2bf95e2ddc9ac12103b7e30b3ba5fa,87,invariant,minDelayLtMaxDelay,81,112,getCurrentState,"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
8aa368715d4def33d5d14e9a16af7032,577 | 578,rule,integrityBurn,138,147,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e, a);
	burn(e,a,x);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
8aefd3ab5b0425073c54cf52ac916733,1251 | 1254,rule,noFrontRunningOnWithdraw,360,402,seizeBond | bondAmount,"rule noFrontRunningOnWithdraw(address operator, address owner, address beneficiary, address otherOperator, uint256 x,
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
        method f) {
    env eF;
    calldataarg args;
    uint256 referenceID;
    require otherOperator != operator;
    require safeAdd(unbondedValue(operator), unbondedValue(otherOperator)) &&
            allUnbonded()  >= unbondedValue(operator) + unbondedValue(otherOperator);
    require safeAdd(totalLockedBonds(operator), totalLockedBonds(otherOperator)) &&
            allLockedBond()  >= totalLockedBonds(operator) + totalLockedBonds(otherOperator);
    require safeAdd(allUnbonded(), allLockedBond()) &&
            balanceOf(currentContract) >= allUnbonded() + allLockedBond();
    require totalLockedBonds(otherOperator) >= bondAmount(otherOperator, eF.msg.sender, referenceID);
    uint256 allUserAssets = allUnbonded() + allLockedBond();
    require safeAdd(balanceOf(currentContract), allUserAssets);
    uint256 allAssets = balanceOf(currentContract) + allUserAssets;
    require safeAdd(balanceOf(beneficiary), allAssets);
    storage init_storage = lastStorage;
    env eWithdraw;
    withdraw(eWithdraw, x, operator);
    bool succSceanrio1 = !lastReverted;
    // f should only change other operator and if changed totalLocked than the specific bondID used in the require
    uint256 u = unbondedValue(otherOperator) at init_storage;
    uint256 l = totalLockedBonds(otherOperator);
    uint256 bondBefore = bondAmount(otherOperator, eF.msg.sender, referenceID);
    f(eF, args);
    require u != unbondedValue(otherOperator) || l != totalLockedBonds(otherOperator);
    require f.selector==seizeBond(address,uint256,uint256,address).selector =>
                bondBefore != bondAmount(otherOperator, eF.msg.sender, referenceID);
    invoke withdraw(eWithdraw, x, operator);
    bool succSceanrio2 = !lastReverted;
    assert succSceanrio2;
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
8b3dce129e5798b11f02a26c40b6f6fb,364 | 366 | 367,rule,inverseMintBurn,174,184,balanceOf | mint | burn,"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x);
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
8b53a90047ebccc8bb4c45d839fdfb49,875 | 877 | 879,rule,only_initializer_changes_initialized_field,350,350,getUpvotedProposal | upvote | getUpvoteRecord,"rule only_initializer_changes_initialized_field(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
8bc2c5da3c78142e3b490e8253147e9c,2400 | 2401,invariant,pairAndGetPairCorrelation,178,185,allowEmergencyWithdraw | initialize,"invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
8bf1981a6821c7253d045c1fb73f5a78,1669,invariant,readyCheck,53,55,isOperationReady,"invariant readyCheck(env e, bytes32 id)
    (e.block.timestamp >= getTimestamp(id) && getTimestamp(id) > 1) <=> isOperationReady(e, id)
filtered { f -> !f.isView }
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
8ca2ef6914fb211e7306493314d1f709,1314 | 1315,rule,riskAdjustedPresentValueIsLessThanPresentValue,138,149,getPresentValue | getRiskAdjustedPresentValue,"rule riskAdjustedPresentValueIsLessThanPresentValue(
    int256 notional,
    uint256 maturity,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 pv = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 riskAdjustedPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);

    assert riskAdjustedPV <= pv;
}
","getPresentValue (Lines 59-72),  | getRiskAdjustedPresentValue (Lines 76-104), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
8d7515f99321318a1a0d06b4e7df8d52,1696 | 1697,rule,onlyProposer,245,246,schedule | scheduleBatch,"rule onlyProposer(method f, env e) filtered { f -> f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector
                                                    || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector } {
","schedule (Lines 214-225),  | scheduleBatch (Lines 236-252), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
 |     function scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata payloads,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == payloads.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
        _schedule(id, delay);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);
        }
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
8daf2b9ef2da2a5ce9364f0f9fa8c7ab,1372 | 1373,rule,validMarketMaturitesHaveAnIndex,57,71,isValidMarketMaturity | getMarketIndex,"rule validMarketMaturitesHaveAnIndex(
    uint256 maxMarketIndex,
    uint256 maturity,
    uint256 blockTime
) {
    // Respect time boundaries
    uint256 marketIndex;
    bool isIdiosyncratic;
    marketIndex, isIdiosyncratic = getMarketIndex(maxMarketIndex, maturity, blockTime);
    bool isValidMarket = isValidMarketMaturity(maxMarketIndex, maturity, blockTime);

    // If a market is a valid market maturity then the getMarketIndex should agree
    assert isValidMarket <=> !isIdiosyncratic, ""is valid market does not imply a market index"";
    assert MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX(), ""market index out of boundaries"";
}","isValidMarketMaturity (Lines 40-56),  | getMarketIndex (Lines 74-90), ","    function isValidMarketMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, ""CG: market index bound"");

        if (maturity % Constants.QUARTER != 0) return false;
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;
        }

        return false;
    }
 |     function getMarketIndex(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (uint256, bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, ""CG: market index bound"");
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));
            if (marketMaturity == maturity) return (i, false);
            if (marketMaturity > maturity) return (i, true);
        }

        revert(""CG: no market found"");
    }
",./notional_finance_v2/certora/asset/DateTime.spec,,Yes,
8ec8f69b2e1b782f09b0e89868926530,1578,rule,withdrawToSpecUnderlying,162,187,withdrawTo,"rule withdrawToSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    withdrawTo(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore 
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter 
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update (acc == sender)"";
    
    assert account != e.msg.sender && account == currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter, ""underlying balances wrong update (acc == contract)""; 
    assert account != e.msg.sender && account != currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter
                && underlyingThisBalanceBefore == underlyingThisBalanceAfter + amount, ""underlying balances wrong update (acc != contract)"";   
}
","withdrawTo (Lines 48-52), ","    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
8ed1f1ae4862c858247c91be7671c46d,663,rule,previewMint_amount_check,211,233,previewWithdraw,"rule previewMint_amount_check() {
    env e1;
    env e2;
    uint256 shares;
    address receiver;
    uint256 previewAssets;
    uint256 assets;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address owner;
    uint256 previewShares;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
        
    previewAssets = previewMint(e1,shares);
    require (shares <= convertToShares(e2,maxDeposit(receiver)) => convertToAssets(e2,shares) <= maxDeposit(receiver));
    assets = mint(e2, shares, receiver);
    assert previewAssets == assets || previewAssets == assets+1 || previewAssets+1 == assets, ""preview should be equal to actual - mint"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
8f1ff28b8387f64d1e0676b313659db6,2546 | 2548,rule,integrityHarvest,46,67,harvest | checkAplusBeqC,"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	
	require strategyBalanceBefore == tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	env e;
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 strategyBalanceAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","harvest (Lines 26-33),  | checkAplusBeqC (Lines 28-36), ","    function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/strategy.spec,,Yes,
8fc106145c33d363a3e376ff60cff5a5,1350,rule,testAssetCash,149,160,executeTrade,"rule testAssetCash(int256 fCashToAccount, uint256 timeToMaturity){
    // require timeToMaturity <= 2^255-1;
    // require timeToMaturity > 0;
    // require fCashToAccount != 0;
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    assetCashToAccount, assetCashToReserve = executeTrade(timeToMaturity, fCashToAccount);
    // require (assetCashToReserve > 0, ""asset cash to reserve cannot be negative"");
    int256 marketAssetCashAfter = getMarketAssetCash();
    assert marketAssetCashAfter > marketAssetCashBefore;
}
","executeTrade (Lines 124-143), ","    function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
902e197aa01c1da4bca7b403836c67b4,1455 | 1456,rule,allFunctionsRevertIfCanceled,308,316,queue | __acceptAdmin,"rule allFunctionsRevertIfCanceled(method f) filtered {
    f -> !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","queue (Lines 90-107),  | __acceptAdmin (Lines 168-170), ","    function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,,Yes,
90603630825667ac21f361f75cd5b4dc,1301 | 1302 | 1303,rule,settlingBitmapAssetsDoesNotLoseTrack,57,70,getNumSettleableAssets | getNumAssets | settleAccount,"rule settlingBitmapAssetsDoesNotLoseTrack(address account) {
    env e;
    // This is only true for bitmap currencies, it's mostly true for array portfolios but there
    // is an edge case where liquidity tokens net off against fCash exactly.
    require getBitmapCurrencyId(account) != 0;
    uint256 numAssets;
    uint256 numSettleAssets;
    numAssets = getNumAssets(account);
    numSettleAssets = getNumSettleableAssets(account, e.block.timestamp);

    settleAccount(e, account);
    assert getNumAssets(account) == numAssets - numSettleAssets;
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}","getNumSettleableAssets (Lines 52-65),  | getNumAssets (Lines 85-90),  | settleAccount (Lines 34-40), ","    function getNumSettleableAssets(address account, uint256 blockTime)
        external
        view
        returns (uint256)
    {
        uint256 numSettleableAssets;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            if (assets[i].getSettlementDate() <= blockTime) numSettleableAssets++;
        }

        return numSettleableAssets;
    }
 |     function getNumAssets(address account) external view returns (uint256) {
        PortfolioAsset[] memory assets = _getAccountAssets(account);
        // Value of any asset should never be zero. If it is then it should not exist in the portfolio.
        for (uint256 i; i < assets.length; i++) assert(assets[i].notional != 0);
        return assets.length;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,,Yes,
90711e60dc94ed4c9ca5b24d35ea7f37,2399,invariant,factoryGetPairCorrelationNewVals,165,172,initialize,"invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
    {
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            require token == _token;
        }
    }
","initialize (Lines 28-35), ","    function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
90864081139856a10b556b9454f399d3,1487 | 1488,rule,transferAdditivity,140,157,balanceOf | safeTransferFrom,"rule transferAdditivity(env e){
    address from; address to; uint256 id; bytes data;
    uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount1, data) at initialStorage;
    safeTransferFrom(e, from, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
90a6b394d17ec347fccba99e4b390a9f,2276 | 2278 | 2279,rule,integrityOfSplit,143,209,split | _setSplits | _assertSplitsValid,"rule integrityOfSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id; uint256 userC_Id; uint256 userD_Id;
    
    require userA_Id != userB_Id;   require userA_Id != userD_Id;
    require userA_Id != userC_Id;   require userB_Id != userD_Id;
    require userB_Id != userC_Id;   require userC_Id != userD_Id;

    // obtaining splittable/collectable states before calling split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    require userA_splittableBefore > 0;
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    uint128 userD_splittableBefore = splittable(e, userD_Id, assetId);
    uint128 userD_collectableBefore = collectable(e, userD_Id, assetId);
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require index1 != index2;     // different indexes sample different splitReceivers
    require userId1 == userB_Id;  // userB is on the list of splitReceivers of userA
    require userId2 != userC_Id;  // the second splitReceiver is not userC
    require userId2 != userA_Id;  // the second splitReceiver is not the splitter itself
    require userId2 == userD_Id;  // since we run with loop_iter 2, there are max 2 receivers
    // obtaining splittable/collectable states after calling split()
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    uint128 userC_collectableAfter = collectable(e, userC_Id, assetId);
    uint128 userD_splittableAfter = splittable(e, userD_Id, assetId);
    uint128 userD_collectableAfter = collectable(e, userD_Id, assetId);
    // UserA's splittable should NOT increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userA_splittableAfter <= userA_splittableBefore;
    assert userA_splittableAfter == 0; // it should be zero
    // UserB is on the list of UserA's splitters, therefore ""userB's splittable should NOT decrease""
    assert userB_splittableAfter >= userB_splittableBefore;
    // UserC is NOT on the list of UserA's splitters, therefore ""userC's splittable should NOT change""
    assert userC_splittableAfter == userC_splittableBefore;
    // UserA's collectable should NOT decrease, UserB and UserC's collectable should NOT change
    assert userA_collectableAfter >= userA_collectableBefore;
    assert userB_collectableAfter == userB_collectableBefore;
    assert userC_collectableAfter == userC_collectableBefore;
    // The increase of the splittable of the receivers userB and userD should be equal the splittable of userA
    assert (userB_splittableAfter - userB_splittableBefore) +
           (userD_splittableAfter - userD_splittableBefore) +
           (userA_collectableAfter - userA_collectableBefore) == userA_splittableBefore;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
90e006dab3eafdbcf4ca9a35efef01c3,2326 | 2328 | 2329,rule,cannotFrontRunSplitGeneralCase,7,53,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,,Yes,
9101b5f85c42cb7c398b9205c0f0ae30,2118,invariant,totalSupplyIsBelowMaxSupply,29,39,changeSupply,"invariant totalSupplyIsBelowMaxSupply() 
	totalSupply() <= Certora_maxSupply()

rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
9190e21447ea5256050cbbbe7ccea5e0,244,rule,afterCancellationStartMustSucceed,291,314,startDepositCancellation,"rule afterCancellationStartMustSucceed(uint256 amount, address user) {
    env e1; env e2;
    address asset;
    address aToken;
    address static;
    setupTokens(asset, aToken, static);
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    uint256 dynamic = _staticToDynamicAmount_Wrapper(amount, asset, LENDINGPOOL_L1);
    require amount < 2^127;
    require tokenBalanceOf(e2, aToken, currentContract) >= dynamic;
    require tokenBalanceOf(e2, asset, currentContract) >= amount;
    require e1.block.timestamp > 0;
    require e2.block.timestamp > e1.block.timestamp;
    startDepositCancellation(e1, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit@withrevert(e2, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    bool cancelReverted = lastReverted;
    assert cancelReverted <=> !readyToCancel(e2, nonce);
}
","startDepositCancellation (Lines 465-494), ","    function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
91c83a3e5ccf5302dee5148a9545aa5c,1104,rule,integrityOfBalanceOf_noDiscount,665,673,updateDiscountDistribution,"rule integrityOfBalanceOf_noDiscount() {
	address user;
	require(getUserDiscountRate(user) == 0);
	env e;
	uint256 scaledBalance = scaledBalanceOf(user);
	uint256 currentIndex = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 expectedBalance = rayMulCVL(scaledBalance, currentIndex);
	assert(balanceOf(e, user) == expectedBalance);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
9228f7b8b1622d2108c894af4bd773de,870 | 872 | 874,rule,constitution_change,325,328,getUpvotedProposal | upvote | getUpvoteRecord,"rule constitution_change(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
        && f.selector != setConstitution(address,bytes4,uint256).selector
} {
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
92354492e9c7e4236ef303c872af5b9c,1056,rule,onlyMintForUserCanIncreaseUsersBalance,380,401,updateDiscountDistribution,"rule onlyMintForUserCanIncreaseUsersBalance() {
	address user1;
	address user2;
	address user3;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
93f17742285f33b66c645050cfcebdfa,248 | 249 | 250,invariant,inv_atoken_balanceOf_2users_leq_totalSupply,172,204,metaWithdraw | withdraw | redeem,"invariant inv_atoken_balanceOf_2users_leq_totalSupply(address user1, address user2)
	(_AToken.balanceOf(user1) + _AToken.balanceOf(user2))<= _AToken.totalSupply()
    {
		preserved with (env e1){
            setup(e1, user1);
		    setup(e1, user2);
		}
        preserved redeem(uint256 shares, address receiver, address owner) with (env e2){
            require user1 != user2;
            require _AToken.balanceOf(currentContract) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        }
        preserved redeem(uint256 shares, address receiver, address owner, bool toUnderlying) with (env e3){
        	requireInvariant sumAllATokenScaledBalance_eq_totalSupply();
            require _AToken.balanceOf(e3.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        preserved withdraw(uint256 assets, address receiver,address owner) with (env e4){
            require _AToken.balanceOf(e4.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();

        preserved metaWithdraw(address owner, address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 deadline,_StaticATokenLM.SignatureParams sigParams)
        with (env e5){
            require _AToken.balanceOf(e5.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
	}
","metaWithdraw (Lines 182-224),  | withdraw (Lines 443-453),  | redeem (Lines 469-478), ","  function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
 |   function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
94138ade9c9a6d5f3e739f3d62bfdeb1,1576 | 1577,rule,withdrawToSpecWrapper,139,157,balanceOf | withdrawTo,"rule withdrawToSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    withdrawTo(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter + amount, ""wrapper user balance wrong update"";
    assert account != e.msg.sender => wrapperSenderBalanceBefore == wrapperSenderBalanceAfter + amount
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter, ""wrapper user balance wrong update"";
}
","balanceOf (Lines 70-73),  | withdrawTo (Lines 48-52), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,,Yes,
9465dd241cbab432d033f9887874c70d,254 | 255,rule,totalAssets_stable_after_collectAndUpdateRewards,297,307,collectAndUpdateRewards | claimRewardsOnBehalf,"rule totalAssets_stable_after_collectAndUpdateRewards()
rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
{
    env e;
    require _RewardsController.getRewardsByAsset(_AToken, 0) != _AToken;
    require _RewardsController.getUserAccruedReward(currentContract, _AToken, _AToken) ==0;
    address reward;
    mathint totalAssetBefore = totalAssets(e);
    collectAndUpdateRewards(e, reward); 
    mathint totalAssetAfter = totalAssets(e);
    assert totalAssetAfter == totalAssetBefore;
}
","collectAndUpdateRewards (Lines 262-277),  | claimRewardsOnBehalf (Lines 280-291), ","  function collectAndUpdateRewards(address reward) public returns (uint256) {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);

    return
      INCENTIVES_CONTROLLER.claimRewards(
        assets,
        type(uint256).max,
        address(this),
        reward
      );
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
95145c56eb3c7f55e6a323da4121bc07,2211,rule,more_shares_more_amounts_to_withdraw,295,321,withdraw,"///// rule more_shares_more_amounts_to_withdraw()
////  verifies that with larger number of shares one will withdraw a larger amount of assets
////  this rule passes only when the following line added to burnLiquidityShares():
////  require (share == liquidity * totalSupply/uint256(liquidityInPool));
// rule more_shares_more_amounts_to_withdraw( address to){
// env e;
//     uint256 sharesX;
//     uint256 sharesY;
//     uint256 amount0X;
//     uint256 amount1X;
//     uint256 amount0Y;
//     uint256 amount1Y;

//     require governance() != currentContract;
//     require governance() != pool;
//     require to != currentContract && to != pool && to != governance();
//     require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
//     require sharesX > sharesY;
//     storage init = lastStorage;
    
//     amount0X,amount1X =  withdraw(e,sharesX, to);
//     amount0Y,amount1Y =  withdraw(e,sharesY, to) at init;
//     assert amount0X >= amount0Y && amount1X >= amount1Y;
// }
","withdraw (Lines 59-63), ","    function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
9597955c8e2bbe3631118f5f7c3e7f61,2579,rule,solvency,109,146,_tokenBalanceOf,"rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,,Yes,
95cec3fe0428a84924062860aa08dbad,1118 | 1119,rule,level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment,133,148,transferUnderlyingTo | handleRepayment,"rule level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment()
{
	env e;
	calldataarg arg;
	uint256 amount;
	address target;
	address user;
    address onBehalfOf;

	uint256 levelBefore = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	transferUnderlyingTo(e, target, amount);
	handleRepayment(e, user, onBehalfOf, amount);
	uint256 levelAfter = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	assert levelBefore <= levelAfter;
}
","transferUnderlyingTo (Lines 156-158),  | handleRepayment (Lines 161-173), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
 |   function handleRepayment(
    address user,
    address onBehalfOf,
    uint256 amount
  ) external virtual override onlyPool {
    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);
    if (amount <= balanceFromInterest) {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);
    } else {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);
      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);
    }
  }
",./gho-core/ghoAToken.spec,,Yes,
97095dcbe9edee1e85680df4e975f12e,903,rule,noRevert,21,31,getParams,"rule noRevert(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		require false;
	} else {
		f@withrevert(e, arg);
	}
	assert !lastReverted; // only fallback may revert
}","getParams (Lines 34-60), ","    function getParams(
        bytes32 conf
    ) internal pure returns (uint256[] memory refs, uint256[] memory params) {
        require(!isStatic(conf), ""Static params"");
        uint256 n = REFS_LIMIT;
        while (conf & REFS_MASK == REFS_MASK && n > 0) {
            n--;
            conf = conf >> 8;
        }
        require(n > 0, ""No dynamic param"");
        refs = new uint256[](n);
        params = new uint256[](n);
        for (uint256 i = 0; i < n; i++) {
            refs[i] = uint256(conf & REFS_MASK);
            conf = conf >> 8;
        }
        uint256 locCount = 0;
        for (uint256 k = 0; k < PARAMS_SIZE_LIMIT; k++) {
            if (conf & PARAMS_MASK != 0) {
                require(locCount < n, ""Location count exceeds ref count"");
                params[locCount] = k * 32 + 4;
                locCount++;
            }
            conf = conf >> 1;
        }
        require(locCount == n, ""Location count less than ref count"");
    }
",./furucombo/specs/libParam.spec,,Yes,
97f057cfc07a41d098ca4640b36edaa3,2068 | 2069,rule,putOptionsPreExpiryCase2StartingWithAllCases,197,316,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase2StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
982e55f477c725e3a79bd56f6210e61a,219,rule,happened,526,543,returnFunds,"    @Notes: We used the following require to prove, that violation of this rule happened
            when totalSupply() == 0:
            require f.selector == returnFunds(uint256).selector => totalSupply() != 0;
            This has been solved by Lukas in this commit:
            https://github.com/Certora/aave-stk-slashing-mgmt/pull/1/commits/8336dc0747965a06c7dc39b4f89273c4ef7ed18a
    @Link: https://prover.certora.com/output/40577/3fdb151c46c84b1ab323b99c80890273/?anonymousKey=68e37ada870b7b91c68a5eadaf6030f3989002a6
*/
rule exchangeRateNeverZero(method f) {
    env e; calldataarg args;
    uint216 _ER = getExchangeRate();
    require _ER != 0;

    f(e, args);
    uint216 ER_ = getExchangeRate();
    assert ER_ != 0;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
9834b93a34f460bef753f707bca5e47f,594 | 595,rule,burnNoChangeToOther,292,307,balanceOf | burn,"rule burnNoChangeToOther(address user, uint256 amount, address other) {
  
	require other != user;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(e, other);
	burn(e, user, amount);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(e, other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
984a4e9b61c23dd9cab29411441999c9,2215 | 2216,rule,protocolFees_state,348,354,uniswapV3SwapCallback | acceptGovernance,"///// rule protocolFees_state()
////  verifies that balance of governance before applying f() + the change in protocolFees is greater or equal balance of governance after applying f()
////  uniswapV3SwapCallback() - meaningless outside of the swap context
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  acceptGovernance()      - breaks the rule when governance changes
rule protocolFees_state(env e, method f, uint256 shares, address to)
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector && f.selector != acceptGovernance().selector }
","uniswapV3SwapCallback (Lines 34-350),  | acceptGovernance (Lines 2607-2612), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
 |     function acceptGovernance() external {
        require(msg.sender == pendingGovernance, ""PG"");
        emit TransferGovernance(governance, pendingGovernance);
        pendingGovernance = address(0);
        governance = msg.sender;
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
98a5fe0f238825a3098cf34b16bfde1a,108,rule,executedForever,221,228,getCurrentState,"rule executedForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 1;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 1;
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
98a71abc41ec8fa047d5eb06a99d1556,67,rule,afterQueueHashQueued,457,470,processMessageFromRoot,"rule afterQueueHashQueued(bytes32 actionHash)
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();

	bool queueBefore = isActionQueued(e, actionHash);
		processMessageFromRoot(e, args);
	bool queuedAfter = isActionQueued(e, actionHash);
		
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1))
			<=> !queueBefore && queuedAfter;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
98b4fce0123464476c95f751d5e64275,107,rule,noIncarnations3,210,218,getCurrentState,"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
9907f4c538f0fd18c2ec2390f590b29b,259 | 260,rule,reward_balance_stable_after_collectAndUpdateRewards,312,328,_AToken.transferFrom | collectAndUpdateRewards,"rule reward_balance_stable_after_collectAndUpdateRewards()
{
    env e;
    address reward;
    address sender;
    uint256 amount;

    storage initial = lastStorage;
    collectAndUpdateRewards(e, reward); 
    mathint reward_balance_before = _DummyERC20_rewardToken.balanceOf(currentContract);
    _AToken.transferFrom(e, sender, currentContract, amount) at initial;
    mathint reward_balance_after = _DummyERC20_rewardToken.balanceOf(currentContract);
    assert reward_balance_before == reward_balance_after;
}
","transferFrom (Lines 99-121),  | collectAndUpdateRewards (Lines 262-277), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function collectAndUpdateRewards(address reward) public returns (uint256) {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);

    return
      INCENTIVES_CONTROLLER.claimRewards(
        assets,
        type(uint256).max,
        address(this),
        reward
      );
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
99575f545c28c817c94dbb69aab20b2c,2597 | 2598 | 2599,rule,preserveTotalAssetsOfUser,242,281,transferMultiple | setStrategy | harvest,"rule preserveTotalAssetsOfUser(address token, address from, address to,
					    	   address user, uint256 amount, uint256 share,
							   method f) {
	env e;

	// verifying a simplified version
	require totalTokenAmount(token) == totalTokenShare(token);
	uint256 _userShares = balanceOf(token, user);
	// roundUp = true or false shouldn't matter as long as they are consistent
	mathint _userAssets = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true); 
	require user != currentContract &&  user == from && user == harnessFrom() && user == to;
	//for transfermultiple we assume that all transfer are to the same user
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint userAssets_ = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true);
	uint256 userShares_ = balanceOf(token, user);
	
	// transferMultiple transfer from user to some arbitrary other user so we expect assets to be preserved
	require  f.selector != transferMultiple(address,address,address[],uint256[]).selector; 
	// flash loan can reduce asset of user due to fee, and strategy can also reduce user assets due to negative profit
	if (f.selector != 0xf1676d37 && // hascode of flashLoan 
		f.selector != setStrategy(address,address).selector &&
		f.selector != harvest(address,bool,uint256).selector)
	{
		assert (_userAssets <= userAssets_,
			""total user assets not preserved"");
	}
	else  {
		// however on those functions, a user's share should not change
		assert (_userShares == userShares_,
}
","transferMultiple (Lines 42-51),  | setStrategy (Lines 1049-1082),  | harvest (Lines 26-33), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
 |     function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }
 |     function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,,Yes,
9a3b325bd619dabdb4100dd82cd74ae2,1126,rule,integrityOfDistributeFeesToTreasury,114,129,distributeFeesToTreasury,"rule integrityOfDistributeFeesToTreasury(){
    env e;
    address treasury = getGhoTreasury(e);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    uint256 _treasuryBalance = gho.balanceOf(treasury);

    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, treasury, atoken);
    distributeFeesToTreasury(e);
    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 treasuryBalance_ = gho.balanceOf(treasury);
    assert treasury != currentContract => facilitatorBalance_ == 0;
    assert treasuryBalance_ - _treasuryBalance == _facilitatorBalance - facilitatorBalance_;
}
","distributeFeesToTreasury (Lines 176-180), ","  function distributeFeesToTreasury() external virtual override {
    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));
    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);
    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);
  }
",./gho-core/flashMinter.spec,,Yes,
9a553dd57f62d2198f955fd7453a7dc5,2603,invariant,zeroStrategy,78,130,_tokenBalanceOf,"invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
	
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)

// Rules
/**
 * solvency:
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	require straToken == strategy(token);
	//proven in zeroStrategy
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentobox.spec,,Yes,
9a7e907d9743bf621b59aa949d017447,1316 | 1317 | 1318 | 1319 | 1320,rule,riskAdjustedLiquidityTokenValueMatchesClaims,155,186,getRiskAdjustedPresentValue | getLiquidityHaircut | calculateOracleRate | getLiquidityTokenValue | getMarketValues,"rule riskAdjustedLiquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 tokenHaircut;
    tokenHaircut = getLiquidityHaircut(assetType);
    require tokenHaircut <= 100;
    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        true // risk adjusted
    );
    mathint netfCash = (totalfCash * tokens * tokenHaircut) / (100 * totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens * tokenHaircut) / (100 * totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getRiskAdjustedPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","getRiskAdjustedPresentValue (Lines 76-104),  | getLiquidityHaircut (Lines 73-83),  | calculateOracleRate (Lines 221-259),  | getLiquidityTokenValue (Lines 151-216),  | getMarketValues (Lines 37-55), ","    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)
        internal
        pure
        returns (uint256)
    {
        require(assetType > 1); // dev: liquidity haircut invalid asset type
        uint256 offset =
            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);
        uint256 liquidityTokenHaircut = uint256(uint8(uint256(cashGroup.data >> offset)));
        return liquidityTokenHaircut;
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }
 |     function getMarketValues()
        external
        view
        returns (
            uint256 totalfCash,
            uint256 totalAssetCash,
            uint256 totalLiquidity,
            uint256 maturity
        )
    {
        require(symbolicMarket.totalfCash >= 0);
        require(symbolicMarket.totalAssetCash >= 0);
        require(symbolicMarket.totalLiquidity >= 0);

        totalfCash = uint256(symbolicMarket.totalfCash);
        totalAssetCash = uint256(symbolicMarket.totalAssetCash);
        totalLiquidity = uint256(symbolicMarket.totalLiquidity);
        maturity = symbolicMarket.maturity;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
9bbba1adee0105bf12fa08893799ee7b,817 | 819 | 821,rule,proposal_count_monotonic_increasing,99,99,getUpvotedProposal | upvote | getUpvoteRecord,"rule proposal_count_monotonic_increasing(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
9ca45bf5e5ee2b926f8d318e1dfa4575,1378 | 1379,rule,updateInitializationParametersSetsProperly,33,45,getNTokenAccount | updateIncentiveEmissionRate,"// rule updateInitializationParametersSetsProperly;

rule updateIncentiveEmissionRateSetsProperly(
    uint16 currencyId,
    uint32 newEmissionRate,
    address nTokenAddress
) {
    env e;
    require nTokenAddress(currencyId) == nTokenAddress;
    updateIncentiveEmissionRate(currencyId, newEmissionRate);
    _, uint256 incentiveEmissionRate = getNTokenAccount(nTokenAddress);
    assert incentiveEmissionRate == newEmissionRate;
}
","getNTokenAccount (Lines 234-262),  | updateIncentiveEmissionRate (Lines 159-171), ","    function getNTokenAccount(address tokenAddress)
        external
        view
        override
        returns (
            uint256 currencyId,
            uint256 totalSupply,
            uint256 incentiveAnnualEmissionRate,
            uint256 lastInitializedTime,
            bytes6 nTokenParameters,
            int256 cashBalance
        )
    {
        (
            currencyId,
            totalSupply,
            incentiveAnnualEmissionRate,
            lastInitializedTime,
            nTokenParameters
        ) = nTokenHandler.getNTokenContext(tokenAddress);

        // prettier-ignore
        (
            cashBalance,
            /* */,
            /* */,
            /* */
        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);
    }
 |     function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)
        external
        override
        onlyOwner
    {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(nTokenAddress != address(0), ""Invalid currency"");
        // Sanity check that emissions rate is not specified in 1e8 terms.
        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, ""Invalid rate"");

        nTokenHandler.setIncentiveEmissionRate(nTokenAddress, newEmissionRate);
        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);
    }
",./notional_finance_v2/certora/governance/GovernanceAction.spec,,Yes,
9ce383eff0a7a4826d489d57215564d5,2383,rule,deposit_no_frontrunning,256,284,deposit,"rule deposit_no_frontrunning(method f) // passes
{
    // setup
    env e; calldataarg args;
    uint256 x;
    require userJoeStaked(currentContract) > x;
    uint256 bal_pre_clean = userJoeStaked(e.msg.sender);
    uint256 user_bal_pre_clean = joe.balanceOf(e, e.msg.sender);
    storage init = lastStorage;

    // run with frontrunning
    f(e, args);
    uint256 bal_pre_f = userJoeStaked(e.msg.sender);
    uint256 user_bal_pre_f = joe.balanceOf(e, e.msg.sender);
    deposit(e, x);
    uint256 bal_post_f = userJoeStaked(e.msg.sender);
    uint256 user_bal_post_f = joe.balanceOf(e, e.msg.sender);
    uint256 delta_f = bal_post_f - bal_pre_f;
    // run without frontrunning
    deposit(e, x) at init;
    uint256 bal_post_clean = userJoeStaked(e.msg.sender);
    uint256 user_bal_post_clean = joe.balanceOf(e, e.msg.sender);
    uint256 delta_clean = bal_post_clean - bal_pre_clean;
    assert delta_f == delta_clean, ""frontrunning found"";
    assert user_bal_pre_clean - user_bal_post_clean == user_bal_pre_f - user_bal_post_f, ""balance not received by user"";
}
","deposit (Lines 106-126), ","    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
9d0e270037f789d00d413abd19715028,2479 | 2480 | 2481,rule,tr_pairOnlyChange,820,831,createPair | allowEmergencyWithdraw | initialize,"rule tr_pairOnlyChange(method f, env e){     
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore != pairAfter <=> f.selector == createPair().selector, ""pair was changed by wrong method"";
}
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
9d36dccfaae4489a0a898875315b9f8c,115,rule,queuedStateConsistency,261,269,getCurrentState,"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	queue2(e, args);
	assert getCurrentState(e, id) == 0;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
9d6239cdf289a127b6fdad6ef12b76a7,1321 | 1322 | 1323 | 1324,rule,liquidityTokenValueMatchesClaims,188,216,getPresentValue | calculateOracleRate | getLiquidityTokenValue | getMarketValues,"rule liquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        false // non risk adjusted
    );
    mathint netfCash = (totalfCash * tokens) / (totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens) / (totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getLiquidityTokenValue (Lines 151-216),  | getMarketValues (Lines 37-55), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }
 |     function getMarketValues()
        external
        view
        returns (
            uint256 totalfCash,
            uint256 totalAssetCash,
            uint256 totalLiquidity,
            uint256 maturity
        )
    {
        require(symbolicMarket.totalfCash >= 0);
        require(symbolicMarket.totalAssetCash >= 0);
        require(symbolicMarket.totalLiquidity >= 0);

        totalfCash = uint256(symbolicMarket.totalfCash);
        totalAssetCash = uint256(symbolicMarket.totalAssetCash);
        totalLiquidity = uint256(symbolicMarket.totalLiquidity);
        maturity = symbolicMarket.maturity;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
9d680459dc689736399c2c1ef5252057,2457 | 2458,rule,cl_avax_alloc_fixed,622,634,allowEmergencyWithdraw | initialize,"rule cl_avax_alloc_fixed(method f, env e) {
    require pair() != 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    uint256 wavaxAllocatedBefore = avaxAllocated();
    calldataarg args;
    f(e, args);
    uint256 wavaxAllocatedAfter = avaxAllocated();
    assert wavaxAllocatedBefore == wavaxAllocatedAfter, ""not yet implemented"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
9da12aca901185910ac3e62fb248a5eb,270 | 271,rule,getClaimableRewards_stable_after_deposit,514,553,initialize | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_deposit()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    address user;
    address reward;
    
    uint256 assets;
    address recipient;
    uint16 referralCode;
    bool fromUnderlying = true;

    require user != 0;
    require getRewardTokensLength() == 1;
    require _RewardsController.getAvailableRewardsCount(_AToken)  > 0;
    require _RewardsController.getRewardsByAsset(_AToken, 0) == _DummyERC20_rewardToken;
    require currentContract != user;
    require _AToken != user;
    require _RewardsController !=  user;
    require _DummyERC20_aTokenUnderlying  != user;
    require _DummyERC20_rewardToken != user;
    require _SymbolicLendingPoolL1 != user;
    require _TransferStrategy != user;
    require _ScaledBalanceToken != user;
    //assume a single reward
    require reward == _DummyERC20_rewardToken;
    require getRewardToken(0) == _DummyERC20_rewardToken;
    //require isRegisteredRewardToken(reward); //todo: review the assumption
 
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    deposit(e, assets, recipient,referralCode,fromUnderlying);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | isRegisteredRewardToken (Lines 100-107), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
9e2a90db6c8efff8410d5314e955ae43,2311 | 2313 | 2314,rule,cannotFrontRunSplitDifferentUsers,532,582,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
9e33dbf51b6c45ae4362b637c7720d27,1690,rule,cannotCallExecute,184,194,isOperationReady,"rule cannotCallExecute(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    assert lastReverted, ""you go against execution nature"";
}
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
9e6cad8ea296e3dfc508d6ec1acb4954,2019 | 2020,invariant,also,303,441,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase3StartingWithAllCases(
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
9ea3ee073aebab9cfa9ed76fef7209eb,2504 | 2505,rule,hl_twoSideInverse,1218,1232,depositAVAX | withdrawAVAX,"rule hl_twoSideInverse(env e){
    uint256 amount;

    storage initialStorage = lastStorage;
    depositAVAX(e);
    withdrawAVAX(e, amount);
    uint256 balanceOfUser1 = getUserBalance(e.msg.sender);
    withdrawAVAX(e, amount) at initialStorage;
    uint256 balanceOfUser2 = getUserBalance(e.msg.sender);
    assert balanceOfUser1 == balanceOfUser2, ""balances are different"";
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
9ee564552c028dccb08431b2936866ef,1768 | 1769 | 1770 | 1771,rule,additiveAddCollateral,148,167,addShort | addLong | addCollateral | totalCollateral,"rule additiveAddCollateral(address asset, uint256 x, uint256 y, uint256 index)
{
		requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
    	require index < MAXINT(); // no violation when limiting index
    	require x > 0 && y > 0 ;
    	uint256 t = x + y ;
        require( t >= x && t >= y); //no overflow
        storage initialStorage = lastStorage;
    	invoke addCollateral(asset, x, index);
    	bool call1 = !lastReverted;
    	invoke addCollateral(asset, y, index);
    	bool call2 = !lastReverted;
    	uint256 collateralAmountScenario1 = totalCollateral();
    	invoke addCollateral(asset, t, index) at initialStorage;
    	bool call3 = !lastReverted;
    	uint256 collateralAmountScenario2 = totalCollateral();
    	assert (call1 && call2) <=> call3, ""addCollateral is not additive, one scenario reverts"" ;
    	assert call3 => collateralAmountScenario1 == collateralAmountScenario2, ""addCollateral is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
9f3f3b251f9be3f33c609ba44faaa108,678,rule,checks,310,333,previewWithdraw,"  The following rule checks that the value returned by the previewWithdraw depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewWithdraw_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewWithdraw(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewWithdraw(e2, assets);
    assert (previewShares1 == previewShares2);
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
9f9fd761bd55191d7ed838aed41e5af5,1304 | 1305 | 1306,invariant,calculateOracleRateIsBetweenOnChainRates,82,117,getPresentValue | calculateOracleRate | getMaturityAtMarketIndex,"invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )

// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getMaturityAtMarketIndex (Lines 21-27), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getMaturityAtMarketIndex(uint256 marketIndex, uint256 blockTime)
        external
        pure
        returns (uint256)
    {
        return DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
9fed64686c53b81b5adf2ab26146e30a,864 | 866 | 867 | 869,rule,can_add_to_queue,311,314,getUpvotedProposal | propose | upvote | getUpvoteRecord,"rule can_add_to_queue(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != propose(uint256[],address[],bytes,uint256[],string).selector
} {
","getUpvotedProposal (Lines 43-48),  | propose (Lines 467-485),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function propose(
    uint256[] calldata values,
    address[] calldata destinations,
    bytes calldata data,
    uint256[] calldata dataLengths,
    string calldata descriptionUrl
  ) external payable returns (uint256) {
    dequeueProposalsIfReady();
    require(msg.value >= minDeposit, ""Too small deposit"");

    proposalCount = proposalCount.add(1);
    Proposals.Proposal storage proposal = proposals[proposalCount];
    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);
    proposal.setDescriptionUrl(descriptionUrl);
    queue.push(proposalCount);
    // solhint-disable-next-line not-rely-on-time
    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);
    return proposalCount;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
a018c4072e128e5afeff827646d6ee58,1679 | 1680,rule,readyDoneTransition,106,116,execute | isOperationReady,"rule readyDoneTransition(method f, env e){
    bytes32 id;

    require isOperationReady(e, id);
    calldataarg args;
    f(e, args);
    assert isOperationDone(id) => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector , ""It's not isOperationDone yet!"";
}
","execute (Lines 96-104),  | isOperationReady (Lines 148-151), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
a02f160902ea2b8f5f1fd31d36969688,2350,rule,whoChangedBalanceOfUserId,326,362,_dripsState,"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHubBackup.spec,,Yes,
a1367d15c34a3471122a6ff788c7dbed,2236 | 2237 | 2238,rule,cyclesAdditivity,407,443,_receivableDrips | _receiveDrips | _receivableDripsCyclesRange,"rule cyclesAdditivity{
    env e1;
    env e2;
    address erc20;
    uint32 maxCycles;
    uint256 userId;
    uint256 assetId;
    uint32 from1;
    uint32 to1;
    uint32 from2;
    uint32 to2;

    require to_mathint(maxCycles) == 2^32-1;
    //require e2.block.timestamp > e1.block.timestamp;
    storage init = lastStorage;
    from1, to1 = _receivableDripsCyclesRange(e1, userId, assetId);
    from2, to2 = _receivableDripsCyclesRange(e2, userId, assetId);
    //require to1-from1 == 2;
    //require to2-from2 == 3;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < 4294967295;
    uint128 receivableAmt1; uint32 receivableCycles1;
    receivableAmt1, receivableCycles1 = _receivableDrips(e1, userId, assetId, maxCycles);
        _receiveDrips(e1, userId, assetId, maxCycles);
    uint128 receivableAmt2; uint32 receivableCycles2;
    receivableAmt2, receivableCycles2 = _receivableDrips(e2, userId, assetId, maxCycles);
    uint128 receivableAmt12; uint32 receivableCycles12;
    receivableAmt12, receivableCycles12 = _receivableDrips(e2, userId, assetId, maxCycles) at init;
    assert receivableAmt12 == receivableAmt1 + receivableAmt2;
    //assert false;
}
","_receivableDrips (Lines 224-236),  | _receiveDrips (Lines 247-276),  | _receivableDripsCyclesRange (Lines 337-346), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
 |     function _receiveDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    ) public virtual
        //internal
        returns (uint128 receivedAmt, uint32 receivableCycles) {
        uint32 fromCycle;
        uint32 toCycle;
        int128 finalAmtPerCycle;
        (
            receivedAmt,
            receivableCycles,
            fromCycle,
            toCycle,
            finalAmtPerCycle
        ) = _receivableDripsVerbose(userId, assetId, maxCycles);
        if (fromCycle != toCycle) {
            DripsState storage state = _dripsStorage().states[assetId][userId];
            state.nextReceivableCycle = toCycle;
            mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
            for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {
                delete amtDeltas[cycle];
            }
            // The next cycle delta must be relative to the last received cycle, which got zeroed.
            // In other words the next cycle delta must be an absolute value.
            if (finalAmtPerCycle != 0) amtDeltas[toCycle].thisCycle += finalAmtPerCycle;
        }
        emit ReceivedDrips(userId, assetId, receivedAmt, receivableCycles);
    }
 |     function _receivableDripsCyclesRange(uint256 userId, uint256 assetId)
        //private
        public
        view
        returns (uint32 fromCycle, uint32 toCycle)
    {
        fromCycle = _dripsStorage().states[assetId][userId].nextReceivableCycle;
        toCycle = _cycleOf(_currTimestamp());
        if (fromCycle == 0 || toCycle < fromCycle) toCycle = fromCycle;
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
a14efb5c31d183a49531a19fb24d01be,752 | 754,rule,address_can_authorize_two_addresses_legacy,96,120,authorizeSignerWithSignature | authorizeValidatorSigner,"rule address_can_authorize_two_addresses_legacy(address x, address d1, address d2)
rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
	authorizeValidatorSigner(e, d2, v2, r2, s2);  
	authorizeVoteSigner(e, d1, v1, r1, s1) at init;
","authorizeSignerWithSignature (Lines 407-417),  | authorizeValidatorSigner (Lines 461-470), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
 |   function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)
    external
    nonReentrant
  {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(!getValidators().isValidator(msg.sender), ""Cannot authorize validator signer"");
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
",./celo_governance/specs/accounts.spec,,Yes,
a16ef090685136f240e8ba864d1a5c94,2181,rule,checkBurnLiquidityShare,10,25,callBurnLiquidityShare,"rule checkBurnLiquidityShare(
        int24 tickLower,
        int24 tickUpper,
        uint256 share,
        address to){
    env e;
    require (share > 0 && share <= totalSupply());
    uint256 totalSupplyBefore = totalSupply();
    uint256 amount0;
    uint256 amount1;
    amount0, amount1 = callBurnLiquidityShare(e, tickLower, tickUpper, share, 
                       e.msg.sender);
    assert(totalSupply() == totalSupplyBefore);
    assert(!lastReverted);
    
}
","callBurnLiquidityShare (Lines 21-30), ","    function callBurnLiquidityShare(
        int24 tickLower,
        int24 tickUpper,       
        uint256 share,
        address to   
    ) external returns (uint256 amount0, uint256 amount1) {
        // uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);
        (amount0 , amount1) = PoolActions.burnLiquidityShare(pool, tickLower, tickUpper, 
                                  totalSupply, share, to, protocolLiquidity);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,,Yes,
a17ca2e8fe7297047b2c0484f1988b46,532,rule,getReserveNormalizedVariableDebtCheck,197,209,supply,"rule getReserveNormalizedVariableDebtCheck()
{
	env e1;
	calldataarg args;
	calldataarg args2;
    address asset; uint256 amount; address onBehalfOf; uint16 referralCode;
    require asset != _aToken;
	uint256 oldIndex = getReserveNormalizedVariableDebt(e1, args);
    uint256 totalDebtBefore = getCurrScaledVariableDebt(asset);
	supply(e1, asset, amount, onBehalfOf, referralCode);
	uint256 newIndex = getReserveNormalizedVariableDebt(e1, args);
	assert totalDebtBefore != 0 => newIndex >= oldIndex;
}
","supply (Lines 143-160), ","  function supply(
    address asset,
    uint256 amount,
    address onBehalfOf,
    uint16 referralCode
  ) public virtual override {
    SupplyLogic.executeSupply(
      _reserves,
      _reservesList,
      _usersConfig[onBehalfOf],
      DataTypes.ExecuteSupplyParams({
        asset: asset,
        amount: amount,
        onBehalfOf: onBehalfOf,
        referralCode: referralCode
      })
    );
  }
",./aave_v3/specs/pool.spec,,Yes,
a1e4a012a00628378b9f93ff4d57a76b,39 | 43,rule,expiredForever,242,260,processMessageFromRoot | getCurrentState,"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
a21117978d46dc8dc8c63bd0715b83ff,734 | 737,invariant,legacyRolesAreNotUsedInNewRoles,196,212,getOffchainStorageRoots | batchGetMetadataURL,"invariant legacyRolesAreNotUsedInNewRoles(address account, bytes32 role) 
	isLegacyRole(role) => _getDefaultSigner(account, role) == 0

/**
 * view functions in general should not revert.
 * Some exceptions and more refined revert-characteristics are provided.
 */
rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match
  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","getOffchainStorageRoots (Lines 299-324),  | batchGetMetadataURL (Lines 963-984), ","  function getOffchainStorageRoots(address account)
    external
    view
    returns (bytes memory, uint256[] memory)
  {
    require(isAccount(account), ""Unknown account"");
    uint256 numberRoots = offchainStorageRoots[account].length;
    uint256 totalLength = 0;
    for (uint256 i = 0; i < numberRoots; i++) {
      totalLength = totalLength.add(offchainStorageRoots[account][i].length);
    }

    bytes memory concatenated = new bytes(totalLength);
    uint256 lastIndex = 0;
    uint256[] memory lengths = new uint256[](numberRoots);
    for (uint256 i = 0; i < numberRoots; i++) {
      bytes storage root = offchainStorageRoots[account][i];
      lengths[i] = root.length;
      for (uint256 j = 0; j < lengths[i]; j++) {
        concatenated[lastIndex] = root[j];
        lastIndex++;
      }
    }

    return (concatenated, lengths);
  }
 |   function batchGetMetadataURL(address[] calldata accountsToQuery)
    external
    view
    returns (uint256[] memory, bytes memory)
  {
    uint256 totalSize = 0;
    uint256[] memory sizes = new uint256[](accountsToQuery.length);
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;
      totalSize = totalSize.add(sizes[i]);
    }

    bytes memory data = new bytes(totalSize);
    uint256 pointer = 0;
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {
        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];
        pointer = pointer.add(1);
      }
    }
    return (sizes, data);
  }
",./celo_governance/specs/accounts.spec,,Yes,
a276cd48dc01a16f30177141520a1a79,2500,rule,hl_withdrawAdditivity,1117,1135,withdrawAVAX,"rule hl_withdrawAdditivity(env e){
    uint256 single; uint256 doubleOne; uint256 doubleTwo;
    require single > 0 && doubleOne > 0 && doubleTwo > 0;
    require single == doubleOne + doubleTwo;

    uint256 userBalanceAtStart = getUserBalance(e.msg.sender);
    storage initialStorage = lastStorage;
    withdrawAVAX(e, single);
    uint256 userBalanceAfterSingle = getUserBalance(e.msg.sender);
    withdrawAVAX(e, doubleOne) at initialStorage;
    withdrawAVAX(e, doubleTwo);
    uint256 userBalanceAfterDouble = getUserBalance(e.msg.sender);
    assert userBalanceAfterSingle == userBalanceAfterDouble, ""withdraw is not additive"";
}
","withdrawAVAX (Lines 374-398), ","    function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
a33253c68f2bf1192bc92020f9ca8780,2336 | 2338 | 2339,rule,cannotFrontRunSplitTwoSameUsers,116,160,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,,Yes,
a332d69de9c1f8a97e19728ee6c513ff,2517,invariant,cl_wavaxNotZero,259,272,pairBalance,"// invariant cl_wavaxNotZero()
//     pair() != 0 => avaxAllocated() > 0

// STATUS - in progress (maybe add userHasWithdrawnPair(issuer()) => tokenReserve() == 0) - does => <=> make sense?
// run without preserved block: https://vaas-stg.certora.com/output/3106/b0f4853713af2301edcb/?anonymousKey=ea101ebc4801f04d91fddc5053dd7f37425a8089
// run with preserved block: 
// - hasWithdrawnPair and LP token balance of user are related
// invariant cl_hasWithdrawnPair_and_pairBalance_Correlation(env e, address user)
//     pair() != 0 => (userHasWithdrawnPair(user) <=> getPairBalance(user) == pairBalance(e, user))
//     {
//         preserved{
//             requireInvariant cl_wavaxNotZero();
//         }
//     }
","pairBalance (Lines 623-632), ","    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
a3703ae640746da96997492189676f24,2584 | 2585,rule,totalAssetsAfterFlashLoan,151,163,_tokenBalanceOf | flashLoan,"rule totalAssetsAfterFlashLoan(address token) {
	//link the strategy to the current token
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	//assume solvency safe assumption as we know that solvency is kept before and after flash loan
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
	require tokenBalanceOf(token) == totalTokenAmount(token);
	uint256 _systemBalance = tokenBalanceOfUser(token, currentContract);
	flashLoan(e, args);
	uint256 systemBalance_ = tokenBalanceOfUser(token, currentContract);
	assert  systemBalance_ >= _systemBalance, ""system lost assets due to flahs loan"";
","_tokenBalanceOf (Lines 762-764),  | flashLoan (Lines 53-58), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
 | 	function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) override public
	{
		require(harnessToken == token);
		require(harnessBorrower == borrower);
		super.flashLoan(borrower, receiver, token, amount, data );
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,,Yes,
a3d98dd4348ef5777d0e3f5e6dd2f55b,1536 | 1537 | 1538,rule,multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence,810,858,balanceOf | safeTransferFrom | safeBatchTransferFrom,"rule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfers = lastStorage;
    env e;

    address holder; address recipient; bytes data;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalanceA = balanceOf(holder, tokenA);
    mathint holderStartingBalanceB = balanceOf(holder, tokenB);
    mathint holderStartingBalanceC = balanceOf(holder, tokenC);
    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);
    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);
    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);
    require tokens.length == 3; require transferAmounts.length == 3;
    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;
    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;
    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;
    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);
    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);
    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;
    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA
        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB
        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC
        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA
        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB
        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, 
        ""Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
a4633ddc12f34477027e4dc3cdeba7a4,2409 | 2410,invariant,op_user_not_withdrawn_pair,358,379,createPair | allowEmergencyWithdraw,"invariant op_user_not_withdrawn_pair(address user)
    pair() == 0 => !userHasWithdrawnPair(user)

// STATUS - verified
// open implies user has not withdrawn
invariant op_user_not_withdrawn_incentives(address user)
    pair() == 0 => !userHasWithdrawnIncentives(user)
// STATUS - in progress
// run: https://vaas-stg.certora.com/output/3106/4287810baacbcf95e993/?anonymousKey=e85517e16f5d7a8c2f2d68cde1b47c6a618e1d00
// state after createPair() is out of the scope of open state
//  - `WAVAX.balanceOf(LaunchEvent)` ==  getUI[user].balance
invariant opWavaxBalanceAndSumBalances()
    pair() == 0 => getWAVAXbalanceOfThis() == sum_of_users_balances()
    {
        preserved{
            requireInvariant op_not_stopped();                      // double check
invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
            requireInvariant opWavaxBalanceAndWavaxReserve();
invariant opWavaxBalanceAndWavaxReserve()
    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()
            requireInvariant op_not_stopped();
        }
    }
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
a48f20eb4cbf175c9ee7e2b5548a032d,1310 | 1311 | 1312,rule,oracleRatesAreBlendedIntoTheRateWindow,79,117,getPresentValue | calculateOracleRate | getMaturityAtMarketIndex,"// rule oracleRatesAreBlendedIntoTheRateWindow will cover `getOracleRate`

// This should show that the oracle rate is the linear interpolation between two on chain rates.
invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )
// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getMaturityAtMarketIndex (Lines 21-27), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getMaturityAtMarketIndex(uint256 marketIndex, uint256 blockTime)
        external
        pure
        returns (uint256)
    {
        return DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
    }
",./notional_finance_v2/certora/asset/Valuation.spec,,Yes,
a5e8f016e661d23363a7190567c5cdf6,1516,rule,cantMintMoreBatch,534,553,balanceOf,"rule cantMintMoreBatch(env e){
    address to; bytes data;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require amounts.length == 3;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(to, id1) + amount1) > max_uint256 
                || to_mathint(balanceOf(to, id2) + amount2) > max_uint256
                || to_mathint(balanceOf(to, id3) + amount3) > max_uint256;
    mintBatch@withrevert(e, to, ids, amounts, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
a7e8e6f427f8c6efc0c7051d5652af41,310 | 311 | 314,rule,rewardsTotalDeclinesOnlyByClaim,140,162,initialize | claimRewardsOnBehalf | getTotalClaimableRewards,"rule rewardsTotalDeclinesOnlyByClaim(method f) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	require f.selector != initialize(address, address, string, string).selector;
	uint256 preTotal = getTotalClaimableRewards(e);
	uint256 preRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	calldataarg args;
	f(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	uint256 postRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	require preRewards == postRewards;
	assert (postTotal < preTotal) => (
		(f.selector == claimRewardsOnBehalf(address, address).selector) ||
		(f.selector == claimRewards(address).selector) ||
		(f.selector == claimRewardsToSelf().selector)
	), ""Total rewards decline not due to claim"";
}
","initialize (Lines 68-87),  | claimRewardsOnBehalf (Lines 280-291),  | getTotalClaimableRewards (Lines 320-337), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
 |   function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/rewardPreserve.spec,,Yes,
a84864f216889eba754fa9b5c7c0de37,2056 | 2057,rule,is,60,194,shortOtoken.havocTotalSupply | havocVault,"This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
a975822a0d441af4b0e6d85536c22de3,2448,invariant,cl_wavaxNotZero,902,915,pairBalance,"// invariant cl_wavaxNotZero()
//     pair() != 0 => avaxAllocated() > 0

// STATUS - in progress (maybe add userHasWithdrawnPair(issuer()) => tokenReserve() == 0) - does => <=> make sense?
// run without preserved block: https://vaas-stg.certora.com/output/3106/b0f4853713af2301edcb/?anonymousKey=ea101ebc4801f04d91fddc5053dd7f37425a8089
// run with preserved block: 
// - hasWithdrawnPair and LP token balance of user are related
// invariant cl_hasWithdrawnPair_and_pairBalance_Correlation(env e, address user)
//     pair() != 0 => (userHasWithdrawnPair(user) <=> getPairBalance(user) == pairBalance(e, user))
//     {
//         preserved{
//             requireInvariant cl_wavaxNotZero();
//         }
//     }
","pairBalance (Lines 623-632), ","    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
a9ad2fb52b9f699a195da63275d122d9,1688,rule,scheduleCheck,169,179,schedule,"rule scheduleCheck(method f, env e){
    bytes32 id;

    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert getTimestamp(id) == to_uint256(e.block.timestamp + delay), ""Time doesn't obey to mortal souls"";
}
","schedule (Lines 214-225), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
ab1031d11c6e0a924cfa4651646516d4,292,rule,sanity_metaDeposit,693,699,metaDeposit,"rule sanity_metaDeposit    ()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaDeposit(e,args);
","metaDeposit (Lines 121-179), ","  function metaDeposit(
    address depositor,
    address recipient,
    uint256 value,
    uint16 referralCode,
    bool fromUnderlying,
    uint256 deadline,
    PermitParams calldata permit,
    SignatureParams calldata sigParams
  ) external returns (uint256) {
    require(depositor != address(0), StaticATokenErrors.INVALID_DEPOSITOR);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[depositor];

    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METADEPOSIT_TYPEHASH,
              depositor,
              recipient,
              value,
              referralCode,
              fromUnderlying,
              nonce,
              deadline,
              permit
            )
          )
        )
      );
      nonces[depositor] = nonce + 1;
      require(
        depositor == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    // assume if deadline 0 no permit was supplied
    if (permit.deadline != 0) {
      IERC20WithPermit(
        fromUnderlying ? address(_aTokenUnderlying) : address(_aToken)
      ).permit(
          depositor,
          address(this),
          permit.value,
          permit.deadline,
          permit.v,
          permit.r,
          permit.s
        );
    }
    return _deposit(depositor, recipient, value, referralCode, fromUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
ab45c728ea5bd7fbe18def86689e2164,2031 | 2032,invariant,also,428,595,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
/** For put options before expiry (strong bound): 
  obligation(o)   (o.totalSupply() - storedBalance(o)) 
  The debt computation is also different 
rule callOptionsPreExpiry(
   // assume before expiry
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
ab89eb3e35ead76ae09cb2b2a7b562fb,1263 | 1264,rule,validChangeToBalanceOf,456,472,deposit | seizeBond,"rule validChangeToBalanceOf(address o, method f) {
    env e;
    calldataarg args;
    require (o != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 before = balanceOf(o);
    f(e, args);
    uint256 after = balanceOf(o);
    assert before == after ||
        // depositing case
        ( (f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           after == before - e.msg.value ) ||
        // withdrawing case
           ( ( f.selector==seizeBond(address,uint256,uint256,address).selector ||
                f.selector==withdraw(uint256,address).selector) &&
           after >= before );
","deposit (Lines 81-93),  | seizeBond (Lines 242-264), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
abc924047280f8e35bbce99504c76972,2316 | 2318 | 2319,rule,cannotFrontRunSplitTwoSameUsers,586,630,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
abeceada21c252327457f30484b20279,70,rule,onlyQueuedAreExecuted,476,490,execute,"rule onlyQueuedAreExecuted(bytes32 actionHash, uint256 actionsSetId)
{
	env e2; env e;
	calldataarg args;

	require isActionQueued(e, actionHash);
	// This is true in general, guardian is not a contract (is EOA).
	require getGuardian() != _mock(e);
		execute(e2, actionsSetId);
	bool queuedAfter = isActionQueued(e2, actionHash);
	
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1)) 
			<=> !queuedAfter;
}
","execute (Lines 82-107), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
acecab60d64251baad74aa2bfa76e154,1784 | 1785 | 1786 | 1787 | 1788,rule,inverseAddRemoveCollateral,176,183,addShort | addLong | addCollateral | removeCollateral | totalCollateral,"rule inverseAddRemoveCollateral(address asset, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	invoke removeCollateral(asset, x, index);
	assert !lastReverted && totalCollateral() == collateralBefore, ""removeCollateral is not inverse of addCollateral""; 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | removeCollateral (Lines 197-213),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |     function removeCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed collateral exists in the vault at the specified index
        require(_index < _vault.collateralAssets.length, ""V8"");
        require(_vault.collateralAssets[_index] == _collateralAsset, ""V9"");

        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);

        if (newCollateralAmount == 0) {
            delete _vault.collateralAssets[_index];
        }
        _vault.collateralAmounts[_index] = newCollateralAmount;
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
ad8bad6fa1a1b0d635e435c9e7681c24,414 | 415,rule,integrityBurn,207,243,"balanceOf, _underlyingAsset.balanceOf | burn","rule integrityBurn(address user, address to, uint256 amount)
{
	env e;
	uint256 indexRay = gRNI();

	require user != currentContract;
	uint256 balanceBeforeUser = balanceOf(user);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingBeforeUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingBeforeSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyBefore = totalSupply(e); 
	burn(e, user, to, amount, indexRay);
	
	uint256 balanceAfterUser = balanceOf(user);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingAfterUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingAfterSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyAfter = totalSupply(e);
	if (user != to) {
		assert balanceAfterTo == balanceBeforeTo && // balanceOf To should not change
		bounded_error_eq(underlyingBeforeUser, underlyingAfterUser, 1), ""integrity break on user!=to"";
	}
	if (to != currentContract) {
		assert bounded_error_eq(underlyingAfterSystem, underlyingBeforeSystem - amount, 1) && // system transfer underlying_asset
		bounded_error_eq(underlyingAfterTo,  underlyingBeforeTo + amount, 1) , ""integrity break on to!=currentContract"";
	} else {
		assert underlyingAfterSystem == underlyingBeforeSystem, ""integrity break on to==currentContract"";
	} 
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,,Yes,
ae2b1b890d73754684c90af39b339499,767 | 769 | 770 | 771,rule,cannotSetAuthorizedByWithoutSignatures,351,359,authorizeSignerWithSignature | authorizeValidatorSigner | authorizeValidatorSignerWithPublicKey | authorizeValidatorSignerWithKeys,"rule cannotSetAuthorizedByWithoutSignatures(method f) filtered { f -> 
	!f.isView 
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeAttestationSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSignerWithKeys(address,uint8,bytes32,bytes32,bytes,bytes,bytes).selector
		&& f.selector != authorizeValidatorSignerWithPublicKey(address,uint8,bytes32,bytes32,bytes).selector
		&& f.selector != authorizeVoteSigner(address,uint8,bytes32,bytes32).selector
} {
","authorizeSignerWithSignature (Lines 407-417),  | authorizeValidatorSigner (Lines 461-470),  | authorizeValidatorSignerWithPublicKey (Lines 481-496),  | authorizeValidatorSignerWithKeys (Lines 511-528), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
 |   function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)
    external
    nonReentrant
  {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(!getValidators().isValidator(msg.sender), ""Cannot authorize validator signer"");
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
 |   function authorizeValidatorSignerWithPublicKey(
    address signer,
    uint8 v,
    bytes32 r,
    bytes32 s,
    bytes calldata ecdsaPublicKey
  ) external nonReentrant {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(
      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),
      ""Failed to update ECDSA public key""
    );
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
 |   function authorizeValidatorSignerWithKeys(
    address signer,
    uint8 v,
    bytes32 r,
    bytes32 s,
    bytes calldata ecdsaPublicKey,
    bytes calldata blsPublicKey,
    bytes calldata blsPop
  ) external nonReentrant {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(
      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),
      ""Failed to update validator keys""
    );
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
",./celo_governance/specs/accounts.spec,,Yes,
ae39b0814b54f7c493aacca03342581d,241 | 242 | 243,rule,cannotCancelDepositAndGainBothTokens,252,287,deposit | startDepositCancellation | cancelDeposit,"rule cannotCancelDepositAndGainBothTokens(address user, uint256 amount) {
    env e1; env e2; env e3;
    calldataarg args1;
    address asset;
    address aToken;
    address static;
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    uint16 code;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    setupTokens(asset, aToken, static);
    setupUser(user);
    require user == e1.msg.sender;
    require user == e2.msg.sender;
    require user == e3.msg.sender;
    
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance1 = tokenBalanceOf(e1, static, user);
    uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
    uint256 ATokenBalance2 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance2 = tokenBalanceOf(e1, static, user);
    startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance3 = tokenBalanceOf(e3, aToken, user);
    uint256 staticBalance3 = tokenBalanceOf(e3, static, user);
    // If static tokens were minted, no deposit cancellation should succeed.
        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 
        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
    assert staticBalance2 > staticBalance1 => ATokenBalance3 == ATokenBalance2;
","deposit (Lines 74-140),  | startDepositCancellation (Lines 465-494),  | cancelDeposit (Lines 497-554), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
 |     function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
 |     function cancelDeposit(
        address l1AToken,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1AToken].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.cancelL1ToL2Message(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );

        address underlyingAsset = address(
            _aTokenData[l1AToken].underlyingAsset
        );
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        uint256 dynamicAmount = _staticToDynamicAmount(
            amount,
            underlyingAsset,
            lendingPool
        );

        //transfer aTokens back to depositor
        IERC20(l1AToken).safeTransfer(msg.sender, dynamicAmount);

        //claim any accrued rewards for the depositor during the cancellation period
        uint256 currentRewardsIndex = _getCurrentRewardsIndex(l1AToken);
        uint256 rewardsAmount = _computeRewardsDiff(
            amount,
            rewardsIndex,
            currentRewardsIndex
        );

        if (rewardsAmount > 0) {
            _transferRewards(msg.sender, rewardsAmount);
            emit RewardsTransferred(_l2Bridge, msg.sender, rewardsAmount);
        }

        emit CancelledDeposit(
            l2Recipient,
            msg.sender,
            rewardsIndex,
            blockNumber,
            dynamicAmount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
ae66ba09f0bdeb24cc5f1772fb961b05,707 | 710 | 711 | 713,rule,noChangeByOther,80,107,getPendingWithdrawalsLength | incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | slash,"rule noChangeByOther(address a, address b, method f) {
	require(a != b);
	// We assume the sender is not the currentContract
	require(
    a != currentContract &&
    (a == sinvoke getGoldTokenExt() => f.selector != withdraw(uint256).selector));
	uint256 _ercBalance = sinvoke ercBalanceOf(a);
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(a);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(a);
	// We limit the amount of pending records due to loop handling 
	uint length = sinvoke getPendingWithdrawalsLength(a);
	require(length <= 1);
	env eF;
	require(eF.msg.sender == b);
	calldataarg arg;
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	sinvoke f(eF,arg);
	uint256 ercBalance_ = sinvoke ercBalanceOf(a); 
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(a);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(a);
	assert(f.selector != withdraw(uint256).selector => _ercBalance == ercBalance_, ""Unexpected change to erc tokens"");
	assert(_accountTotalPendingWithdrawals == accountTotalPendingWithdrawals_, ""Unexpected change to total pending"");
	assert(_accountNonVoting == accountNonVoting_, ""Unexpected change to account nonvoting"");
}
","getPendingWithdrawalsLength (Lines 51-54),  | incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | slash (Lines 74-84), ","  function getPendingWithdrawalsLength(address account) external view returns (uint256) {
    uint256 length = balances[account].pendingWithdrawals.length;
    return length;
  }
 |   function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,,Yes,
ae6964f2084610ed6f2a9f00082c39a5,1391 | 1392,rule,getAndSetAccountContext,9,24,setAccountContext | getNextSettleTime,"rule getAndSetAccountContext(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    assert getNextSettleTime(account) == nextSettleTime, ""next settle time does not match"";
    assert getHasDebt(account) == hasDebt, ""has debt does not match"";
    assert getAssetArrayLength(account) == assetArrayLength, ""asset array length does not match"";
    assert getBitmapCurrency(account) == bitmapCurrencyId, ""bitmap currency id does not match"";
    assert getActiveCurrencies(account) == activeCurrencies, ""active currencies does not match"";
}
","setAccountContext (Lines 35-49),  | getNextSettleTime (Lines 393-396), ","    function setAccountContext(AccountContext memory accountContext, address account) internal {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data =
            (bytes32(uint256(accountContext.nextSettleTime)) |
                (bytes32(accountContext.hasDebt) >> 208) |
                (bytes32(uint256(accountContext.assetArrayLength)) << 48) |
                (bytes32(uint256(accountContext.bitmapCurrencyId)) << 56) |
                (bytes32(accountContext.activeCurrencies) >> 40));

        assembly {
            sstore(slot, data)
        }

        emit AccountContextUpdate(account);
    }
 |     function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {
        if (nToken.lastInitializedTime == 0) return 0;
        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;
    }
",./notional_finance_v2/certora/accountContext/SetAccountContext.spec,,Yes,
ae94560add7fa0d990dce0ccd9050ce5,1900 | 1907 | 1908 | 1909,rule,validState,72,99,smallVault | depositLongB | redeemA | redeemB,"rule validState(address owner, uint256 vaultId, uint256 index,  method f) 
{
    links();
    /* TODO: Redeem */
    require f.selector != redeemA(address,uint256).selector && f.selector != redeemB(address,uint256).selector;
    /* TODO: depositLongB */
    require f.selector != depositLongB(address,uint256,address,uint256,uint256).selector;
    
    require smallVault(owner, vaultId, 1);
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index) &&
            longOtoken == getVaultLongOtoken(owner, vaultId, index) &&
            collateralToken == getVaultCollateralAsset(owner, vaultId, index) 
    ;
    require assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
            assetTotalSupply(longOtoken) >= pool.getStoredBalance(longOtoken) &&
            pool.getStoredBalance(longOtoken) >= getVaultLongAmount(owner, vaultId, index) &&
            pool.getStoredBalance(collateralToken) >= getVaultCollateralAmount(owner, vaultId, index) 
    callFunctionWithParameters(f, owner, vaultId, index);
    assert  assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
}
","smallVault (Lines 53-66),  | depositLongB (Lines 176-192),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositLongB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
ae9d09f4d37924594efc02762da0657e,1702,rule,scheduleChange,284,295,schedule,"rule scheduleChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","schedule (Lines 214-225), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
aea963cd56662073269f495fd54b0b69,2429 | 2430 | 2431 | 2432 | 2433,invariant,cl_pair_bal_eq_lp_sum,501,510,withdrawIncentives | emergencyWithdraw | allowEmergencyWithdraw | skim | initialize,"invariant cl_pair_bal_eq_lp_sum()
    pair() != 0 => (getPairBalanceOfThis() == lpSupply() / 2 + unwithdrawn_users_lp_tokens)
    {
        preserved with (env e2){
            requireInvariant cl_not_stopped();                          // emergencyWithdraw() and skim()
            requireInvariant pairAndGetPairCorrelation(e2);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
            requireInvariant opPairBalanceIsZero();
            require token() == SymbERC20A || token() == SymbERC20B;     // withdrawIncentives()
","withdrawIncentives (Lines 473-491),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | skim (Lines 554-569),  | initialize (Lines 28-35), ","    function withdrawIncentives() external {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        uint256 amount = getIncentives(msg.sender);
        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        UserInfo storage user = getUserInfo[msg.sender];
        user.hasWithdrawnIncentives = true;

        if (msg.sender == issuer) {
            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;
            tokenReserve = 0;
        } else {
            tokenIncentivesBalance -= amount;
        }

        token.safeTransfer(msg.sender, amount);
        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function skim() external {
        require(msg.sender == tx.origin, ""LaunchEvent: EOA only"");
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.safeTransfer(penaltyCollector, excessToken);
        }

        uint256 excessAvax = address(this).balance - avaxReserve;
        if (excessAvax > 0) {
            _safeTransferAVAX(penaltyCollector, excessAvax);
        }
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
aee6dd6613f4b2497488f412dc63cc89,285 | 286 | 287,rule,getClaimableRewards_stable_after_refreshRewardTokens,638,653,initialize | refreshRewardTokens | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_refreshRewardTokens()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{

    env e;
    address user;
    address reward;
    //require isRegisteredRewardToken(reward); //todo: review assumption
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    refreshRewardTokens(e);
    setup(e, user);    
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | refreshRewardTokens (Lines 90-97),  | isRegisteredRewardToken (Lines 100-107), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function refreshRewardTokens() public override {
    address[] memory rewards = INCENTIVES_CONTROLLER.getRewardsByAsset(
      address(_aToken)
    );
    for (uint256 i = 0; i < rewards.length; i++) {
      _registerRewardToken(rewards[i]);
    }
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
af6f5f4c1aa4455b6f2bd6e791053c3d,2394,rule,updatePool_contained,400,408,updatePool,"rule updatePool_contained() {
    env e;
    address user;
    uint256 balance_pre = userJoeStaked(user);
    uint256 reward_debt_pre = userRewardDebt(user);
    updatePool(e);
    assert userJoeStaked(user) == balance_pre, ""balance changed"";
    assert userRewardDebt(user) == reward_debt_pre, ""reward debt changed"";
}
","updatePool (Lines 179-194), ","    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
af7615173d6ea017a6b7af4deba2efb6,2449 | 2450,invariant,hl_EqualityOfPairs,1049,1072,allowEmergencyWithdraw | initialize,"invariant hl_EqualityOfPairs()
    getPairBalanceOfThis() == getPairBalance(issuer()) + sumOfPairBalances()

// STATUS - in progress
// run without preserved block: https://vaas-stg.certora.com/output/3106/1f91c36ac4e4424e389f/?anonymousKey=c30c7ee9fd1cb8fe7198145cf50a5e0959f623e4
// run with preserved block: 
invariant hl_EqualityOfPairAndTotalSupply()
    getPairBalanceOfThis() == getPairTotalSupplyOfThis()
// run without preserved block: https://vaas-stg.certora.com/output/3106/23f2a4a600d0a020f0cb/?anonymousKey=d1d4fef9e201e201fd039a0dd0ddc1ea5306c9d7
// run with preserved block: https://vaas-stg.certora.com/output/3106/9a888396ade18f00c01a/?anonymousKey=a7cdb01cf4b007d42ee8c2eb885757bfeebef6e6
invariant hl_TotalSupplyEquality()
    getPairTotalSupply() == getPairTotalSupplyOfThis()
    {
        preserved with (env e2){
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
        }
    }
            // requireInvariant factoryGetPairCorrelationNewVals(e2);
            requireInvariant pairAndGetPairCorrelation(e2);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
            require Weth != currentContract;
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
afbd308dc3c9d44c53f17f445a773d78,2273,rule,splittableOfNonReceiverNotAffectedByGive,100,111,give,"rule splittableOfNonReceiverNotAffectedByGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint256 otherUser; uint128 splittableBefore; uint128 splittableAfter;

    require otherUser != receiver;
    splittableBefore = splittable(e, otherUser, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, otherUser, assetId);
    assert splittableAfter == splittableBefore;
}
","give (Lines 65-72), ","    function give(
        uint256 receiver,
        IERC20 erc20,
        uint128 amt
    ) public {
        _transferFromCaller(erc20, amt);
        dripsHub.give(calcUserId(msg.sender), receiver, erc20, amt);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
b0e41ef501d105d2e7828e8fe401d389,2405,invariant,isInitialized,260,272,allowEmergencyWithdraw,"invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
    {
        preserved{
            requireInvariant notStoppedIfNonInitialized();
        }
    }
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
b1168d031e73b3941c3651960d521fa5,2373 | 2374 | 2375,rule,userInfo_amount_safe_mutate,141,152,emergencyWithdraw | deposit | withdraw,"rule userInfo_amount_safe_mutate(method f) {
    env e; calldataarg args;
    address user;
    uint256 userBalance_pre = userJoeStaked(user);
    f(e, args);
    uint256 userBalance_post = userJoeStaked(user);
    assert userBalance_pre != userBalance_post => f.selector == deposit(uint256).selector ||
                                            f.selector == withdraw(uint256).selector ||
                                            f.selector == emergencyWithdraw().selector, ""improper function mutated user balance"";
    assert userBalance_pre != userBalance_post => e.msg.sender == user, ""non-user mutated balance"";

}
","emergencyWithdraw (Lines 154-164),  | deposit (Lines 106-126),  | withdraw (Lines 130-151), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
 |     function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount -= _amount;
        totalJoeStaked -= _amount;

        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        if (pending > 0) _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
b174800f92d62fa67f582c738e21f3a8,500 | 501 | 502 | 504 | 506,rule,IntegrityOfisUsingAsCollateralOrBorrowing,74,79,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"// rule IntegrityOfisUsingAsCollateralOrBorrowing(uint256 reserveIndex, bool borrowing, bool usingAsCollateral){
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// 	bool reserveBorrowing =  isBorrowing(reserveIndex);
// 	bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert ((reserveBorrowing || reserveCollateral) <=> borrowingOrCollateral);
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
b1f5b3ed12104f84713e6c4573472c99,2360 | 2361,rule,totalMoneyIsConstant,84,116,deposit | withdraw,"rule totalMoneyIsConstant(method f) {
    env e; // env eB; env eF;
    calldataarg args;

    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 balanceOfUserBefore;    uint256 balanceOfUserAfter;
    uint256 balanceOfReserveBefore; uint256 balanceOfReserveAfter;
    uint256 depositedBefore;        uint256 depositedAfter;
    balanceOfUserBefore = dummyERC20Token.balanceOf(user);
    balanceOfReserveBefore = dummyERC20Token.balanceOf(reserveH);
    depositedBefore = getDeposited(dummyERC20Token);
    require depositedBefore == balanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(dummyERC20Token) == 0;
    deposit(e, dummyERC20Token, user, amtDeposited);
    //f(e,args);
    withdraw(e, dummyERC20Token, user, amtWithdrawn);
    require amtDeposited == amtWithdrawn;
    balanceOfUserAfter = dummyERC20Token.balanceOf(user);
    balanceOfReserveAfter = dummyERC20Token.balanceOf(reserveH);
    depositedAfter = getDeposited(dummyERC20Token);
    assert balanceOfUserBefore == balanceOfUserAfter;
    //assert balanceOfUserBefore + balanceOfReserveBefore == balanceOfUserAfter + balanceOfReserveAfter;
    //assert depositedAfter == depositedBefore + amtDeposited - amtWithdrawn;
}
","deposit (Lines 171-182),  | withdraw (Lines 191-203), ","    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }
 |     function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }
",./radicle_drips/specs/Reserve.spec,,Yes,
b202b77779ae58a4578fda0cdbce1ccd,1491 | 1492,rule,transferBatchCorrectness,182,221,balanceOf | safeBatchTransferFrom,"rule transferBatchCorrectness(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    require to != from;
    require idToCheck1 != idToCheck2 && idToCheck3 != idToCheck2 && idToCheck1 != idToCheck3;
    
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    uint256 fromBalanceBefore1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceBefore2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceBefore3 = balanceOf(from, idToCheck3);
    uint256 toBalanceBefore1 = balanceOf(to, idToCheck1);
    uint256 toBalanceBefore2 = balanceOf(to, idToCheck2);
    uint256 toBalanceBefore3 = balanceOf(to, idToCheck3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 fromBalanceAfter1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceAfter2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceAfter3 = balanceOf(from, idToCheck3);
    uint256 toBalanceAfter1 = balanceOf(to, idToCheck1);
    uint256 toBalanceAfter2 = balanceOf(to, idToCheck2);
    uint256 toBalanceAfter3 = balanceOf(to, idToCheck3);
    assert (fromBalanceBefore1 == fromBalanceAfter1 + amountToCheck1)
                && (fromBalanceBefore2 == fromBalanceAfter2 + amountToCheck2)
                && (fromBalanceBefore3 == fromBalanceAfter3 + amountToCheck3), ""Something wet wrong"";
    assert (toBalanceBefore1 == toBalanceAfter1 - amountToCheck1)
                && (toBalanceBefore2 == toBalanceAfter2 - amountToCheck2)
                && (toBalanceBefore3 == toBalanceAfter3 - amountToCheck3), ""Something wet wrong"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
b36df21463e0bf49d73ba2ced5b29209,351 | 353,rule,integrityMint,106,116,balanceOf | mint,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e,a);
	sinvoke mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = sinvoke balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/StableDebtToken.spec,,Yes,
b3939dee3c4960f4083fbd98d5e872f2,1351 | 1352,rule,impliedRatesDoNotChangeOnAddLiquidity,162,193,addLiquidity | getStoredOracleRate,"rule impliedRatesDoNotChangeOnAddLiquidity(
    int256 cashAmount
) {
    env e;
    require cashAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    int256 liquidityTokens;
    int256 fCashToAccount;
    liquidityTokens, fCashToAccount = addLiquidity(e, cashAmount);
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
   assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    // assert getLastImpliedRate() == lastImpliedRate, ""last trade rate did update"";
    // assert to_mathint(marketAssetCashBefore) + to_mathint(cashAmount) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    // assert to_mathint(liquidityTokens) + to_mathint(marketLiquidityBefore) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    // assert getPreviousTradeTime() == previousTradeTime, ""previous trade time did update "";
}
","addLiquidity (Lines 34-53),  | getStoredOracleRate (Lines 56-75), ","    function addLiquidity(MarketParameters storage market, int256 assetCash)
        internal
        returns (int256, int256)
    {
        require(market.totalLiquidity > 0, ""M: zero liquidity"");
        if (assetCash == 0) return (0, 0);
        require(assetCash > 0); // dev: negative asset cash

        int256 liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);
        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.
        int256 fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);

        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);
        market.totalfCash = market.totalfCash.add(fCash);
        market.totalAssetCash = market.totalAssetCash.add(assetCash);
        market.storageState = updateLiquidity(market.storageState);
        // market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (liquidityTokens, fCash.neg());
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
b3a846592b121beff19f973c9e12938b,2269,rule,integrityOfCollect,60,68,collect,"rule integrityOfCollect() {
    env e; uint256 userId; uint256 assetId;
    uint128 collectedAmt; uint128 collectableAfter;

    collectedAmt = collect(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert collectableAfter == 0;
}
","collect (Lines 54-57), ","    function collect(address user, IERC20 erc20) public returns (uint128 amt) {
        amt = dripsHub.collect(calcUserId(user), erc20);
        erc20.safeTransfer(user, amt);
    }
",./radicle_drips/specs/Splits.spec,,Yes,
b3b32f531413543467eff6933814b06d,2520,rule,op_allocationChangeByDeposit,88,99,depositAVAX,"rule op_allocationChangeByDeposit(method f, env e){
    address user;

    uint256 allocationBefore = getUserAllocation(user);
    calldataarg args;
    f(e, args);
    uint256 allocationAfter = getUserAllocation(user);
    assert allocationBefore != allocationAfter => (f.selector == depositAVAX().selector && e.msg.sender == user), ""allocation was changed by wrong method"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
b3b55edaa1db879e83c221173a43288b,1358 | 1359,rule,impliedRatesDoNotChangeOnRemoveLiquidity,195,231,removeLiquidity | getStoredOracleRate,"rule impliedRatesDoNotChangeOnRemoveLiquidity(
    int256 tokenAmount
) {
    env e;
    require tokenAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    require marketLiquidityBefore >= tokenAmount;
    int256 assetCash;
    int256 fCashToAccount;
    assetCash, fCashToAccount = removeLiquidity(e, tokenAmount);
    require fCashToAccount != 0;
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
    uint256 previousTradeTimeAfter = getPreviousTradeTime();
    uint256 lastImpliedRateAfter = getLastImpliedRate();
    assert to_mathint(marketAssetCashBefore) - to_mathint(assetCash) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    assert to_mathint(marketLiquidityBefore) - to_mathint(tokenAmount) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    assert previousTradeTimeAfter == previousTradeTime, ""previous trade time did update"";
    assert lastImpliedRateAfter == lastImpliedRate, ""last trade rate did update"";
}
","removeLiquidity (Lines 57-74),  | getStoredOracleRate (Lines 56-75), ","    function removeLiquidity(MarketParameters storage market, int256 tokensToRemove)
        internal
        returns (int256, int256)
    {
        if (tokensToRemove == 0) return (0, 0);
        require(tokensToRemove > 0); // dev: negative tokens to remove

        int256 assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);
        int256 fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);

        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);
        market.totalfCash = market.totalfCash.subNoNeg(fCash);
        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);
        market.storageState = updateLiquidity(market.storageState);
        // market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (assetCash, fCash);
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
b3c244bdda23c1dbf83c2a347616e708,283,rule,getClaimableRewards_stable,601,607,initialize,"/// @title special case of rule getClaimableRewards_stable for initialize
//fail
//todo: consider removing this rule. no method is called before initialize()
/// @title getClaimableRewards() is stable after initialize()
/// @dev case splitting
rule getClaimableRewards_stable_after_initialize(method f)
    filtered { f -> !f.isView && !claimFunctions(f) }{
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
b43462f78bde0ba058338012c96e3196,2446 | 2447,invariant,but,597,610,currentPhase | depositAVAX,"// was listed as an invariant but makes more sense as a parametric rule
//   - getUA[user].allocation is unchanging
rule cl_user_alloc_unchanging(address user, method f, env e) {
    require currentPhase(e) == PhaseThree(); // depositAVAX()

    uint256 userAllocationBefore = getUserAllocation(user);
    calldataarg args;
    f(e, args);
    uint256 userAllocationAfter = getUserAllocation(user);
    assert userAllocationBefore == userAllocationAfter, ""tokenReserve was changed"";
}
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
b4e82776f62a6eed7f2a204a2423decb,534,rule,withdrawCheck,213,225,withdraw,"// rule withdrawCheck()
// {
// 	env e;
// 	address to;
// 	address asset;
// 	uint256 part1;
// 	uint256 part2;
// 	storage init = lastStorage;
// 	withdraw(e, asset, part1, to);
// 	withdraw(e, asset, part2, to);
// 	withdraw@withrevert(e, asset, part1 + part2, to) at init;
// 	assert !lastReverted;
// }
","withdraw (Lines 196-216), ","  function withdraw(
    address asset,
    uint256 amount,
    address to
  ) public virtual override returns (uint256) {
    return
      SupplyLogic.executeWithdraw(
        _reserves,
        _reservesList,
        _eModeCategories,
        _usersConfig[msg.sender],
        DataTypes.ExecuteWithdrawParams({
          asset: asset,
          amount: amount,
          to: to,
          reservesCount: _reservesCount,
          oracle: ADDRESSES_PROVIDER.getPriceOracle(),
          userEModeCategory: _usersEModeCategory[msg.sender]
        })
      );
  }
",./aave_v3/specs/pool.spec,,Yes,
b4f1b383da25135a485fc293d7d278aa,575,invariant,principalLessThanBalance,130,132,balanceOf,"invariant principalLessThanBalance(env e, address user)
    principalBalanceOf(e, user) <= balanceOf(e, user)
    filtered { f -> !disAllowedFunctions(f) }
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
b50baaae649904fc8c2aec1fda30bde8,237,rule,initializeIntegrity,191,206,initialize,"rule initializeIntegrity(address AToken, address asset)
{
    env e;
    calldataarg args;

    // Post-constructor conditions
    require getUnderlyingAssetHelper(AToken) == 0;
    require getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == 0;
    
    initialize(e, args);
    assert (asset !=0 && AToken !=0) => (
        getUnderlyingAssetHelper(AToken) == asset 
        <=>
        getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == AToken);
}
","initialize (Lines 53-71), ","    function initialize(
        uint256 l2Bridge,
        address messagingContract,
        address incentivesController,
        address[] calldata l1Tokens,
        uint256[] calldata l2Tokens,
        uint256[] calldata ceilings
    ) external virtual onlyValidL2Address(l2Bridge) initializer {
        require(
            address(incentivesController) != address(0),
            Errors.B_INVALID_INCENTIVES_CONTROLLER_ADDRESS
        );
        _messagingContract = IStarknetMessaging(messagingContract);
        _l2Bridge = l2Bridge;
        _incentivesController = IAaveIncentivesController(incentivesController);
        _rewardToken = IERC20(_incentivesController.REWARD_TOKEN());

        _approveBridgeTokens(l1Tokens, l2Tokens, ceilings);
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
b5b7950b2cb46d3bf99714a167fe18b5,447 | 448 | 449 | 451 | 453,invariant,integrityOfisUsingAsCollateralAny,103,111,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()

// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
b625a597ec38859d4d6517a24b574beb,687 | 688,rule,checks,386,410,previewWithdraw | previewRedeem,"  The following rule checks that the value returned by the previewRedeem depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewRedeem_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewRedeem(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewRedeem(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
","previewWithdraw (Lines 393-396),  | previewRedeem (Lines 399-402), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function previewRedeem(uint256 shares) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToAssets(shares, MathUpgradeable.Rounding.Down).min(maxWithdrawable);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
b627e8103af6b181da693b2ec33b159a,1995 | 1997,rule,inverse,156,185,isValidVault | depositLongA,"// rule inverse (address owner, uint256 vaultId, address from, uint256 index, uint256 amount) { 
//     require(isValidVault(owner, vaultId));

//     storage initialStorage = lastStorage;
//     env e1; 
//     calldataarg arg1;
//     sinvoke f1(e1, arg1);
//     env e2;
//     calldataarg arg2;
//     sinvoke f2(e2, arg2);
//     function depositLongA(
//     address owner,
//     uint256 vaultId,
//     address from,
//     uint256 index,
//     uint256 amount
//   ) 
    
//     uint256 vaultCollateralAmount1 = getVaultCollateralAmount(owner, vaultId,0);
//     sinvoke f2(e2, arg2) at initialStorage;
//     sinvoke f2(e1, arg1);
//     uint256 vaultCollateralAmount2 = getVaultCollateralAmount(owner, vaultId,0);
//     assert vaultCollateralAmount1 == vaultCollateralAmount1;
//     // run first method and then second method and store the result 
//     // run the second method then first method and compare result 
// }
","isValidVault (Lines 79-88),  | depositLongA (Lines 158-174), ","  function isValidVault(address owner, uint256 vaultId) external view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    (, bool isValidVault) = calculator.getExcessCollateral(
      _vault.shortAmounts[0],
      _vault.longAmounts[0],
      _vault.collateralAmounts[0],
      vaultType[owner][vaultId]
    );
    return isValidVault;
  }
 |   function depositLongA(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenA,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
",./opyn_gamma_protocol/specs/controller.spec,,Yes,
b6c33512f326ede7ddae2b5db483d687,1595 | 1597 | 1598,rule,delegates_safe,165,167,delegate | delegateBySig | _delegate,"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
","delegate (Lines 95-98),  | delegateBySig (Lines 103-120),  | _delegate (Lines 127-133), ","    function delegate(address delegatee) public virtual override {
        address account = _msgSender();
        _delegate(account, delegatee);
    }
 |     function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= expiry, ""Votes: signature expired"");
        address signer = ECDSA.recover(
            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),
            v,
            r,
            s
        );
        require(nonce == _useNonce(signer), ""Votes: invalid nonce"");
        _delegate(signer, delegatee);
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,,Yes,
b6cc5e5592d5468e238c37b8cc5c5f5e,937,rule,approvedTokensAreTemporary,493,504,summaryInstance.getEthAddress,"rule approvedTokensAreTemporary(method f, address someAllowed) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
","getEthAddress (Lines 30-39), ","    function getEthAddress(address handler) external returns (address) {
        // either the handler defines a ETH_ADDRESS function or it does not. If it does not then just return address(0)
        address eth = address(0);
        try WithEthAddress(handler).ETH_ADDRESS() returns (address x) {
            eth = x;
        } catch {
            eth = address(0);
        }
        return eth;
    }
",./furucombo/specs/proxy.spec,,Yes,
b6fa1373095e549fac0067c5d3144d3c,683,rule,to,345,379,previewRedeem,"// rule to check the following for the previewRedeem function:
// 1. MUST return as CLOSE to and no more than the exact amount of assets that would be
//    withdrawn in a redeem call in the same transaction.
// I.e. redeem should return the same or more assets as previewRedeem if called in the
// same transaction.

// STATUS: pass
// The amount returned by previewRedeem is exactly equal to that returned by the redeem function.
rule previewRedeem_amount_check(env e1, env e2){
    uint256 shares;
    address receiver;
    address owner;
    uint256 previewAssets;
    uint256 assets;
    
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require (getFee() <= SCALE());  // SCALE is 10^18
    previewAssets = previewRedeem(e1, shares);
    require (shares <= convertToShares(e2,maxAssetsWithdrawableFromAave()) =>
                     convertToAssets(e2,shares) <= maxAssetsWithdrawableFromAave());
    assets = redeem(e2, shares, receiver, owner);
    assert previewAssets == assets 
        || previewAssets + 1 == assets
        //        || previewAssets + 2 == assets        
        ,""preview should the same as the actual assets received"";
}
","previewRedeem (Lines 399-402), ","    function previewRedeem(uint256 shares) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToAssets(shares, MathUpgradeable.Rounding.Down).min(maxWithdrawable);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
b83a4d1b5304b0bec228d2b8bf703b31,2114,rule,mathOfChangeSupply,24,35,divPrecisely,"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= MAX_SUPPLY();
}
","divPrecisely (Lines 102-111), ","    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
",./ousd/spec/math.spec,,Yes,
b8f3cd8c54fcd2be6a0f2d9758ce2daf,516 | 517,rule,integrityOfisBorrowingAny,118,122,isBorrowing | isBorrowingAny,"// rule integrityOfisBorrowingAny(uint256 reserveIndex){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
// }
","isBorrowing (Lines 87-95),  | isBorrowingAny (Lines 153-155), ","  function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
b9bc2e6436f7b1ef85f6029f9bf75a64,2523,rule,tr_initializedOnlyChange,194,204,initialize,"rule tr_initializedOnlyChange(method f){     
    uint256 initBefore = auctionStart();

    env e;
    calldataarg args;
    f(e, args);
    uint256 initAfter = auctionStart();
    assert initBefore != initAfter <=> (initBefore == 0 && f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector), ""initialized was changed by wrong method"";
}
","initialize (Lines 28-35), ","    function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
ba180b05fda6c7f8a377eb5a012621c7,416 | 417,rule,additiveBurn,249,266,balanceOf | burn,"rule additiveBurn(address user1, address user2, address to1, address to2, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require (user1 != user2 && to1 != to2 && user1 != to2 && user2 != to1 && 
	        (user1 == to1 <=> user2 == to2) &&
			 balanceOf(user1) == balanceOf(user2) && balanceOf(to1) == balanceOf(to2));
	require user1 != currentContract && user2 != currentContract;

	sinvoke burn(e, user1, to1, x, indexRay);
	sinvoke burn(e, user1, to1, y, indexRay);
	uint256 balanceUserScenario1 = balanceOf(user1);
	
	sinvoke burn(e, user2, to2, x+y, indexRay);
	uint256 balanceUserScenario2 = balanceOf(user2);
	assert 	bounded_error_eq(balanceUserScenario1, balanceUserScenario2, 3), ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,,Yes,
ba6091245295a0bbb3fcedc47372c0bf,1024,rule,times,162,183,updateDiscountDistribution,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
bac57955ecb800bfe75fc177616b4b39,1967 | 1968,rule,settleVault,52,72,settleVault | getProceed,"rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,,Yes,
bb50a156cf13a8276faff05171a8c44f,2352 | 2353 | 2354,rule,singleUserTimeUpdateNotChangingOtherUserBalance,392,490,"DH.create, create | _dripsState | _updateReceiverStates","rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
    env e; env eB; env eF;
    calldataarg args;

    // uint8 i;
    // userId1 and userId2 - receivers Id
    uint256 assetId; uint256 userId1; uint256 userId2;
    require userId != userId1; // != userId2;
    require userId1 < userId2; // sorted
    require userId != userId2;
    // step 1 - balance before of user2
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
    // assert false; // false 0
    // step 2 - setup user1 changes and then call _updateReceiverStates()
    /*  //setting values to config by create:
        uint192 _amtPerSec;
        uint32 _start;
        uint32 _duration;
    require _amtPerSec != 0;
    */
    DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
    DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
    DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
   // DH.DripsConfig configNew2;
    require configOld1 != configNew1;
    // require configOld2 == configNew2;
    DH.DripsReceiver receiverOld1;
    require receiverOld1.userId == userId1;
    require receiverOld1.config == configOld1;
    DH.DripsReceiver receiverOld2;
    require receiverOld2.userId == userId2;
    require receiverOld2.config == configOld2;
    DH.DripsReceiver receiverNew1;
    require receiverNew1.userId == userId1;
    require receiverNew1.config == configNew1;
    // DripsReceiver[] memory currReceivers;
    // DripsReceiver[] memory newReceivers;
    // currReceivers[i].userId = userId1;
    // currReceivers[i].config = configCurr;
    // require sorted
    // require no duplicate
    // require amtPerSec != 0
    // require(i < _MAX_DRIPS_RECEIVERS,"""");
    // require currReceivers == newReceivers;
    // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
    // DripsState storage state = _dripsStorage().states[assetId][userId];
    // uint32 lastUpdate = state.updateTime;
    // uint32 currMaxEnd = state.maxEnd;
    // uint32 newMaxEnd = sizeof(uint32);
    // assert false;  // false 1
     //assert configOld2 != configNew2;  //returned 0
    _helperUpdateReceiverStates( e,
            receiverOld1,
            receiverOld2,
            receiverNew1,
            assetId,
            userId
        );
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
    assert false;
}
","create (Lines 59-68),  | _dripsState (Lines 509-529),  | _updateReceiverStates (Lines 818-1089), ","    function create(
        uint192 _amtPerSec,
        uint32 _start,
        uint32 _duration
    ) internal pure returns (DripsConfig) {
        uint256 config = _amtPerSec;
        config = (config << 32) | _start;
        config = (config << 32) | _duration;
        return DripsConfig.wrap(config);
    }
 |     function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
 |     function _updateReceiverStates(
        mapping(uint256 => DripsState) storage states,
        DripsReceiver[] memory currReceivers,
        uint32 lastUpdate,
        uint32 currMaxEnd,
        DripsReceiver[] memory newReceivers,
        uint32 newMaxEnd
    //) private {
    ) internal virtual {
        //return;
        //require(currReceivers.length == 1, ""Attempt to reduce computation"");
        //require(newReceivers.length == 1, ""Attempt to reduce computation"");
        uint256 currIdx = 0;
        uint256 newIdx = 0;
        while (true) {
            bool pickCurr = currIdx < currReceivers.length;
            DripsReceiver memory currRecv;
            if (pickCurr) currRecv = currReceivers[currIdx];

            bool pickNew = newIdx < newReceivers.length;
            DripsReceiver memory newRecv;
            if (pickNew) newRecv = newReceivers[newIdx];

            // if-1
            // Limit picking both curr and new to situations when they differ only by start/end time
            if (
                pickCurr &&
                pickNew &&
                (currRecv.userId != newRecv.userId ||
                    currRecv.config.amtPerSec() != newRecv.config.amtPerSec())
            ) {
                pickCurr = _isOrdered(currRecv, newRecv);
                pickNew = !pickCurr;
            }
            
            if (pickCurr && pickNew) {
                // if-2: same userId, same amtPerSec
                // Shift the existing drip to fulfil the new configuration

                // states[currRecv.userId].amtDeltas[_currTimestamp()].thisCycle = thisCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].amtDeltas[_currTimestamp()].nextCycle = nextCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].nextReceivableCycle = nextReceivableCycleMapping[currRecv.userId];

                DripsState storage state = states[currRecv.userId];
                (uint32 currStart, uint32 currEnd) = _dripsRangeInFuture(
                    currRecv,
                    lastUpdate,
                    currMaxEnd
                );
                (uint32 newStart, uint32 newEnd) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                {
                    int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                    // Move the start and end times if updated
                    _addDeltaRange(state, currStart, newStart, -amtPerSec);
                    _addDeltaRange(state, currEnd, newEnd, amtPerSec);
                }
                // Ensure that the user receives the updated cycles
                uint32 currStartCycle = _cycleOf(currStart);
                uint32 newStartCycle = _cycleOf(newStart);
                if (currStartCycle > newStartCycle && state.nextReceivableCycle > newStartCycle) {
                    state.nextReceivableCycle = newStartCycle;
                }
                
            } else if (pickCurr) {
                // if-3
                // Remove an existing drip
                DripsState storage state = states[currRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(currRecv, lastUpdate, currMaxEnd);
                //require (end - start == 10);
                int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, -amtPerSec);
                //
            } else if (pickNew) {
                // if-4
                // Create a new drip
                DripsState storage state = states[newRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                int256 amtPerSec = int256(uint256(newRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, amtPerSec);
                // Ensure that the user receives the updated cycles
                uint32 startCycle = _cycleOf(start);
                if (state.nextReceivableCycle == 0 || state.nextReceivableCycle > startCycle) {
                    state.nextReceivableCycle = startCycle;
                }
                //
                
            } else {
                break;
            }

            if (pickCurr) currIdx++;
            if (pickNew) newIdx++;
        }
    }

    /// @notice Calculates the time range in the future in which a receiver will be dripped to.
    /// @param receiver The drips receiver
    /// @param maxEnd The maximum end time of drips
    function _dripsRangeInFuture(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd
    //) private view returns (uint32 start, uint32 end) {
    ) internal view returns (uint32 start, uint32 end) {
        return _dripsRange(receiver, updateTime, maxEnd, _currTimestamp(), type(uint32).max);
    }

    /// @notice Calculates the time range in which a receiver is to be dripped to.
    /// This range is capped to provide a view on drips through a specific time window.
    /// @param receiver The drips receiver
    /// @param updateTime The time when drips are configured
    /// @param maxEnd The maximum end time of drips
    /// @param startCap The timestamp the drips range start should be capped to
    /// @param endCap The timestamp the drips range end should be capped to
    function _dripsRange(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd,
        uint32 startCap,
        uint32 endCap
    //) private pure returns (uint32 start, uint32 end_) {
    ) internal pure returns (uint32 start, uint32 end_) {
        start = receiver.config.start();
        if (start == 0) start = updateTime;
        uint40 end = uint40(start) + receiver.config.duration();
        if (end == start || end > maxEnd) end = maxEnd;
        if (start < startCap) start = startCap;
        if (end > endCap) end = endCap;
        if (end < start) end = start;
        return (start, uint32(end));
    }

    /// @notice Adds funds received by a user in a given time range
    /// @param state The user state
    /// @param start The timestamp from which the delta takes effect
    /// @param end The timestamp until which the delta takes effect
    /// @param amtPerSec The dripping rate
    function _addDeltaRange(
        DripsState storage state,
        uint32 start,
        uint32 end,
        int256 amtPerSec
    //) private {
    ) internal {
        if (start == end) return;
        mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
        _addDelta(amtDeltas, start, amtPerSec);
        _addDelta(amtDeltas, end, -amtPerSec);
    }

    /// @notice Adds delta of funds received by a user at a given time
    /// @param amtDeltas The user amount deltas
    /// @param timestamp The timestamp when the deltas need to be added
    /// @param amtPerSec The dripping rate
    function _addDelta(
        mapping(uint32 => AmtDelta) storage amtDeltas,
        uint256 timestamp,
        int256 amtPerSec
    //) private {
    ) internal virtual {
        unchecked {
            
            // In order to set a delta on a specific timestamp it must be introduced in two cycles.
            // These formulas follow the logic from `_drippedAmt`, see it for more details.
            int256 amtPerSecMultiplier = int256(_AMT_PER_SEC_MULTIPLIER);
            int256 fullCycle = (int256(uint256(_cycleSecs)) * amtPerSec) / amtPerSecMultiplier;
            int256 nextCycle = (int256(timestamp % _cycleSecs) * amtPerSec) / amtPerSecMultiplier;
            AmtDelta storage amtDelta = amtDeltas[_cycleOf(uint32(timestamp))];
            // Any over- or under-flows are fine, they're guaranteed to be fixed by a matching
            // under- or over-flow from the other call to `_addDelta` made by `_addDeltaRange`.
            // This is because the total balance of `Drips` can never exceed `type(int128).max`,
            // so in the end no amtDelta can have delta higher than `type(int128).max`.
            amtDelta.thisCycle += int128(fullCycle - nextCycle);
            amtDelta.nextCycle += int128(nextCycle);
            
        }
    }

    /// @notice Checks if two receivers fulfil the sortedness requirement of the receivers list.
    /// @param prev The previous receiver
    /// @param prev The next receiver
    function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)
        //private
        internal
        pure
        returns (bool)
    {
        if (prev.userId != next.userId) return prev.userId < next.userId;
        return prev.config.lt(next.config);
    }

    /// @notice Calculates the amount dripped over a time range.
    /// The amount dripped in the `N`th second of each cycle is:
    /// `(N + 1) * amtPerSec / AMT_PER_SEC_MULTIPLIER - N * amtPerSec / AMT_PER_SEC_MULTIPLIER`.
    /// For a range of `N`s from `0` to `M` the sum of the dripped amounts is calculated as:
    /// `M * amtPerSec / AMT_PER_SEC_MULTIPLIER` assuming that `M <= cycleSecs`.
    /// For an arbitrary time range across multiple cycles the amount is calculated as the sum of
    /// the amount dripped in the start cycle, each of the full cycles in between and the end cycle.
    /// This algorithm has the following properties:
    /// - During every second full units are dripped, there are no partially dripped units.
    /// - Undripped fractions are dripped when they add up into full units.
    /// - Undripped fractions don't add up across cycle end boundaries.
    /// - Some seconds drip more units and some less.
    /// - Every `N`th second of each cycle drips the same amount.
    /// - Every full cycle drips the same amount.
    /// - The amount dripped in a given second is independent from the dripping start and end.
    /// - Dripping over time ranges `A:B` and then `B:C` is equivalent to dripping over `A:C`.
    /// - Different drips existing in the system don't interfere with each other.
    /// @param amtPerSec The dripping rate
    /// @param start The dripping start time
    /// @param end The dripping end time
    /// @param amt The dripped amount
    function _drippedAmt(
        uint256 amtPerSec,
        uint256 start,
        uint256 end
    //) private view returns (uint256 amt) {
    ) internal view returns (uint256 amt) {
        // This function is written in Yul because it can be called thousands of times
        // per transaction and it needs to be optimized as much as possible.
        // As of Solidity 0.8.13, rewriting it in unchecked Solidity triples its gas cost.
        uint256 cycleSecs = _cycleSecs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let endedCycles := sub(div(end, cycleSecs), div(start, cycleSecs))
            let amtPerCycle := div(mul(cycleSecs, amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := mul(endedCycles, amtPerCycle)
            let amtEnd := div(mul(mod(end, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := add(amt, amtEnd)
            let amtStart := div(mul(mod(start, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := sub(amt, amtStart)
        }
    }

    /// @notice Calculates the cycle containing the given timestamp.
    /// @param timestamp The timestamp.
    /// @return cycle The cycle containing the timestamp.
    //function _cycleOf(uint32 timestamp) private view returns (uint32 cycle) {
    function _cycleOf(uint32 timestamp) internal view returns (uint32 cycle) {
        unchecked {
            return timestamp / _cycleSecs + 1;
            //return timestamp + 1;  // attempt to simplify
        }
    }

    /// @notice The current timestamp, casted to the library's internal representation.
    /// @return timestamp The current timestamp
    //function _currTimestamp() private view returns (uint32 timestamp) {
    function _currTimestamp() internal view returns (uint32 timestamp) {
        return uint32(block.timestamp);
    }

    /// @notice Returns the Drips storage.
    /// @return dripsStorage The storage.
    //function _dripsStorage() private view returns (DripsStorage storage dripsStorage) {
    function _dripsStorage() internal view returns (DripsStorage storage dripsStorage) {
        bytes32 slot = _dripsStorageSlot;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            dripsStorage.slot := slot
        }
    }
}
",./radicle_drips/specs/DripsHubBackup.spec,,Yes,
bbd7c3a4681b4e8cd87664c89eac7c8c,1269 | 1270 | 1271,rule,validChangeToTotalBondAmount,487,504,createBond | freeBond | seizeBond,"rule validChangeToTotalBondAmount(address o, method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 lockedBondsBefore = totalLockedBonds(o) ;
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 lockedBondsAfter = totalLockedBonds(o);
    assert lockedBondsBefore == lockedBondsAfter ||
           // case of unlocking
           ( (f.selector==freeBond(address,uint256).selector ||
              f.selector==seizeBond(address,uint256,uint256,address).selector ) &&
              lockedBondsAfter <= lockedBondsBefore )
           ||
           // case of locking
           ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
             lockedBondsAfter >= lockedBondsBefore && lockedBondsAfter <= lockedBondsBefore + unbondedBefore )
           ;
","createBond (Lines 136-169),  | freeBond (Lines 222-232),  | seizeBond (Lines 242-264), ","    function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
bc6bedc574d165310c9dbe483f1fd089,238 | 239 | 240,rule,cancelAfterDepositGivesBackExactAmount,209,249,deposit | startDepositCancellation | cancelDeposit,"rule cancelAfterDepositGivesBackExactAmount(uint256 amount) {
    
    env e1;
    env e2;
    env e3;
    address user = e1.msg.sender;
    address asset ;
    address aToken;
    address static ;
    address recipient;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;
    uint16 code;

    setupTokens(asset, aToken, static);
    requireValidUser(user);
    requireRayIndex(asset);
    require e1.msg.sender == e2.msg.sender;
    require e2.msg.sender == e3.msg.sender;
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp < e3.block.timestamp;
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 assetBalance1 = tokenBalanceOf(e1, asset, user);
        uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
        startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
        cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance2 = tokenBalanceOf(e3, aToken, user);
    uint256 assetBalance2 = tokenBalanceOf(e3, asset, user);
    if(fromUA){
        assert assetBalance1 == assetBalance2 + amount;
        assert ATokenBalance2 == ATokenBalance1 + amount;  
    }
    else {
        assert assetBalance1 == assetBalance2;
        assert ATokenBalance1 == ATokenBalance2;
}
","deposit (Lines 74-140),  | startDepositCancellation (Lines 465-494),  | cancelDeposit (Lines 497-554), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
 |     function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
 |     function cancelDeposit(
        address l1AToken,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1AToken].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.cancelL1ToL2Message(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );

        address underlyingAsset = address(
            _aTokenData[l1AToken].underlyingAsset
        );
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        uint256 dynamicAmount = _staticToDynamicAmount(
            amount,
            underlyingAsset,
            lendingPool
        );

        //transfer aTokens back to depositor
        IERC20(l1AToken).safeTransfer(msg.sender, dynamicAmount);

        //claim any accrued rewards for the depositor during the cancellation period
        uint256 currentRewardsIndex = _getCurrentRewardsIndex(l1AToken);
        uint256 rewardsAmount = _computeRewardsDiff(
            amount,
            rewardsIndex,
            currentRewardsIndex
        );

        if (rewardsAmount > 0) {
            _transferRewards(msg.sender, rewardsAmount);
            emit RewardsTransferred(_l2Bridge, msg.sender, rewardsAmount);
        }

        emit CancelledDeposit(
            l2Recipient,
            msg.sender,
            rewardsIndex,
            blockNumber,
            dynamicAmount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
bce393a0667d28567da556b9549bea03,1034 | 1035,rule,userAccumulatedDebtInterestWontDecrease,251,267,updateDiscountDistribution | decreaseBalanceFromInterest,"rule userAccumulatedDebtInterestWontDecrease(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 initAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	env e2 = envAtTimestamp(ts2);
	f(e2,args);
	uint256 finAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	assert(initAccumulatedInterest > finAccumulatedInterest => f.selector == decreaseBalanceFromInterest(address, uint256).selector);
","updateDiscountDistribution (Lines 258-314),  | decreaseBalanceFromInterest (Lines 327-330), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function decreaseBalanceFromInterest(address user, uint256 amount) external override onlyAToken {
    _ghoUserState[user].accumulatedDebtInterest = (_ghoUserState[user].accumulatedDebtInterest -
      amount).toUint128();
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
bce514d6299a44b797bfb87ba29e53d5,2177,rule,isRebasingPredicateSynchronized,348,366,changeSupply,"rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
bd622ea4ecc35f9c4d6553ff3d59bae6,2408,invariant,op_not_stopped,351,353,allowEmergencyWithdraw,"invariant op_not_stopped()
    pair() == 0 => !stopped()
        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
bd8e968d62636c21f778bc20b9866c14,29 | 31,rule,to,177,193,processMessageFromRoot | getCurrentState,"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
bde417a50b4ad4f79fb7d8b4809fca07,1801 | 1802 | 1803 | 1808,rule,integrityOfAddShort,188,196,addShort | addLong | addCollateral | totalShortAmount,"rule integrityOfAddShort(address shortOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	assert  totalShortAmount() == shortAmountBefore + x &&
		    getShortOtoken(index) == shortOtoken, ""integrity break of addShort"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
be85f79ead4f9d1b27ed66ccc14926b4,2404,invariant,al_differentTokenAndWavaxAddresses,246,253,initialize,"invariant al_differentTokenAndWavaxAddresses(address user)
    WAVAX() != token()
    {
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            require getNewWAVAX() != _token;
        }
    }
","initialize (Lines 28-35), ","    function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
bf3346295073d544ab43da2516f00629,215,rule,slashingIncreaseExchangeRate,471,481,slash,"rule slashingIncreaseExchangeRate(address receiver, uint256 amount) {
    env e; calldataarg args;

    uint216 _ExchangeRate = getExchangeRate();
    slash(e, args);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ >= _ExchangeRate;
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
bfa15d92e5a1b86e062356c758e9f662,898,rule,no_vote_delegation_when_voting,24,39,isVoting,"rule no_vote_delegation_when_voting {
	env _e;
	env eF;
	
	address account = eF.msg.sender;
	bool _isAccountVoting = sinvoke isVoting(_e,account);

	calldataarg arg;
	invoke delegateVoting(eF,arg);
	bool succeededDelegate = !lastReverted;
	assert(
    _isAccountVoting => !succeededDelegate,
    ""Account successfully delegated voting even though it is already a voter""
  );
} 
","isVoting (Lines 986-995), ","  function isVoting(address account) external view returns (bool) {
    Voter storage voter = voters[account];
    uint256 upvotedProposal = voter.upvote.proposalId;
    bool isVotingQueue = upvotedProposal != 0 &&
      isQueued(upvotedProposal) &&
      !isQueuedProposalExpired(upvotedProposal);
    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];
    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);
    return isVotingQueue || isVotingReferendum;
  }
",./celo_governance/specs/locked_gold_linked.spec,,Yes,
c0e9b4ecf88680806e811df97fda19ef,749,invariant,accountToSignerAndInverseNewRoles,460,466,signerToAccount,"invariant accountToSignerAndInverseNewRoles(address a, address s, bytes32 r)	
	getIndexedSigner(a, r) == s => signerToAccount(s) == a 
{
		preserved {
			require a != s;
		}
}
","signerToAccount (Lines 791-799), ","  function signerToAccount(address signer) external view returns (address) {
    address authorizingAccount = authorizedBy[signer];
    if (authorizingAccount != address(0)) {
      return authorizingAccount;
    } else {
      require(isAccount(signer), ""Must first register address with Account.createAccount"");
      return signer;
    }
  }
",./celo_governance/specs/accounts.spec,,Yes,
c1ad2ca42005e4b192943b0553607e00,1207 | 1211,rule,validState,115,150,seizeBond | bondAmount,"rule validState(address operator, uint unbonded, uint totalLocked) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )
/**
    @title Valid state of an operator .
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 
            ( ownerOf(o)  0  beneficiaryOf(o)  0  authorizerOf(o)  0 )
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
c2f2be2923bb5de563358e212905750d,1532,rule,cantBurnBatchOtherBalances,749,770,balanceOf,"rule cantBurnBatchOtherBalances(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    address other;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != from => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
c2f9834187a43439ecbde091a21c5d84,2321 | 2323 | 2324,rule,cannotFrontRunSplitThreeSameUsers,634,676,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
c35844604e3e6dc0d4376beedc60d9f0,2384,rule,withdraw_no_frontrunning,287,287,emergencyWithdraw,"rule withdraw_no_frontrunning(method f) filtered { f-> (f.selector != emergencyWithdraw().selector)}
","emergencyWithdraw (Lines 154-164), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
c36da130cfadb53ec42168c69ec8c87c,2386,rule,additivity_deposit,336,353,deposit,"rule additivity_deposit() {
    uint256 x;
    uint256 y;
    env e; 
    require x > 0 && y > 0;

    storage init = lastStorage;
    deposit(e, x);
    deposit(e, y);
    uint256 bal_sep = userJoeStaked(e.msg.sender);
    deposit(e, x+y) at init;
    uint256 bal_sum = userJoeStaked(e.msg.sender);
    assert bal_sep == bal_sum, ""additivity failed"";
}
","deposit (Lines 106-126), ","    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
c40c034df2d7060242259ba3fc9697d4,850 | 852 | 854,rule,approved_proposals_invariants,244,244,getUpvotedProposal | upvote | getUpvoteRecord,"rule approved_proposals_invariants(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
c4a147a06800d9ec64421eaf69d5f949,232,rule,depositWithdrawReversed,27,63,deposit,"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,,Yes,
c54482f3f462be80b7a10a5bda2d44bf,637,rule,lastVaultBalance_LEQ_ATokenBalThis,63,68,initialize,"rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/lastVaultBal_LEQ_ATokenBalThis.spec,,Yes,
c682985224aa29cd9c90e3bf25b8c0c3,564,rule,setSupplyCapIntegrity,139,142,setSupplyCap,"rule setSupplyCapIntegrity(uint256 supplyCap) {
    setSupplyCap(supplyCap);
    assert getSupplyCap() == supplyCap;
}
","setSupplyCap (Lines 299-308), ","  function setSupplyCap(
    address asset,
    uint256 newSupplyCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldSupplyCap = currentConfig.getSupplyCap();
    currentConfig.setSupplyCap(newSupplyCap);
    _pool.setConfiguration(asset, currentConfig);
    emit SupplyCapChanged(asset, oldSupplyCap, newSupplyCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
c6bd4fc19bed3b4f9e4bba2912b893be,2123,invariant,rebasingCreditsPerTokenMustBeGreaterThan0,34,62,changeSupply,"	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
c6cb1116ac2d4ba6a0a58edecaf666ac,2357,rule,ideas,2,34,afterStart,"// rule ideas for verification of the functions in Reserve.sol
// ///////////////////////////////////////////////////////////////

using DummyERC20Impl as dummyERC20Token
using DummyERC20A as tokenA
using DummyERC20B as tokenB
using ReserveHarness as reserveH
methods{
    ////////////////////////////////////////
	// ERC20 methods
	transferFrom(address, address, uint256) => DISPATCHER(true)
	transfer(address, uint256) => DISPATCHER(true)
	//
    tokenA.balanceOf(address) envfree
	tokenB.balanceOf(address) envfree
	dummyERC20Token.balanceOf(address) envfree
    tokenA.totalSupply() envfree
	tokenB.totalSupply() envfree
	dummyERC20Token.totalSupply() envfree
    transfer() => DISPATCHER(true)
    // Call resolutions for IReservePlugin
    afterStart(address, uint256) => NONDET //HAVOC_ALL
    afterDeposition(address, uint256) => NONDET //HAVOC_ALL
    beforeWithdrawal(address, uint256) => NONDET //HAVOC_ALL
    beforeEnd(address, uint256) => NONDET //HAVOC_ALL
    reserveH.getDeposited(address) envfree
    reserveH.getPlugins(address) envfree
}
","afterStart (Lines 41-267), ","    function afterStart(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve immediately after
    /// transferring funds to the plugin for deposition.
    /// @param token The used token.
    /// @param amt The amount which has been transferred for deposition.
    function afterDeposition(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve right before transferring funds for withdrawal.
    /// The reserve will `transferFrom` the tokens from the plugin address.
    /// The reserve can always withdraw everything that has been ever deposited, but never more.
    /// @param token The used token.
    /// @param amt The amount which will be transferred.
    function beforeWithdrawal(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve when it stops using the plugin,
    /// right before transferring from the plugin all the deposited funds.
    /// The reserve will `transferFrom` the tokens from the plugin address.
    /// This final transfer won't trigger the regular call to `beforeWithdrawal`.
    /// @param token The used token.
    /// @param amt The amount which will be transferred.
    function beforeEnd(IERC20 token, uint256 amt) external;
}

/// @notice The ERC-20 tokens reserve contract.
/// The registered users can deposit and withdraw funds.
/// The reserve by default doesn't do anything with the tokens,
/// but for each ERC-20 address a plugin can be registered for tokens storage.
contract Reserve is IReserve, Ownable {
    using SafeERC20 for IERC20;
    /// @notice The dummy plugin address meaning that no plugin is being used.
    IReservePlugin public constant NO_PLUGIN = IReservePlugin(address(0));

    /// @notice A set of addresses considered users.
    /// The value is `true` if an address is a user, `false` otherwise.
    mapping(address => bool) public isUser;
    /// @notice How many tokens are deposited for each token address.
    mapping(IERC20 => uint256) public deposited;
    /// @notice The reserved plugins for each token address.
    mapping(IERC20 => IReservePlugin) public plugins;

    /// @notice Emitted when a plugin is set.
    /// @param owner The address which called the function.
    /// @param token The token for which plugin has been set.
    /// @param oldPlugin The old plugin address. `NO_PLUGIN` if no plugin was being used.
    /// @param newPlugin The new plugin address. `NO_PLUGIN` if no plugin will be used.
    /// @param amt The amount which has been withdrawn
    /// from the old plugin and deposited into the new one.
    event PluginSet(
        address owner,
        IERC20 indexed token,
        IReservePlugin indexed oldPlugin,
        IReservePlugin indexed newPlugin,
        uint256 amt
    );

    /// @notice Emitted when funds are deposited.
    /// @param user The address which called the function.
    /// @param token The used token.
    /// @param from The address from which tokens have been transferred.
    /// @param amt The amount which has been deposited.
    event Deposited(address user, IERC20 indexed token, address indexed from, uint256 amt);

    /// @notice Emitted when funds are withdrawn.
    /// @param user The address which called the function.
    /// @param token The used token.
    /// @param to The address to which tokens have been transferred.
    /// @param amt The amount which has been withdrawn.
    event Withdrawn(address user, IERC20 indexed token, address indexed to, uint256 amt);

    /// @notice Emitted when funds are force withdrawn.
    /// @param owner The address which called the function.
    /// @param token The used token.
    /// @param plugin The address of the plugin from which funds have been withdrawn or
    /// `NO_PLUGIN` if from the reserve itself.
    /// @param to The address to which tokens have been transferred.
    /// @param amt The amount which has been withdrawn.
    event ForceWithdrawn(
        address owner,
        IERC20 indexed token,
        IReservePlugin indexed plugin,
        address indexed to,
        uint256 amt
    );

    /// @notice Emitted when an address is registered as a user.
    /// @param owner The address which called the function.
    /// @param user The registered user address.
    event UserAdded(address owner, address indexed user);

    /// @notice Emitted when an address is unregistered as a user.
    /// @param owner The address which called the function.
    /// @param user The unregistered user address.
    event UserRemoved(address owner, address indexed user);

    /// @param owner The initial owner address.
    constructor(address owner) {
        transferOwnership(owner);
    }

    modifier onlyUser() {
        require(isUser[msg.sender], ""Reserve: caller is not the user"");
        _;
    }

    /// @notice Sets a plugin for a given token.
    /// All future deposits and withdrawals of that token will be made using that plugin.
    /// All currently deposited tokens of that type will be withdrawn from the plugin previously
    /// set for that token and deposited into the new one.
    /// If no plugin has been set, funds are deposited from the reserve itself.
    /// If no plugin is being set, funds are deposited into the reserve itself.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param newPlugin The new plugin address. `NO_PLUGIN` if no plugin should be used.
    function setPlugin(IERC20 token, IReservePlugin newPlugin) public onlyOwner {
        IReservePlugin oldPlugin = plugins[token];
        plugins[token] = newPlugin;
        uint256 amt = deposited[token];
        if (oldPlugin != NO_PLUGIN) oldPlugin.beforeEnd(token, amt);
        _transfer(token, _pluginAddr(oldPlugin), _pluginAddr(newPlugin), amt);
        if (newPlugin != NO_PLUGIN) newPlugin.afterStart(token, amt);
        emit PluginSet(msg.sender, token, oldPlugin, newPlugin, amt);
    }

    /// @notice Deposits funds into the reserve.
    /// The reserve will `transferFrom` `amt` tokens from the `from` address.
    /// Callable only by a current user.
    /// @param token The used token.
    /// @param from The address from which funds are deposited.
    /// @param amt The deposited amount.
    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }

    /// @notice Withdraws funds from the reserve.
    /// The reserve will transfer `amt` tokens to the `to` address.
    /// Only funds previously deposited can be withdrawn.
    /// Callable only by a current user.
    /// @param token The used token.
    /// @param to The address to which funds are withdrawn.
    /// @param amt The withdrawn amount.
    function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }

    /// @notice Withdraws funds from the reserve or a plugin.
    /// The reserve will transfer `amt` tokens to the `to` address.
    /// The function doesn't update the deposited amount counter.
    /// If used recklessly, it may cause a mismatch between the counter and the actual balance
    /// making valid future calls to `withdraw` or `setPlugin` fail due to lack of funds.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param plugin The plugin to withdraw from.
    /// It doesn't need to be registered as a plugin for `token`.
    /// Pass `NO_PLUGIN` to withdraw directly from the reserve balance.
    /// @param to The address to which funds are withdrawn.
    /// @param amt The withdrawn amount.
    function forceWithdraw(
        IERC20 token,
        IReservePlugin plugin,
        address to,
        uint256 amt
    ) public onlyOwner {
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit ForceWithdrawn(msg.sender, token, plugin, to, amt);
    }

    /// @notice Sets the deposited amount counter for a token without transferring any funds.
    /// If used recklessly, it may cause a mismatch between the counter and the actual balance
    /// making valid future calls to `withdraw` or `setPlugin` fail due to lack of funds.
    /// It may also make the counter lower than what users expect it to be again making
    /// valid future calls to `withdraw` fail.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param amt The new deposited amount counter value.
    function setDeposited(IERC20 token, uint256 amt) public onlyOwner {
        deposited[token] = amt;
    }

    /// @notice Adds a new user.
    /// @param user The new user address.
    function addUser(address user) public onlyOwner {
        isUser[user] = true;
        emit UserAdded(msg.sender, user);
    }

    /// @notice Removes an existing user.
    /// @param user The removed user address.
    function removeUser(address user) public onlyOwner {
        isUser[user] = false;
        emit UserRemoved(msg.sender, user);
    }

    function _pluginAddr(IReservePlugin plugin) internal view returns (address) {
        return plugin == NO_PLUGIN ? address(this) : address(plugin);
    }

    function _transfer(
        IERC20 token,
        address from,
        address to,
        uint256 amt
    ) internal {
        if (from == address(this)) token.safeTransfer(to, amt);
        else token.safeTransferFrom(from, to, amt);
    }
}
",./radicle_drips/specs/Reserve.spec,,Yes,
c722d9326bf19a90005f2ac4c3eb3acf,2080 | 2081,rule,putOptionsPreExpiryCase3StartingWithAllCases,318,441,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
c7427c09db69e09eb025898c30b56571,1296,rule,settlementRatesAreNeverReset,23,35,settleAccount,"rule settlementRatesAreNeverReset(address account, uint256 currencyId, uint256 maturity) {
    env e;
    require maturity < e.block.timestamp;
    // TODO: need to specify that the asset that is being settled exists at the maturity provided here.
    int256 settlementRateBefore = getSettlementRate(currencyId, maturity);
    settleAccount(e, account);
    int256 settlementRateAfter = getSettlementRate(currencyId, maturity);

    // Settlement rates must always be set after settling accounts
    assert settlementRateAfter > 0;
    // If settlement rates were set before, then they must not change after
    assert settlementRateBefore == 0 => settlementRateBefore == settlementRateAfter;
}
","settleAccount (Lines 34-40), ","    function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,,Yes,
c79f6a9386ce1510d78fc0163111712a,636,invariant,inv_sumAllBalance_eq_totalSupply__underline,40,68,initialize,"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
    
// ******************************************************************************
// The main invariant of this file:
// _s.lastVaultBalance <= ATOKEN.balanceOf(theVault).
//
// Status: pass for all methods.
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/lastVaultBal_LEQ_ATokenBalThis.spec,,Yes,
c7f987fc748e630abc59db2134196077,560,rule,setReserveFactorIntegrity,127,130,setReserveFactor,"rule setReserveFactorIntegrity(uint256 reserveFactor) {
    setReserveFactor(reserveFactor);
    assert getReserveFactor() == reserveFactor;
}
","setReserveFactor (Lines 234-244), ","  function setReserveFactor(
    address asset,
    uint256 newReserveFactor
  ) external override onlyRiskOrPoolAdmins {
    require(newReserveFactor <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldReserveFactor = currentConfig.getReserveFactor();
    currentConfig.setReserveFactor(newReserveFactor);
    _pool.setConfiguration(asset, currentConfig);
    emit ReserveFactorChanged(asset, oldReserveFactor, newReserveFactor);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
c81addfa914c68cf6bb8c597f9c806b3,1526,rule,burnBatchCorrectWork,666,692,balanceOf,"rule burnBatchCorrectWork(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(from, id1);
    uint256 otherBalanceBefore2 = balanceOf(from, id2);
    uint256 otherBalanceBefore3 = balanceOf(from, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(from, id1);
    uint256 otherBalanceAfter2 = balanceOf(from, id2);
    uint256 otherBalanceAfter3 = balanceOf(from, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 + amount1
            && otherBalanceBefore2 == otherBalanceAfter2 + amount2
            && otherBalanceBefore3 == otherBalanceAfter3 + amount3
            , ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
c82b94fca0e206d3036906a5e34248d9,1076,rule,burnZeroDoesntChangeBalance,496,512,updateDiscountDistribution,"use rule burnZeroDoesntChangeBalance

/**
* @title proves a concrete case of repaying the full debt that ends with a zero balance
**/
rule integrityOfBurn_fullRepay_concrete() {
	env e;
	address user;
	uint256 currentDebt = balanceOf(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == ray());
	require(index == 2*ray());
	require(scaledBalanceOf(user) == 4*ray());
	burn(e, user, currentDebt, index);
	uint256 scaled = scaledBalanceOf(user);
	assert(scaled == 0);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
c84fc2b800ef2cefc6c60bf613636d00,410,rule,integrityTransfer,147,171,"balanceOf, _underlyingAsset.balanceOf","rule integrityTransfer(address from, address to, uint256 amount)
{
	env e;
	require e.msg.sender == from;
	address other; // for any address including from, to, currentContract the underlying asset balance should stay the same
	
	uint256 balanceBeforeFrom = balanceOf(from);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeOther =  _underlyingAsset.balanceOf(e, other);
	transfer(e, to, amount);
	uint256 balanceAfterFrom = balanceOf(from);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterOther =  _underlyingAsset.balanceOf(e, other);
	assert underlyingAfterOther == underlyingBeforeOther, ""unexpected change in underlying asserts"";
	if (from != to) {
		assert bounded_error_eq(balanceAfterFrom, balanceBeforeFrom - amount, 1) &&
	 		bounded_error_eq(balanceAfterTo, balanceBeforeTo + amount, 1), ""unexpected balance of from/to, when from!=to"";
	} else {
		assert balanceAfterFrom == balanceAfterTo , ""unexpected balance of from/to, when from==to"";
	}
}
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
c8ae7e73dd80d7347106427554bcc45e,592 | 593,rule,burnZeroDoesntChangeBalance,281,287,balanceOf | burn,"rule burnZeroDoesntChangeBalance(address u) {
	env e;
	uint256 balanceBefore = balanceOf(e, u);
	burn(e, u, 0);
	uint256 balanceAfter = balanceOf(e, u);
	assert balanceBefore == balanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
c9cc248456b22aa33f9b45d687f3f7d9,1586,rule,reinitVersionCheckGrandchild,146,151,initialize,"rule reinitVersionCheckGrandchild {
/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
    uint8 n;
    returnsBVN(n);
    assert initialized() == n, ""gransdchild contract's version n functions must only be callable in version n"";
","initialize (Lines 14-16), ","    function initialize(uint256 value) public payable initializer {
        x = value;
    }
",./openzepplin/specs/Initializable.spec,,Yes,
c9dae76e519769a4a4e2e7dcb378f0be,1412,invariant,total_supply_is_sum_of_balances,45,51,balanceOf,"invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,,Yes,
c9fc17a95b00ed74332addb1fe6124b7,186 | 187,invariant,totalSupplyGreaterThanUserBalance,78,109,transfer | transferFrom,"invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
    {
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
        {
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
","transfer (Lines 53-61),  | transferFrom (Lines 81-90), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
 |   function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external override returns (bool) {
    b[sender] = sub(b[sender], amount);
    b[recipient] = add(b[recipient], amount);
    a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
    return true;
  }
",./aave_staked_token/certora/specs/invariants.spec,,Yes,
ca1e7fa28108be184815c7cb581cae09,47,rule,queuedChangedCounter,275,284,processMessageFromRoot,"rule queuedChangedCounter()
{
	env e;
	calldataarg args;
	uint256 count1 = getActionsSetCount();
		processMessageFromRoot(e, args);
	uint256 count2 = getActionsSetCount();

	assert count1 < max_uint => count2 == count1+1;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
ca8a6a62a935ae02369374acf7ccd7b9,137,rule,cancelPriviliged,520,529,cancel,"rule cancelPriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	cancel(e1, args1);
	cancel@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","cancel (Lines 110-132), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
caab3daedd7ef4870bc377e0d46353c9,1612,rule,sanity,219,234,_delegate,"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","_delegate (Lines 127-133), ","    function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,,Yes,
caec741683fc6eed178cbcfe8cef0d97,1097,rule,integrityOfRebalanceUserDiscountPercent_userIsolation,634,642,rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	address targetUser;
	rebalanceUserDiscountPercent(e, targetUser);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => otherUser == targetUser);
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
cb728ea63ff74380f5198b5dc966d384,495 | 496,rule,setUsingAsCollateral,47,51,setUsingAsCollateral | isUsingAsCollateral,"rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
{
	setUsingAsCollateral(reserveIndex, usingAsCollateral);
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
","setUsingAsCollateral (Lines 49-63),  | isUsingAsCollateral (Lines 103-111), ","  function setUsingAsCollateral(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool usingAsCollateral
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << ((reserveIndex << 1) + 1);
      if (usingAsCollateral) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
cb81952394ea33aa5b1e095725df8d51,584 | 585,rule,additiveBurn,187,198,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	storage initialStorage = lastStorage;
	burn(e, a, x);
	burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
cc104bdb08133057c32a8223bc84c0a2,2379 | 2380,rule,faster,191,222,pendingRJoe | deposit,"    require rJoePerSec() > 0 && rJoePerSec() < 1000000; // realistic range to help the tool run this rule faster

    uint256 amount;
    require amount > 0;
    env e0; env e1;
    require e0.msg.sender == e1.msg.sender;
    deposit(e0, amount);
    require e1.block.timestamp > lastRewardTimestamp();
    require userRewardDebt(e0.msg.sender) < max_uint256;
    uint dt = e1.block.timestamp - lastRewardTimestamp(); // store this as a variable for more readable cex
    uint256 rewards = pendingRJoe(e1, e0.msg.sender);
    assert exists uint256 t. (t == dt) => rewards > 0,  ""trivial rJoe"";
    // doing the min interval calculations would likely be a better rule but causes timeouts, left for future consideration
    // uint256 min_interval = totalJoeStaked() / rJoePerSec();
    // require min_interval < (max_uint256 / 10) && min_interval > 0; // divide by 10 to reduce the scope of the problem
    // assert dt > min_interval => rJoe != 0, ""trivial rJoe"";
}
rule staking_trivial_on_zero_time() { // passes
    env e0;
    env e1; 
    uint delta_t = e1.block.timestamp - e0.block.timestamp; // store this as a variable for more readable cex
    require delta_t == 0; 
    uint256 rJoe = pendingRJoe(e1, e0.msg.sender);
    assert rJoe == 0, ""RJOE gained with no stake time"";
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
cd108d038ced5169ddeb5afdc5ebdd1a,369 | 371 | 372,rule,integirtyBalanceOfTotalSupply,26,41,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
cd74f6164fe5b2edd58a2c20ba1ccdc0,586 | 587 | 588,rule,inverseMintBurn,201,208,mint | balanceOf | burn,"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 rate) {
	env e;
	uint256 balancebefore = balanceOf(e, a);
	mint(e, delegatedUser, a, amount, rate);
	burn(e, a, amount);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
cddd9fdcb628cbcbb8d6e5e2b827c87c,38,rule,canceledForever,233,240,getCurrentState,"rule canceledForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 2;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
ce084d104807d610c1c0b3e06a7d487c,204,rule,airdropNotMutualized,242,248,stake_token.transfer,"rule airdropNotMutualized(uint256 amount){
    env e;
    uint216 exchangeRateBefore = getExchangeRate();
    stake_token.transfer(e, currentContract, amount);
    uint216 exchangeRateAfter = getExchangeRate();
    assert exchangeRateBefore == exchangeRateAfter;
}
","transfer (Lines 53-61), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
ce6177fbd7280f699f7c5375bc9340c8,194,rule,noSlashingMoreThanMax,98,112,slash,"rule noSlashingMoreThanMax(uint256 amount, address recipient){
    env e;
    uint vaultBalanceBefore = stake_token.balanceOf(currentContract);
    require(vaultBalanceBefore < AAVE_MAX_SUPPLY());
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());
    uint256 maxSlashable = vaultBalanceBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();

    require (amount > maxSlashable);
    require (recipient != currentContract);
    slash(e, recipient, amount);
    uint vaultBalanceAfter = stake_token.balanceOf(currentContract);
    assert vaultBalanceBefore - vaultBalanceAfter == maxSlashable;
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
ce7d759a4d5f9b4764d7f5d75ca9dec9,2507,rule,hl_noWithdrawFrontRun,1259,1277,withdrawAVAX,"rule hl_noWithdrawFrontRun(method f, env e, env e2){
    require e.msg.sender != e2.msg.sender;
    uint256 amount;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    withdrawAVAX(e, amount);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore - amount == userBalanceAfter1 && userBalanceBefore - amount == userBalanceAfter2, ""frontrun on Withdraw"";
}
","withdrawAVAX (Lines 374-398), ","    function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
cf609edc79b5d7ec679714c6d7bc6f63,1512,rule,mintCorrectWork,473,483,balanceOf,"rule mintCorrectWork(env e){
    address to; uint256 id; uint256 amount; bytes data;

    uint256 otherBalanceBefore = balanceOf(to, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(to, id);
    
    assert otherBalanceBefore == otherBalanceAfter - amount, ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
d006d522c332ba3ba477c7e5c892b16a,568,rule,setLiquidationProtocolFeeIntegrity,151,154,setLiquidationProtocolFee,"rule setLiquidationProtocolFeeIntegrity(uint256 liquidationProtocolFee) {
    setLiquidationProtocolFee(liquidationProtocolFee);
    assert getLiquidationProtocolFee() == liquidationProtocolFee;
}
","setLiquidationProtocolFee (Lines 311-321), ","  function setLiquidationProtocolFee(
    address asset,
    uint256 newFee
  ) external override onlyRiskOrPoolAdmins {
    require(newFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldFee = currentConfig.getLiquidationProtocolFee();
    currentConfig.setLiquidationProtocolFee(newFee);
    _pool.setConfiguration(asset, currentConfig);
    emit LiquidationProtocolFeeChanged(asset, oldFee, newFee);
  }
",./aave_v3/specs/ReserveConfiguration.spec,,Yes,
d0ad252e2ce475e9b26e7ae958477428,2455 | 2456,rule,cl_user_alloc_unchanging,599,610,currentPhase | depositAVAX,"rule cl_user_alloc_unchanging(address user, method f, env e) {
    require currentPhase(e) == PhaseThree(); // depositAVAX()

    uint256 userAllocationBefore = getUserAllocation(user);
    calldataarg args;
    f(e, args);
    uint256 userAllocationAfter = getUserAllocation(user);
    assert userAllocationBefore == userAllocationAfter, ""tokenReserve was changed"";
}
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
d12900bfb736b1070bd5e26630a9de40,121 | 122,rule,cancelExclusive,300,308,cancel | getCurrentState,"rule cancelExclusive(uint actionsSetId1, uint actionsSetId2)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId2);
		cancel(e, actionsSetId1);
	uint8 stateAfter = getCurrentState(e, actionsSetId2);

	assert actionsSetId1 != actionsSetId2 => stateBefore == stateAfter;
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
d187da783f2b30f4b8f5e1f1603d5e37,2251 | 2252 | 2253,rule,singleUserTimeUpdateNotChangingOtherUserBalance,808,906,"DH.create, create | _dripsState | _updateReceiverStates","// rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // uint8 i;
//     // userId1 and userId2 - receivers Id
//     uint256 assetId; uint256 userId1; uint256 userId2;
//     require userId != userId1; // != userId2;
//     require userId1 < userId2; // sorted
//     require userId != userId2;
//     // step 1 - balance before of user2
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
//     // assert false; // false 0
//     // step 2 - setup user1 changes and then call _updateReceiverStates()
//     /*  //setting values to config by create:
//         uint192 _amtPerSec;
//         uint32 _start;
//         uint32 _duration;
//     require _amtPerSec != 0;
//     */
//     DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
//     DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
//     DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
//    // DH.DripsConfig configNew2;
//     require configOld1 != configNew1;
//     // require configOld2 == configNew2;
//     DH.DripsReceiver receiverOld1;
//     require receiverOld1.userId == userId1;
//     require receiverOld1.config == configOld1;
//     DH.DripsReceiver receiverOld2;
//     require receiverOld2.userId == userId2;
//     require receiverOld2.config == configOld2;
//     DH.DripsReceiver receiverNew1;
//     require receiverNew1.userId == userId1;
//     require receiverNew1.config == configNew1;
//     // DripsReceiver[] memory currReceivers;
//     // DripsReceiver[] memory newReceivers;
//     // currReceivers[i].userId = userId1;
//     // currReceivers[i].config = configCurr;
//     // require sorted
//     // require no duplicate
//     // require amtPerSec != 0
//     // require(i < _MAX_DRIPS_RECEIVERS,"""");
//     // require currReceivers == newReceivers;
//     // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
//     // DripsState storage state = _dripsStorage().states[assetId][userId];
//     // uint32 lastUpdate = state.updateTime;
//     // uint32 currMaxEnd = state.maxEnd;
//     // uint32 newMaxEnd = sizeof(uint32);
//     // assert false;  // false 1
//      //assert configOld2 != configNew2;  //returned 0
//     _helperUpdateReceiverStates( e,
//             receiverOld1,
//             receiverOld2,
//             receiverNew1,
//             assetId,
//             userId
//         );
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
//     assert false;
// }
","create (Lines 59-68),  | _dripsState (Lines 509-529),  | _updateReceiverStates (Lines 818-1089), ","    function create(
        uint192 _amtPerSec,
        uint32 _start,
        uint32 _duration
    ) internal pure returns (DripsConfig) {
        uint256 config = _amtPerSec;
        config = (config << 32) | _start;
        config = (config << 32) | _duration;
        return DripsConfig.wrap(config);
    }
 |     function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
 |     function _updateReceiverStates(
        mapping(uint256 => DripsState) storage states,
        DripsReceiver[] memory currReceivers,
        uint32 lastUpdate,
        uint32 currMaxEnd,
        DripsReceiver[] memory newReceivers,
        uint32 newMaxEnd
    //) private {
    ) internal virtual {
        //return;
        //require(currReceivers.length == 1, ""Attempt to reduce computation"");
        //require(newReceivers.length == 1, ""Attempt to reduce computation"");
        uint256 currIdx = 0;
        uint256 newIdx = 0;
        while (true) {
            bool pickCurr = currIdx < currReceivers.length;
            DripsReceiver memory currRecv;
            if (pickCurr) currRecv = currReceivers[currIdx];

            bool pickNew = newIdx < newReceivers.length;
            DripsReceiver memory newRecv;
            if (pickNew) newRecv = newReceivers[newIdx];

            // if-1
            // Limit picking both curr and new to situations when they differ only by start/end time
            if (
                pickCurr &&
                pickNew &&
                (currRecv.userId != newRecv.userId ||
                    currRecv.config.amtPerSec() != newRecv.config.amtPerSec())
            ) {
                pickCurr = _isOrdered(currRecv, newRecv);
                pickNew = !pickCurr;
            }
            
            if (pickCurr && pickNew) {
                // if-2: same userId, same amtPerSec
                // Shift the existing drip to fulfil the new configuration

                // states[currRecv.userId].amtDeltas[_currTimestamp()].thisCycle = thisCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].amtDeltas[_currTimestamp()].nextCycle = nextCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].nextReceivableCycle = nextReceivableCycleMapping[currRecv.userId];

                DripsState storage state = states[currRecv.userId];
                (uint32 currStart, uint32 currEnd) = _dripsRangeInFuture(
                    currRecv,
                    lastUpdate,
                    currMaxEnd
                );
                (uint32 newStart, uint32 newEnd) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                {
                    int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                    // Move the start and end times if updated
                    _addDeltaRange(state, currStart, newStart, -amtPerSec);
                    _addDeltaRange(state, currEnd, newEnd, amtPerSec);
                }
                // Ensure that the user receives the updated cycles
                uint32 currStartCycle = _cycleOf(currStart);
                uint32 newStartCycle = _cycleOf(newStart);
                if (currStartCycle > newStartCycle && state.nextReceivableCycle > newStartCycle) {
                    state.nextReceivableCycle = newStartCycle;
                }
                
            } else if (pickCurr) {
                // if-3
                // Remove an existing drip
                DripsState storage state = states[currRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(currRecv, lastUpdate, currMaxEnd);
                //require (end - start == 10);
                int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, -amtPerSec);
                //
            } else if (pickNew) {
                // if-4
                // Create a new drip
                DripsState storage state = states[newRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                int256 amtPerSec = int256(uint256(newRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, amtPerSec);
                // Ensure that the user receives the updated cycles
                uint32 startCycle = _cycleOf(start);
                if (state.nextReceivableCycle == 0 || state.nextReceivableCycle > startCycle) {
                    state.nextReceivableCycle = startCycle;
                }
                //
                
            } else {
                break;
            }

            if (pickCurr) currIdx++;
            if (pickNew) newIdx++;
        }
    }

    /// @notice Calculates the time range in the future in which a receiver will be dripped to.
    /// @param receiver The drips receiver
    /// @param maxEnd The maximum end time of drips
    function _dripsRangeInFuture(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd
    //) private view returns (uint32 start, uint32 end) {
    ) internal view returns (uint32 start, uint32 end) {
        return _dripsRange(receiver, updateTime, maxEnd, _currTimestamp(), type(uint32).max);
    }

    /// @notice Calculates the time range in which a receiver is to be dripped to.
    /// This range is capped to provide a view on drips through a specific time window.
    /// @param receiver The drips receiver
    /// @param updateTime The time when drips are configured
    /// @param maxEnd The maximum end time of drips
    /// @param startCap The timestamp the drips range start should be capped to
    /// @param endCap The timestamp the drips range end should be capped to
    function _dripsRange(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd,
        uint32 startCap,
        uint32 endCap
    //) private pure returns (uint32 start, uint32 end_) {
    ) internal pure returns (uint32 start, uint32 end_) {
        start = receiver.config.start();
        if (start == 0) start = updateTime;
        uint40 end = uint40(start) + receiver.config.duration();
        if (end == start || end > maxEnd) end = maxEnd;
        if (start < startCap) start = startCap;
        if (end > endCap) end = endCap;
        if (end < start) end = start;
        return (start, uint32(end));
    }

    /// @notice Adds funds received by a user in a given time range
    /// @param state The user state
    /// @param start The timestamp from which the delta takes effect
    /// @param end The timestamp until which the delta takes effect
    /// @param amtPerSec The dripping rate
    function _addDeltaRange(
        DripsState storage state,
        uint32 start,
        uint32 end,
        int256 amtPerSec
    //) private {
    ) internal {
        if (start == end) return;
        mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
        _addDelta(amtDeltas, start, amtPerSec);
        _addDelta(amtDeltas, end, -amtPerSec);
    }

    /// @notice Adds delta of funds received by a user at a given time
    /// @param amtDeltas The user amount deltas
    /// @param timestamp The timestamp when the deltas need to be added
    /// @param amtPerSec The dripping rate
    function _addDelta(
        mapping(uint32 => AmtDelta) storage amtDeltas,
        uint256 timestamp,
        int256 amtPerSec
    //) private {
    ) internal virtual {
        unchecked {
            
            // In order to set a delta on a specific timestamp it must be introduced in two cycles.
            // These formulas follow the logic from `_drippedAmt`, see it for more details.
            int256 amtPerSecMultiplier = int256(_AMT_PER_SEC_MULTIPLIER);
            int256 fullCycle = (int256(uint256(_cycleSecs)) * amtPerSec) / amtPerSecMultiplier;
            int256 nextCycle = (int256(timestamp % _cycleSecs) * amtPerSec) / amtPerSecMultiplier;
            AmtDelta storage amtDelta = amtDeltas[_cycleOf(uint32(timestamp))];
            // Any over- or under-flows are fine, they're guaranteed to be fixed by a matching
            // under- or over-flow from the other call to `_addDelta` made by `_addDeltaRange`.
            // This is because the total balance of `Drips` can never exceed `type(int128).max`,
            // so in the end no amtDelta can have delta higher than `type(int128).max`.
            amtDelta.thisCycle += int128(fullCycle - nextCycle);
            amtDelta.nextCycle += int128(nextCycle);
            
        }
    }

    /// @notice Checks if two receivers fulfil the sortedness requirement of the receivers list.
    /// @param prev The previous receiver
    /// @param prev The next receiver
    function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)
        //private
        internal
        pure
        returns (bool)
    {
        if (prev.userId != next.userId) return prev.userId < next.userId;
        return prev.config.lt(next.config);
    }

    /// @notice Calculates the amount dripped over a time range.
    /// The amount dripped in the `N`th second of each cycle is:
    /// `(N + 1) * amtPerSec / AMT_PER_SEC_MULTIPLIER - N * amtPerSec / AMT_PER_SEC_MULTIPLIER`.
    /// For a range of `N`s from `0` to `M` the sum of the dripped amounts is calculated as:
    /// `M * amtPerSec / AMT_PER_SEC_MULTIPLIER` assuming that `M <= cycleSecs`.
    /// For an arbitrary time range across multiple cycles the amount is calculated as the sum of
    /// the amount dripped in the start cycle, each of the full cycles in between and the end cycle.
    /// This algorithm has the following properties:
    /// - During every second full units are dripped, there are no partially dripped units.
    /// - Undripped fractions are dripped when they add up into full units.
    /// - Undripped fractions don't add up across cycle end boundaries.
    /// - Some seconds drip more units and some less.
    /// - Every `N`th second of each cycle drips the same amount.
    /// - Every full cycle drips the same amount.
    /// - The amount dripped in a given second is independent from the dripping start and end.
    /// - Dripping over time ranges `A:B` and then `B:C` is equivalent to dripping over `A:C`.
    /// - Different drips existing in the system don't interfere with each other.
    /// @param amtPerSec The dripping rate
    /// @param start The dripping start time
    /// @param end The dripping end time
    /// @param amt The dripped amount
    function _drippedAmt(
        uint256 amtPerSec,
        uint256 start,
        uint256 end
    //) private view returns (uint256 amt) {
    ) internal view returns (uint256 amt) {
        // This function is written in Yul because it can be called thousands of times
        // per transaction and it needs to be optimized as much as possible.
        // As of Solidity 0.8.13, rewriting it in unchecked Solidity triples its gas cost.
        uint256 cycleSecs = _cycleSecs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let endedCycles := sub(div(end, cycleSecs), div(start, cycleSecs))
            let amtPerCycle := div(mul(cycleSecs, amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := mul(endedCycles, amtPerCycle)
            let amtEnd := div(mul(mod(end, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := add(amt, amtEnd)
            let amtStart := div(mul(mod(start, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := sub(amt, amtStart)
        }
    }

    /// @notice Calculates the cycle containing the given timestamp.
    /// @param timestamp The timestamp.
    /// @return cycle The cycle containing the timestamp.
    //function _cycleOf(uint32 timestamp) private view returns (uint32 cycle) {
    function _cycleOf(uint32 timestamp) internal view returns (uint32 cycle) {
        unchecked {
            return timestamp / _cycleSecs + 1;
            //return timestamp + 1;  // attempt to simplify
        }
    }

    /// @notice The current timestamp, casted to the library's internal representation.
    /// @return timestamp The current timestamp
    //function _currTimestamp() private view returns (uint32 timestamp) {
    function _currTimestamp() internal view returns (uint32 timestamp) {
        return uint32(block.timestamp);
    }

    /// @notice Returns the Drips storage.
    /// @return dripsStorage The storage.
    //function _dripsStorage() private view returns (DripsStorage storage dripsStorage) {
    function _dripsStorage() internal view returns (DripsStorage storage dripsStorage) {
        bytes32 slot = _dripsStorageSlot;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            dripsStorage.slot := slot
        }
    }
}
",./radicle_drips/specs/DripsHub.spec,,Yes,
d1bfdd55444619c97b902ddfd3a1881e,1109 | 1110,invariant,userBalanceAlwaysZero,97,126,transferUnderlyingTo | handleRepayment,"invariant userBalanceAlwaysZero(address user)
	scaledBalanceOf(user) == 0

// /**
// * @title first handleRepayment(amount) after transferUnderlyingTo(amount) succeeds.
// * @dev assumption of sufficient balanceOf(msg.sender) is justified because BorrowLogic.executeRepay()
// * @dev executes: IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);
// * @dev before invocation of handleRepayment()
// * OBSOLETE - GhoToken has other rules to validate the behavior of the facilitator level maintenance
// */
// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;
// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
","transferUnderlyingTo (Lines 156-158),  | handleRepayment (Lines 161-173), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
 |   function handleRepayment(
    address user,
    address onBehalfOf,
    uint256 amount
  ) external virtual override onlyPool {
    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);
    if (amount <= balanceFromInterest) {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);
    } else {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);
      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);
    }
  }
",./gho-core/ghoAToken.spec,,Yes,
d1f59659acdb5117edfd627a1777537d,1370 | 1371,rule,bitNumValidMaturitiesMustBeExact,39,52,getBitNumFromMaturity | isValidMaturity,"rule bitNumValidMaturitiesMustBeExact(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    require MIN_TIMESTAMP() <= blockTime && blockTime <= MAX_TIMESTAMP();
    require MIN_TIMESTAMP() <= maturity && maturity <= MAX_TIMESTAMP();
    require isValidMaturity(MAX_MARKET_INDEX(), maturity, blockTime);
    bool isExact;
    _, isExact = getBitNumFromMaturity(blockTime, maturity);

    // BitNums go out a bit past the max 20 year maturity, those bits are not valid
    assert isExact && maturity <= MAX_MARKET_MATURITY(blockTime), ""bitnum is valid does not match is valid maturity"";
}
","getBitNumFromMaturity (Lines 95-146),  | isValidMaturity (Lines 59-71), ","    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        internal
        pure
        returns (uint256, bool)
    {
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);

        if (maturity % Constants.DAY != 0) return (0, false);
        if (blockTimeUTC0 >= maturity) return (0, false);

        // Overflow check done above
        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;

        // These if statements need to fall through to the next one
        if (daysOffset <= Constants.MAX_DAY_OFFSET) {
            return (daysOffset, true);
        }

        if (daysOffset <= Constants.MAX_WEEK_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_DAY_OFFSET +
                    (blockTimeUTC0 % Constants.WEEK) /
                    Constants.DAY;
            // Ensures that the maturity specified falls on the actual day, otherwise division
            // will truncate it
            return (Constants.WEEK_BIT_OFFSET + offset / 6, (offset % 6) == 0);
        }

        if (daysOffset <= Constants.MAX_MONTH_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_WEEK_OFFSET +
                    (blockTimeUTC0 % Constants.MONTH) /
                    Constants.DAY;

            return (Constants.MONTH_BIT_OFFSET + offset / 30, (offset % 30) == 0);
        }

        if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_MONTH_OFFSET +
                    (blockTimeUTC0 % Constants.QUARTER) /
                    Constants.DAY;

            return (Constants.QUARTER_BIT_OFFSET + offset / 90, (offset % 90) == 0);
        }

        // This is the maximum 1-indexed bit num
        return (256, false);
    }
 |     function isValidMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        uint256 tRef = DateTime.getReferenceTime(blockTime);
        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));
        if (maturity > maxMaturity) return false;

        // prettier-ignore
        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);
        return isValid;
    }
",./notional_finance_v2/certora/asset/DateTime.spec,,Yes,
d23e3f1d348d28f9b57dd2f5fb93cd55,1585,rule,and,67,74,initialize,"/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
","initialize (Lines 14-16), ","    function initialize(uint256 value) public payable initializer {
        x = value;
    }
",./openzepplin/specs/Initializable.spec,,Yes,
d286347bed34bbf33e877c5571387424,400,rule,permitIntegrity,58,65,permit,"rule permitIntegrity(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) 
{
    env e;
    uint256 nonceBefore = nonces(owner);
    permit(e, owner, spender, value, deadline, v, r, s);
    assert allowance(owner, spender) == value;
    assert nonces(owner) == nonceBefore + 1;
}
","permit (Lines 170-193), ","  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external override {
    require(owner != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[owner];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))
      )
    );
    require(owner == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[owner] = currentValidNonce + 1;
    _approve(owner, spender, value);
  }
",./aave_v3/specs/AToken.spec,,Yes,
d2944a711af9be78ad79ef95920a6d33,1495 | 1496,rule,transferBalanceReduceEffect,262,276,balanceOf | safeTransferFrom,"rule transferBalanceReduceEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require other != to;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert from != other => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
d296507cc1113d76649bdf4021822e7c,2570 | 2571,rule,integrityExit,152,165,exit | checkAplusBeqC,"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance,receiverInstance);
		
	int256 amountAdded = exit(e, balance);
	
	uint256 balanceAfter = tokenBalanceOf(tokenInstance,receiverInstance);

	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
}","exit (Lines 46-50),  | checkAplusBeqC (Lines 28-36), ","    function exit(uint256 balance) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		token.transfer(receiver, b);
		return safeSub(b, balance); 
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/compoundStrategy.spec,,Yes,
d2e5a24de787f4511214d6c4b9ea68c8,2245,rule,startDrippingToUserCannotDecreaseReceivableAmt,672,686,Drips._receivableDrips,"// rule startDrippingToUserCannotDecreaseReceivableAmt()
// {
//     // make sure that the dripper was not sending to the user:
//     // require currReceivers.length == 0;

//     // check the receivable balance of the user before:
//     // (uint128 receivedAmtBefore, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // start sending to the user
//     // check the receivable balance of the user after:
//     // (uint128 receivedAmtAfter, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // assert receivedAmtAfter > receivedAmtBefore
// }
","_receivableDrips (Lines 224-236), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
d3013503d662a8b808fa336b7b9f6f3a,623 | 624,rule,mintNoChangeToOther,230,247,mint | balanceOf,"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 index, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint256 userBalanceBefore = balanceOf(user);
	uint256 otherBalanceBefore = balanceOf(other);
	mint(e, user, onBehalfOf, amount, index);
  	uint256 userBalanceAfter = balanceOf(user);
	uint256 otherBalanceAfter = balanceOf(other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter ; 
	}
	assert otherBalanceBefore == otherBalanceAfter ;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,,Yes,
d37c0dd25e371ea38fa91d5158d92698,1520,rule,cantMintBatchOtherBalances,574,595,balanceOf,"rule cantMintBatchOtherBalances(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256[] ids; uint256[] amounts;
    address other;
    bytes data;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
d39cb1049a1632b976bf2a73c9138e39,134,rule,onlyQueuedAreExecuted,473,487,execute,"rule onlyQueuedAreExecuted(bytes32 actionHash, uint256 actionsSetId)
{
	env e2; env e;
	calldataarg args;

	require isActionQueued(e, actionHash);
	// This is true in general, guardian is not a contract (is EOA).
	require getGuardian() != _mock(e);
		execute(e2, actionsSetId);
	bool queuedAfter = isActionQueued(e2, actionHash);
	
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1)) 
			<=> !queuedAfter;
}
","execute (Lines 82-107), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
d58172b43752182c41b41c9411f32355,2459 | 2460,rule,cl_lp_supply_fixed,639,651,allowEmergencyWithdraw | initialize,"rule cl_lp_supply_fixed(method f, env e) {
    require pair() != 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    uint256 lpSupplyBefore = lpSupply();
    calldataarg args;
    f(e, args);
    uint256 lpSupplyAfter = lpSupply();
    assert lpSupplyBefore == lpSupplyAfter, ""not yet implemented"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
d63e42b2f617966804427550795fac40,1202,invariant,noBankruptcy,161,175,deposit,"invariant noBankruptcy()
    (allUnbonded() + allLockedBond()) <= balanceOf(currentContract) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    preserved deposit(env e, address operator) {
        require e.msg.sender != currentContract;
        require (allUnbonded() + allLockedBond()) <= balanceOf(currentContract);
    }
    preserved topUp(env e, address _) {
    preserved delegate(env e, address _1 ,address _2, address _3) {
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
d6c2378ee4d893eb1e3eb690a2660717,842 | 843 | 845 | 848 | 849,rule,approval_only_if_promoted_and_allowed,218,241,getUpvotedProposal | approve | upvote | getUpvoteRecord | isDequeuedProposalExpired,"rule approval_only_if_promoted_and_allowed(uint256 p, uint256 index) {
	// A proposal should never be able to be approved unless it was promoted from the queue
	env eF;
    env eGet;
    require eF.block.timestamp == eGet.block.timestamp;
    require eF.block.number == eGet.block.number;
	
	bool _isProposalApproved = isApproved(p);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	bool _isDequeued = getFromDequeued(index) == p;
	bool _isExpired = isDequeuedProposalExpired(eGet, p);
	address _approver = approver();
	require !_isProposalApproved; // we assume not approved yet
	require !_isExpired; // we also assume it did not expire
		
	approve(eF,p,index);
	// should check if dequeued right during approve
	bool isDequeued_ = getFromDequeued(index) == p;
	bool isProposalApproved_ = isApproved(p);
	assert isProposalApproved_ => _isDequeued || (!_isDequeued && isDequeued_), ""Cannot approve proposal $p unless $index points to it before approve or during it""; // index has p
	assert isProposalApproved_ => eF.msg.sender == _approver, ""Only approver ${_approver} can approve"";
","getUpvotedProposal (Lines 43-48),  | approve (Lines 614-634),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164),  | isDequeuedProposalExpired (Lines 1343-1346), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {
    dequeueProposalsIfReady();
    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(
      proposalId,
      index
    );
    if (!proposal.exists()) {
      return false;
    }

    require(!proposal.isApproved(), ""Proposal already approved"");
    require(
      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,
      ""Proposal not in correct stage""
    );
    proposal.approved = true;
    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.
    proposal.networkWeight = getLockedGold().getTotalLockedGold();
    emit ProposalApproved(proposalId);
    return true;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
 |   function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {
    Proposals.Proposal storage proposal = proposals[proposalId];
    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));
  }
",./celo_governance/specs/governance.spec,,Yes,
d6d6c1363864791e50a3dad38316faae,1460,rule,executedOnlyAfterExecuteFunc,331,341,execute,"rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/GovernorBase.spec,,Yes,
d7bb3b1d887d7f79004dfac9adf1f954,2613 | 2614,rule,totalAssetsAfterFlashLoan,135,147,_tokenBalanceOf | flashLoan,"rule totalAssetsAfterFlashLoan(address token) {
	//link the strategy to the current token
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	//assume solvency safe assumption as we know that solvency is kept before and after flash loan
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
	require tokenBalanceOf(token) == totalTokenAmount(token);
	uint256 _systemBalance = tokenBalanceOfUser(token, currentContract);
	flashLoan(e, args);
	uint256 systemBalance_ = tokenBalanceOfUser(token, currentContract);
	assert  systemBalance_ >= _systemBalance, ""system lost assets due to flahs loan"";
","_tokenBalanceOf (Lines 762-764),  | flashLoan (Lines 53-58), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
 | 	function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) override public
	{
		require(harnessToken == token);
		require(harnessBorrower == borrower);
		super.flashLoan(borrower, receiver, token, amount, data );
	}
",./sushi_benttobox/spec/bentobox.spec,,Yes,
d805d65c2b4b75ede56d0b87690dae6f,1527,rule,cantBurnMoreSingle,697,705,balanceOf,"rule cantBurnMoreSingle(env e){
    address from; uint256 id; uint256 amount;

    require to_mathint(balanceOf(from, id) - amount) < 0;
    burn@withrevert(e, from, id, amount);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
d93e9908c6fc626241edb9d468bf0e25,2529,rule,cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer,299,315,withdrawLiquidity,"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user == issuer();
    require token() == SymbERC20A || token() == SymbERC20B;

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
","withdrawLiquidity (Lines 453-470), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
d962e3e79c34af762c0fcb779b48018b,1921 | 1924 | 1925,rule,validBalanceTotalLong,151,181,smallVault | depositLongB | mintOtokenB,"rule validBalanceTotalLong(address owner, uint256 vaultId, uint256 index, method f, address secondAddress, uint256 amount, address asset)
description ""$f breaks the validity of stored balance of long asset""
{
    links();
    env e;
    require asset == longOtoken;
    require getVaultLongOtoken(owner, vaultId, index) == asset;
    uint256 longVaultBefore = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = longOtoken.balanceOf(pool);
    // the margin pool can neither be the owner nor the msg sender since it is a contract. 
    require (owner != pool);
    require (e.msg.sender != pool);

    if (f.selector == depositLongB(address,uint256,address,uint256,uint256).selector) {
        sinvoke depositLongB(e, owner, vaultId, secondAddress, index, amount);
	} else if (f.selector == mintOtokenB(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenB(e, owner, vaultId, secondAddress, index, amount);
	} else {
        require smallVault(owner, vaultId, 1);
        require longOtoken.collateralAsset() == collateralToken;
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    
    uint256 longVaultAfter = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = longOtoken.balanceOf(pool);
    assert longVaultBefore != longVaultAfter => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
    assert poolBalanceAfter != poolBalanceBefore => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
}
","smallVault (Lines 53-66),  | depositLongB (Lines 176-192),  | mintOtokenB (Lines 287-304), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositLongB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
 |   function mintOtokenB(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.MintArgs memory args = Actions.MintArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      otoken: anOtokenB,
      index: index,
      amount: amount
    });
    _mintOtoken(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,,Yes,
d9a904660290d17581d5a5b74248d145,2536,rule,hl_noDepositFrontRun,110,128,depositAVAX,"rule hl_noDepositFrontRun(method f, env e, env e2){
    require open();
    require e.msg.sender != e2.msg.sender;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, ""frontrun on Deposit"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
d9b161d69bbfb8cc8ea860343753c78b,127,rule,executeFailsIfExpired,366,373,getCurrentState,"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
dac13993d398b877f17f0aeb49311404,1528,rule,cantBurnMoreBatch,710,728,balanceOf,"rule cantBurnMoreBatch(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(from, id1) - amount1) < 0 
                || to_mathint(balanceOf(from, id2) - amount2) < 0 
                || to_mathint(balanceOf(from, id3) - amount3) < 0 ;
    burnBatch@withrevert(e, from, ids, amounts);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
dac6549e983a6d48333be7dc3ab27658,1524,rule,burnCorrectWork,651,661,balanceOf,"rule burnCorrectWork(env e){
    address from; uint256 id; uint256 amount;

    uint256 otherBalanceBefore = balanceOf(from, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(from, id);
    
    assert otherBalanceBefore == otherBalanceAfter + amount, ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
db3d5547b479755a0c8b7b86956bcd39,1039,rule,userCantNullifyItsDebt,273,302,updateDiscountDistribution,"rule userCantNullifyItsDebt(method f) {
	address user;
	uint256 ts1;
	env e1 = envAtTimestamp(ts1);
	uint256 ts2;
	require(ts2 >= ts1);
	env e2 = envAtTimestamp(ts2);
	uint256 ts3;
	require(ts3 >= ts2);
	env e3 = envAtTimestamp(ts3);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));
	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
db5d6df99b53dc81261649d55d1a7956,2228,rule,zeroBalancesAfterRebalance,458,463,rebalance,"/* rule zeroBalancesAfterRebalance(){
    env e;
    rebalance(e);
    assert (token0.balanceOf(e, currentContract)==0 && 
                             token1.balanceOf(e, currentContract)==0);
} */
","rebalance (Lines 2375-2438), ","    function rebalance() external override nonReentrant checkDeviation {
        require(_operatorApproved[msg.sender], ""ONA"");
        _earnFees();
        //Burn all liquidity from pool to rerange for Optimizer's balances.
        pool.burnAllLiquidity(tickLower, tickUpper);
        
        //Calc base ticks
        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
        PoolVariables.Info memory cache;
        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);
        
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        // Calc liquidity for base ticks
        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);

        // Get exact amounts for base ticks
        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);

        // Get imbalanced token
        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio
        int256 amountSpecified = 
            zeroForOne
                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))
                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. ""overflow"" safe convertion cuz we are dividing by 2

        // Calculate Price limit depending on price impact
        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;
        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);

        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit
        pool.swap(
            address(this),
            zeroForOne,
            amountSpecified,
            sqrtPriceLimitX96,
            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))
        );


        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();

        // Emit snapshot to record balances
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        //Get exact ticks depending on Optimizer's new balances
        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);

        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);

        // Add liquidity to the pool
        (cache.amount0, cache.amount1) = pool.mint(
            address(this),
            tickLower,
            tickUpper,
            cache.liquidity,
            abi.encode(MintCallbackData({payer: address(this)})));

        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
db68f601d7b9981db74ae39de81afd1e,2515,rule,cl_userAllocUnchanging,279,293,currentPhase,"rule cl_userAllocUnchanging(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 userAllocationBefore = getUserAllocation(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 userAllocationAfter = getUserAllocation(user);
    assert userAllocationBefore == userAllocationAfter, ""userAllocation was changed"";
}
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,,Yes,
dc1ea7205620af6804566abac976f792,1343 | 1348,rule,executeTradeMovesImpliedRates,100,147,getRateScalar | executeTrade,"rule executeTradeMovesImpliedRates(
    int256 fCashToAccount,
    uint256 timeToMaturity
) {
    env e;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;

    assetCashToAccount, assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require assetCashToAccount != 0 && assetCashToReserve != 0;
    require (fCashToAccount < 0 => lastImpliedRate > getLastImpliedRate(),""last trade rate did not move in correct direction"");
    
    // assert fCashToAccount > 0 ? 
    //     // When fCashToAccount > 0 then lending, implied rates should decrease
    //     lastImpliedRate > getLastImpliedRate() :
    //     // When fCashToAccount < 0 then borrowing, implied rates should increase
    //     lastImpliedRate < getLastImpliedRate(),
    //     ""last trade rate did not move in correct direction"";
    require (fCashToAccount > 0 ? assetCashToAccount < 0 : assetCashToAccount > 0, ""incorrect asset cash for fCash"");
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
    require (getPreviousTradeTime() < e.block.timestamp, ""previous trade time did not update"");
    // assert  to_mathint(marketfCashBefore) ==  to_mathint(fCashToAccount) + to_mathint(marketfCashAfter), ""Market fCash does not net out"";
   
    // require marketfCashBefore < 1000 &&
    //         marketAssetCashBefore < 1000 &&
    //         assetCashToAccount < 1000 &&
    //         assetCashToReserve < 1000 &&
    //         marketfCashAfter < 1000 &&
    //         marketAssetCashAfter < 1000;
            
    // Jeff's NEW VERSION assert getMarketAssetCash() == marketAssetCashBefore - assetCashToAccount - assetCashToReserve;
    // int256 a_minus_b_minus_c = to_int256(marketAssetCashBefore - assetCashToAccount - assetCashToReserve);
    // int256 a_minus_b_minus_c = to_int256(to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve));
    // require a_minus_b_minus_c >= 0;
    // assert a_minus_b_minus_c == marketAssetCashAfter, //marketAssetCashBefore,
    //     ""Market asset cash does not net out"";
    assert to_mathint(marketAssetCashAfter) == to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve), //marketAssetCashBefore,
        ""Market asset cash does not net out"";
}
","getRateScalar (Lines 39-53),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
dd1b2afe91af1df2889b8b063dcd3280,98,rule,queueCannotCancel,151,160,getCurrentState,"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
dd91771c89495f05befa5a3e85051667,649,rule,previewDeposit_amount_check,142,165,previewWithdraw,"rule previewDeposit_amount_check() {
    env e1;
    env e2;
    uint256 assets;
    address receiver;   
    uint256 previewShares;
    uint256 shares;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address receiver;
    address owner;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
    previewShares = previewDeposit(e1, assets);
    shares = deposit(e2, assets, receiver);
    assert previewShares == shares, ""preview shares should be equal to actual shares"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,,Yes,
de379461c5eb64b0c28840bbbb57e230,1088,rule,integrityOfUpdateDiscountDistribution_userIsolation,591,603,updateDiscountDistribution,"rule integrityOfUpdateDiscountDistribution_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	uint256 amount;
	uint256 senderDiscountTokenBalance;
	uint256 recipientDiscountTokenBalance;
	address sender;
	address recipient;
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => (otherUser == sender || otherUser == recipient));
}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
de9b73e2d0acb6c986c9cda6f3cedfea,490 | 491,rule,setBorrowing,20,24,setBorrowing | isBorrowing,"rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
","setBorrowing (Lines 27-41),  | isBorrowing (Lines 87-95), ","  function setBorrowing(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool borrowing
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << (reserveIndex << 1);
      if (borrowing) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
dff780ce81cd09ddb05ec132212febc1,2486 | 2487,rule,cl_unchangingPair,887,899,allowEmergencyWithdraw | initialize,"rule cl_unchangingPair(method f, env e){
    require pair() != 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore == pairAfter, ""pair was changed in close stage"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
e048152d004f950c8928015a4ddd0128,599 | 600,rule,checks,347,361,burn | _calculateBalanceIncrease,"By finding a violation, this rule checks that one can burn when there totalSupply is zero.
It is commented out since it should fail 
rule canBurnAtZero() {
	env e;
	address user;
	require totalSupply(e) == 0;
	uint256 userRate = additionalData(user);
	uint256 previousPrincipalBalance;
    uint256 newPrincipalBalance;
    uint256 diff;
	previousPrincipalBalance, newPrincipalBalance, diff =  _calculateBalanceIncrease(e,user);
	uint256 amount; 
	invoke burn(e,user,amount);
	assert amount>0 => lastReverted;
}
","burn (Lines 178-245),  | _calculateBalanceIncrease (Lines 254-270), ","  function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
 |   function _calculateBalanceIncrease(
    address user
  ) internal view returns (uint256, uint256, uint256) {
    uint256 previousPrincipalBalance = super.balanceOf(user);

    if (previousPrincipalBalance == 0) {
      return (0, 0, 0);
    }

    uint256 newPrincipalBalance = balanceOf(user);

    return (
      previousPrincipalBalance,
      newPrincipalBalance,
      newPrincipalBalance - previousPrincipalBalance
    );
  }
",./aave_v3/specs/StableDebtToken.spec,,Yes,
e0e25c2eff6e77e4aa64ef1b150b6797,719 | 720,rule,noWithdrawBeforeUnlocking,128,150,pendingWithdrawalsNotFull | unlock,"rule noWithdrawBeforeUnlocking(address account, uint256 value, method f) {
	// We must make sure the length of pending withdrawals is not MAX_UINT, since then the `push` will make the length 0.
	// (this should have been checked by the solidity compiler)
	require(sinvoke pendingWithdrawalsNotFull(account), ""Pending withdrawals are full"");
	
	// Unlock a value and add it to pending withdrawals
	env _e;
	require(_e.msg.sender == account);
	sinvoke unlock(_e,value);

	// Try to run any function - adversary's goal is to succeed in unlocking before time
	env eF;
	require(eF.block.timestamp > _e.block.timestamp);
	calldataarg arg;
	sinvoke f(eF,arg);
	// We check if adversary succeeded
	uint256 totalPendingWithdrawals_ = sinvoke getTotalPendingWithdrawals(account);
	assert(
    eF.block.timestamp < _e.block.timestamp + sinvoke getunlockingPeriod() =>
    sinvoke getAccountNonvotingLockedGold(account) + totalPendingWithdrawals_ >= value,
    ""If we are before the unlock period passed, we cannot transfer the value outside the locked balance or pending balance""
  );
}
","pendingWithdrawalsNotFull (Lines 47-49),  | unlock (Lines 62-64), ","  function pendingWithdrawalsNotFull(address account) public view returns (bool) {
    return balances[account].pendingWithdrawals.length.add(2) >= 2; // we can add 2 more additional elements
  }
 |   function unlock(uint256 value) external {
    accountTotalLockedGold[msg.sender] = accountTotalLockedGold[msg.sender].sub(value);
  }
",./celo_governance/specs/lockedGold.spec,,Yes,
e1ac335f06161252dbb765388ee80abb,117 | 120,rule,onlyCancelCanCancel,285,297,cancel | getCurrentState,"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
e1b05b2eeb80abf195c4651197e441d5,236,rule,depositWithdrawReversed,96,132,deposit,"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridge.spec,,Yes,
e1b2e43f16e886fc37949cddfb10f341,2623,rule,validDecreaseToBalanceOf,182,197,transferMultiple,"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
","transferMultiple (Lines 42-51), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
",./sushi_benttobox/spec/bentobox.spec,,Yes,
e2e9909b0532a2eb9a695c7512179354,1515,rule,cantMintMoreSingle,521,529,balanceOf,"rule cantMintMoreSingle(env e){
    address to; uint256 id; uint256 amount; bytes data;

    require to_mathint(balanceOf(to, id) + amount) > max_uint256;
    mint@withrevert(e, to, id, amount, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
e33f9ef3d3b7eb7cd645d9eb7b404f1b,960 | 961,rule,haltingIsReversible,104,119,halt | unhalt,"rule haltingIsReversible(method f) {
    require owner() != 0;
    env e;
    halt(e);

    // call some function for covering more cases
    require f.selector != unhalt().selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    assert e.msg.sender != 0, ""Cannot send transactions from 0 address"";
    unhalt@withrevert(e2);
    assert !lastReverted, ""Unhalting should succeed"";
}
","halt (Lines 139-142),  | unhalt (Lines 144-147), ","    function halt() external isNotHalted onlyOwner {
        fHalt = true;
        emit Halted();
    }
 |     function unhalt() external isHalted onlyOwner {
        fHalt = false;
        emit Unhalted();
    }
",./furucombo/specs/registry.spec,,Yes,
e438d9fd1e89cf34c68ae2275f73ae7a,822 | 824 | 826,rule,no_referendum_votes_unless_approved,118,118,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_referendum_votes_unless_approved(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
e46677da2aa46d0434d5704fb41edc63,2206,invariant,total_vs_protocol_Fees,233,243,deposit,"    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
    }
","deposit (Lines 53-57), ","    function deposit() external payable {
        // assume succeeds
        supply = supply.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,,Yes,
e4b457b6683f6db56193b1e3763565fb,2007 | 2008,invariant,also,181,316,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
e5c1003fa926635a164cb5ca90a76138,1647 | 1651,rule,delegate_no_frontrunning,236,271,balanceOf | _delegate,"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,,Yes,
e5d81ed5aa238ce0dd5a509fc99095b4,2377 | 2378,rule,staking_non_trivial_rJoe,186,209,pendingRJoe | deposit,"rule staking_non_trivial_rJoe() {
    // requireInvariant totalJoeStaked_sums_user_balance();
// invariant totalJoeStaked_sums_user_balance() // passes
//     totalJoeStaked() == sum_user_balance()
// { preserved {
//     requireInvariant user_balances_less_than_totalJoeStaked();
invariant user_balances_less_than_totalJoeStaked() // passes
    forall address a. forall address b. (a != b) => to_uint256(totalJoeStaked()) >= userJoeStaked(a) + userJoeStaked(b)
{ preserved with (env e) {
    require e.msg.sender != currentContract;
}}
// }}
    requireInvariant is_initialized();
invariant is_initialized()
    initialized()
{ preserved {
    requireInvariant not_initializing();
invariant not_initializing()
    !initializing()

////////////////////////////////////////////////////////////////////////////
//                       Invariants                                       //
// // rJoe.totalSupply is sum of rJoe balances
// invariant User_RJ_balance_sums_supply()
//     false
//joe.balanceOf(RJStaking)    userInfo[user].amount
// invariant staking_joe_bal_sums_user_balance(env e) // passes
//    joe.balanceOf(e, currentContract) >= sum_user_balance()
// { preserved with (env otherE) {
//     require otherE.msg.sender != currentContract;
// } }
    require PRECISION() > 0;
    require rJoePerSec() > 0 && rJoePerSec() < 1000000; // realistic range to help the tool run this rule faster
    uint256 amount;
    require amount > 0;
    env e0; env e1;
    require e0.msg.sender == e1.msg.sender;
    deposit(e0, amount);
    require e1.block.timestamp > lastRewardTimestamp();
    require userRewardDebt(e0.msg.sender) < max_uint256;
    uint dt = e1.block.timestamp - lastRewardTimestamp(); // store this as a variable for more readable cex
    uint256 rewards = pendingRJoe(e1, e0.msg.sender);
    assert exists uint256 t. (t == dt) => rewards > 0,  ""trivial rJoe"";
    // doing the min interval calculations would likely be a better rule but causes timeouts, left for future consideration
    // uint256 min_interval = totalJoeStaked() / rJoePerSec();
    // require min_interval < (max_uint256 / 10) && min_interval > 0; // divide by 10 to reduce the scope of the problem
    // assert dt > min_interval => rJoe != 0, ""trivial rJoe"";
}
rule staking_trivial_on_zero_time() { // passes
    env e0;
    env e1; 
    uint delta_t = e1.block.timestamp - e0.block.timestamp; // store this as a variable for more readable cex
    require delta_t == 0; 
    uint256 rJoe = pendingRJoe(e1, e0.msg.sender);
    assert rJoe == 0, ""RJOE gained with no stake time"";
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
e65710e6231a663d25e54b28026875ec,1092,rule,integrityOfRebalanceUserDiscountPercent_updateDiscountRate,612,617,rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_updateDiscountRate() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	assert(discStrategy.calculateDiscountRate(balanceOf(e, user), getBalanceOfDiscountToken(e, user)) == getUserDiscountRate(user));
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
e6933cd94304141775079e9eff6f76d6,1489 | 1490,rule,transferCorrectness,162,177,balanceOf | safeTransferFrom,"rule transferCorrectness(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;

    require to != from;
    uint256 fromBalanceBefore = balanceOf(from, id);
    uint256 toBalanceBefore = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 fromBalanceAfter = balanceOf(from, id);
    uint256 toBalanceAfter = balanceOf(to, id);
    assert fromBalanceBefore == fromBalanceAfter + amount, ""Something wet wrong"";
    assert toBalanceBefore == toBalanceAfter - amount, ""Something wet wrong"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
e6b78647bd448fbfefeb789e27afb31c,2497 | 2498,rule,cl_tokenIncentivesBalanceCanBeZero,1025,1038,emergencyWithdraw | initialize,"rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){
    require initialized();          // initialize()

    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();
    require tokenIncentivesBalanceBefore > 0;
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();
    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, ""tokenIncentivesBalance is 0 unintentionally"";
}
","emergencyWithdraw (Lines 154-164),  | initialize (Lines 28-35), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
e7c006600bd7639168a991269eb11cf2,2516,rule,cl_userBalanceFixed,315,329,currentPhase,"rule cl_userBalanceFixed(method f, env e, address user) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 balanceBefore = getUserBalance(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 balanceAfter = getUserBalance(user);
    assert balanceBefore == balanceAfter, ""userBalance was changed"";
}
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,,Yes,
e805743084db7a353cbe3e664f66e35a,2453 | 2454,rule,op_token_res_fixed,574,591,allowEmergencyWithdraw | initialize,"rule op_token_res_fixed(method f, env e) {

    require pair() == 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    require initialized();
    require !stopped();
    uint256 tokenReserveBefore = tokenReserve();
    calldataarg args;
    f(e, args);
    uint256 tokenReserveAfter = tokenReserve();
    assert tokenReserveBefore == tokenReserveAfter, ""tokenReserve was changed"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
e874df90fa5327ff15858e2d0b0c7f4e,2434 | 2435 | 2436,invariant,cl_token_bal_eq_res_token,515,529,createPair | allowEmergencyWithdraw | initialize,"invariant cl_token_bal_eq_res_token()
    false

// STATUS - in progress
// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459
// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632
// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`
invariant clIncentivesCorrelation()
    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
e99ec1e0380c9662c818d1564805722b,477 | 478 | 479 | 481 | 483,invariant,integrityOfEmpty,134,147,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,,Yes,
e9ae07c7d4266db0cce153c367b125cf,2403,invariant,al_balance_less_than_allocation,229,241,allowEmergencyWithdraw,"invariant al_balance_less_than_allocation(address user)
    getUserBalance(user) <= getUserAllocation(user) 

// STATUS - verified
// - getUI[user].allocation <= maxAllocation
invariant al_userAllocation_less_than_maxAllocation(address user)
    getUserAllocation(user) <= maxAllocation()
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
ea3d83ed976940e0ddc7cfb8b3596b17,2092 | 2093,rule,callOptionsPreExpiry,449,595,shortOtoken.havocTotalSupply | havocVault,"rule callOptionsPreExpiry(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
   // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume before expiry
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,,Yes,
ea4ba5e30a4c062b8d537ef09b36af6b,766,rule,cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner,309,313,authorizeSignerWithSignature,"rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector	
} {
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,,Yes,
ea7d4570d01619657844781819447258,263 | 264,rule,totalClaimableRewards_stable_after_initialized,410,448,initialize | getTotalClaimableRewards,"rule totalClaimableRewards_stable_after_initialized()
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
{
    env e;
    require e.msg.sender != currentContract;
    setup(e, 0);
    calldataarg args;
    address reward;

    require e.msg.sender != reward;
 
    require currentContract != e.msg.sender;
    require _AToken != e.msg.sender;
    require _RewardsController != e.msg.sender;
    require _DummyERC20_aTokenUnderlying  != e.msg.sender;
    require _DummyERC20_rewardToken != e.msg.sender;
    require _SymbolicLendingPoolL1 != e.msg.sender;
    require _TransferStrategy != e.msg.sender;
    require _ScaledBalanceToken != e.msg.sender;
    require currentContract != reward;
    require _AToken != reward;
    require _RewardsController !=  reward;
    require _DummyERC20_aTokenUnderlying  != reward;
    require _SymbolicLendingPoolL1 != reward;
    require _TransferStrategy != reward;
    require _ScaledBalanceToken != reward;
    address newAToken;
    string staticATokenName;
    string staticATokenSymbol;
    mathint totalClaimableRewardsBefore = getTotalClaimableRewards(e, reward);
    initialize(e, newAToken, staticATokenName, staticATokenSymbol);
    mathint totalClaimableRewardsAfter = getTotalClaimableRewards(e, reward);
    assert totalClaimableRewardsAfter == totalClaimableRewardsBefore;
}
","initialize (Lines 68-87),  | getTotalClaimableRewards (Lines 320-337), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
ea8444431540fefb99cfa34a20af034f,390 | 391,rule,integrityBurn,129,138,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke burn(e, a, x, index);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
eaa3e8af391a273c9f785dc55ab14a78,1336 | 1338 | 1342,rule,oracleRatesBlandedIntoRateWindow,46,98,getRateScalar | getStoredOracleRate | executeTrade,"rule oracleRatesBlandedIntoRateWindow(method f){
env e;

uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","getRateScalar (Lines 39-53),  | getStoredOracleRate (Lines 56-75),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,,Yes,
eb7aa38b080a799792eb6feea03228f0,1120,rule,balanceOfFlashMinterGrows,57,58,distributeFeesToTreasury,"rule balanceOfFlashMinterGrows(method f, env e, calldataarg args) 
    filtered { f -> f.selector != distributeFeesToTreasury().selector }{
","distributeFeesToTreasury (Lines 176-180), ","  function distributeFeesToTreasury() external virtual override {
    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));
    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);
    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);
  }
",./gho-core/flashMinter.spec,,Yes,
ec112847ccd9377b93501972bf878ff3,2364 | 2365,rule,transition_balThisZero,2,19,currentPhase | createPair,"rule transition_balThisZero(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 wavaxBalanceBefore = getWAVAXbalanceOfThis();
    uint256 wavaxPairBalanceBefore = getWAVAXbalanceOfPair();
    uint256 avaxAllocBefore = avaxAllocated();
    require open();
    calldataarg args;
    createPair(e);
    require closed();
    uint256 wavaxBalanceAfter = getWAVAXbalanceOfThis();
    assert wavaxBalanceBefore == wavaxBalanceAfter, ""wavax balance of LE contract was changed"";
    assert getWAVAXbalanceOfPair() - wavaxPairBalanceBefore == avaxAllocated(), ""correlation is wrong"";
}
","currentPhase (Lines 319-330),  | createPair (Lines 402-450), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEInProgress.spec,,Yes,
ec22d780fbd0516f44f37e1752ca70e3,2522,rule,tr_pairOnlyChange,180,190,createPair,"rule tr_pairOnlyChange(method f, env e){     

    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore != pairAfter <=> f.selector == createPair().selector, ""pair was changed by wrong method"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
ec94157365af0a8d8ad4ed57ec684886,1485 | 1486,rule,unexpectedBalanceChange,87,93,safeTransferFrom | safeBatchTransferFrom,"rule unexpectedBalanceChange(method f, env e) 
    filtered { f -> f.selector != safeTransferFrom(address, address, uint256, uint256, bytes).selector
                        && f.selector != safeBatchTransferFrom(address, address, uint256[], uint256[], bytes).selector 
                        && f.selector != mint(address, uint256, uint256, bytes).selector 
                        && f.selector != mintBatch(address, uint256[], uint256[], bytes).selector  
                        && f.selector != burn(address, uint256, uint256).selector 
                        && f.selector != burnBatch(address, uint256[], uint256[]).selector } {
","safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
ec9c93112beed3167d727d63b823b9bb,1050,rule,integrityOfMint_updateScaledBalance_fixedIndex,341,357,updateDiscountDistribution,"rule integrityOfMint_updateScaledBalance_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	mint(e, caller, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore + scaledAmount);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,,Yes,
eceb25c7b4d1c28f1b1637211e6bc892,262,rule,totalClaimableRewards_stable_SANITY,370,371,initialize,"rule totalClaimableRewards_stable_SANITY(method f)
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
    filtered { f -> f.selector == claimSingleRewardOnBehalf(address, address,address).selector   }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
ed3609e590bd867ab7ed1433037a85c1,1693,rule,executeRevertsEffectCheck,214,225,isOperationReady,"rule executeRevertsEffectCheck(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    bool reverted = lastReverted;
    assert lastReverted => isOperationPending(id) && !isOperationReady(e, id), ""you go against execution nature"";
}
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,,Yes,
eda8d99348e80c0ae2bcda651695053e,379 | 381 | 382,rule,integirtyBalanceOfTotalSupplyOnMint,65,79,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupplyOnMint(address u, address delegatedUser)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke mint(e, delegatedUser, u, x, index); 
	uint256 balanceUAfter = balanceOf(e, u);
	assert (balanceUAfter != balanceUBefore  => (balanceUAfter - balanceUBefore  == totalSupplyAfter - totalSupplyBefore));
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
edfff2a81ec7a1cafbc532a35123aaa0,2132,rule,neverRevert_BalanceOf,33,39,changeSupply,"rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
ee6d8f5bd36e0405046f6e299fc7f330,293,rule,sanity_metaWithdraw,700,706,metaWithdraw,"rule sanity_metaWithdraw()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaWithdraw(e,args);
","metaWithdraw (Lines 182-224), ","  function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
ee90a3f451728c349f2ea7f2ffa1df5e,2654,rule,toElasticAndToBaseAreInverse0BaseEdgeCase,193,210,toBase,"rule toElasticAndToBaseAreInverse0BaseEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  ||  amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
ee93ab3260c2a18871bf7e8b75c2aefc,2650,rule,toElasticAndToBaseAreInverse0ElasticEdgeCase,174,191,toBase,"rule toElasticAndToBaseAreInverse0ElasticEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require elastic1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  || amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
eec9e5a12b4a425d9d9d9eeac08ab0e7,1121,rule,integrityOfTreasurySet,78,83,updateGhoTreasury,"rule integrityOfTreasurySet(address token){
    env e;
    updateGhoTreasury(e, token);
    address treasury_ = getGhoTreasury(e);
    assert treasury_ == token;
}
","updateGhoTreasury (Lines 246-251), ","  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {
    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');
    address oldGhoTreasury = _ghoTreasury;
    _ghoTreasury = newGhoTreasury;
    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);
  }
",./gho-core/flashMinter.spec,,Yes,
efa0872e2bd5bc7b8586d20edeed3133,403 | 404,rule,integrityMint,101,119,mint | balanceOf,"rule integrityMint(address a, address b, uint256 x) 
{
	env e;
	uint256 indexRay = gRNI();

	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e,b,a,x,indexRay);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);
	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
	assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
eff6819270a241845b4dca9d6cdf2d0c,113,rule,expiredForever,239,257,getCurrentState,"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
efff4092bc3b8f8ce76091de03bbe3cb,2306 | 2308 | 2309,rule,should,466,523,split | _setSplits | _assertSplitsValid,"        ""This rule should always fail"";
}
*/

/// @notice front running split() does not affect receiver
/// userA has a single splitReceiver userC
/// userB also has the same single splitReceiver UserC
/// we want to verify split() can be called on userA successfully
/// even if someone front runs it and calls splits() first on userB
/// no assumptions about userA, userB, userC
rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,,Yes,
f04c2fd6ddfa492cbed994f3f78a3c9f,1405,rule,withdrawsMustDecreaseCashBalance,12,16,getCashBalance,"rule withdrawsMustDecreaseCashBalance {
    env e;
    int256 cashBalance = getCashBalance(account);

}
","getCashBalance (Lines 80-84), ","    function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
",./notional_finance_v2/certora/accountContext/Balances.spec,,Yes,
f07c7d6af7bfce67631a5a383d927a15,2473 | 2474 | 2475,rule,op_tokenIncentivesForUsersUnchange,770,784,createPair | allowEmergencyWithdraw | initialize,"rule op_tokenIncentivesForUsersUnchange(method f, env e){
    require pair() == 0;                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);   // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    requireInvariant isInitialized();       // initialize()
    uint256 tokenIncentivesForUsersBefore = tokenIncentivesForUsers();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesForUsersAfter = tokenIncentivesForUsers();
    assert tokenIncentivesForUsersBefore == tokenIncentivesForUsersAfter, ""tokenRestokenIncentivesForUserserve was changed"";
}
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f089b9479bb759919decacd77cc0008c,2499,rule,hl_depositAdditivity,1097,1113,depositAVAX,"rule hl_depositAdditivity(env e, env e2){
    require e.msg.value > 0;
    require e.msg.value == 2 * e2.msg.value;
    require e.msg.sender != e2.msg.sender;

    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);
    
    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);
    require userOneBalanceBefore == userTwoBalanceBefore;
    depositAVAX(e2);
    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);
    assert userOneBalanceAfter == userTwoBalanceAfter, ""deposit is not additive"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f0f9f49ffb6aedfa59f3920098039328,1833 | 1834 | 1835 | 1836 | 1841,rule,inverseAddRemoveShort,225,232,addShort | removeShort | addLong | addCollateral | totalShortAmount,"rule inverseAddRemoveShort(address shortOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	invoke removeShort(shortOtoken, x, index);
	assert !lastReverted && totalShortAmount() == shortAmountBefore, ""removeShort is not inverse of addShort""; 
","addShort (Lines 57-78),  | removeShort (Lines 87-103),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function removeShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed short oToken exists in the vault at the specified index
        require(_index < _vault.shortOtokens.length, ""V2"");
        require(_vault.shortOtokens[_index] == _shortOtoken, ""V3"");

        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);

        if (newShortAmount == 0) {
            delete _vault.shortOtokens[_index];
        }
        _vault.shortAmounts[_index] = newShortAmount;
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
f0fd45ddb7814c4e7944892905b8c619,762 | 764,rule,viewFunctionsDoNotRevert,203,212,getOffchainStorageRoots | batchGetMetadataURL,"rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match

  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","getOffchainStorageRoots (Lines 299-324),  | batchGetMetadataURL (Lines 963-984), ","  function getOffchainStorageRoots(address account)
    external
    view
    returns (bytes memory, uint256[] memory)
  {
    require(isAccount(account), ""Unknown account"");
    uint256 numberRoots = offchainStorageRoots[account].length;
    uint256 totalLength = 0;
    for (uint256 i = 0; i < numberRoots; i++) {
      totalLength = totalLength.add(offchainStorageRoots[account][i].length);
    }

    bytes memory concatenated = new bytes(totalLength);
    uint256 lastIndex = 0;
    uint256[] memory lengths = new uint256[](numberRoots);
    for (uint256 i = 0; i < numberRoots; i++) {
      bytes storage root = offchainStorageRoots[account][i];
      lengths[i] = root.length;
      for (uint256 j = 0; j < lengths[i]; j++) {
        concatenated[lastIndex] = root[j];
        lastIndex++;
      }
    }

    return (concatenated, lengths);
  }
 |   function batchGetMetadataURL(address[] calldata accountsToQuery)
    external
    view
    returns (uint256[] memory, bytes memory)
  {
    uint256 totalSize = 0;
    uint256[] memory sizes = new uint256[](accountsToQuery.length);
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;
      totalSize = totalSize.add(sizes[i]);
    }

    bytes memory data = new bytes(totalSize);
    uint256 pointer = 0;
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {
        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];
        pointer = pointer.add(1);
      }
    }
    return (sizes, data);
  }
",./celo_governance/specs/accounts.spec,,Yes,
f10873924b8c60246813e7ff872ad5fd,1722 | 1723 | 1724,rule,where,71,89,addShort | addLong | addCollateral,"This is a parametic rule where f is any of the external/public functions of the contract
*/
rule changeToOneEntity(uint256 shortIndex, uint256 longIndex, uint256 collateralIndex, method f ) {
	
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = getLongAmount(longIndex);
	uint256 shortAmountBefore = getShortAmount(shortIndex);
	uint256 collateralAmountBefore = getCollateralAmount(collateralIndex);
	calldataarg args;
	env e;
	sinvoke f(e,args);
	uint256 longAmountAfter = getLongAmount(longIndex);
	uint256 shortAmountAfter = getShortAmount(shortIndex);
	uint256 collateralAmountAfter = getCollateralAmount(collateralIndex);

	assert (longAmountBefore != longAmountAfter => (shortAmountBefore == shortAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (shortAmountBefore != shortAmountAfter  => (longAmountBefore == longAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (collateralAmountBefore != collateralAmountAfter  => (longAmountBefore == longAmountAfter && shortAmountBefore == shortAmountAfter)); 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,,Yes,
f24e7d78eab331ddf5b63feee8224e7e,131,rule,sameExecutionTimesReverts,402,423,getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	queue2(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	queue2@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,,Yes,
f2b0c241f015f64c31393939fae8368e,2646,rule,toElasticAndToBaseAreInverse2up,153,167,toBase,"rule toElasticAndToBaseAreInverse2up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 2; 
    assert only_slightly_smaller_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
f40242dd01fb5bcfc6a3fadde0825f66,2362 | 2363,rule,tokensNonInterference,120,170,deposit | withdraw,"rule tokensNonInterference() {
    env e;
    calldataarg args;

    bool depositOrWithdraw;
    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 tokenABalanceOfUserBefore;    uint256 tokenABalanceOfUserAfter;
    uint256 tokenBBalanceOfUserBefore;    uint256 tokenBBalanceOfUserAfter;
    uint256 tokenABalanceOfReserveBefore; uint256 tokenABalanceOfReserveAfter;
    uint256 tokenBBalanceOfReserveBefore; uint256 tokenBBalanceOfReserveAfter;
    uint256 tokenADepositedBefore;        uint256 tokenADepositedAfter;
    uint256 tokenBDepositedBefore;        uint256 tokenBDepositedAfter;
    tokenABalanceOfUserBefore = tokenA.balanceOf(user);
    tokenBBalanceOfUserBefore = tokenB.balanceOf(user);
    tokenABalanceOfReserveBefore = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveBefore = tokenB.balanceOf(reserveH);
    tokenADepositedBefore = getDeposited(tokenA);
    tokenBDepositedBefore = getDeposited(tokenB);
    require tokenADepositedBefore == tokenABalanceOfReserveBefore;
    require tokenBDepositedBefore == tokenBBalanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(tokenA) == 0;
    require reserveH.getPlugins(tokenB) == 0;
    //deposit(e, tokenA, user, amtDeposited);
    //f(e,args);
    //withdraw(e, tokenA, user, amtWithdrawn);
    if (depositOrWithdraw) {
        deposit(e, tokenA, user, amtDeposited);
    } else {
        withdraw(e, tokenA, user, amtWithdrawn);
    }
    require amtDeposited == amtWithdrawn;
    tokenABalanceOfUserAfter = tokenA.balanceOf(user);
    tokenBBalanceOfUserAfter = tokenB.balanceOf(user);
    tokenABalanceOfReserveAfter = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveAfter = tokenB.balanceOf(reserveH);
    tokenADepositedAfter = getDeposited(tokenA);
    tokenBDepositedAfter = getDeposited(tokenB);
    assert tokenBBalanceOfUserBefore == tokenBBalanceOfUserAfter;
    assert tokenBBalanceOfReserveBefore == tokenBBalanceOfReserveAfter;
    assert tokenBDepositedBefore == tokenBDepositedAfter;
}
","deposit (Lines 171-182),  | withdraw (Lines 191-203), ","    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }
 |     function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }
",./radicle_drips/specs/Reserve.spec,,Yes,
f42822566974f4f8ba598551edb94bb1,2155 | 2158,rule,zeroMintDoesNotIncreaseBalance,154,163,mint | changeSupply,"rule zeroMintDoesNotIncreaseBalance(address user) {
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(user);
	mint(e, user, 0);
	uint after = balanceOf(user);
	assert after == before;
","mint (Lines 42-87),  | changeSupply (Lines 472-507), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
f4466f865ca52d7ffa25b07318044952,2171,rule,zeroBurnDoesNotDecreaseBalance,199,208,changeSupply,"rule zeroBurnDoesNotDecreaseBalance(address burned){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, 0);
	uint after = balanceOf(burned);
	assert before == after;
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,,Yes,
f4502f38f9ab63a1c3e3807bdfab9353,836 | 838 | 840,rule,no_double_vote_referendum_all_but_vote,164,164,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_double_vote_referendum_all_but_vote(method f, address account, uint256 deqIndex) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
f46a723e8cbd488a323712dcaec4be6b,2476 | 2477 | 2478,rule,op_tokenIncentiveIssuerRefundUnchange,790,803,createPair | allowEmergencyWithdraw | initialize,"rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){
    require pair() == 0;                                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);          // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();
    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, ""tokenIncentiveIssuerRefund was changed"";
}
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f51a0d1d9036676d5a89bc753d695207,2437 | 2438 | 2439 | 2440 | 2441 | 2442 | 2443,invariant,cl_nonzero_user_pair_bal,537,545,currentPhase | withdrawAVAX | createPair | emergencyWithdraw | allowEmergencyWithdraw | pairBalance | initialize,"invariant cl_nonzero_user_pair_bal(address user, env e)
    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)
    {
        preserved with (env e2){
            requireInvariant cl_not_stopped();                  // emergencyWithdraw()
            require currentPhase(e2) == PhaseThree();           // withdrawAVAX(uint256)
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","currentPhase (Lines 319-330),  | withdrawAVAX (Lines 374-398),  | createPair (Lines 402-450),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | pairBalance (Lines 623-632),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f51c7ba5d2946ebe18b96b976b8e7ef9,407 | 408,rule,additiveMint,125,140,mint | balanceOf,"rule additiveMint(address a, address b, address c, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require(balanceOf(a) == balanceOf(b) && a != b);
	uint256 balanceScenario0 = balanceOf(a);
	// storage initialStorage = lastStorage;
	mint(e,c,a,x,indexRay);
	mint(e,c,a,y,indexRay);
	uint256 balanceScenario1 = balanceOf(a);
	// mint(e,c, a, x+y ,indexRay) at initialStorage;
	mint(e, c, b, x+y ,indexRay);

	uint256 balanceScenario2 = balanceOf(b);
	assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""mint is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,,Yes,
f5596d82f90ec08ae9ba965f87989564,2371,invariant,that,431,442,updatePool,"// // I'd like to do an invariant that shows this is always increasing, but I can't see a good way to do so
// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
","updatePool (Lines 179-194), ","    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
f5df0b85751fa518cacf13a8f4961d2f,2376,rule,pending_reward_decreased_only_user,170,171,emergencyWithdraw,"rule pending_reward_decreased_only_user(method f) filtered { f -> (f.selector != 0xeb990c59 && f.selector != emergencyWithdraw().selector)
} { 
","emergencyWithdraw (Lines 154-164), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
f69e9d07328750a92075ba099b449aab,1469,rule,singleTokenBurnBurnBatchEquivalence,75,98,balanceOf,"rule singleTokenBurnBurnBatchEquivalence {
    storage beforeBurn = lastStorage;
    env e;

    address holder;
    uint256 token; uint256 burnAmount;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalance = balanceOf(holder, token);
    require tokens.length == 1; require burnAmounts.length == 1;
    require tokens[0] == token; require burnAmounts[0] == burnAmount;
    // burning via burn
    burn(e, holder, token, burnAmount) at beforeBurn;
    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;
    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);
    assert burnBalanceChange == burnBatchBalanceChange, 
        ""Burning a single token via burn or burnBatch must be equivalent"";
}   
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
f6aaf5fe4b0257bc7b1685e1ae9b72bb,2524 | 2525,rule,tr_incentivesForUsersChanges,208,220,createPair | initialize,"rule tr_incentivesForUsersChanges(method f){     
    uint256 incentivesBefore = tokenIncentivesForUsers();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentivesForUsers();
    assert incentivesBefore != incentivesAfter 
                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector
                || f.selector == createPair().selector, ""tokenIncentivesForUsers was changed by wrong method"";
}
","createPair (Lines 402-450),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
f6e4ce1109082cda4c2c1c2473673d39,2642,rule,named,135,151,toBase,"    Contributes to proof of rule named ""Identity"" in GDoc.
 */
rule toElasticAndToBaseAreInverse2down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 1; 
    assert only_slightly_larger_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,,Yes,
f756903d59f2aed80775848b57232223,1533 | 1534 | 1535,rule,singleTokenSafeTransferFromSafeBatchTransferFromEquivalence,779,806,balanceOf | safeTransferFrom | safeBatchTransferFrom,"rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfer = lastStorage;
    env e;

    address holder; address recipient;
    uint256 token; uint256 transferAmount; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalance = balanceOf(holder, token);
    mathint recipientStartingBalance = balanceOf(recipient, token);
    require tokens.length == 1; require transferAmounts.length == 1;
    require tokens[0] == token; require transferAmounts[0] == transferAmount;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;
    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;
    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange
        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, 
        ""Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}   
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,,Yes,
f82cc8f446ed13f8c14ae9cfd4c4b93f,2483 | 2484,rule,tr_incentivesForUsersChanges,849,861,createPair | initialize,"rule tr_incentivesForUsersChanges(method f){     
    uint256 incentivesBefore = tokenIncentivesForUsers();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentivesForUsers();
    assert incentivesBefore != incentivesAfter 
                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector
                || f.selector == createPair().selector, ""tokenIncentivesForUsers was changed by wrong method"";
}
","createPair (Lines 402-450),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f83d7edd31003566c52023d403cf1f07,197,rule,integrityOfSlashing,134,163,slash,"rule integrityOfSlashing(address to, uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract && to != currentContract);
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());

    require(totalSupply() > 0 && totalSupply() < AAVE_MAX_SUPPLY());
    uint256 total = totalSupply();
    uint256 balanceStakeTokenToBefore = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenToBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    slash(e, to, amount);
    uint256 balanceStakeTokenToAfter = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    uint256 maxSlashable = balanceStakeTokenVaultBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();
    uint256 amountToSlash;
    if (amount > maxSlashable) {
        amountToSlash = maxSlashable;
    } else {
        amountToSlash = amount;
    }
    assert balanceStakeTokenToAfter == balanceStakeTokenToBefore + amountToSlash;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore - amountToSlash;
    assert inPostSlashingPeriod();
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,,Yes,
f884b100c609512a7788b4fb61931545,267 | 269,rule,getClaimableRewards_stable_SANITY,483,486,initialize | claimRewardsOnBehalf,"rule getClaimableRewards_stable_SANITY(method f)
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
    filtered { f -> //claimFunctions(f)
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector   
","initialize (Lines 68-87),  | claimRewardsOnBehalf (Lines 280-291), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,,Yes,
f8c5392c1e72e20556ad370bd86dfc79,2491 | 2492 | 2493 | 2494 | 2495,rule,cl_pairAndTokenBalancesNonIncreasing,966,984,currentPhase | depositAVAX | createPair | allowEmergencyWithdraw | initialize,"rule cl_pairAndTokenBalancesNonIncreasing(method f, env e){
    require pair() != 0;                                // createPair()
    requireInvariant pairAndGetPairCorrelation(e);      // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant isInitialized();                   // initialize()
    require currentPhase(e) == PhaseThree();            // depositAVAX() 
    uint256 tokenBalanceBefore = getTokenBalanceOfThis();
    uint256 pairBalanceBefore = getPairBalanceOfThis();
    calldataarg args;
    f(e, args);
    uint256 tokenBalanceAfter = getTokenBalanceOfThis();
    uint256 pairBalanceAfter = getPairBalanceOfThis();
    assert tokenBalanceBefore >= tokenBalanceAfter, ""token balance was increased"";
    assert pairBalanceBefore >= pairBalanceAfter, ""pair balance was increased"";
}
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370),  | createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,,Yes,
f96340bb5b2edebb42346d3192f88b3e,2248,rule,integrityOfPast,688,766,setDrips,"rule integrityOfPast(method f)
{
    require requireValidSlots();

    env e0;                 address erc20;
    calldataarg args;       uint256 dripperId;      uint256 receiverId;
    require erc20 == 0x100;
    require dripperId == 1;
    require receiverId == 2;
    // setup one dripper and one receiver with start dripping timestamp of now
    uint192 amtPerSec;      uint32 start;           uint32 duration;
    require amtPerSec == 1;
    require start == 5;
    require duration == 100;
    DH.DripsConfig configBefore = _helperCreateConfig(amtPerSec, start, duration);
    require e0.block.timestamp == start;
    int128 balanceDelta;
    DH.DripsReceiver currReceiverBefore;
    require currReceiverBefore.userId == 0; // this will force passing empty currReceivers
    DH.DripsReceiver newReceiverBefore;
    require newReceiverBefore.userId == receiverId;
    require receiverId != 0;
    require newReceiverBefore.config == configBefore;
    //_helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    //helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    // let at least one cycle pass
    uint32 cycleSecs = getCycleSecs();
    require cycleSecs == 2;
    env e1;
    require e1.block.timestamp > e0.block.timestamp + cycleSecs;
    // calculate the ReceivableDripsBefore of the receiver
    // collectableAll() can be used if the user has also set splits
    uint128 ReceivableDripsBefore; uint32 receivableCyclesBefore;
    // type(uint32).max = 2^32 - 1 = 4294967295
    ReceivableDripsBefore, receivableCyclesBefore = receivableDrips(e1, receiverId, erc20, 4294967295);
    // change the dripper configuration to start dripping to the receiver in the future
    // i.e. try to alter the past, as if the past dripping did not occur
    // use the same amtPerSec and duration, only change the start time to the future
    uint32 newStart;
    require newStart > e1.block.timestamp + 10 * cycleSecs;
    DH.DripsConfig configAfter = _helperCreateConfig(amtPerSec, newStart, duration);
    DH.DripsReceiver newReceiverAfter;
    require newReceiverAfter.userId == receiverId;
    require newReceiverAfter.config == configAfter;
    //_helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    //setDrips(e1, dripperId, erc20, _helperArrOfStruct(e1, newReceiverBefore), balanceDelta, _helperArrOfStruct(e1, newReceiverAfter));
    //helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    // calculate again the ReceivableDripsAfter of the receiver
    // at a time before the newStart begins
    env e2;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < newStart;
    uint128 ReceivableDripsAfter; uint32 receivableCyclesAfter;
    ReceivableDripsAfter, receivableCyclesAfter = receivableDrips(e2, receiverId, erc20, 4294967295);
    // validate that the past dripping stays, i.e. what was already dripped is still receivable
    assert ReceivableDripsBefore == ReceivableDripsAfter;
    assert false; // sanity
rule sanity(method f){
    //uint32 cycleSecs = getCycleSecs();
    //require cycleSecs == 2;
    //setupState();
    env e;
    calldataarg args;
    f(e,args);
    assert false;
}
","setDrips (Lines 87-102), ","    function setDrips(
        IERC20 erc20,
        DripsReceiver[] calldata currReceivers,
        int128 balanceDelta,
        DripsReceiver[] calldata newReceivers
    ) public returns (uint128 newBalance, int128 realBalanceDelta) {
        if (balanceDelta > 0) _transferFromCaller(erc20, uint128(balanceDelta));
        (newBalance, realBalanceDelta) = dripsHub.setDrips(
            calcUserId(msg.sender),
            erc20,
            currReceivers,
            balanceDelta,
            newReceivers
        );
        if (realBalanceDelta < 0) erc20.safeTransfer(msg.sender, uint128(-realBalanceDelta));
    }
",./radicle_drips/specs/DripsHub.spec,,Yes,
f9840b401fe68d7a6413b07d8cbad65d,952,rule,unregisterHandlerIsPermanent,54,61,unregister,"rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,,Yes,
f9c62852edca3b3f917987f696bd877a,1276 | 1277 | 1278,rule,validChangeToUnbondedValue,519,538,deposit | createBond | freeBond,"rule validChangeToUnbondedValue(address o, address owner,  method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 unbondedAfter = unbondedValue(o);
    assert  unbondedAfter  == unbondedBefore ||
        //cases for deposit
        (( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           unbondedAfter == unbondedBefore + e.msg.value ) ||
        //cases for withdraw
        ( f.selector==withdraw(uint256,address).selector && (e.msg.sender==o || e.msg.sender == ownerOf(o)) &&
          unbondedAfter <= unbondedBefore) ||
        // cases for holder free
        ( f.selector==freeBond(address,uint256).selector &&  unbondedAfter >= unbondedBefore ) ||
        // case for holder locking
        ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
           unbondedAfter <= unbondedBefore );
","deposit (Lines 81-93),  | createBond (Lines 136-169),  | freeBond (Lines 222-232), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
 |     function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
",./keep_fully/specs/fullyBackedBonding.spec,,Yes,
f9e6ed390500679350d672a64af5070d,62 | 66,rule,sameExecutionTimesReverts,405,426,processMessageFromRoot | getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	processMessageFromRoot(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	processMessageFromRoot@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
fa2a422fee5dd1c3e6ef33248b1533df,790 | 792 | 794,invariant,dequeuedIsWithinRange,58,62,getUpvotedProposal | upvote | getUpvoteRecord,"invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
fa40f6e5412f669823cb7f1f2cfe2380,396 | 397 | 398,rule,inverseMintBurn,164,174,balanceOf | mint | burn,"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address asset;
	address delegatedUser;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x, index);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,,Yes,
fa776b5c4182a8ae091f55e1af54298c,947 | 948,rule,changesHandler,22,28,register | unregister,"rule changesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != register(address,bytes32).selector && f.selector != unregister(address).selector) 
        => _regState == regState_, ""method unexpectedly changes handler info"";
}
","register (Lines 28-32),  | unregister (Lines 38-43), ","    function register(address registration, bytes32 info) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] == bytes32(0), ""registered"");
        adapters[registration] = info;
    }
 |     function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,,Yes,
faa2bba81f6a8aca859e0b6005f3ca27,1125,rule,availableLiquidityDoesntChange,98,107,maxFlashLoan,"rule availableLiquidityDoesntChange(method f, address token){
    env e; calldataarg args;
    uint256 _liquidity = maxFlashLoan(e, token);

    f(e, args);
    uint256 liquidity_ = maxFlashLoan(e, token);
    assert liquidity_ == _liquidity;
}
","maxFlashLoan (Lines 115-124), ","  function maxFlashLoan(address token) external view override returns (uint256) {
    if (token != address(GHO_TOKEN)) {
      return 0;
    } else {
      IGhoToken.Facilitator memory flashMinterFacilitator = GHO_TOKEN.getFacilitator(address(this));
      uint256 capacity = flashMinterFacilitator.bucketCapacity;
      uint256 level = flashMinterFacilitator.bucketLevel;
      return capacity > level ? capacity - level : 0;
    }
  }
",./gho-core/flashMinter.spec,,Yes,
fabc916264f84f1f9ea1f559c05a2f34,2513,invariant,cl_avaxReservCheck,260,267,currentPhase,"invariant cl_avaxReservCheck()
    closed() => avaxReserve() == 0
    { 
        preserved with (env e2) { 
            require currentPhase(e2) == PhaseThree();
            safeAssumptions(e2); 
        } 
    }
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,,Yes,
fb662f94e73e4ad3319e6a499631686e,1558,rule,getTimestampOnlyChange,160,175,execute,"rule getTimestampOnlyChange(method f, env e){
    bytes32 id;
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt; uint256 delay;
    address[] targets; uint256[] values; bytes[] datas;

    require (targets[0] == target && values[0] == value && datas[0] == data)
                || (targets[1] == target && values[1] == value && datas[1] == data)
                || (targets[2] == target && values[2] == value && datas[2] == data);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    executionsCall(f, e, target, value, data, predecessor, salt, delay, targets, values, datas);
    assert getTimestamp(id) == 1 => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                        || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector, ""Did you find a way to break the system?"";
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/RulesInProgress.spec,,Yes,
fcf27aba688e291e62d137994d6424fb,2526,rule,tr_incentiveIssuerRefundChanges,224,234,createPair,"rule tr_incentiveIssuerRefundChanges(method f){     
    uint256 incentivesBefore = tokenIncentiveIssuerRefund();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentiveIssuerRefund();
    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, ""tokenIncentiveIssuerRefund was changed by wrong method"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEVarTran.spec,,Yes,
fd0d3a73d03f5c8ce35a376514ef27bd,1464,rule,holds,24,45,balanceOf,"/// n.b. This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule burnAmountProportionalToBalanceReduction {
    storage beforeBurn = lastStorage;
    env e;
    
    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 smallBurn; uint256 largeBurn;
    require smallBurn < largeBurn;

    // smaller burn amount
    burn(e, holder, token, smallBurn) at beforeBurn;
    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);
    // larger burn amount
    burn(e, holder, token, largeBurn) at beforeBurn;
    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert smallBurnBalanceChange < largeBurnBalanceChange, 
        ""A larger burn must lead to a larger decrease in balance"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,,Yes,
fd9b6856eb83d37bb9d598b39f647c98,2542 | 2543 | 2544 | 2545,rule,hl_whatShouldRevert,212,224,depositAVAX | withdrawAVAX | createPair | withdrawLiquidity,"rule hl_whatShouldRevert(method f, env e){
    require stopped();

    calldataarg args;
    f@withrevert(e, args);
    assert((f.selector == depositAVAX().selector
                || f.selector == withdrawAVAX(uint256).selector
                || f.selector == createPair().selector
                || f.selector == withdrawLiquidity().selector)
                => lastReverted, 
                ""function was not reverted"");
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398),  | createPair (Lines 402-450),  | withdrawLiquidity (Lines 453-470), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LEHighLevel.spec,,Yes,
fe84951735c703be004207a0b3e78ab9,856 | 859 | 860 | 861 | 863,rule,modifying_stageDuration,291,297,getUpvotedProposal | setReferendumStageDuration | setExecutionStageDuration | upvote | getUpvoteRecord,"rule modifying_stageDuration(method f) filtered { f -> 
    !f.isView 
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != initialize(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256).selector
    && f.selector != setApprovalStageDuration(uint256).selector
    && f.selector != setExecutionStageDuration(uint256).selector
    && f.selector != setReferendumStageDuration(uint256).selector
} {
","getUpvotedProposal (Lines 43-48),  | setReferendumStageDuration (Lines 342-347),  | setExecutionStageDuration (Lines 353-358),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {
    require(referendumStageDuration != 0, ""Duration must be larger than 0"");
    require(referendumStageDuration != stageDurations.referendum, ""Duration unchanged"");
    stageDurations.referendum = referendumStageDuration;
    emit ReferendumStageDurationSet(referendumStageDuration);
  }
 |   function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {
    require(executionStageDuration != 0, ""Duration must be larger than 0"");
    require(executionStageDuration != stageDurations.execution, ""Duration unchanged"");
    stageDurations.execution = executionStageDuration;
    emit ExecutionStageDurationSet(executionStageDuration);
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,,Yes,
fe8c987fb27105b67dce90aa69e6d968,953,rule,unregisterCallerIsPermanent,63,70,unregisterCaller,"rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,,Yes,
fea827ba597c9264761d0555abd2be24,2385,rule,additivity_withdraw,318,334,withdraw,"rule additivity_withdraw() {
    storage init = lastStorage;
    env e; 
    uint256 x;
    uint256 y;
    // require x > 0 && y > 0;
    // require userJoeStakede.msg.sender) > x + y;
    withdraw(e, x);
    withdraw(e, y);

    uint256 bal_sep = userJoeStaked(e.msg.sender);
    withdraw(e, x+y) at init;
    uint256 bal_sum = userJoeStaked(e.msg.sender);
    
    assert bal_sep == bal_sum, ""additivity failed"";
}
","withdraw (Lines 130-151), ","    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount -= _amount;
        totalJoeStaked -= _amount;

        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        if (pending > 0) _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,,Yes,
ff1cbe75de0f4d75fb1978174a455f4a,18,rule,queueDoesntModifyStateVariables,116,145,processMessageFromRoot,"rule queueDoesntModifyStateVariables()
{
	env e;
	calldataarg args;
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();

	// Call queue with one action in the set.
	processMessageFromRoot(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateIntact =  delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2;
	assert stateIntact,
		""_queue changed state variables unexpectedly"";
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,,Yes,
