SpecHash,SpecIndex,Type,Name,StartLine,EndLine,MethodsInRule,RuleContent,RelatedFunctions,FunctionBodies,FilePath,Project,ContractCode,StateVarAssignment,RuleContentNL,Funcitonality
5d0434df4921334fa79ab8deef1791df,2372 | 2374,rule,integrityExit,88,105,exit | checkAplusBeqC,"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;

	uint256 strategyBalanceBefore = tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	
	env e;
	int256 amountAdded = exit(e, balance);
	uint256 strategyBalanceBAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	assert compareLTzero(amountAdded) => strategyBalanceBefore < balance , ""did not send all availaible tokens"";
}","exit (Lines 46-50),  | checkAplusBeqC (Lines 28-36), ","    function exit(uint256 balance) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		token.transfer(receiver, b);
		return safeSub(b, balance); 
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/strategy.spec,sushi_benttobox,,Yes,,"Functionality: Transfer a specified balance to a receiver and calculate the difference between the current and specified balances using `exit`. In `checkAplusBeqC`, verify if the sum or difference of `a` and `b` equals `c`, adjusting for `b`'s sign."
8f1ff28b8387f64d1e0676b313659db6,2364 | 2366,rule,integrityHarvest,46,67,harvest | checkAplusBeqC,"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	
	require strategyBalanceBefore == tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	env e;
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 strategyBalanceAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","harvest (Lines 26-33),  | checkAplusBeqC (Lines 28-36), ","    function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/strategy.spec,sushi_benttobox,,Yes,,"Functionality: Calculate and transfer the positive gains of a balance to a receiver by subtracting the initial balance from the current balance. Also, verify if the sum or difference of two numbers (a plus/minus b) equals a third number (c), handling both positive and negative cases for b."
09961ed97c1b3fd554fc854fbe72872a,2450,rule,toBaseIsMonotone,48,56,toBase,"rule toBaseIsMonotone {
    bool roundUp;
    uint x;
    uint y;
    require x < y;
    uint xToBase = toBase(x, roundUp);
    uint yToBase = toBase(y, roundUp);
    assert xToBase <= yToBase; 
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an amount specified in the elastic unit to the base unit using the `rebase` object's `toBase` method, optionally rounding up the result. The conversion is defined by the rebase mechanism's underlying logic, which typically involves adjusting for accumulated interest or contract-specific scaling factors."
65bd1330ec0316177076c69a9d4886c9,2452,rule,toElasticAndToBaseAreInverse1down,86,103,toBase,"    Contributes to proof of rule named ""Identity"" in GDoc.
 */ 
rule toElasticAndToBaseAreInverse1down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 1; 
    assert only_slightly_larger_than(amount, amountToElasticToBase, error_margin1);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert a given amount (elastic) into its base value utilizing the `rebase.toBase` method, with an option to round up the result if specified. This function essentially translates a dynamic quantity into its underlying fundamental unit, considering rounding preferences."
693b7e03413bfaa928ac27ecbd00e41b,2456,rule,toElasticAndToBaseAreInverse1up,113,128,toBase,"rule toElasticAndToBaseAreInverse1up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 2; // ""base1/elastic1 + 1"":to
    assert only_slightly_smaller_than(amount, amountToElasticToBase, error_margin1);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert a given amount from an elastic (variable) unit to a base (fixed) unit using the `rebase.toBase` function. If `roundUp` is true, round the result up to the nearest whole number; otherwise, perform a standard conversion."
ee90a3f451728c349f2ea7f2ffa1df5e,2472,rule,toElasticAndToBaseAreInverse0BaseEdgeCase,193,210,toBase,"rule toElasticAndToBaseAreInverse0BaseEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  ||  amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert a given quantity (elastic) to its base value using a rebase mechanism, and choose whether to round the result up or down based on the boolean parameter (roundUp). This is typically used in finance or token systems to adjust quantities for inflation or deflation."
ee93ab3260c2a18871bf7e8b75c2aefc,2468,rule,toElasticAndToBaseAreInverse0ElasticEdgeCase,174,191,toBase,"rule toElasticAndToBaseAreInverse0ElasticEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require elastic1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  || amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an elastic amount into its base form using the `rebase` contract's `toBase` method. If the `roundUp` parameter is true, round the conversion up; otherwise, perform standard rounding. Return the resulting base amount."
f2b0c241f015f64c31393939fae8368e,2464,rule,toElasticAndToBaseAreInverse2up,153,167,toBase,"rule toElasticAndToBaseAreInverse2up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 2; 
    assert only_slightly_smaller_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert the provided `elastic` amount to its corresponding `base` amount using the `rebase.toBase` method, incorporating the `roundUp` parameter to determine rounding behavior. This conversion adheres to a predefined rebase mechanism, typically for adjusting token amounts."
f6e4ce1109082cda4c2c1c2473673d39,2460,rule,toElasticAndToBaseAreInverse2down,135,151,toBase,"    Contributes to proof of rule named ""Identity"" in GDoc.
 */
rule toElasticAndToBaseAreInverse2down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 1; 
    assert only_slightly_larger_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an elastic amount, represented by the variable `elastic`, to its corresponding base amount, with the option to round up the result if `roundUp` is true. This conversion leverages the `rebase.toBase` method, which returns the calculated base amount."
ee90a3f451728c349f2ea7f2ffa1df5e,2654,rule,toElasticAndToBaseAreInverse0BaseEdgeCase,193,210,toBase,"rule toElasticAndToBaseAreInverse0BaseEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  ||  amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an 'elastic' amount to its corresponding 'base' amount using the 'rebase' contract, with the option to round the conversion up if 'roundUp' is true. This method returns the converted base amount as determined by the 'rebase.toBase' function call."
ee93ab3260c2a18871bf7e8b75c2aefc,2650,rule,toElasticAndToBaseAreInverse0ElasticEdgeCase,174,191,toBase,"rule toElasticAndToBaseAreInverse0ElasticEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require elastic1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  || amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an 'elastic' amount into a 'base' amount by calling the 'toBase' method of the 'rebase' object. Optionally adjust the conversion to round up the result, based on the 'roundUp' boolean parameter provided."
f2b0c241f015f64c31393939fae8368e,2646,rule,toElasticAndToBaseAreInverse2up,153,167,toBase,"rule toElasticAndToBaseAreInverse2up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 2; 
    assert only_slightly_smaller_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert an elastic amount to its base value using a rebase strategy. If the `roundUp` parameter is true, round the result up to the nearest whole number; otherwise, round down. This operation is performed by accessing a method in the `rebase` object."
f6e4ce1109082cda4c2c1c2473673d39,2642,rule,toElasticAndToBaseAreInverse2down,135,151,toBase,"    Contributes to proof of rule named ""Identity"" in GDoc.
 */
rule toElasticAndToBaseAreInverse2down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 1; 
    assert only_slightly_larger_than(amount, amountToBaseToElastic, error_margin2);
}
","toBase (Lines 21-23), ","    function toBase(uint256 elastic, bool roundUp) public view returns (uint256 base) {
        base = rebase.toBase(elastic, roundUp);
    }
",./sushi_benttobox/spec/rebase.spec,sushi_benttobox,,Yes,,"Functionality: Convert a specified amount (elastic) into its base equivalent by calling the `toBase` method from the `rebase` object. Additionally, the conversion adheres to a rounding direction specified by the `roundUp` boolean, determining whether to round the resulting base value up or not."
79c9aec6f0686cbc25a0242e49b76a72,2379,rule,ifExitedIsTrueThenMethodsRevertExceptOwner,101,113,claimOwnership,"rule ifExitedIsTrueThenMethodsRevertExceptOwner() {
	env e;

	require exited() == true;
	method f;
	calldataarg args;
	require !f.isView && f.selector != claimOwnership().selector;
	require e.msg.sender != owner();
	f@withrevert(e, args);
	
	assert(lastReverted, ""Methods didn't revert"");
}
","claimOwnership (Lines 386-396), ","    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }
",./sushi_benttobox/spec/compoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Transfer the contract's ownership to a pre-designated pending owner. It verifies that the caller of this function is the current pending owner, then emits an event signaling the transfer of ownership, updates the contract's owner to the new owner, and resets the pending owner to a null address."
7f344830ce6d2c0440d7a8d2b0e3d4fa,2380 | 2382,rule,integrityHarvest,116,133,harvest | checkAplusBeqC,"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance, receiverInstance);
		
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 balanceAfter = tokenBalanceOf(tokenInstance, receiverInstance);
	
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","harvest (Lines 26-33),  | checkAplusBeqC (Lines 28-36), ","    function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/compoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Harvest the gains from an account balance by subtracting the original balance from the current balance, and if there is a gain, transfer it to a receiver. Additionally, check if the sum or difference of two numbers equals a third number, supporting both positive and negative second numbers."
d296507cc1113d76649bdf4021822e7c,2388 | 2389,rule,integrityExit,152,165,exit | checkAplusBeqC,"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance,receiverInstance);
		
	int256 amountAdded = exit(e, balance);
	
	uint256 balanceAfter = tokenBalanceOf(tokenInstance,receiverInstance);

	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
}","exit (Lines 46-50),  | checkAplusBeqC (Lines 28-36), ","    function exit(uint256 balance) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		token.transfer(receiver, b);
		return safeSub(b, balance); 
	}
 | 	function checkAplusBeqC(uint256 a, int256 b, uint256 c) public returns (bool) {
		if (b >= 0) {
            uint256 b_ = uint256(b);
            return a.add(b_) == c;
        } else if (b < 0) {
            uint256 b_ = uint256(-b);
            return a.sub(b_) == c;
        }
	}
",./sushi_benttobox/spec/compoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Transfer a specific balance amount from the token to the receiver and return the difference between the final balance and the initial balance. Additionally, evaluate whether the sum of the first number and a signed second number equals the third number, handling both positive and negative cases for the second number."
28cad6aafbbf352327b1ba4df3d94fdb,2392,invariant,zeroStrategy,94,146,_tokenBalanceOf,"invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
	
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)

// Rules
/**
 * solvency:
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	require straToken == strategy(token);
	//proven in zeroStrategy
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,sushi_benttobox,,Yes,,Functionality: Calculate the total balance of a specific ERC20 token associated with the contract by summing the token's balance directly held by the contract and the balance recorded in a separate strategy data structure for that token.
7e9aac58bbbccc00c71b63c64ab4325f,2412,rule,validDecreaseToBalanceOf,198,213,transferMultiple,"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
","transferMultiple (Lines 42-51), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Enforce restrictions on bulk token transfers by verifying that the number of recipient addresses (`tos`) does not exceed three, ensuring these addresses are not a specific unauthorized address (`harnessOther`), and confirming the sender (`from`) matches a predetermined address (`harnessFrom`) before executing the transfer."
9597955c8e2bbe3631118f5f7c3e7f61,2397,rule,solvency,109,146,_tokenBalanceOf,"rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Retrieve and sum the current balance of a specified ERC20 token held by the contract with any additional balance recorded in the contract's strategy data, then return the total amount as a uint256 variable."
99575f545c28c817c94dbb69aab20b2c,2415 | 2416 | 2417,rule,preserveTotalAssetsOfUser,242,281,transferMultiple | setStrategy | harvest,"rule preserveTotalAssetsOfUser(address token, address from, address to,
					    	   address user, uint256 amount, uint256 share,
							   method f) {
	env e;

	// verifying a simplified version
	require totalTokenAmount(token) == totalTokenShare(token);
	uint256 _userShares = balanceOf(token, user);
	// roundUp = true or false shouldn't matter as long as they are consistent
	mathint _userAssets = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true); 
	require user != currentContract &&  user == from && user == harnessFrom() && user == to;
	//for transfermultiple we assume that all transfer are to the same user
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint userAssets_ = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true);
	uint256 userShares_ = balanceOf(token, user);
	
	// transferMultiple transfer from user to some arbitrary other user so we expect assets to be preserved
	require  f.selector != transferMultiple(address,address,address[],uint256[]).selector; 
	// flash loan can reduce asset of user due to fee, and strategy can also reduce user assets due to negative profit
	if (f.selector != 0xf1676d37 && // hascode of flashLoan 
		f.selector != setStrategy(address,address).selector &&
		f.selector != harvest(address,bool,uint256).selector)
	{
		assert (_userAssets <= userAssets_,
			""total user assets not preserved"");
	}
	else  {
		// however on those functions, a user's share should not change
		assert (_userShares == userShares_,
}
","transferMultiple (Lines 42-51),  | setStrategy (Lines 1049-1082),  | harvest (Lines 26-33), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
 |     function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }
 |     function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Implement a strategy for managing and optimizing the allocation of an ERC20 token's assets, including queued strategy updates, profit and loss logging, and elastic supply adjustments. Additionally, handle the distribution of profits during asset harvesting, enforcing specific rules and requirements for transfers and strategy changes."
a3703ae640746da96997492189676f24,2402 | 2403,rule,totalAssetsAfterFlashLoan,151,163,_tokenBalanceOf | flashLoan,"rule totalAssetsAfterFlashLoan(address token) {
	//link the strategy to the current token
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	//assume solvency safe assumption as we know that solvency is kept before and after flash loan
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
	require tokenBalanceOf(token) == totalTokenAmount(token);
	uint256 _systemBalance = tokenBalanceOfUser(token, currentContract);
	flashLoan(e, args);
	uint256 systemBalance_ = tokenBalanceOfUser(token, currentContract);
	assert  systemBalance_ >= _systemBalance, ""system lost assets due to flahs loan"";
","_tokenBalanceOf (Lines 762-764),  | flashLoan (Lines 53-58), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
 | 	function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) override public
	{
		require(harnessToken == token);
		require(harnessBorrower == borrower);
		super.flashLoan(borrower, receiver, token, amount, data );
	}
",./sushi_benttobox/spec/bentoBoxCompoundStrategy.spec,sushi_benttobox,,Yes,,"Functionality: Calculate the total balance of a specified ERC20 token held by the smart contract, which includes both the direct balance of the token and any additional balance tracked in the contract's strategy data. Then, enable a controlled flash loan operation for a predefined token and borrower, ensuring adherence to predefined conditions before proceeding with the loan execution."
5947b1a0a136479c1dbc3810dbd91a65,2444 | 2445 | 2446,rule,preserveTotalAssetsOfUser,226,265,transferMultiple | setStrategy | harvest,"rule preserveTotalAssetsOfUser(address token, address from, address to,
					    	   address user, uint256 amount, uint256 share,
							   method f) {
	env e;

	// verifying a simplified version
	require totalTokenAmount(token) == totalTokenShare(token);
	uint256 _userShares = balanceOf(token, user);
	// roundUp = true or false shouldn't matter as long as they are consistent
	mathint _userAssets = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true); 
	require user != currentContract &&  user == from && user == harnessFrom() && user == to;
	//for transfermultiple we assume that all transfer are to the same user
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint userAssets_ = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true);
	uint256 userShares_ = balanceOf(token, user);
	
	// transferMultiple transfer from user to some arbitrary other user so we expect assets to be preserved
	require  f.selector != transferMultiple(address,address,address[],uint256[]).selector; 
	// flash loan can reduce asset of user due to fee, and strategy can also reduce user assets due to negative profit
	if (f.selector != 0xf1676d37 && // hascode of flashLoan 
		f.selector != setStrategy(address,address).selector &&
		f.selector != harvest(address,bool,uint256).selector)
	{
		assert (_userAssets <= userAssets_,
			""total user assets not preserved"");
	}
	else  {
		// however on those functions, a user's share should not change
		assert (_userShares == userShares_,
}
","transferMultiple (Lines 42-51),  | setStrategy (Lines 1049-1082),  | harvest (Lines 26-33), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
 |     function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }
 |     function harvest(uint256 balance, address sender) external override returns (int256 amountAdded) {
		uint256 b = getCurrentBalance(balance);
		int256 gain = safeSub(b, balance);
		if (gain > 0) {
			token.transfer(receiver, uint256(gain));
		}
		return gain;
	}
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Enforce multiple token transfers with specific rules, manage token strategy by setting new or exiting current strategies with profit or loss impact, and enable harvesting of gains from a balance update, reflecting changes in elastic totals and logging the strategy adjustments."
7332c670487e920fa3ca8cacf4743411,2426,rule,solvency,93,130,_tokenBalanceOf,"rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Calculate the total balance of a specific ERC20 token held by the current contract, combining the token balance directly held by the contract with an additional amount recorded in a strategic data structure, and return this cumulative amount."
9a553dd57f62d2198f955fd7453a7dc5,2421,invariant,zeroStrategy,78,130,_tokenBalanceOf,"invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
	
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)

// Rules
/**
 * solvency:
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	require straToken == strategy(token);
	//proven in zeroStrategy
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","_tokenBalanceOf (Lines 762-764), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Calculate and return the combined total balance of a specified ERC20 token, considering both the balance held directly by the contract and an additional amount potentially managed by a strategy, as indicated in `strategyData` for that token."
d7bb3b1d887d7f79004dfac9adf1f954,2431 | 2432,rule,totalAssetsAfterFlashLoan,135,147,_tokenBalanceOf | flashLoan,"rule totalAssetsAfterFlashLoan(address token) {
	//link the strategy to the current token
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	//assume solvency safe assumption as we know that solvency is kept before and after flash loan
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
	require tokenBalanceOf(token) == totalTokenAmount(token);
	uint256 _systemBalance = tokenBalanceOfUser(token, currentContract);
	flashLoan(e, args);
	uint256 systemBalance_ = tokenBalanceOfUser(token, currentContract);
	assert  systemBalance_ >= _systemBalance, ""system lost assets due to flahs loan"";
","_tokenBalanceOf (Lines 762-764),  | flashLoan (Lines 53-58), ","    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }
 | 	function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) override public
	{
		require(harnessToken == token);
		require(harnessBorrower == borrower);
		super.flashLoan(borrower, receiver, token, amount, data );
	}
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Calculate the balance of a specific ERC20 token held by the current contract and add any additional balance tracked in a separate strategy data structure, then provide a mechanism to execute a flash loan with specified parameters, ensuring compliance with predefined conditions for the borrower and the token."
e1b2e43f16e886fc37949cddfb10f341,2441,rule,validDecreaseToBalanceOf,182,197,transferMultiple,"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
","transferMultiple (Lines 42-51), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Enforce a rule where only a maximum of three recipients can be specified for a token transfer operation from a single source. Additionally, ensure that the transaction originates only from a specified address and excludes any transfers that might affect a predefined set of balances negatively."
e1b2e43f16e886fc37949cddfb10f341,2623,rule,validDecreaseToBalanceOf,182,197,transferMultiple,"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
","transferMultiple (Lines 42-51), ","	function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public override {
		require (tos.length <= 3);
	
		// this would not constraint tos for any other rule except noChangeToOthersBalances,
		// because harnessOther is only constraint in noChangeToOthersBalances
		assumeTosNotOther(tos, harnessOther);
		require(from == harnessFrom);

		super.transferMultiple(token, from, tos, shares);
	}
",./sushi_benttobox/spec/bentobox.spec,sushi_benttobox,,Yes,,"Functionality: Implement a restricted bulk transfer for an ERC20 token, allowing transfers from a specific sender to up to three recipients. It enforces no balance changes for uninvolved parties, except within specified conditions, by superimposing conditions about the sender and recipient list integrity."
e5d81ed5aa238ce0dd5a509fc99095b4,2377 | 2378,rule,staking_non_trivial_rJoe,186,209,pendingRJoe | deposit,"rule staking_non_trivial_rJoe() {
    // requireInvariant totalJoeStaked_sums_user_balance();
// invariant totalJoeStaked_sums_user_balance() // passes
//     totalJoeStaked() == sum_user_balance()
// { preserved {
//     requireInvariant user_balances_less_than_totalJoeStaked();
invariant user_balances_less_than_totalJoeStaked() // passes
    forall address a. forall address b. (a != b) => to_uint256(totalJoeStaked()) >= userJoeStaked(a) + userJoeStaked(b)
{ preserved with (env e) {
    require e.msg.sender != currentContract;
}}
// }}
    requireInvariant is_initialized();
invariant is_initialized()
    initialized()
{ preserved {
    requireInvariant not_initializing();
invariant not_initializing()
    !initializing()

////////////////////////////////////////////////////////////////////////////
//                       Invariants                                       //
// // rJoe.totalSupply is sum of rJoe balances
// invariant User_RJ_balance_sums_supply()
//     false
//joe.balanceOf(RJStaking)    userInfo[user].amount
// invariant staking_joe_bal_sums_user_balance(env e) // passes
//    joe.balanceOf(e, currentContract) >= sum_user_balance()
// { preserved with (env otherE) {
//     require otherE.msg.sender != currentContract;
// } }
    require PRECISION() > 0;
    require rJoePerSec() > 0 && rJoePerSec() < 1000000; // realistic range to help the tool run this rule faster
    uint256 amount;
    require amount > 0;
    env e0; env e1;
    require e0.msg.sender == e1.msg.sender;
    deposit(e0, amount);
    require e1.block.timestamp > lastRewardTimestamp();
    require userRewardDebt(e0.msg.sender) < max_uint256;
    uint dt = e1.block.timestamp - lastRewardTimestamp(); // store this as a variable for more readable cex
    uint256 rewards = pendingRJoe(e1, e0.msg.sender);
    assert exists uint256 t. (t == dt) => rewards > 0,  ""trivial rJoe"";
    // doing the min interval calculations would likely be a better rule but causes timeouts, left for future consideration
    // uint256 min_interval = totalJoeStaked() / rJoePerSec();
    // require min_interval < (max_uint256 / 10) && min_interval > 0; // divide by 10 to reduce the scope of the problem
    // assert dt > min_interval => rJoe != 0, ""trivial rJoe"";
}
rule staking_trivial_on_zero_time() { // passes
    env e0;
    env e1; 
    uint delta_t = e1.block.timestamp - e0.block.timestamp; // store this as a variable for more readable cex
    require delta_t == 0; 
    uint256 rJoe = pendingRJoe(e1, e0.msg.sender);
    assert rJoe == 0, ""RJOE gained with no stake time"";
","pendingRJoe (Lines 91-102),  | deposit (Lines 106-126), ","    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo memory user = userInfo[_user];
        uint256 joeSupply = totalJoeStaked;
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }
 |     function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        uint256 pending;
        if (user.amount > 0) {
            pending =
                (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
        }
        user.amount += _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
        totalJoeStaked += _amount;

        if (_amount != 0)
            joe.safeTransferFrom(msg.sender, address(this), _amount);
        if (pending != 0) _safeRJoeTransfer(msg.sender, pending);
        emit Deposit(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,rocket_joe,,Yes,,"Functionality: The given code calculates a user's pending rewards based on their stake in a pool and handles deposits into the pool. Upon deposit, it updates the user's stake amount, calculates any pending reward based on the updated global reward rate, and safely transfers the pending rewards and the deposit amount."
f5596d82f90ec08ae9ba965f87989564,2371,rule,updatePool_increases_accRJoePerShare,431,442,updatePool,"// // I'd like to do an invariant that shows this is always increasing, but I can't see a good way to do so
// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
","updatePool (Lines 179-194), ","    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = totalJoeStaked;
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }
",./rocket_joe/spec/Staking.spec,rocket_joe,,Yes,,"Functionality: Update rewards for a staking pool by checking if the current time exceeds the last reward timestamp, computing new rewards based on the elapsed time and total staked tokens, adjusting the accumulated reward per share accordingly, and minting the calculated reward tokens."
f5df0b85751fa518cacf13a8f4961d2f,2376,rule,pending_reward_decreased_only_user,170,171,emergencyWithdraw,"rule pending_reward_decreased_only_user(method f) filtered { f -> (f.selector != 0xeb990c59 && f.selector != emergencyWithdraw().selector)
} { 
","emergencyWithdraw (Lines 154-164), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,rocket_joe,,Yes,,"Functionality: Enable users to withdraw their full staked amount in an emergency situation. It resets the user's staked amount and reward debt to zero, decreases the total staked Joe by the withdrawn amount, and safely transfers the withdrawn amount back to the user's account."
fea827ba597c9264761d0555abd2be24,2385,rule,additivity_withdraw,318,334,withdraw,"rule additivity_withdraw() {
    storage init = lastStorage;
    env e; 
    uint256 x;
    uint256 y;
    // require x > 0 && y > 0;
    // require userJoeStakede.msg.sender) > x + y;
    withdraw(e, x);
    withdraw(e, y);

    uint256 bal_sep = userJoeStaked(e.msg.sender);
    withdraw(e, x+y) at init;
    uint256 bal_sum = userJoeStaked(e.msg.sender);
    
    assert bal_sep == bal_sum, ""additivity failed"";
}
","withdraw (Lines 130-151), ","    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount -= _amount;
        totalJoeStaked -= _amount;

        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        if (pending > 0) _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }
",./rocket_joe/spec/Staking.spec,rocket_joe,,Yes,,"Functionality: Deduct a specified amount from a user's balance in a staking contract, calculate and transfer any pending rewards to them, update their staked balance and rewards debt accordingly, and emit a withdrawal event. Ensure the withdrawal amount does not exceed the user's balance."
d93e9908c6fc626241edb9d468bf0e25,2529,rule,cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer,299,315,withdrawLiquidity,"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user == issuer();
    require token() == SymbERC20A || token() == SymbERC20B;

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
","withdrawLiquidity (Lines 453-470), ","    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LEVarTran.spec,rocket_joe,,Yes,,"Functionality: Verify that the liquidity-generating pair exists and that the caller has a balance to withdraw. Mark the user as having withdrawn their liquidity. Conditional on the caller's identity, emit the appropriate event, then transfer the caller's liquidity balance to them."
ec22d780fbd0516f44f37e1752ca70e3,2522,rule,tr_pairOnlyChange,180,190,createPair,"rule tr_pairOnlyChange(method f, env e){     

    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore != pairAfter <=> f.selector == createPair().selector, ""pair was changed by wrong method"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEVarTran.spec,rocket_joe,,Yes,,"Functionality: Create a liquidity pool for a token and Wrapped AVAX (WAVAX) on a decentralized exchange, ensuring no existing pool with the same pair or non-zero supply exists. It dynamically adjusts the token allocation based on the floor price before minting liquidity pool (LP) tokens and allocating incentives."
f6aaf5fe4b0257bc7b1685e1ae9b72bb,2524 | 2525,rule,tr_incentivesForUsersChanges,208,220,createPair | initialize,"rule tr_incentivesForUsersChanges(method f){     
    uint256 incentivesBefore = tokenIncentivesForUsers();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentivesForUsers();
    assert incentivesBefore != incentivesAfter 
                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector
                || f.selector == createPair().selector, ""tokenIncentivesForUsers was changed by wrong method"";
}
","createPair (Lines 402-450),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LEVarTran.spec,rocket_joe,,Yes,,"Functionality: Create a liquidity pair for a token and Wrapped AVAX (WAVAX) if it doesn't exist or has no supply, adjusting the allocated token amount based on a floor price. It deposits AVAX and the adjusted token amount into the pool, mints liquidity pool (LP) tokens, and then emits an event detailing the creation. Initialize the contract by setting the rocketJoeFactory with the sender's address, provided it hasn't been initialized previously."
fcf27aba688e291e62d137994d6424fb,2526,rule,tr_incentiveIssuerRefundChanges,224,234,createPair,"rule tr_incentiveIssuerRefundChanges(method f){     
    uint256 incentivesBefore = tokenIncentiveIssuerRefund();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentiveIssuerRefund();
    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, ""tokenIncentiveIssuerRefund was changed by wrong method"";
}
","createPair (Lines 402-450), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEVarTran.spec,rocket_joe,,Yes,,"Functionality: The given code creates a liquidity pool pair between WAVAX and another token, ensuring no existing active pair, adjusting token allocation based on a floor price, depositing AVAX and tokens into the pair, and emitting an event upon creation."
db68f601d7b9981db74ae39de81afd1e,2515,rule,cl_userAllocUnchanging,279,293,currentPhase,"rule cl_userAllocUnchanging(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 userAllocationBefore = getUserAllocation(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 userAllocationAfter = getUserAllocation(user);
    assert userAllocationBefore == userAllocationAfter, ""userAllocation was changed"";
}
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,rocket_joe,,Yes,,"Functionality: Determine the current phase of an auction based on the blockchain's timestamp relative to the auction's start time and predefined durations for the first two phases, returning the applicable phase among 'NotStarted', 'PhaseOne', 'PhaseTwo', or 'PhaseThree'."
e7c006600bd7639168a991269eb11cf2,2516,rule,cl_userBalanceFixed,315,329,currentPhase,"rule cl_userBalanceFixed(method f, env e, address user) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 balanceBefore = getUserBalance(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 balanceAfter = getUserBalance(user);
    assert balanceBefore == balanceAfter, ""userBalance was changed"";
}
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,rocket_joe,,Yes,,"Functionality: Determine the current phase of an auction based on the current timestamp in relation to the auction's start time and the durations of its first two phases, returning the appropriate phase indicator among 'NotStarted', 'PhaseOne', 'PhaseTwo', or 'PhaseThree'."
fabc916264f84f1f9ea1f559c05a2f34,2513,invariant,cl_avaxReservCheck,260,267,currentPhase,"invariant cl_avaxReservCheck()
    closed() => avaxReserve() == 0
    { 
        preserved with (env e2) { 
            require currentPhase(e2) == PhaseThree();
            safeAssumptions(e2); 
        } 
    }
","currentPhase (Lines 319-330), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
",./rocket_joe/spec/LEValidStates.spec,rocket_joe,,Yes,,"Functionality: Determine and return the current phase of an auction based on the elapsed time since its start. It considers the auction not started, in phase one, in phase two, or has moved into phase three according to predefined phase durations."
ec112847ccd9377b93501972bf878ff3,2364 | 2365,rule,transition_balThisZero,2,19,currentPhase | createPair,"rule transition_balThisZero(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 wavaxBalanceBefore = getWAVAXbalanceOfThis();
    uint256 wavaxPairBalanceBefore = getWAVAXbalanceOfPair();
    uint256 avaxAllocBefore = avaxAllocated();
    require open();
    calldataarg args;
    createPair(e);
    require closed();
    uint256 wavaxBalanceAfter = getWAVAXbalanceOfThis();
    assert wavaxBalanceBefore == wavaxBalanceAfter, ""wavax balance of LE contract was changed"";
    assert getWAVAXbalanceOfPair() - wavaxPairBalanceBefore == avaxAllocated(), ""correlation is wrong"";
}
","currentPhase (Lines 319-330),  | createPair (Lines 402-450), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
",./rocket_joe/spec/LEInProgress.spec,rocket_joe,,Yes,,"Functionality: Calculate auction phases based on elapsed time, and if in phase three, create or update a liquidity pool between WAVAX and a custom token. Adjust token allocation if the set floor price is not met, deposit AVAX, transfer assets to the pool, and mint liquidity provider tokens."
d9a904660290d17581d5a5b74248d145,2536,rule,hl_noDepositFrontRun,110,128,depositAVAX,"rule hl_noDepositFrontRun(method f, env e, env e2){
    require open();
    require e.msg.sender != e2.msg.sender;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, ""frontrun on Deposit"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LEHighLevel.spec,rocket_joe,,Yes,,"Functionality: Allow non-issuer users in PhaseOne to deposit AVAX into the contract if their total investment doesn't exceed the maximum allocation, with the requirement to burn rJoe tokens proportional to any allocation beyond their existing amount, increasing their balance and the contract's AVAX reserve."
fd9b6856eb83d37bb9d598b39f647c98,2542 | 2543 | 2544 | 2545,rule,hl_whatShouldRevert,212,224,depositAVAX | withdrawAVAX | createPair | withdrawLiquidity,"rule hl_whatShouldRevert(method f, env e){
    require stopped();

    calldataarg args;
    f@withrevert(e, args);
    assert((f.selector == depositAVAX().selector
                || f.selector == withdrawAVAX(uint256).selector
                || f.selector == createPair().selector
                || f.selector == withdrawLiquidity().selector)
                => lastReverted, 
                ""function was not reverted"");
}
","depositAVAX (Lines 333-370),  | withdrawAVAX (Lines 374-398),  | createPair (Lines 402-450),  | withdrawLiquidity (Lines 453-470), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];

        uint256 balance = pairBalance(msg.sender);
        require(balance > 0, ""LaunchEvent: caller has no liquidity to claim"");

        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }
",./rocket_joe/spec/LEHighLevel.spec,rocket_joe,,Yes,,"Functionality: Manage user interactions with a launch event, including depositing and withdrawing AVAX, adjusting allocations based on rJOE token burns, creating a liquidity pair, and allowing users to withdraw their liquidity. This process involves fee deductions, rewards adjustments, and ensuring phase-specific conditions are met."
dff780ce81cd09ddb05ec132212febc1,2486 | 2487,rule,cl_unchangingPair,887,899,allowEmergencyWithdraw | initialize,"rule cl_unchangingPair(method f, env e){
    require pair() != 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore == pairAfter, ""pair was changed in close stage"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Enable the RocketJoeFactory's owner to trigger an emergency stop by setting the 'stopped' variable to true, emitting a 'Stopped' event. Also, initialize the 'rocketJoeFactory' variable with the sender's address if not previously initialized, ensuring it can only be set once."
e6b78647bd448fbfefeb789e27afb31c,2497 | 2498,rule,cl_tokenIncentivesBalanceCanBeZero,1025,1038,emergencyWithdraw | initialize,"rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){
    require initialized();          // initialize()

    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();
    require tokenIncentivesBalanceBefore > 0;
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();
    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, ""tokenIncentivesBalance is 0 unintentionally"";
}
","emergencyWithdraw (Lines 154-164),  | initialize (Lines 28-35), ","    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Allow users to perform an emergency withdrawal of their staked tokens, resetting their staked amount and reward debt to zero, reducing the total tokens staked accordingly, and safely transferring the withdrawn amount to their address. Additionally, initialize the contract by setting the factory address, provided it hasn't been set before."
e805743084db7a353cbe3e664f66e35a,2453 | 2454,rule,op_token_res_fixed,574,591,allowEmergencyWithdraw | initialize,"rule op_token_res_fixed(method f, env e) {

    require pair() == 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    require initialized();
    require !stopped();
    uint256 tokenReserveBefore = tokenReserve();
    calldataarg args;
    f(e, args);
    uint256 tokenReserveAfter = tokenReserve();
    assert tokenReserveBefore == tokenReserveAfter, ""tokenReserve was changed"";
}
","allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Enable a safeguard mechanism through `allowEmergencyWithdraw` by stopping operations if the caller is the owner of the RocketJoeFactory, signaled by emitting `Stopped`. Initialize the contract once with `initialize` by setting the `rocketJoeFactory` to the caller, ensuring it can't be re-initialized by checking its current state."
e874df90fa5327ff15858e2d0b0c7f4e,2434 | 2435 | 2436,invariant,cl_token_bal_eq_res_token,515,529,createPair | allowEmergencyWithdraw | initialize,"invariant cl_token_bal_eq_res_token()
    false

// STATUS - in progress
// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459
// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632
// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`
invariant clIncentivesCorrelation()
    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Establish a new liquidity pair between WAVAX and a token if it doesn't exist or its total supply is zero, ensuring there's enough AVAX. It dynamically adjusts token allocation based on the floor price, transfers assets to the liquidity pool, and mints new liquidity provider (LP) tokens."
e9ae07c7d4266db0cce153c367b125cf,2403,invariant,al_balance_less_than_allocation,229,241,allowEmergencyWithdraw,"invariant al_balance_less_than_allocation(address user)
    getUserBalance(user) <= getUserAllocation(user) 

// STATUS - verified
// - getUI[user].allocation <= maxAllocation
invariant al_userAllocation_less_than_maxAllocation(address user)
    getUserAllocation(user) <= maxAllocation()
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
","allowEmergencyWithdraw (Lines 543-550), ","    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Allow the function to be called only by the owner of the RocketJoeFactory contract. If the caller is the owner, set the `stopped` variable to true and emit a `Stopped` event, thus enabling an emergency withdrawal mechanism or similar emergency stop functionality."
f07c7d6af7bfce67631a5a383d927a15,2473 | 2474 | 2475,rule,op_tokenIncentivesForUsersUnchange,770,784,createPair | allowEmergencyWithdraw | initialize,"rule op_tokenIncentivesForUsersUnchange(method f, env e){
    require pair() == 0;                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);   // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    requireInvariant isInitialized();       // initialize()
    uint256 tokenIncentivesForUsersBefore = tokenIncentivesForUsers();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesForUsersAfter = tokenIncentivesForUsers();
    assert tokenIncentivesForUsersBefore == tokenIncentivesForUsersAfter, ""tokenRestokenIncentivesForUserserve was changed"";
}
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Create a liquidity pair on a decentralized exchange, adjust token allocation based on a set floor price, deposit assets into the pair, and then emit an event detailing the creation. Optionally, allow emergency withdrawal if triggered by the factory owner, and initialize the contract with a factory reference."
f089b9479bb759919decacd77cc0008c,2499,rule,hl_depositAdditivity,1097,1113,depositAVAX,"rule hl_depositAdditivity(env e, env e2){
    require e.msg.value > 0;
    require e.msg.value == 2 * e2.msg.value;
    require e.msg.sender != e2.msg.sender;

    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);
    
    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);
    require userOneBalanceBefore == userTwoBalanceBefore;
    depositAVAX(e2);
    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);
    assert userOneBalanceAfter == userTwoBalanceAfter, ""deposit is not additive"";
}
","depositAVAX (Lines 333-370), ","    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Accept non-zero AVAX deposits from non-issuer users during Phase One, unless it exceeds their max allocation. Calculate the required rJOE for additional allocations, burn it from the user's balance, update user's AVAX balance and total AVAX reserve, and emit participation details."
f46a723e8cbd488a323712dcaec4be6b,2476 | 2477 | 2478,rule,op_tokenIncentiveIssuerRefundUnchange,790,803,createPair | allowEmergencyWithdraw | initialize,"rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){
    require pair() == 0;                                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);          // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();
    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, ""tokenIncentiveIssuerRefund was changed"";
}
","createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Create a liquidity pair between WAVAX and another token during a specified phase, adjusting token allocation if a floor price is not met, and deposit both assets into the pool. Allow emergency withdrawal by the RocketJoeFactory owner, and initialize the contract ensuring it's only called once."
f51a0d1d9036676d5a89bc753d695207,2437 | 2438 | 2439 | 2440 | 2441 | 2442 | 2443,invariant,cl_nonzero_user_pair_bal,537,545,currentPhase | withdrawAVAX | createPair | emergencyWithdraw | allowEmergencyWithdraw | pairBalance | initialize,"invariant cl_nonzero_user_pair_bal(address user, env e)
    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)
    {
        preserved with (env e2){
            requireInvariant cl_not_stopped();                  // emergencyWithdraw()
            require currentPhase(e2) == PhaseThree();           // withdrawAVAX(uint256)
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","currentPhase (Lines 319-330),  | withdrawAVAX (Lines 374-398),  | createPair (Lines 402-450),  | emergencyWithdraw (Lines 154-164),  | allowEmergencyWithdraw (Lines 543-550),  | pairBalance (Lines 623-632),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function withdrawAVAX(uint256 _amount) external isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        avaxReserve -= _amount;

        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
        _safeTransferAVAX(msg.sender, amountMinusFee);
        emit UserWithdrawn(msg.sender, _amount, feeAmount);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        totalJoeStaked -= _amount;
        joe.safeTransfer(msg.sender, _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (avaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        if (msg.sender == issuer) {
            return lpSupply / 2;
        }
        return (user.balance * lpSupply) / avaxAllocated / 2;
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Implement a launch event for a token, enabling phase-based participation where users can withdraw funds with a penalty during early phases, create liquidity pairs in the final phase, permit emergency withdrawals, calculate user balances in the created pair, and initialize the event."
f82cc8f446ed13f8c14ae9cfd4c4b93f,2483 | 2484,rule,tr_incentivesForUsersChanges,849,861,createPair | initialize,"rule tr_incentivesForUsersChanges(method f){     
    uint256 incentivesBefore = tokenIncentivesForUsers();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentivesForUsers();
    assert incentivesBefore != incentivesAfter 
                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector
                || f.selector == createPair().selector, ""tokenIncentivesForUsers was changed by wrong method"";
}
","createPair (Lines 402-450),  | initialize (Lines 28-35), ","    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Create a liquidity pair between WAVAX and a specified token if no such pair exists or if the existing pair has no tokens. Adjust token allocation based on the floor price. Deposit AVAX and the allocated tokens into the liquidity pool, mint liquidity provider (LP) tokens, and emit an event detailing the creation. Initialize the contract by setting the factory address if not previously set."
f8c5392c1e72e20556ad370bd86dfc79,2491 | 2492 | 2493 | 2494 | 2495,rule,cl_pairAndTokenBalancesNonIncreasing,966,984,currentPhase | depositAVAX | createPair | allowEmergencyWithdraw | initialize,"rule cl_pairAndTokenBalancesNonIncreasing(method f, env e){
    require pair() != 0;                                // createPair()
    requireInvariant pairAndGetPairCorrelation(e);      // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant isInitialized();                   // initialize()
    require currentPhase(e) == PhaseThree();            // depositAVAX() 
    uint256 tokenBalanceBefore = getTokenBalanceOfThis();
    uint256 pairBalanceBefore = getPairBalanceOfThis();
    calldataarg args;
    f(e, args);
    uint256 tokenBalanceAfter = getTokenBalanceOfThis();
    uint256 pairBalanceAfter = getPairBalanceOfThis();
    assert tokenBalanceBefore >= tokenBalanceAfter, ""token balance was increased"";
    assert pairBalanceBefore >= pairBalanceAfter, ""pair balance was increased"";
}
","currentPhase (Lines 319-330),  | depositAVAX (Lines 333-370),  | createPair (Lines 402-450),  | allowEmergencyWithdraw (Lines 543-550),  | initialize (Lines 28-35), ","    function currentPhase() public view returns (Phase) {
        if (auctionStart == 0 || block.timestamp < auctionStart) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + phaseOneDuration) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }
 |     function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Get amount of rJOE tokens needed to burn and update allocation
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        avaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }
 |     function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        address _pair = factory.getPair(wavaxAddress, tokenAddress);
        require(
            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(avaxReserve > 0, ""LaunchEvent: no avax balance"");

        uint256 tokenDecimals = token.decimals();
        tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {
            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        avaxAllocated = avaxReserve;
        avaxReserve = 0;

        tokenReserve -= tokenAllocated;

        WAVAX.deposit{value: avaxAllocated}();
        if (_pair == address(0)) {
            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));
        } else {
            pair = IJoePair(_pair);
        }
        WAVAX.transfer(address(pair), avaxAllocated);
        token.safeTransfer(address(pair), tokenAllocated);
        lpSupply = pair.mint(address(this));

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            avaxAllocated
        );
    }
 |     function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }
 |     function initialize() external {
        require(
            address(rocketJoeFactory) == address(0),
            ""RocketJoeToken: already initialized""
        );

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
    }
",./rocket_joe/spec/LaunchEvent.spec,rocket_joe,,Yes,,"Functionality: Determine the current phase of the auction, accept AVAX deposits during Phase One while ensuring deposits do not exceed max allocation and participants are not the issuer, create a liquidity pair in Phase Three if one does not exist or has no supply, enable emergency withdrawal, and initialize the contract once."
11af76f89f8ed9916919a17956af0eb9,2341 | 2343 | 2344,rule,cannotFrontRunSplitThreeSameUsers,164,206,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,radicle_drips,,Yes,,"Functionality: Validate and perform splits of ERC20 tokens based on user-defined percentages, ensuring the distribution complies with specified limits on the number of receivers and total weight. The code also updates and validates receiver information, enforcing order and uniqueness, while emitting relevant events for tracking."
73ad8110692226b827767bbca83f889c,2331 | 2333 | 2334,rule,cannotFrontRunSplitDifferentUsers,62,112,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,radicle_drips,,Yes,,"Functionality: Validate and update the distribution of funds (splits) among multiple receivers for a given user, ensuring weights are non-zero, receivers are unique and sorted by user ID, the total weight doesn't exceed a maximum limit, and emit relevant events for changes and validations performed."
7eb4d0f3e010f270890222dad599856c,2346 | 2348 | 2349,rule,revertCharacteristicsOfSplit,210,235,split | setSplits | hashSplits,"// the rule below still fails, probably because some of the split receivers can overflow too
rule revertCharacteristicsOfSplit() {
    env e; uint256 userA_Id; uint256 assetId;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;

    // allowing only valid splitReceivers because revert is not allowed
    bytes32 receiversHash = hashSplits(e, true);
    assertSplitsValid(e, true, receiversHash);
    setSplits(e, userA_Id, true);
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    require userA_splittableBefore + userA_collectableBefore < 2^128;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    //require userA_splittableAfter + userA_collectableAfter < 2^128;
    userA_collectableAmt, userA_splitAmt = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | setSplits (Lines 109-111),  | hashSplits (Lines 523-529), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function setSplits(SplitsReceiver[] calldata receivers) public {
        dripsHub.setSplits(calcUserId(msg.sender), receivers);
    }
 |     function hashSplits(SplitsReceiver[] memory receivers)
        public
        pure
        returns (bytes32 receiversHash)
    {
        return Splits._hashSplits(receivers);
    }
",./radicle_drips/specs/Splits2.spec,radicle_drips,,Yes,,"Functionality: Split funds between different receivers based on predefined shares. Specifically, for a given user and ERC20 token, distribute a specified amount among multiple recipients and return the amounts available for collection and splitting. Additionally, allow setting and hashing of split configurations for users."
90e006dab3eafdbcf4ca9a35efef01c3,2326 | 2328 | 2329,rule,cannotFrontRunSplitGeneralCase,7,53,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,radicle_drips,,Yes,,"Functionality: Manage and validate split configurations for funds allocation among receivers based on their weights. Ensure the total weight does not exceed a predefined limit, each receiver's weight is non-zero, receiver IDs are unique and sorted, and update the split configuration only upon changes."
a33253c68f2bf1192bc92020f9ca8780,2336 | 2338 | 2339,rule,cannotFrontRunSplitTwoSameUsers,116,160,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits2.spec,radicle_drips,,Yes,,"Functionality: Facilitate the distribution of ERC20 tokens to multiple recipients based on predefined splits, validate distribution parameters including the maximum number of recipients, ensure uniqueness and order of recipients, and manage the total allocation weight within an allowed range."
005b6ddff4b8e17b64f187f8704dfbbf,2291 | 2293 | 2294,rule,sameReturnOfSplitAndSplitResults,311,347,split | _setSplits | _assertSplitsValid,"rule sameReturnOfSplitAndSplitResults() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    require userA_Id != userB_Id;   require userA_Id != userC_Id;   require userB_Id != userC_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require length == 2;
    require index1 != index2;
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 > 0;
    require weight2 > 0;
    require weight1 + weight2 <= 1000000;  // safe assumptions
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we force the receivers to be only two, therefore totalWeight = weight1 + weight2
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // calling splitResults() upon userA with amount = userA.splittable
    uint128 userA_splitAmt_splitResults; uint128 userA_collectableAmt_splitResults;
    userA_collectableAmt_splitResults, userA_splitAmt_splitResults = splitResults(e, userA_Id, true, userA_splittableBefore);
    
    // calling split() on userA
    uint128 userA_collectableAmt_split; uint128 userA_splitAmt_split;
    userA_collectableAmt_split, userA_splitAmt_split = split(e, userA_Id, assetId, true);
    assert userA_collectableAmt_split == userA_collectableAmt_splitResults;
    assert userA_splitAmt_split == userA_splitAmt_splitResults;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Validate and record split configurations for distributing ERC20 tokens among multiple recipients. This involves checking that the number of receivers and their cumulative weights do not exceed predefined limits, ensuring receiver weights are non-zero, verifying no duplicate or improperly ordered user IDs, and updating or asserting the validity of the split configurations based on their hash."
0d6904cd3ffe9cfd294659decc320b06,2274,rule,correctnessOfHashSplits,118,133,hashSplits,"rule correctnessOfHashSplits() {
    env e; uint256 index; uint256 length1; uint256 length2;  
    uint256 userId1; uint32 weight1; uint256 userId2; uint32 weight2;
    bytes32 receiversHash1; bytes32 receiversHash2;

    length1 = getCurrSplitsReceiverLocaLength(e, true);
    length2 = getCurrSplitsReceiverLocaLength(e, false);
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index);
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, false, index);
    receiversHash1 = hashSplits(e, true);
    receiversHash2 = hashSplits(e, false);
    assert (receiversHash1 == receiversHash2) => ((length1 == length2) && (userId1 == userId2) && (weight1 == weight2));
}
","hashSplits (Lines 523-529), ","    function hashSplits(SplitsReceiver[] memory receivers)
        public
        pure
        returns (bytes32 receiversHash)
    {
        return Splits._hashSplits(receivers);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Calculate and return the hash of an array of `SplitsReceiver` structures passed as input, using the `_hashSplits` function from the `Splits` contract or library. This operation is performed in a pure context, implying it doesn't read or modify the contract's state."
15a880ab42e336b40741cbed721b28d0,2271,rule,correctnessOfGive,86,95,give,"rule correctnessOfGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint128 splittableBefore; uint128 splittableAfter;

    splittableBefore = splittable(e, receiver, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, receiver, assetId);
    assert splittableAfter == splittableBefore + amt;
}
","give (Lines 65-72), ","    function give(
        uint256 receiver,
        IERC20 erc20,
        uint128 amt
    ) public {
        _transferFromCaller(erc20, amt);
        dripsHub.give(calcUserId(msg.sender), receiver, erc20, amt);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Transfer a specified amount of an ERC20 token from the caller's account to a designated receiver through the DripsHub contract. This involves first transferring the token amount from the caller to the executing contract, then invoking the DripsHub's `give` method to facilitate the transfer to the receiver."
3ded8f364c58fc26f378cfa2fc76f8b7,2281 | 2283 | 2284,rule,assetsDoNotInterfereEachOther,216,260,split | _setSplits | _assertSplitsValid,"rule assetsDoNotInterfereEachOther() {
    env e; uint256 assetId1; uint256 assetId2; uint256 userA_Id; uint256 userB_Id;

    // make sure the users/assets are not the same
    require userA_Id != userB_Id;
    require assetId1 != assetId2;
    // recording the state before split()
    uint128 userA_splittableAssetId1_Before = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_Before = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_Before = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_Before = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_Before = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_Before = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_Before = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_Before = collectable(e, userB_Id, assetId2);
    // calling the split() for userA over assertId1
    uint128 userA_collectableAmtAssetId1; uint128 userA_splitAmtAssetId1;
    userA_collectableAmtAssetId1, userA_splitAmtAssetId1 = split(e, userA_Id, assetId1, true);
    // recording the state after split()
    uint128 userA_splittableAssetId1_After = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_After = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_After = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_After = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_After = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_After = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_After = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_After = collectable(e, userB_Id, assetId2);
    // the expectation:
    // splittable and collectable for any user's assetId2 stays the same
    assert userA_splittableAssetId2_After == userA_splittableAssetId2_Before;
    assert userA_collectableAssetId2_After == userA_collectableAssetId2_Before;
    assert userB_splittableAssetId2_After == userB_splittableAssetId2_Before;
    assert userB_collectableAssetId2_After == userB_collectableAssetId2_Before;
    // the collectable of userB's assetId1 should not be affected by the split
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_collectableAssetId1_After == userB_collectableAssetId1_Before;
    // the splittable of userB's assetId1 should not decrease
    assert userB_splittableAssetId1_After >= userB_splittableAssetId1_Before;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Split a user's funds between multiple receivers according to predefined weights, validate the receivers and weights ensuring no duplicates, the weights are not zero, receivers are sorted by user ID, and the total weight does not exceed a maximum limit, then update or affirm the split configuration if valid."
4227f00ee484759743eac597f2a71ae8,2263,rule,correctnessOfSplitResults,26,32,split,"rule correctnessOfSplitResults() {
rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
    env e; uint256 userId; uint128 amount; uint128 collectableAmt; uint128 splitAmt;
    collectableAmt, splitAmt = splitResults(e, userId, true, amount);
    assert amount == collectableAmt + splitAmt;
","split (Lines 343-349), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Execute a split operation for a user's assets in an ERC20 token among specified receivers. It calculates and returns the amount collectable by the user and the amount to be distributed among the receivers after invoking an internal `_split` function with the user's ID, the token's asset ID, and the current receivers' details."
4ab50f0aab632ef906f191e4844d9720,2258 | 2260 | 2261,invariant,moneyNotLostOrCreatedDuringSplit,267,303,split | _setSplits | _assertSplitsValid,"/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Split assets among multiple receivers according to predefined weights, ensuring no duplicate or unordered entries, weights are non-zero, the number of receivers doesn't exceed the maximum limit, and the total of weights doesn't surpass the allowed sum."
5c85eb443563087c5f36051ce4a6f982,2301 | 2303 | 2304,rule,equalSplitWeightsResultEqualSplittableIncrease,413,456,split | _setSplits | _assertSplitsValid,"rule equalSplitWeightsResultEqualSplittableIncrease() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;

    // all the 3 users are different
    require userA_Id != userB_Id; require userA_Id != userC_Id; require userB_Id != userC_Id;
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1; uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 2;            // only two split receivers
    require index1 != index2;       // different indexes sample different splitReceivers
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 == weight2;
    require weight1 <= 500000;      // safe assumption since MAX _TOTAL_SPLITS_WEIGHT == 1000000
    require weight1 > 0;            // safe assumption
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId); 
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    require userA_splittableBefore > 0; // there is a splittable amount to be split
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    // the splittable balances of userB and userC will increase by the same amount
    // in case of rounding - diffrence between amounts can be 1
    uint128 userB_splittableChange = userB_splittableAfter - userB_splittableBefore;
    uint128 userC_splittableChange = userC_splittableAfter - userC_splittableBefore;
    assert ((userC_splittableChange == userB_splittableChange) || 
            (userB_splittableChange == userC_splittableChange + 1) || 
            (userC_splittableChange == userB_splittableChange + 1));    
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Split tokens among receivers based on predefined rules, ensuring the total weight of all receivers does not exceed the maximum limit and that receivers are unique and sorted by user ID. Emit events for each receiver seen and when a new split configuration is set."
5f31cac0ec2512fbaf4dd3312ab8604d,2296 | 2298 | 2299,rule,moneyNotLostOrCreatedDuringSplit,355,406,split | _setSplits | _assertSplitsValid,"/// Note: this rule fails!
/// In cases when userB weight is small, the calculation for the split
/// will be rounded down to zero, therefore the receiver will get nothing!
///
/// Possible abuse vector:
/// split is called every time when the splittable balance of userA is so low, 
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// so that rounding error will cause the splitReceiver userB to get zero
/// as a result userA will get all the splittable to himself
/// Severity: low
/// The one who will benefit the abuse is the splitter,
/// but he is also the one that in advance decided who
/// are going to be his splitReceivers
rule splitReceiverShouldGetMoneyUponSplit() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id;
    require userA_Id != userB_Id;
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userB_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;         // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    require userA_splittableBefore > 0;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    // the expectation: the splittable balance of userB should increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_splittableAfter > userB_splittableBefore;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Implement a system for distributing assets among multiple receivers based on predefined splits. This involves validating and recording the distribution parameters, ensuring no identical receivers exist and that their combined weights do not exceed a specified limit, while allowing updates to these parameters when necessary."
82c40e04f3e556bbdf4feac170959366,2266,rule,correctnessOfSplit,38,55,split,"rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
","split (Lines 343-349), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Perform a funds split for a specific user and ERC20 token, distributing amounts to specified receivers. This method calculates the collectable and split amounts based on current receiver configurations, using the internal `_split` function and pausing execution if the contract is paused."
8744b9e874dbd54853aaebcc27d8c0f1,2286 | 2288 | 2289,rule,moneyNotLostOrCreatedDuringSplit,268,303,split | _setSplits | _assertSplitsValid,"rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Enable split transactions for a user with specified ERC20 tokens among designated receivers based on their weights, ensuring each transaction adheres to constraints such as the maximum number of receivers, receiver weight conditions, and the sorting and uniqueness of receivers user IDs."
90a6b394d17ec347fccba99e4b390a9f,2276 | 2278 | 2279,rule,integrityOfSplit,143,209,split | _setSplits | _assertSplitsValid,"rule integrityOfSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id; uint256 userC_Id; uint256 userD_Id;
    
    require userA_Id != userB_Id;   require userA_Id != userD_Id;
    require userA_Id != userC_Id;   require userB_Id != userD_Id;
    require userB_Id != userC_Id;   require userC_Id != userD_Id;

    // obtaining splittable/collectable states before calling split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    require userA_splittableBefore > 0;
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    uint128 userD_splittableBefore = splittable(e, userD_Id, assetId);
    uint128 userD_collectableBefore = collectable(e, userD_Id, assetId);
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require index1 != index2;     // different indexes sample different splitReceivers
    require userId1 == userB_Id;  // userB is on the list of splitReceivers of userA
    require userId2 != userC_Id;  // the second splitReceiver is not userC
    require userId2 != userA_Id;  // the second splitReceiver is not the splitter itself
    require userId2 == userD_Id;  // since we run with loop_iter 2, there are max 2 receivers
    // obtaining splittable/collectable states after calling split()
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    uint128 userC_collectableAfter = collectable(e, userC_Id, assetId);
    uint128 userD_splittableAfter = splittable(e, userD_Id, assetId);
    uint128 userD_collectableAfter = collectable(e, userD_Id, assetId);
    // UserA's splittable should NOT increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userA_splittableAfter <= userA_splittableBefore;
    assert userA_splittableAfter == 0; // it should be zero
    // UserB is on the list of UserA's splitters, therefore ""userB's splittable should NOT decrease""
    assert userB_splittableAfter >= userB_splittableBefore;
    // UserC is NOT on the list of UserA's splitters, therefore ""userC's splittable should NOT change""
    assert userC_splittableAfter == userC_splittableBefore;
    // UserA's collectable should NOT decrease, UserB and UserC's collectable should NOT change
    assert userA_collectableAfter >= userA_collectableBefore;
    assert userB_collectableAfter == userB_collectableBefore;
    assert userC_collectableAfter == userC_collectableBefore;
    // The increase of the splittable of the receivers userB and userD should be equal the splittable of userA
    assert (userB_splittableAfter - userB_splittableBefore) +
           (userD_splittableAfter - userD_splittableBefore) +
           (userA_collectableAfter - userA_collectableBefore) == userA_splittableBefore;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Validate and update a user's split configurations, ensuring the total weights do not exceed a set limit, receivers have non-zero weights, are unique, properly sorted, and do not exceed a maximum number. Emit relevant events for updated splits and observed receivers for tracking purposes."
9e2a90db6c8efff8410d5314e955ae43,2311 | 2313 | 2314,rule,cannotFrontRunSplitDifferentUsers,532,582,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Validate and set weighted splits among receivers for a specified user, ensuring no duplicate or incorrectly ordered entries, and that total weights do not exceed a maximum limit. Emit relevant events for both setting new splits and confirming individual receiver details."
abc924047280f8e35bbce99504c76972,2316 | 2318 | 2319,rule,cannotFrontRunSplitTwoSameUsers,586,630,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Validate and report on the distribution of ERC20 tokens to multiple receivers based on predefined weightings. This involves ensuring no receiver is skipped or duplicated, the overall distribution does not exceed set limits, and weightings are non-zero and properly ordered by user ID."
afbd308dc3c9d44c53f17f445a773d78,2273,rule,splittableOfNonReceiverNotAffectedByGive,100,111,give,"rule splittableOfNonReceiverNotAffectedByGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint256 otherUser; uint128 splittableBefore; uint128 splittableAfter;

    require otherUser != receiver;
    splittableBefore = splittable(e, otherUser, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, otherUser, assetId);
    assert splittableAfter == splittableBefore;
}
","give (Lines 65-72), ","    function give(
        uint256 receiver,
        IERC20 erc20,
        uint128 amt
    ) public {
        _transferFromCaller(erc20, amt);
        dripsHub.give(calcUserId(msg.sender), receiver, erc20, amt);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Transfer a given amount of ERC20 tokens from the caller's account to another specified account, using the sender's account details to calculate the user ID. The transfer is executed by first pulling the specified amount of tokens from the caller and then invoking the `dripsHub.give` method to facilitate the transaction to the receiver."
b3a846592b121beff19f973c9e12938b,2269,rule,integrityOfCollect,60,68,collect,"rule integrityOfCollect() {
    env e; uint256 userId; uint256 assetId;
    uint128 collectedAmt; uint128 collectableAfter;

    collectedAmt = collect(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert collectableAfter == 0;
}
","collect (Lines 54-57), ","    function collect(address user, IERC20 erc20) public returns (uint128 amt) {
        amt = dripsHub.collect(calcUserId(user), erc20);
        erc20.safeTransfer(user, amt);
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Collect pending tokens for a user from the DripsHub contract and transfer them to the user's address. This is achieved by first calculating the user's ID based on their address, then collecting the tokens using the `collect` function of the DripsHub, and finally transferring the collected tokens to the user via the ERC20 `safeTransfer` method."
c2f9834187a43439ecbde091a21c5d84,2321 | 2323 | 2324,rule,cannotFrontRunSplitThreeSameUsers,634,676,split | _setSplits | _assertSplitsValid,"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Split assets among receivers based on predefined weights, ensuring the total split does not exceed limits and receivers are unique, sorted, and have non-zero weights. Emit events for setting new splits and seeing individual receivers, while validating receiver count and total weight."
efff4092bc3b8f8ce76091de03bbe3cb,2306 | 2308 | 2309,rule,cannotFrontRunSplitGeneralCase,466,523,split | _setSplits | _assertSplitsValid,"        ""This rule should always fail"";
}
*/

/// @notice front running split() does not affect receiver
/// userA has a single splitReceiver userC
/// userB also has the same single splitReceiver UserC
/// we want to verify split() can be called on userA successfully
/// even if someone front runs it and calls splits() first on userB
/// no assumptions about userA, userB, userC
rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Enable the division of incoming funds or assets among multiple recipients based on predefined criteria. Verify the number of receivers and their weights do not exceed specified limits, ensure no duplicate or zero-weight receivers, and enforce that receivers are sorted by user ID."
efff4092bc3b8f8ce76091de03bbe3cb,2306 | 2308 | 2309,rule,cannotFrontRunSplitGeneralCase,466,523,split | _setSplits | _assertSplitsValid,"        ""This rule should always fail"";
}
*/

/// @notice front running split() does not affect receiver
/// userA has a single splitReceiver userC
/// userB also has the same single splitReceiver UserC
/// we want to verify split() can be called on userA successfully
/// even if someone front runs it and calls splits() first on userB
/// no assumptions about userA, userB, userC
rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","split (Lines 343-349),  | _setSplits (Lines 215-223),  | _assertSplitsValid (Lines 229-247), ","    function split(
        uint256 userId,
        IERC20 erc20,
        SplitsReceiver[] memory currReceivers
    ) public whenNotPaused returns (uint128 collectableAmt, uint128 splitAmt) {
        return Splits._split(userId, _assetId(erc20), currReceivers);
    }
 |     function _setSplits(uint256 userId, SplitsReceiver[] memory receivers) internal {
        SplitsState storage state = _splitsStorage().splitsStates[userId];
        bytes32 newSplitsHash = _hashSplits(receivers);
        emit SplitsSet(userId, newSplitsHash);
        if (newSplitsHash != state.splitsHash) {
            _assertSplitsValid(receivers, newSplitsHash);
            state.splitsHash = newSplitsHash;
        }
    }
 |     function _assertSplitsValid(SplitsReceiver[] memory receivers, bytes32 receiversHash) internal {
        require(receivers.length <= _MAX_SPLITS_RECEIVERS, ""Too many splits receivers"");
        uint64 totalWeight = 0;
        uint256 prevUserId;
        for (uint256 i = 0; i < receivers.length; i++) {
            SplitsReceiver memory receiver = receivers[i];
            uint32 weight = receiver.weight;
            require(weight != 0, ""Splits receiver weight is zero"");
            totalWeight += weight;
            uint256 userId = receiver.userId;
            if (i > 0) {
                require(prevUserId != userId, ""Duplicate splits receivers"");
                require(prevUserId < userId, ""Splits receivers not sorted by user ID"");
            }
            prevUserId = userId;
            emit SplitsReceiverSeen(receiversHash, userId, weight);
        }
        require(totalWeight <= _TOTAL_SPLITS_WEIGHT, ""Splits weights sum too high"");
    }
",./radicle_drips/specs/Splits.spec,radicle_drips,,Yes,,"Functionality: Validate and record splitting configurations for users, ensuring that each split configuration has unique, non-zero-weighted receivers sorted by user ID, does not exceed the maximum number of receivers or the total permissible weight, and emits events for changes in splits settings and validations."
66f2b20b65aa41d905a3c172269c3af9,2358 | 2359,rule,whoChangedUserState,61,81,addUser | removeUser,"rule whoChangedUserState(method f) {
    env e;
    calldataarg args;
    
    address userA;
    address userB;

    bool isUserBefore;
    bool isUserAfter;
    isUserBefore = getIsUser(e, userB);
    f(e,args);
    // addUser(userA);
    // removeUser(userA);
    // require userA != userB;
    isUserAfter = getIsUser(e, userB);
    assert isUserBefore == isUserAfter;
}
","addUser (Lines 242-245),  | removeUser (Lines 249-252), ","    function addUser(address user) public onlyOwner {
        isUser[user] = true;
        emit UserAdded(msg.sender, user);
    }
 |     function removeUser(address user) public onlyOwner {
        isUser[user] = false;
        emit UserRemoved(msg.sender, user);
    }
",./radicle_drips/specs/Reserve.spec,radicle_drips,,Yes,,"Functionality: Enable the contract's owner to add or remove users by modifying their status in a mapping (`isUser`). When a user is added or removed, trigger an event (`UserAdded` or `UserRemoved`) to log the action, including the owner's address and the user's address."
b1f5b3ed12104f84713e6c4573472c99,2360 | 2361,rule,totalMoneyIsConstant,84,116,deposit | withdraw,"rule totalMoneyIsConstant(method f) {
    env e; // env eB; env eF;
    calldataarg args;

    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 balanceOfUserBefore;    uint256 balanceOfUserAfter;
    uint256 balanceOfReserveBefore; uint256 balanceOfReserveAfter;
    uint256 depositedBefore;        uint256 depositedAfter;
    balanceOfUserBefore = dummyERC20Token.balanceOf(user);
    balanceOfReserveBefore = dummyERC20Token.balanceOf(reserveH);
    depositedBefore = getDeposited(dummyERC20Token);
    require depositedBefore == balanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(dummyERC20Token) == 0;
    deposit(e, dummyERC20Token, user, amtDeposited);
    //f(e,args);
    withdraw(e, dummyERC20Token, user, amtWithdrawn);
    require amtDeposited == amtWithdrawn;
    balanceOfUserAfter = dummyERC20Token.balanceOf(user);
    balanceOfReserveAfter = dummyERC20Token.balanceOf(reserveH);
    depositedAfter = getDeposited(dummyERC20Token);
    assert balanceOfUserBefore == balanceOfUserAfter;
    //assert balanceOfUserBefore + balanceOfReserveBefore == balanceOfUserAfter + balanceOfReserveAfter;
    //assert depositedAfter == depositedBefore + amtDeposited - amtWithdrawn;
}
","deposit (Lines 171-182),  | withdraw (Lines 191-203), ","    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }
 |     function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }
",./radicle_drips/specs/Reserve.spec,radicle_drips,,Yes,,"Functionality: Facilitate the deposit and withdrawal of tokens by users while ensuring transactions do not originate from or go to restricted addresses. Adjust token balances accordingly and optionally engage a plugin's logic before withdrawal or after deposition, emitting respective events for tracking."
c6cb1116ac2d4ba6a0a58edecaf666ac,2357,rule,ideas,2,34,afterStart,"// rule ideas for verification of the functions in Reserve.sol
// ///////////////////////////////////////////////////////////////

using DummyERC20Impl as dummyERC20Token
using DummyERC20A as tokenA
using DummyERC20B as tokenB
using ReserveHarness as reserveH
methods{
    ////////////////////////////////////////
	// ERC20 methods
	transferFrom(address, address, uint256) => DISPATCHER(true)
	transfer(address, uint256) => DISPATCHER(true)
	//
    tokenA.balanceOf(address) envfree
	tokenB.balanceOf(address) envfree
	dummyERC20Token.balanceOf(address) envfree
    tokenA.totalSupply() envfree
	tokenB.totalSupply() envfree
	dummyERC20Token.totalSupply() envfree
    transfer() => DISPATCHER(true)
    // Call resolutions for IReservePlugin
    afterStart(address, uint256) => NONDET //HAVOC_ALL
    afterDeposition(address, uint256) => NONDET //HAVOC_ALL
    beforeWithdrawal(address, uint256) => NONDET //HAVOC_ALL
    beforeEnd(address, uint256) => NONDET //HAVOC_ALL
    reserveH.getDeposited(address) envfree
    reserveH.getPlugins(address) envfree
}
","afterStart (Lines 41-267), ","    function afterStart(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve immediately after
    /// transferring funds to the plugin for deposition.
    /// @param token The used token.
    /// @param amt The amount which has been transferred for deposition.
    function afterDeposition(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve right before transferring funds for withdrawal.
    /// The reserve will `transferFrom` the tokens from the plugin address.
    /// The reserve can always withdraw everything that has been ever deposited, but never more.
    /// @param token The used token.
    /// @param amt The amount which will be transferred.
    function beforeWithdrawal(IERC20 token, uint256 amt) external;

    /// @notice Called by the reserve when it stops using the plugin,
    /// right before transferring from the plugin all the deposited funds.
    /// The reserve will `transferFrom` the tokens from the plugin address.
    /// This final transfer won't trigger the regular call to `beforeWithdrawal`.
    /// @param token The used token.
    /// @param amt The amount which will be transferred.
    function beforeEnd(IERC20 token, uint256 amt) external;
}

/// @notice The ERC-20 tokens reserve contract.
/// The registered users can deposit and withdraw funds.
/// The reserve by default doesn't do anything with the tokens,
/// but for each ERC-20 address a plugin can be registered for tokens storage.
contract Reserve is IReserve, Ownable {
    using SafeERC20 for IERC20;
    /// @notice The dummy plugin address meaning that no plugin is being used.
    IReservePlugin public constant NO_PLUGIN = IReservePlugin(address(0));

    /// @notice A set of addresses considered users.
    /// The value is `true` if an address is a user, `false` otherwise.
    mapping(address => bool) public isUser;
    /// @notice How many tokens are deposited for each token address.
    mapping(IERC20 => uint256) public deposited;
    /// @notice The reserved plugins for each token address.
    mapping(IERC20 => IReservePlugin) public plugins;

    /// @notice Emitted when a plugin is set.
    /// @param owner The address which called the function.
    /// @param token The token for which plugin has been set.
    /// @param oldPlugin The old plugin address. `NO_PLUGIN` if no plugin was being used.
    /// @param newPlugin The new plugin address. `NO_PLUGIN` if no plugin will be used.
    /// @param amt The amount which has been withdrawn
    /// from the old plugin and deposited into the new one.
    event PluginSet(
        address owner,
        IERC20 indexed token,
        IReservePlugin indexed oldPlugin,
        IReservePlugin indexed newPlugin,
        uint256 amt
    );

    /// @notice Emitted when funds are deposited.
    /// @param user The address which called the function.
    /// @param token The used token.
    /// @param from The address from which tokens have been transferred.
    /// @param amt The amount which has been deposited.
    event Deposited(address user, IERC20 indexed token, address indexed from, uint256 amt);

    /// @notice Emitted when funds are withdrawn.
    /// @param user The address which called the function.
    /// @param token The used token.
    /// @param to The address to which tokens have been transferred.
    /// @param amt The amount which has been withdrawn.
    event Withdrawn(address user, IERC20 indexed token, address indexed to, uint256 amt);

    /// @notice Emitted when funds are force withdrawn.
    /// @param owner The address which called the function.
    /// @param token The used token.
    /// @param plugin The address of the plugin from which funds have been withdrawn or
    /// `NO_PLUGIN` if from the reserve itself.
    /// @param to The address to which tokens have been transferred.
    /// @param amt The amount which has been withdrawn.
    event ForceWithdrawn(
        address owner,
        IERC20 indexed token,
        IReservePlugin indexed plugin,
        address indexed to,
        uint256 amt
    );

    /// @notice Emitted when an address is registered as a user.
    /// @param owner The address which called the function.
    /// @param user The registered user address.
    event UserAdded(address owner, address indexed user);

    /// @notice Emitted when an address is unregistered as a user.
    /// @param owner The address which called the function.
    /// @param user The unregistered user address.
    event UserRemoved(address owner, address indexed user);

    /// @param owner The initial owner address.
    constructor(address owner) {
        transferOwnership(owner);
    }

    modifier onlyUser() {
        require(isUser[msg.sender], ""Reserve: caller is not the user"");
        _;
    }

    /// @notice Sets a plugin for a given token.
    /// All future deposits and withdrawals of that token will be made using that plugin.
    /// All currently deposited tokens of that type will be withdrawn from the plugin previously
    /// set for that token and deposited into the new one.
    /// If no plugin has been set, funds are deposited from the reserve itself.
    /// If no plugin is being set, funds are deposited into the reserve itself.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param newPlugin The new plugin address. `NO_PLUGIN` if no plugin should be used.
    function setPlugin(IERC20 token, IReservePlugin newPlugin) public onlyOwner {
        IReservePlugin oldPlugin = plugins[token];
        plugins[token] = newPlugin;
        uint256 amt = deposited[token];
        if (oldPlugin != NO_PLUGIN) oldPlugin.beforeEnd(token, amt);
        _transfer(token, _pluginAddr(oldPlugin), _pluginAddr(newPlugin), amt);
        if (newPlugin != NO_PLUGIN) newPlugin.afterStart(token, amt);
        emit PluginSet(msg.sender, token, oldPlugin, newPlugin, amt);
    }

    /// @notice Deposits funds into the reserve.
    /// The reserve will `transferFrom` `amt` tokens from the `from` address.
    /// Callable only by a current user.
    /// @param token The used token.
    /// @param from The address from which funds are deposited.
    /// @param amt The deposited amount.
    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }

    /// @notice Withdraws funds from the reserve.
    /// The reserve will transfer `amt` tokens to the `to` address.
    /// Only funds previously deposited can be withdrawn.
    /// Callable only by a current user.
    /// @param token The used token.
    /// @param to The address to which funds are withdrawn.
    /// @param amt The withdrawn amount.
    function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }

    /// @notice Withdraws funds from the reserve or a plugin.
    /// The reserve will transfer `amt` tokens to the `to` address.
    /// The function doesn't update the deposited amount counter.
    /// If used recklessly, it may cause a mismatch between the counter and the actual balance
    /// making valid future calls to `withdraw` or `setPlugin` fail due to lack of funds.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param plugin The plugin to withdraw from.
    /// It doesn't need to be registered as a plugin for `token`.
    /// Pass `NO_PLUGIN` to withdraw directly from the reserve balance.
    /// @param to The address to which funds are withdrawn.
    /// @param amt The withdrawn amount.
    function forceWithdraw(
        IERC20 token,
        IReservePlugin plugin,
        address to,
        uint256 amt
    ) public onlyOwner {
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit ForceWithdrawn(msg.sender, token, plugin, to, amt);
    }

    /// @notice Sets the deposited amount counter for a token without transferring any funds.
    /// If used recklessly, it may cause a mismatch between the counter and the actual balance
    /// making valid future calls to `withdraw` or `setPlugin` fail due to lack of funds.
    /// It may also make the counter lower than what users expect it to be again making
    /// valid future calls to `withdraw` fail.
    /// Callable only by the current owner.
    /// @param token The used token.
    /// @param amt The new deposited amount counter value.
    function setDeposited(IERC20 token, uint256 amt) public onlyOwner {
        deposited[token] = amt;
    }

    /// @notice Adds a new user.
    /// @param user The new user address.
    function addUser(address user) public onlyOwner {
        isUser[user] = true;
        emit UserAdded(msg.sender, user);
    }

    /// @notice Removes an existing user.
    /// @param user The removed user address.
    function removeUser(address user) public onlyOwner {
        isUser[user] = false;
        emit UserRemoved(msg.sender, user);
    }

    function _pluginAddr(IReservePlugin plugin) internal view returns (address) {
        return plugin == NO_PLUGIN ? address(this) : address(plugin);
    }

    function _transfer(
        IERC20 token,
        address from,
        address to,
        uint256 amt
    ) internal {
        if (from == address(this)) token.safeTransfer(to, amt);
        else token.safeTransferFrom(from, to, amt);
    }
}
",./radicle_drips/specs/Reserve.spec,radicle_drips,,Yes,,"Functionality: Manage ERC-20 token deposits and withdrawals in a reserve, enabling fund transfer between the reserve, users, and plugins. It allows setting up token-specific plugins for managing tokens, adjusting deposited amounts, adding or removing users, and executing forceful withdrawals without updating deposited balance counters."
f40242dd01fb5bcfc6a3fadde0825f66,2362 | 2363,rule,tokensNonInterference,120,170,deposit | withdraw,"rule tokensNonInterference() {
    env e;
    calldataarg args;

    bool depositOrWithdraw;
    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 tokenABalanceOfUserBefore;    uint256 tokenABalanceOfUserAfter;
    uint256 tokenBBalanceOfUserBefore;    uint256 tokenBBalanceOfUserAfter;
    uint256 tokenABalanceOfReserveBefore; uint256 tokenABalanceOfReserveAfter;
    uint256 tokenBBalanceOfReserveBefore; uint256 tokenBBalanceOfReserveAfter;
    uint256 tokenADepositedBefore;        uint256 tokenADepositedAfter;
    uint256 tokenBDepositedBefore;        uint256 tokenBDepositedAfter;
    tokenABalanceOfUserBefore = tokenA.balanceOf(user);
    tokenBBalanceOfUserBefore = tokenB.balanceOf(user);
    tokenABalanceOfReserveBefore = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveBefore = tokenB.balanceOf(reserveH);
    tokenADepositedBefore = getDeposited(tokenA);
    tokenBDepositedBefore = getDeposited(tokenB);
    require tokenADepositedBefore == tokenABalanceOfReserveBefore;
    require tokenBDepositedBefore == tokenBBalanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(tokenA) == 0;
    require reserveH.getPlugins(tokenB) == 0;
    //deposit(e, tokenA, user, amtDeposited);
    //f(e,args);
    //withdraw(e, tokenA, user, amtWithdrawn);
    if (depositOrWithdraw) {
        deposit(e, tokenA, user, amtDeposited);
    } else {
        withdraw(e, tokenA, user, amtWithdrawn);
    }
    require amtDeposited == amtWithdrawn;
    tokenABalanceOfUserAfter = tokenA.balanceOf(user);
    tokenBBalanceOfUserAfter = tokenB.balanceOf(user);
    tokenABalanceOfReserveAfter = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveAfter = tokenB.balanceOf(reserveH);
    tokenADepositedAfter = getDeposited(tokenA);
    tokenBDepositedAfter = getDeposited(tokenB);
    assert tokenBBalanceOfUserBefore == tokenBBalanceOfUserAfter;
    assert tokenBBalanceOfReserveBefore == tokenBBalanceOfReserveAfter;
    assert tokenBDepositedBefore == tokenBDepositedAfter;
}
","deposit (Lines 171-182),  | withdraw (Lines 191-203), ","    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }
 |     function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }
",./radicle_drips/specs/Reserve.spec,radicle_drips,,Yes,,"Functionality: The provided code defines two functions, `deposit` and `withdraw`, for handling token transactions in a smart contract. The `deposit` function lets a user transfer a specified amount of tokens to a plugin's address and emits a deposited event. The `withdraw` function allows a user to withdraw a specified amount of tokens from their deposited balance, adjusts their balance accordingly, potentially interacts with a plugin's withdrawal hook, transfers the tokens to the specified address, and emits a withdrawn event."
f40242dd01fb5bcfc6a3fadde0825f66,2362 | 2363,rule,tokensNonInterference,120,170,deposit | withdraw,"rule tokensNonInterference() {
    env e;
    calldataarg args;

    bool depositOrWithdraw;
    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 tokenABalanceOfUserBefore;    uint256 tokenABalanceOfUserAfter;
    uint256 tokenBBalanceOfUserBefore;    uint256 tokenBBalanceOfUserAfter;
    uint256 tokenABalanceOfReserveBefore; uint256 tokenABalanceOfReserveAfter;
    uint256 tokenBBalanceOfReserveBefore; uint256 tokenBBalanceOfReserveAfter;
    uint256 tokenADepositedBefore;        uint256 tokenADepositedAfter;
    uint256 tokenBDepositedBefore;        uint256 tokenBDepositedAfter;
    tokenABalanceOfUserBefore = tokenA.balanceOf(user);
    tokenBBalanceOfUserBefore = tokenB.balanceOf(user);
    tokenABalanceOfReserveBefore = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveBefore = tokenB.balanceOf(reserveH);
    tokenADepositedBefore = getDeposited(tokenA);
    tokenBDepositedBefore = getDeposited(tokenB);
    require tokenADepositedBefore == tokenABalanceOfReserveBefore;
    require tokenBDepositedBefore == tokenBBalanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(tokenA) == 0;
    require reserveH.getPlugins(tokenB) == 0;
    //deposit(e, tokenA, user, amtDeposited);
    //f(e,args);
    //withdraw(e, tokenA, user, amtWithdrawn);
    if (depositOrWithdraw) {
        deposit(e, tokenA, user, amtDeposited);
    } else {
        withdraw(e, tokenA, user, amtWithdrawn);
    }
    require amtDeposited == amtWithdrawn;
    tokenABalanceOfUserAfter = tokenA.balanceOf(user);
    tokenBBalanceOfUserAfter = tokenB.balanceOf(user);
    tokenABalanceOfReserveAfter = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveAfter = tokenB.balanceOf(reserveH);
    tokenADepositedAfter = getDeposited(tokenA);
    tokenBDepositedAfter = getDeposited(tokenB);
    assert tokenBBalanceOfUserBefore == tokenBBalanceOfUserAfter;
    assert tokenBBalanceOfReserveBefore == tokenBBalanceOfReserveAfter;
    assert tokenBDepositedBefore == tokenBDepositedAfter;
}
","deposit (Lines 171-182),  | withdraw (Lines 191-203), ","    function deposit(
        IERC20 token,
        address from,
        uint256 amt
    ) public override onlyUser {
        IReservePlugin plugin = plugins[token];
        require(from != address(plugin) && from != address(this), ""Reserve: deposition from self"");
        deposited[token] += amt;
        _transfer(token, from, _pluginAddr(plugin), amt);
        if (plugin != NO_PLUGIN) plugin.afterDeposition(token, amt);
        emit Deposited(msg.sender, token, from, amt);
    }
 |     function withdraw(
        IERC20 token,
        address to,
        uint256 amt
    ) public override onlyUser {
        uint256 balance = deposited[token];
        require(balance >= amt, ""Reserve: withdrawal over balance"");
        deposited[token] = balance - amt;
        IReservePlugin plugin = plugins[token];
        if (plugin != NO_PLUGIN) plugin.beforeWithdrawal(token, amt);
        _transfer(token, _pluginAddr(plugin), to, amt);
        emit Withdrawn(msg.sender, token, to, amt);
    }
",./radicle_drips/specs/Reserve.spec,radicle_drips,,Yes,,"Functionality: Enable users to deposit and withdraw ERC20 tokens into a reserve, updating balances accordingly. It involves checking for self-depositions, handling plugin interactions before withdrawal and after deposition, and ensuring transactions do not exceed available balances. Events are emitted for both deposit and withdrawal actions."
00855ecd93ee4c0c11781cfdefe45ac9,2356,rule,unrelatedUserBalanceNotChangingParametric,513,562,_dripsState,"rule unrelatedUserBalanceNotChangingParametric(
        method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
    env e; env eB; env eF;
    calldataarg args;

    // step 1 - balance before of receiverId
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
    uint256 userId1; uint256 config1;
    uint256 userId2; uint256 config2;
    uint256 userId3; uint256 config3;
    userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
    DH.DripsReceiver argsReceiver1;
    require argsReceiver1.userId == userId1;
    require argsReceiver1.config == config1;
    DH.DripsReceiver argsReceiver2;
    require argsReceiver2.userId == userId2;
    require argsReceiver2.config == config2;
    DH.DripsReceiver argsReceiver3;
    require argsReceiver3.userId == userId3;
    require argsReceiver3.config == config3;
    require argsReceiver1.userId != receiverId;
    require argsReceiver2.userId != receiverId;
    require argsReceiver3.userId != receiverId;
    f(e, args);
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
    //assert false;
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHubBackup.spec,radicle_drips,,Yes,,"Functionality: Retrieve and return the current state of a user's drips configuration for a specific asset, including the drips and drips history hashes, the last update time, the current balance, and the maximum end time of all drips."
a02f160902ea2b8f5f1fd31d36969688,2350,rule,whoChangedBalanceOfUserId,326,362,_dripsState,"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHubBackup.spec,radicle_drips,,Yes,,"Functionality: Retrieve and return the state of drips for a specific user and asset, including the drips hash, drips history hash, the last update time, current balance, and the maximum end time, by accessing and querying data from a storage structure."
bb50a156cf13a8276faff05171a8c44f,2352 | 2353 | 2354,rule,singleUserTimeUpdateNotChangingOtherUserBalance,392,490,"DH.create, create | _dripsState | _updateReceiverStates","rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
    env e; env eB; env eF;
    calldataarg args;

    // uint8 i;
    // userId1 and userId2 - receivers Id
    uint256 assetId; uint256 userId1; uint256 userId2;
    require userId != userId1; // != userId2;
    require userId1 < userId2; // sorted
    require userId != userId2;
    // step 1 - balance before of user2
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
    // assert false; // false 0
    // step 2 - setup user1 changes and then call _updateReceiverStates()
    /*  //setting values to config by create:
        uint192 _amtPerSec;
        uint32 _start;
        uint32 _duration;
    require _amtPerSec != 0;
    */
    DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
    DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
    DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
   // DH.DripsConfig configNew2;
    require configOld1 != configNew1;
    // require configOld2 == configNew2;
    DH.DripsReceiver receiverOld1;
    require receiverOld1.userId == userId1;
    require receiverOld1.config == configOld1;
    DH.DripsReceiver receiverOld2;
    require receiverOld2.userId == userId2;
    require receiverOld2.config == configOld2;
    DH.DripsReceiver receiverNew1;
    require receiverNew1.userId == userId1;
    require receiverNew1.config == configNew1;
    // DripsReceiver[] memory currReceivers;
    // DripsReceiver[] memory newReceivers;
    // currReceivers[i].userId = userId1;
    // currReceivers[i].config = configCurr;
    // require sorted
    // require no duplicate
    // require amtPerSec != 0
    // require(i < _MAX_DRIPS_RECEIVERS,"""");
    // require currReceivers == newReceivers;
    // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
    // DripsState storage state = _dripsStorage().states[assetId][userId];
    // uint32 lastUpdate = state.updateTime;
    // uint32 currMaxEnd = state.maxEnd;
    // uint32 newMaxEnd = sizeof(uint32);
    // assert false;  // false 1
     //assert configOld2 != configNew2;  //returned 0
    _helperUpdateReceiverStates( e,
            receiverOld1,
            receiverOld2,
            receiverNew1,
            assetId,
            userId
        );
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
    assert false;
}
","create (Lines 59-68),  | _dripsState (Lines 509-529),  | _updateReceiverStates (Lines 818-1089), ","    function create(
        uint192 _amtPerSec,
        uint32 _start,
        uint32 _duration
    ) internal pure returns (DripsConfig) {
        uint256 config = _amtPerSec;
        config = (config << 32) | _start;
        config = (config << 32) | _duration;
        return DripsConfig.wrap(config);
    }
 |     function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
 |     function _updateReceiverStates(
        mapping(uint256 => DripsState) storage states,
        DripsReceiver[] memory currReceivers,
        uint32 lastUpdate,
        uint32 currMaxEnd,
        DripsReceiver[] memory newReceivers,
        uint32 newMaxEnd
    //) private {
    ) internal virtual {
        //return;
        //require(currReceivers.length == 1, ""Attempt to reduce computation"");
        //require(newReceivers.length == 1, ""Attempt to reduce computation"");
        uint256 currIdx = 0;
        uint256 newIdx = 0;
        while (true) {
            bool pickCurr = currIdx < currReceivers.length;
            DripsReceiver memory currRecv;
            if (pickCurr) currRecv = currReceivers[currIdx];

            bool pickNew = newIdx < newReceivers.length;
            DripsReceiver memory newRecv;
            if (pickNew) newRecv = newReceivers[newIdx];

            // if-1
            // Limit picking both curr and new to situations when they differ only by start/end time
            if (
                pickCurr &&
                pickNew &&
                (currRecv.userId != newRecv.userId ||
                    currRecv.config.amtPerSec() != newRecv.config.amtPerSec())
            ) {
                pickCurr = _isOrdered(currRecv, newRecv);
                pickNew = !pickCurr;
            }
            
            if (pickCurr && pickNew) {
                // if-2: same userId, same amtPerSec
                // Shift the existing drip to fulfil the new configuration

                // states[currRecv.userId].amtDeltas[_currTimestamp()].thisCycle = thisCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].amtDeltas[_currTimestamp()].nextCycle = nextCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].nextReceivableCycle = nextReceivableCycleMapping[currRecv.userId];

                DripsState storage state = states[currRecv.userId];
                (uint32 currStart, uint32 currEnd) = _dripsRangeInFuture(
                    currRecv,
                    lastUpdate,
                    currMaxEnd
                );
                (uint32 newStart, uint32 newEnd) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                {
                    int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                    // Move the start and end times if updated
                    _addDeltaRange(state, currStart, newStart, -amtPerSec);
                    _addDeltaRange(state, currEnd, newEnd, amtPerSec);
                }
                // Ensure that the user receives the updated cycles
                uint32 currStartCycle = _cycleOf(currStart);
                uint32 newStartCycle = _cycleOf(newStart);
                if (currStartCycle > newStartCycle && state.nextReceivableCycle > newStartCycle) {
                    state.nextReceivableCycle = newStartCycle;
                }
                
            } else if (pickCurr) {
                // if-3
                // Remove an existing drip
                DripsState storage state = states[currRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(currRecv, lastUpdate, currMaxEnd);
                //require (end - start == 10);
                int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, -amtPerSec);
                //
            } else if (pickNew) {
                // if-4
                // Create a new drip
                DripsState storage state = states[newRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                int256 amtPerSec = int256(uint256(newRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, amtPerSec);
                // Ensure that the user receives the updated cycles
                uint32 startCycle = _cycleOf(start);
                if (state.nextReceivableCycle == 0 || state.nextReceivableCycle > startCycle) {
                    state.nextReceivableCycle = startCycle;
                }
                //
                
            } else {
                break;
            }

            if (pickCurr) currIdx++;
            if (pickNew) newIdx++;
        }
    }

    /// @notice Calculates the time range in the future in which a receiver will be dripped to.
    /// @param receiver The drips receiver
    /// @param maxEnd The maximum end time of drips
    function _dripsRangeInFuture(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd
    //) private view returns (uint32 start, uint32 end) {
    ) internal view returns (uint32 start, uint32 end) {
        return _dripsRange(receiver, updateTime, maxEnd, _currTimestamp(), type(uint32).max);
    }

    /// @notice Calculates the time range in which a receiver is to be dripped to.
    /// This range is capped to provide a view on drips through a specific time window.
    /// @param receiver The drips receiver
    /// @param updateTime The time when drips are configured
    /// @param maxEnd The maximum end time of drips
    /// @param startCap The timestamp the drips range start should be capped to
    /// @param endCap The timestamp the drips range end should be capped to
    function _dripsRange(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd,
        uint32 startCap,
        uint32 endCap
    //) private pure returns (uint32 start, uint32 end_) {
    ) internal pure returns (uint32 start, uint32 end_) {
        start = receiver.config.start();
        if (start == 0) start = updateTime;
        uint40 end = uint40(start) + receiver.config.duration();
        if (end == start || end > maxEnd) end = maxEnd;
        if (start < startCap) start = startCap;
        if (end > endCap) end = endCap;
        if (end < start) end = start;
        return (start, uint32(end));
    }

    /// @notice Adds funds received by a user in a given time range
    /// @param state The user state
    /// @param start The timestamp from which the delta takes effect
    /// @param end The timestamp until which the delta takes effect
    /// @param amtPerSec The dripping rate
    function _addDeltaRange(
        DripsState storage state,
        uint32 start,
        uint32 end,
        int256 amtPerSec
    //) private {
    ) internal {
        if (start == end) return;
        mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
        _addDelta(amtDeltas, start, amtPerSec);
        _addDelta(amtDeltas, end, -amtPerSec);
    }

    /// @notice Adds delta of funds received by a user at a given time
    /// @param amtDeltas The user amount deltas
    /// @param timestamp The timestamp when the deltas need to be added
    /// @param amtPerSec The dripping rate
    function _addDelta(
        mapping(uint32 => AmtDelta) storage amtDeltas,
        uint256 timestamp,
        int256 amtPerSec
    //) private {
    ) internal virtual {
        unchecked {
            
            // In order to set a delta on a specific timestamp it must be introduced in two cycles.
            // These formulas follow the logic from `_drippedAmt`, see it for more details.
            int256 amtPerSecMultiplier = int256(_AMT_PER_SEC_MULTIPLIER);
            int256 fullCycle = (int256(uint256(_cycleSecs)) * amtPerSec) / amtPerSecMultiplier;
            int256 nextCycle = (int256(timestamp % _cycleSecs) * amtPerSec) / amtPerSecMultiplier;
            AmtDelta storage amtDelta = amtDeltas[_cycleOf(uint32(timestamp))];
            // Any over- or under-flows are fine, they're guaranteed to be fixed by a matching
            // under- or over-flow from the other call to `_addDelta` made by `_addDeltaRange`.
            // This is because the total balance of `Drips` can never exceed `type(int128).max`,
            // so in the end no amtDelta can have delta higher than `type(int128).max`.
            amtDelta.thisCycle += int128(fullCycle - nextCycle);
            amtDelta.nextCycle += int128(nextCycle);
            
        }
    }

    /// @notice Checks if two receivers fulfil the sortedness requirement of the receivers list.
    /// @param prev The previous receiver
    /// @param prev The next receiver
    function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)
        //private
        internal
        pure
        returns (bool)
    {
        if (prev.userId != next.userId) return prev.userId < next.userId;
        return prev.config.lt(next.config);
    }

    /// @notice Calculates the amount dripped over a time range.
    /// The amount dripped in the `N`th second of each cycle is:
    /// `(N + 1) * amtPerSec / AMT_PER_SEC_MULTIPLIER - N * amtPerSec / AMT_PER_SEC_MULTIPLIER`.
    /// For a range of `N`s from `0` to `M` the sum of the dripped amounts is calculated as:
    /// `M * amtPerSec / AMT_PER_SEC_MULTIPLIER` assuming that `M <= cycleSecs`.
    /// For an arbitrary time range across multiple cycles the amount is calculated as the sum of
    /// the amount dripped in the start cycle, each of the full cycles in between and the end cycle.
    /// This algorithm has the following properties:
    /// - During every second full units are dripped, there are no partially dripped units.
    /// - Undripped fractions are dripped when they add up into full units.
    /// - Undripped fractions don't add up across cycle end boundaries.
    /// - Some seconds drip more units and some less.
    /// - Every `N`th second of each cycle drips the same amount.
    /// - Every full cycle drips the same amount.
    /// - The amount dripped in a given second is independent from the dripping start and end.
    /// - Dripping over time ranges `A:B` and then `B:C` is equivalent to dripping over `A:C`.
    /// - Different drips existing in the system don't interfere with each other.
    /// @param amtPerSec The dripping rate
    /// @param start The dripping start time
    /// @param end The dripping end time
    /// @param amt The dripped amount
    function _drippedAmt(
        uint256 amtPerSec,
        uint256 start,
        uint256 end
    //) private view returns (uint256 amt) {
    ) internal view returns (uint256 amt) {
        // This function is written in Yul because it can be called thousands of times
        // per transaction and it needs to be optimized as much as possible.
        // As of Solidity 0.8.13, rewriting it in unchecked Solidity triples its gas cost.
        uint256 cycleSecs = _cycleSecs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let endedCycles := sub(div(end, cycleSecs), div(start, cycleSecs))
            let amtPerCycle := div(mul(cycleSecs, amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := mul(endedCycles, amtPerCycle)
            let amtEnd := div(mul(mod(end, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := add(amt, amtEnd)
            let amtStart := div(mul(mod(start, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := sub(amt, amtStart)
        }
    }

    /// @notice Calculates the cycle containing the given timestamp.
    /// @param timestamp The timestamp.
    /// @return cycle The cycle containing the timestamp.
    //function _cycleOf(uint32 timestamp) private view returns (uint32 cycle) {
    function _cycleOf(uint32 timestamp) internal view returns (uint32 cycle) {
        unchecked {
            return timestamp / _cycleSecs + 1;
            //return timestamp + 1;  // attempt to simplify
        }
    }

    /// @notice The current timestamp, casted to the library's internal representation.
    /// @return timestamp The current timestamp
    //function _currTimestamp() private view returns (uint32 timestamp) {
    function _currTimestamp() internal view returns (uint32 timestamp) {
        return uint32(block.timestamp);
    }

    /// @notice Returns the Drips storage.
    /// @return dripsStorage The storage.
    //function _dripsStorage() private view returns (DripsStorage storage dripsStorage) {
    function _dripsStorage() internal view returns (DripsStorage storage dripsStorage) {
        bytes32 slot = _dripsStorageSlot;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            dripsStorage.slot := slot
        }
    }
}
",./radicle_drips/specs/DripsHubBackup.spec,radicle_drips,,Yes,,"Functionality: Manage and update the states of drips receivers with added complexity involving timing and funds distribution. It includes functionalities to create drips configurations, update receiver states based on new configurations, calculate the amount dripped over a time range, and manage funds received by users within specified timeframes."
21d9c3b44533dd7b2f54ea2f42689a71,2244,rule,ifTheOnlyOneDripperStopsReceivableDripsCanNotIncrease,661,669,_receivableDrips,"// rule ifTheOnlyOneDripperStopsReceivableDripsCanNotIncrease()
// {
//     // make sure there is only one sender and one receiver
//     // make sure the sender is dripping to the receiver
//     // calculate the _receivableDrips(receiver) before dripping stops
//     // stop the dripping
//     // calculate the _receivableDrips(receiver) after dripping stops
//     // after == before
// }
","_receivableDrips (Lines 224-236), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Calculate and return the amount receivable (`receivableAmt`) and the number of receivable cycles (`receivableCycles`) for a given user's asset, based on a maximum number of cycles (`maxCycles`), by calling another function `_receivableDripsVerbose`."
31710ec9726375d0270e04e557922060,2241,rule,whoChangedBalanceOfUserId,567,605,_dripsState,"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    require requireValidSlots();
    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Retrieve and return the current state of a user's drip configuration for a specific asset, including the drip settings hash, drip history hash, last update time, balance, and maximum end time, ensuring visibility of the user's drip status."
8817c3e3f94e6cb1fef12918c6792b78,2255,rule,unrelatedUserBalanceNotChangingParametric,929,978,_dripsState,"// rule unrelatedUserBalanceNotChangingParametric(
//         method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // step 1 - balance before of receiverId
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
//     uint256 userId1; uint256 config1;
//     uint256 userId2; uint256 config2;
//     uint256 userId3; uint256 config3;
//     userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
//     DH.DripsReceiver argsReceiver1;
//     require argsReceiver1.userId == userId1;
//     require argsReceiver1.config == config1;
//     DH.DripsReceiver argsReceiver2;
//     require argsReceiver2.userId == userId2;
//     require argsReceiver2.config == config2;
//     DH.DripsReceiver argsReceiver3;
//     require argsReceiver3.userId == userId3;
//     require argsReceiver3.config == config3;
//     require argsReceiver1.userId != receiverId;
//     require argsReceiver2.userId != receiverId;
//     require argsReceiver3.userId != receiverId;
//     f(e, args);
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
//     //assert false;
// }
","_dripsState (Lines 509-529), ","    function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Retrieve the state of drips for a specific user and asset, returning the current drips configuration hash, drips history hash, the last update time, the user's balance in the drips mechanism, and the maximum end time of any ongoing drips."
a1367d15c34a3471122a6ff788c7dbed,2236 | 2237 | 2238,rule,cyclesAdditivity,407,443,_receivableDrips | _receiveDrips | _receivableDripsCyclesRange,"rule cyclesAdditivity{
    env e1;
    env e2;
    address erc20;
    uint32 maxCycles;
    uint256 userId;
    uint256 assetId;
    uint32 from1;
    uint32 to1;
    uint32 from2;
    uint32 to2;

    require to_mathint(maxCycles) == 2^32-1;
    //require e2.block.timestamp > e1.block.timestamp;
    storage init = lastStorage;
    from1, to1 = _receivableDripsCyclesRange(e1, userId, assetId);
    from2, to2 = _receivableDripsCyclesRange(e2, userId, assetId);
    //require to1-from1 == 2;
    //require to2-from2 == 3;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < 4294967295;
    uint128 receivableAmt1; uint32 receivableCycles1;
    receivableAmt1, receivableCycles1 = _receivableDrips(e1, userId, assetId, maxCycles);
        _receiveDrips(e1, userId, assetId, maxCycles);
    uint128 receivableAmt2; uint32 receivableCycles2;
    receivableAmt2, receivableCycles2 = _receivableDrips(e2, userId, assetId, maxCycles);
    uint128 receivableAmt12; uint32 receivableCycles12;
    receivableAmt12, receivableCycles12 = _receivableDrips(e2, userId, assetId, maxCycles) at init;
    assert receivableAmt12 == receivableAmt1 + receivableAmt2;
    //assert false;
}
","_receivableDrips (Lines 224-236),  | _receiveDrips (Lines 247-276),  | _receivableDripsCyclesRange (Lines 337-346), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
 |     function _receiveDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    ) public virtual
        //internal
        returns (uint128 receivedAmt, uint32 receivableCycles) {
        uint32 fromCycle;
        uint32 toCycle;
        int128 finalAmtPerCycle;
        (
            receivedAmt,
            receivableCycles,
            fromCycle,
            toCycle,
            finalAmtPerCycle
        ) = _receivableDripsVerbose(userId, assetId, maxCycles);
        if (fromCycle != toCycle) {
            DripsState storage state = _dripsStorage().states[assetId][userId];
            state.nextReceivableCycle = toCycle;
            mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
            for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {
                delete amtDeltas[cycle];
            }
            // The next cycle delta must be relative to the last received cycle, which got zeroed.
            // In other words the next cycle delta must be an absolute value.
            if (finalAmtPerCycle != 0) amtDeltas[toCycle].thisCycle += finalAmtPerCycle;
        }
        emit ReceivedDrips(userId, assetId, receivedAmt, receivableCycles);
    }
 |     function _receivableDripsCyclesRange(uint256 userId, uint256 assetId)
        //private
        public
        view
        returns (uint32 fromCycle, uint32 toCycle)
    {
        fromCycle = _dripsStorage().states[assetId][userId].nextReceivableCycle;
        toCycle = _cycleOf(_currTimestamp());
        if (fromCycle == 0 || toCycle < fromCycle) toCycle = fromCycle;
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Calculate and update the receivable or received drips for a user based on asset ID and number of cycles, including deleting outdated amount deltas. It also determines the range of cycles applicable for calculating receivables, adjusting for the current state and timestamp."
d187da783f2b30f4b8f5e1f1603d5e37,2251 | 2252 | 2253,rule,singleUserTimeUpdateNotChangingOtherUserBalance,808,906,"DH.create, create | _dripsState | _updateReceiverStates","// rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // uint8 i;
//     // userId1 and userId2 - receivers Id
//     uint256 assetId; uint256 userId1; uint256 userId2;
//     require userId != userId1; // != userId2;
//     require userId1 < userId2; // sorted
//     require userId != userId2;
//     // step 1 - balance before of user2
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
//     // assert false; // false 0
//     // step 2 - setup user1 changes and then call _updateReceiverStates()
//     /*  //setting values to config by create:
//         uint192 _amtPerSec;
//         uint32 _start;
//         uint32 _duration;
//     require _amtPerSec != 0;
//     */
//     DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
//     DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
//     DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
//    // DH.DripsConfig configNew2;
//     require configOld1 != configNew1;
//     // require configOld2 == configNew2;
//     DH.DripsReceiver receiverOld1;
//     require receiverOld1.userId == userId1;
//     require receiverOld1.config == configOld1;
//     DH.DripsReceiver receiverOld2;
//     require receiverOld2.userId == userId2;
//     require receiverOld2.config == configOld2;
//     DH.DripsReceiver receiverNew1;
//     require receiverNew1.userId == userId1;
//     require receiverNew1.config == configNew1;
//     // DripsReceiver[] memory currReceivers;
//     // DripsReceiver[] memory newReceivers;
//     // currReceivers[i].userId = userId1;
//     // currReceivers[i].config = configCurr;
//     // require sorted
//     // require no duplicate
//     // require amtPerSec != 0
//     // require(i < _MAX_DRIPS_RECEIVERS,"""");
//     // require currReceivers == newReceivers;
//     // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
//     // DripsState storage state = _dripsStorage().states[assetId][userId];
//     // uint32 lastUpdate = state.updateTime;
//     // uint32 currMaxEnd = state.maxEnd;
//     // uint32 newMaxEnd = sizeof(uint32);
//     // assert false;  // false 1
//      //assert configOld2 != configNew2;  //returned 0
//     _helperUpdateReceiverStates( e,
//             receiverOld1,
//             receiverOld2,
//             receiverNew1,
//             assetId,
//             userId
//         );
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
//     assert false;
// }
","create (Lines 59-68),  | _dripsState (Lines 509-529),  | _updateReceiverStates (Lines 818-1089), ","    function create(
        uint192 _amtPerSec,
        uint32 _start,
        uint32 _duration
    ) internal pure returns (DripsConfig) {
        uint256 config = _amtPerSec;
        config = (config << 32) | _start;
        config = (config << 32) | _duration;
        return DripsConfig.wrap(config);
    }
 |     function _dripsState(uint256 userId, uint256 assetId)
        //internal
        public
        view
        returns (
            bytes32 dripsHash,
            bytes32 dripsHistoryHash,
            uint32 updateTime,
            uint128 balance,
            uint32 maxEnd
        )
    {
        DripsState storage state = _dripsStorage().states[assetId][userId];
        return (
            state.dripsHash,
            state.dripsHistoryHash,
            state.updateTime,
            state.balance,
            state.maxEnd
        );
    }
 |     function _updateReceiverStates(
        mapping(uint256 => DripsState) storage states,
        DripsReceiver[] memory currReceivers,
        uint32 lastUpdate,
        uint32 currMaxEnd,
        DripsReceiver[] memory newReceivers,
        uint32 newMaxEnd
    //) private {
    ) internal virtual {
        //return;
        //require(currReceivers.length == 1, ""Attempt to reduce computation"");
        //require(newReceivers.length == 1, ""Attempt to reduce computation"");
        uint256 currIdx = 0;
        uint256 newIdx = 0;
        while (true) {
            bool pickCurr = currIdx < currReceivers.length;
            DripsReceiver memory currRecv;
            if (pickCurr) currRecv = currReceivers[currIdx];

            bool pickNew = newIdx < newReceivers.length;
            DripsReceiver memory newRecv;
            if (pickNew) newRecv = newReceivers[newIdx];

            // if-1
            // Limit picking both curr and new to situations when they differ only by start/end time
            if (
                pickCurr &&
                pickNew &&
                (currRecv.userId != newRecv.userId ||
                    currRecv.config.amtPerSec() != newRecv.config.amtPerSec())
            ) {
                pickCurr = _isOrdered(currRecv, newRecv);
                pickNew = !pickCurr;
            }
            
            if (pickCurr && pickNew) {
                // if-2: same userId, same amtPerSec
                // Shift the existing drip to fulfil the new configuration

                // states[currRecv.userId].amtDeltas[_currTimestamp()].thisCycle = thisCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].amtDeltas[_currTimestamp()].nextCycle = nextCycleMapping[currRecv.userId][_currTimestamp()];
                // states[currRecv.userId].nextReceivableCycle = nextReceivableCycleMapping[currRecv.userId];

                DripsState storage state = states[currRecv.userId];
                (uint32 currStart, uint32 currEnd) = _dripsRangeInFuture(
                    currRecv,
                    lastUpdate,
                    currMaxEnd
                );
                (uint32 newStart, uint32 newEnd) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                {
                    int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                    // Move the start and end times if updated
                    _addDeltaRange(state, currStart, newStart, -amtPerSec);
                    _addDeltaRange(state, currEnd, newEnd, amtPerSec);
                }
                // Ensure that the user receives the updated cycles
                uint32 currStartCycle = _cycleOf(currStart);
                uint32 newStartCycle = _cycleOf(newStart);
                if (currStartCycle > newStartCycle && state.nextReceivableCycle > newStartCycle) {
                    state.nextReceivableCycle = newStartCycle;
                }
                
            } else if (pickCurr) {
                // if-3
                // Remove an existing drip
                DripsState storage state = states[currRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(currRecv, lastUpdate, currMaxEnd);
                //require (end - start == 10);
                int256 amtPerSec = int256(uint256(currRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, -amtPerSec);
                //
            } else if (pickNew) {
                // if-4
                // Create a new drip
                DripsState storage state = states[newRecv.userId];
                (uint32 start, uint32 end) = _dripsRangeInFuture(
                    newRecv,
                    _currTimestamp(),
                    newMaxEnd
                );
                int256 amtPerSec = int256(uint256(newRecv.config.amtPerSec()));
                _addDeltaRange(state, start, end, amtPerSec);
                // Ensure that the user receives the updated cycles
                uint32 startCycle = _cycleOf(start);
                if (state.nextReceivableCycle == 0 || state.nextReceivableCycle > startCycle) {
                    state.nextReceivableCycle = startCycle;
                }
                //
                
            } else {
                break;
            }

            if (pickCurr) currIdx++;
            if (pickNew) newIdx++;
        }
    }

    /// @notice Calculates the time range in the future in which a receiver will be dripped to.
    /// @param receiver The drips receiver
    /// @param maxEnd The maximum end time of drips
    function _dripsRangeInFuture(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd
    //) private view returns (uint32 start, uint32 end) {
    ) internal view returns (uint32 start, uint32 end) {
        return _dripsRange(receiver, updateTime, maxEnd, _currTimestamp(), type(uint32).max);
    }

    /// @notice Calculates the time range in which a receiver is to be dripped to.
    /// This range is capped to provide a view on drips through a specific time window.
    /// @param receiver The drips receiver
    /// @param updateTime The time when drips are configured
    /// @param maxEnd The maximum end time of drips
    /// @param startCap The timestamp the drips range start should be capped to
    /// @param endCap The timestamp the drips range end should be capped to
    function _dripsRange(
        DripsReceiver memory receiver,
        uint32 updateTime,
        uint32 maxEnd,
        uint32 startCap,
        uint32 endCap
    //) private pure returns (uint32 start, uint32 end_) {
    ) internal pure returns (uint32 start, uint32 end_) {
        start = receiver.config.start();
        if (start == 0) start = updateTime;
        uint40 end = uint40(start) + receiver.config.duration();
        if (end == start || end > maxEnd) end = maxEnd;
        if (start < startCap) start = startCap;
        if (end > endCap) end = endCap;
        if (end < start) end = start;
        return (start, uint32(end));
    }

    /// @notice Adds funds received by a user in a given time range
    /// @param state The user state
    /// @param start The timestamp from which the delta takes effect
    /// @param end The timestamp until which the delta takes effect
    /// @param amtPerSec The dripping rate
    function _addDeltaRange(
        DripsState storage state,
        uint32 start,
        uint32 end,
        int256 amtPerSec
    //) private {
    ) internal {
        if (start == end) return;
        mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;
        _addDelta(amtDeltas, start, amtPerSec);
        _addDelta(amtDeltas, end, -amtPerSec);
    }

    /// @notice Adds delta of funds received by a user at a given time
    /// @param amtDeltas The user amount deltas
    /// @param timestamp The timestamp when the deltas need to be added
    /// @param amtPerSec The dripping rate
    function _addDelta(
        mapping(uint32 => AmtDelta) storage amtDeltas,
        uint256 timestamp,
        int256 amtPerSec
    //) private {
    ) internal virtual {
        unchecked {
            
            // In order to set a delta on a specific timestamp it must be introduced in two cycles.
            // These formulas follow the logic from `_drippedAmt`, see it for more details.
            int256 amtPerSecMultiplier = int256(_AMT_PER_SEC_MULTIPLIER);
            int256 fullCycle = (int256(uint256(_cycleSecs)) * amtPerSec) / amtPerSecMultiplier;
            int256 nextCycle = (int256(timestamp % _cycleSecs) * amtPerSec) / amtPerSecMultiplier;
            AmtDelta storage amtDelta = amtDeltas[_cycleOf(uint32(timestamp))];
            // Any over- or under-flows are fine, they're guaranteed to be fixed by a matching
            // under- or over-flow from the other call to `_addDelta` made by `_addDeltaRange`.
            // This is because the total balance of `Drips` can never exceed `type(int128).max`,
            // so in the end no amtDelta can have delta higher than `type(int128).max`.
            amtDelta.thisCycle += int128(fullCycle - nextCycle);
            amtDelta.nextCycle += int128(nextCycle);
            
        }
    }

    /// @notice Checks if two receivers fulfil the sortedness requirement of the receivers list.
    /// @param prev The previous receiver
    /// @param prev The next receiver
    function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)
        //private
        internal
        pure
        returns (bool)
    {
        if (prev.userId != next.userId) return prev.userId < next.userId;
        return prev.config.lt(next.config);
    }

    /// @notice Calculates the amount dripped over a time range.
    /// The amount dripped in the `N`th second of each cycle is:
    /// `(N + 1) * amtPerSec / AMT_PER_SEC_MULTIPLIER - N * amtPerSec / AMT_PER_SEC_MULTIPLIER`.
    /// For a range of `N`s from `0` to `M` the sum of the dripped amounts is calculated as:
    /// `M * amtPerSec / AMT_PER_SEC_MULTIPLIER` assuming that `M <= cycleSecs`.
    /// For an arbitrary time range across multiple cycles the amount is calculated as the sum of
    /// the amount dripped in the start cycle, each of the full cycles in between and the end cycle.
    /// This algorithm has the following properties:
    /// - During every second full units are dripped, there are no partially dripped units.
    /// - Undripped fractions are dripped when they add up into full units.
    /// - Undripped fractions don't add up across cycle end boundaries.
    /// - Some seconds drip more units and some less.
    /// - Every `N`th second of each cycle drips the same amount.
    /// - Every full cycle drips the same amount.
    /// - The amount dripped in a given second is independent from the dripping start and end.
    /// - Dripping over time ranges `A:B` and then `B:C` is equivalent to dripping over `A:C`.
    /// - Different drips existing in the system don't interfere with each other.
    /// @param amtPerSec The dripping rate
    /// @param start The dripping start time
    /// @param end The dripping end time
    /// @param amt The dripped amount
    function _drippedAmt(
        uint256 amtPerSec,
        uint256 start,
        uint256 end
    //) private view returns (uint256 amt) {
    ) internal view returns (uint256 amt) {
        // This function is written in Yul because it can be called thousands of times
        // per transaction and it needs to be optimized as much as possible.
        // As of Solidity 0.8.13, rewriting it in unchecked Solidity triples its gas cost.
        uint256 cycleSecs = _cycleSecs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let endedCycles := sub(div(end, cycleSecs), div(start, cycleSecs))
            let amtPerCycle := div(mul(cycleSecs, amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := mul(endedCycles, amtPerCycle)
            let amtEnd := div(mul(mod(end, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := add(amt, amtEnd)
            let amtStart := div(mul(mod(start, cycleSecs), amtPerSec), _AMT_PER_SEC_MULTIPLIER)
            amt := sub(amt, amtStart)
        }
    }

    /// @notice Calculates the cycle containing the given timestamp.
    /// @param timestamp The timestamp.
    /// @return cycle The cycle containing the timestamp.
    //function _cycleOf(uint32 timestamp) private view returns (uint32 cycle) {
    function _cycleOf(uint32 timestamp) internal view returns (uint32 cycle) {
        unchecked {
            return timestamp / _cycleSecs + 1;
            //return timestamp + 1;  // attempt to simplify
        }
    }

    /// @notice The current timestamp, casted to the library's internal representation.
    /// @return timestamp The current timestamp
    //function _currTimestamp() private view returns (uint32 timestamp) {
    function _currTimestamp() internal view returns (uint32 timestamp) {
        return uint32(block.timestamp);
    }

    /// @notice Returns the Drips storage.
    /// @return dripsStorage The storage.
    //function _dripsStorage() private view returns (DripsStorage storage dripsStorage) {
    function _dripsStorage() internal view returns (DripsStorage storage dripsStorage) {
        bytes32 slot = _dripsStorageSlot;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            dripsStorage.slot := slot
        }
    }
}
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Manage and update drip configurations and states for users during transactions, including creating new drips, adjusting existing ones, and calculating amounts dripped over specific time ranges. It leverages efficient data handling to optimize gas costs in scenarios involving frequent updates and calculations."
d2e5a24de787f4511214d6c4b9ea68c8,2245,rule,startDrippingToUserCannotDecreaseReceivableAmt,672,686,Drips._receivableDrips,"// rule startDrippingToUserCannotDecreaseReceivableAmt()
// {
//     // make sure that the dripper was not sending to the user:
//     // require currReceivers.length == 0;

//     // check the receivable balance of the user before:
//     // (uint128 receivedAmtBefore, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // start sending to the user
//     // check the receivable balance of the user after:
//     // (uint128 receivedAmtAfter, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // assert receivedAmtAfter > receivedAmtBefore
// }
","_receivableDrips (Lines 224-236), ","    function _receivableDrips(
        uint256 userId,
        uint256 assetId,
        uint32 maxCycles
    )   public
        // internal
        view returns (uint128 receivableAmt, uint32 receivableCycles) {
        (receivableAmt, receivableCycles, , , ) = _receivableDripsVerbose(
            userId,
            assetId,
            maxCycles
        );
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Retrieve the amount and number of cycles of receivable drips for a given user and asset up to a maximum number of cycles specified, by delegating the calculation to the `_receivableDripsVerbose` function and ignoring additional returned values."
f96340bb5b2edebb42346d3192f88b3e,2248,rule,integrityOfPast,688,766,setDrips,"rule integrityOfPast(method f)
{
    require requireValidSlots();

    env e0;                 address erc20;
    calldataarg args;       uint256 dripperId;      uint256 receiverId;
    require erc20 == 0x100;
    require dripperId == 1;
    require receiverId == 2;
    // setup one dripper and one receiver with start dripping timestamp of now
    uint192 amtPerSec;      uint32 start;           uint32 duration;
    require amtPerSec == 1;
    require start == 5;
    require duration == 100;
    DH.DripsConfig configBefore = _helperCreateConfig(amtPerSec, start, duration);
    require e0.block.timestamp == start;
    int128 balanceDelta;
    DH.DripsReceiver currReceiverBefore;
    require currReceiverBefore.userId == 0; // this will force passing empty currReceivers
    DH.DripsReceiver newReceiverBefore;
    require newReceiverBefore.userId == receiverId;
    require receiverId != 0;
    require newReceiverBefore.config == configBefore;
    //_helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    //helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    // let at least one cycle pass
    uint32 cycleSecs = getCycleSecs();
    require cycleSecs == 2;
    env e1;
    require e1.block.timestamp > e0.block.timestamp + cycleSecs;
    // calculate the ReceivableDripsBefore of the receiver
    // collectableAll() can be used if the user has also set splits
    uint128 ReceivableDripsBefore; uint32 receivableCyclesBefore;
    // type(uint32).max = 2^32 - 1 = 4294967295
    ReceivableDripsBefore, receivableCyclesBefore = receivableDrips(e1, receiverId, erc20, 4294967295);
    // change the dripper configuration to start dripping to the receiver in the future
    // i.e. try to alter the past, as if the past dripping did not occur
    // use the same amtPerSec and duration, only change the start time to the future
    uint32 newStart;
    require newStart > e1.block.timestamp + 10 * cycleSecs;
    DH.DripsConfig configAfter = _helperCreateConfig(amtPerSec, newStart, duration);
    DH.DripsReceiver newReceiverAfter;
    require newReceiverAfter.userId == receiverId;
    require newReceiverAfter.config == configAfter;
    //_helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    //setDrips(e1, dripperId, erc20, _helperArrOfStruct(e1, newReceiverBefore), balanceDelta, _helperArrOfStruct(e1, newReceiverAfter));
    //helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    // calculate again the ReceivableDripsAfter of the receiver
    // at a time before the newStart begins
    env e2;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < newStart;
    uint128 ReceivableDripsAfter; uint32 receivableCyclesAfter;
    ReceivableDripsAfter, receivableCyclesAfter = receivableDrips(e2, receiverId, erc20, 4294967295);
    // validate that the past dripping stays, i.e. what was already dripped is still receivable
    assert ReceivableDripsBefore == ReceivableDripsAfter;
    assert false; // sanity
rule sanity(method f){
    //uint32 cycleSecs = getCycleSecs();
    //require cycleSecs == 2;
    //setupState();
    env e;
    calldataarg args;
    f(e,args);
    assert false;
}
","setDrips (Lines 87-102), ","    function setDrips(
        IERC20 erc20,
        DripsReceiver[] calldata currReceivers,
        int128 balanceDelta,
        DripsReceiver[] calldata newReceivers
    ) public returns (uint128 newBalance, int128 realBalanceDelta) {
        if (balanceDelta > 0) _transferFromCaller(erc20, uint128(balanceDelta));
        (newBalance, realBalanceDelta) = dripsHub.setDrips(
            calcUserId(msg.sender),
            erc20,
            currReceivers,
            balanceDelta,
            newReceivers
        );
        if (realBalanceDelta < 0) erc20.safeTransfer(msg.sender, uint128(-realBalanceDelta));
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: Transfer a specified token amount from the caller to the contract if the balance delta is positive. Then, adjust the token balance and receivers according to given parameters through an external `dripsHub` contract call. If the resulting balance delta is negative, refund the excess tokens back to the caller."
f96340bb5b2edebb42346d3192f88b3e,2248,rule,integrityOfPast,688,766,setDrips,"rule integrityOfPast(method f)
{
    require requireValidSlots();

    env e0;                 address erc20;
    calldataarg args;       uint256 dripperId;      uint256 receiverId;
    require erc20 == 0x100;
    require dripperId == 1;
    require receiverId == 2;
    // setup one dripper and one receiver with start dripping timestamp of now
    uint192 amtPerSec;      uint32 start;           uint32 duration;
    require amtPerSec == 1;
    require start == 5;
    require duration == 100;
    DH.DripsConfig configBefore = _helperCreateConfig(amtPerSec, start, duration);
    require e0.block.timestamp == start;
    int128 balanceDelta;
    DH.DripsReceiver currReceiverBefore;
    require currReceiverBefore.userId == 0; // this will force passing empty currReceivers
    DH.DripsReceiver newReceiverBefore;
    require newReceiverBefore.userId == receiverId;
    require receiverId != 0;
    require newReceiverBefore.config == configBefore;
    //_helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    //helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    // let at least one cycle pass
    uint32 cycleSecs = getCycleSecs();
    require cycleSecs == 2;
    env e1;
    require e1.block.timestamp > e0.block.timestamp + cycleSecs;
    // calculate the ReceivableDripsBefore of the receiver
    // collectableAll() can be used if the user has also set splits
    uint128 ReceivableDripsBefore; uint32 receivableCyclesBefore;
    // type(uint32).max = 2^32 - 1 = 4294967295
    ReceivableDripsBefore, receivableCyclesBefore = receivableDrips(e1, receiverId, erc20, 4294967295);
    // change the dripper configuration to start dripping to the receiver in the future
    // i.e. try to alter the past, as if the past dripping did not occur
    // use the same amtPerSec and duration, only change the start time to the future
    uint32 newStart;
    require newStart > e1.block.timestamp + 10 * cycleSecs;
    DH.DripsConfig configAfter = _helperCreateConfig(amtPerSec, newStart, duration);
    DH.DripsReceiver newReceiverAfter;
    require newReceiverAfter.userId == receiverId;
    require newReceiverAfter.config == configAfter;
    //_helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    //setDrips(e1, dripperId, erc20, _helperArrOfStruct(e1, newReceiverBefore), balanceDelta, _helperArrOfStruct(e1, newReceiverAfter));
    //helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    // calculate again the ReceivableDripsAfter of the receiver
    // at a time before the newStart begins
    env e2;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < newStart;
    uint128 ReceivableDripsAfter; uint32 receivableCyclesAfter;
    ReceivableDripsAfter, receivableCyclesAfter = receivableDrips(e2, receiverId, erc20, 4294967295);
    // validate that the past dripping stays, i.e. what was already dripped is still receivable
    assert ReceivableDripsBefore == ReceivableDripsAfter;
    assert false; // sanity
rule sanity(method f){
    //uint32 cycleSecs = getCycleSecs();
    //require cycleSecs == 2;
    //setupState();
    env e;
    calldataarg args;
    f(e,args);
    assert false;
}
","setDrips (Lines 87-102), ","    function setDrips(
        IERC20 erc20,
        DripsReceiver[] calldata currReceivers,
        int128 balanceDelta,
        DripsReceiver[] calldata newReceivers
    ) public returns (uint128 newBalance, int128 realBalanceDelta) {
        if (balanceDelta > 0) _transferFromCaller(erc20, uint128(balanceDelta));
        (newBalance, realBalanceDelta) = dripsHub.setDrips(
            calcUserId(msg.sender),
            erc20,
            currReceivers,
            balanceDelta,
            newReceivers
        );
        if (realBalanceDelta < 0) erc20.safeTransfer(msg.sender, uint128(-realBalanceDelta));
    }
",./radicle_drips/specs/DripsHub.spec,radicle_drips,,Yes,,"Functionality: This function adjusts a user's contributions to a DripsHub by transferring ERC20 tokens to or from the calling user, based on the desired balance change. It updates the user's drips configuration, transferring additional funds if increasing their balance or returning excess funds if decreasing."
010445e39eaa71f2e4d984c3296ae5da,2194,invariant,empty_pool_state,150,156,collectProtocolFees,"    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Collect protocol fees in two different token amounts designated by `amount0` and `amount1`. Ensure sufficient balances and fees are available, transfer the specified amounts to the sender, reduce the recorded protocol fees, and finally, compound any remaining fees. Emit an event indicating reward payment."
01adaa8f05c8d61bed3cb8e9aaf9924e,2218,rule,empty_pool_zero_totalSupply,381,386,collectProtocolFees,"///// rule empty_pool_zero_totalSupply()
////  verifies that pool is empty IFF totalSupply == 0
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  collectProtocolFees() - it breakes the rule
rule empty_pool_zero_totalSupply(method f, address to)
filtered { f -> excludeCallback(f) }{
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Check and collect specified amounts of two different protocol fees, ensuring the contract has sufficient balance and the caller is authorized. Deduct the collected fees from total protocol fees, compound any remaining fees, and emit an event detailing the withdrawal."
136c7125c667a5318d75cb0c17bfbc38,2213,rule,totalSupply_vs_positionAmounts,323,346,position_Liquidity,"///// rule totalSupply_vs_positionAmounts()
////  verifies that totalSupply before applying f() greater than totalSupply after implies posistion 
////  liquidity before is greater than position liquidity after minus last compound liquidity
rule totalSupply_vs_positionAmounts(method f){
   env e;

   uint256 totalSupplyBefore = totalSupply();
   uint256 posLiquidityBefore = position_Liquidity();
    require governance() != currentContract;
    require governance() != pool;
   require lastCompoundLiquidity(e) == 0;
   calldataarg args;
	f(e,args);
   uint256 totalSupplyAfter = totalSupply();
   uint256 posLiquidityAfter = position_Liquidity();   
   uint256 compoundAfter = lastCompoundLiquidity(e);
    assert totalSupplyAfter < totalSupplyBefore =>
            posLiquidityAfter - compoundAfter < posLiquidityBefore;
}
","position_Liquidity (Lines 692-695), ","    function position_Liquidity() public returns (uint128){
        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
        return liquidity;
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,Functionality: Retrieve the liquidity amount from a pool for a specific position defined by its lower and upper tick boundaries. The function calls the `positionLiquidity` method on the `pool` object with `tickLower` and `tickUpper` as arguments and returns the resulting liquidity value.
1fbc60ad5ad5565b9d097481f0331cc2,2201,invariant,zero_totalSupply_zero_owed,206,213,collectProtocolFees,"    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    } 
    }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Collect protocol fees in two token types, verifying sufficient balance and authorization. Deduct collected amounts from tracked protocol fees, transfer the requested amounts to the caller, and optionally engage in further actions such as earnings accrual and fee compounding, with relevant event emission for tracking."
2c44760d7203f2595948aa2e68337e84,2210,rule,zeroCharacteristicOfWithdraw,278,293,withdraw,"///// rule zeroCharacteristicOfWithdraw()
////  verifies that if withraw returns amount0 == 0 and amount1 == 0 then necessarily shares == 0
rule zeroCharacteristicOfWithdraw(uint256 shares, address to){
    env e;
    uint256 amount0;
    uint256 amount1;

    require governance() != currentContract;
    require governance() != pool;
    require to != currentContract && to != pool && to != governance();
    require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
    amount0,amount1 =  withdraw(e,shares, to);
    assert (amount0 == 0 && amount1 == 0 => shares == 0);
}
","withdraw (Lines 59-63), ","    function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Reduce the total supply and the balance of the sender by the specified amount, then attempt to send the withdrawn amount of Ether to the sender's address by calling the `acceptEth` function on it, ensuring the transaction only succeeds if `acceptEth` returns `true`."
3aacc8cd5cf302c6ba77e1e141a3ac27,2197,invariant,empty_pool_state_reverse,176,183,collectProtocolFees,"    ///// invariant empty_pool_state_reverse()
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    ////  verifies that pool liquidity == 0 IFF pool balance - pool owed == 0
    ////  following function are excluded:
    invariant empty_pool_state_reverse()
    pool.liquidity() == 0 <=> (pool.balance0() - pool.owed0() == 0 && pool.balance1() - pool.owed1() == 0)
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: The code allows a governance authority to collect specified amounts of two types of protocol fees, ensuring sufficient protocol and actual balances, subtracts these amounts from recorded fees, compounds remaining fees, and emits an event indicating the reward has been paid."
3b6954985c0026065cb8c65c1dd633a9,2208,invariant,liquidity_GE_poolBalance0,246,252,collectProtocolFees,"    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
    filtered { f -> excludeCallback(f) }
","collectProtocolFees (Lines 2568-2585), ","    function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Collect protocol fees in two different token types, validating sufficient balances and protocol fee amounts before transferring specified amounts to the caller. Adjust protocol fee totals accordingly, re-invest or manage the remaining fees, and log the transaction details through an event."
5c51b33628edeeae8210a1c39c246e52,2221 | 2222 | 2224 | 2225,rule,withdraw_amount,423,456,deposit | withdraw | uniswapV3SwapCallback | collectProtocolFees,"// rule withdraw_amount(address to){
//     env e;

//     require governance() != currentContract;
//     require governance() != pool;
//     require (to!=governance() && to != pool && to != currentContract);
//     require e.msg.sender != pool && e.msg.sender != currentContract && e.msg.sender != governance();
//     require token0.balanceOf(currentContract) == 0 &&
//             token1.balanceOf(currentContract) == 0;
//             requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
//             requireInvariant zero_totalSupply_zero_owed();
    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    } 
    }
//             requireInvariant pool_balance_vs_owed();
    ///// invariant pool_balance_vs_owed()
    ////  verifies that pool balance greater equal to pool owed
    invariant pool_balance_vs_owed()
    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()
//             requireInvariant total_vs_protocol_Fees();
    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
//             requireInvariant liquidity_GE_poolBalance0();
    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
//             requireInvariant balance_contract_GE_protocolFees();
    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
//     uint256 shares;
//     uint256 amount0;
//     uint256 amount1;
//     uint256 totalsupply = totalSupply();
//     uint256 pool_balance0 = pool.balance0();
//     uint256 pool_owed0 = pool.owed0();
//             amount0,amount1 =  withdraw(e,shares, to);
    
//     // uint256 amount0_calc = (pool_balance0 - pool_owed0) * shares / totalsupply;
//     mathint amount0_calc = pool_balance0 * shares / totalsupply;
//     require amount0_calc >= 1;
//     assert  amount0 <= amount0_calc;
// }
","deposit (Lines 53-57),  | withdraw (Lines 59-63),  | uniswapV3SwapCallback (Lines 34-350),  | collectProtocolFees (Lines 2568-2585), ","    function deposit() external payable {
        // assume succeeds
        supply = supply.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
 |     function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
 |     function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
 |     function collectProtocolFees(
        uint256 amount0,
        uint256 amount1
    ) external nonReentrant onlyGovernance {
        _earnFees();
        require(protocolFees0 >= amount0, ""A0F"");
        require(protocolFees1 >= amount1, ""A1F"");
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        require(balance0 >= amount0 && balance1 >= amount1);
        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);
        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);
        
        protocolFees0 = protocolFees0.sub(amount0);
        protocolFees1 = protocolFees1.sub(amount1);
        _compoundFees();
        emit RewardPaid(msg.sender, amount0, amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Implement a mock Uniswap V3 liquidity pool that allows adding liquidity, removing liquidity, collecting fees, and swapping tokens under predefined conditions. It showcases basic interactions with liquidity pools, such as minting liquidity tokens, burning them, and executing swaps with mock pricing dynamics."
75fdebaccf9425899feb022a4823a8de,2191,invariant,balance_contract_GE_protocolFees,120,126,uniswapV3SwapCallback,"    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","uniswapV3SwapCallback (Lines 34-350), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Simulate a Uniswap V3 liquidity pool with custom functions to mint liquidity, collect fees, burn liquidity, and perform swaps between two tokens, while dynamically adjusting the price ratio through swaps. It interacts with external Uniswap interfaces for mint and swap callbacks."
7ccd53de0d51531c564b6dcb2aad53f1,2188,invariant,balance_vs_protocol_Liquidity,92,99,uniswapV3SwapCallback,"    ///// invariant balance_vs_protocol_Liquidity()
    ////  verifies that if total supply is zero than all the assets of the system is the owned to governance 
    ////  uniswapV3SwapCallback() - meaningless outside of the swap context
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant balance_vs_protocol_Liquidity()
    (totalSupply() == 0) => token0.balanceOf(currentContract) == protocolFees0() //&&
                            //token1.balanceOf(currentContract) == protocolFees1()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","uniswapV3SwapCallback (Lines 34-350), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Simulate a Uniswap V3 pool's core interactions, including minting liquidity positions, swapping tokens with custom logic for price adjustment, burning liquidity to claim fees, and tracking pool and positional states such as balances, liquidity levels, and fees owed."
95145c56eb3c7f55e6a323da4121bc07,2211,rule,more_shares_more_amounts_to_withdraw,295,321,withdraw,"///// rule more_shares_more_amounts_to_withdraw()
////  verifies that with larger number of shares one will withdraw a larger amount of assets
////  this rule passes only when the following line added to burnLiquidityShares():
////  require (share == liquidity * totalSupply/uint256(liquidityInPool));
// rule more_shares_more_amounts_to_withdraw( address to){
// env e;
//     uint256 sharesX;
//     uint256 sharesY;
//     uint256 amount0X;
//     uint256 amount1X;
//     uint256 amount0Y;
//     uint256 amount1Y;

//     require governance() != currentContract;
//     require governance() != pool;
//     require to != currentContract && to != pool && to != governance();
//     require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
//     require sharesX > sharesY;
//     storage init = lastStorage;
    
//     amount0X,amount1X =  withdraw(e,sharesX, to);
//     amount0Y,amount1Y =  withdraw(e,sharesY, to) at init;
//     assert amount0X >= amount0Y && amount1X >= amount1Y;
// }
","withdraw (Lines 59-63), ","    function withdraw(uint256 amount) external {
        supply = supply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        require (Receiver(payable(msg.sender)).acceptEth{value:amount}());
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Reduce the supply and the balance of the message sender by the specified amount, then attempt to send the equivalent value of Ether to the sender's address by calling the `acceptEth` function on the sender's address, ensuring the operation is successful."
984a4e9b61c23dd9cab29411441999c9,2215 | 2216,rule,protocolFees_state,348,354,uniswapV3SwapCallback | acceptGovernance,"///// rule protocolFees_state()
////  verifies that balance of governance before applying f() + the change in protocolFees is greater or equal balance of governance after applying f()
////  uniswapV3SwapCallback() - meaningless outside of the swap context
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  acceptGovernance()      - breaks the rule when governance changes
rule protocolFees_state(env e, method f, uint256 shares, address to)
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector && f.selector != acceptGovernance().selector }
","uniswapV3SwapCallback (Lines 34-350),  | acceptGovernance (Lines 2607-2612), ","    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

contract SymbolicUniswapV3Pool is IUniswapV3Pool {
    uint256 public liquidity;
    uint256 public ratio;
    address public immutable override token0;
    address public immutable override token1;
    uint128 public owed0;
    uint128 public owed1;
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for uint128;
    using LowGasSafeMath for int256;
    using PoolVariables for IUniswapV3Pool;

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
        ratio = 4;
    }

    function balance0() public view returns (uint256) {
        return IERC20(token0).balanceOf(address(this));
    }

    /// @dev Get the pool's balance of token1
    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
    /// check
    function balance1() public view returns (uint256) {
        return IERC20(token1).balanceOf(address(this));
    }


     function liquidityForAmounts(
        IUniswapV3Pool pool,
        uint256 amount0,
        uint256 amount1,
        int24 _tickLower,
        int24 _tickUpper
    ) public view returns (uint128) {
        return pool.liquidityForAmounts(amount0, amount1, _tickLower, _tickUpper);
    }

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        liquidity = liquidity.add(amount);
        amount0 = amount;
        amount1 = uint256(amount).mul(ratio);
        uint256 token0Balance = balance0();
        uint256 token1Balance = balance1();
        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
            amount0,
            amount1,
            data
        );
        //maybe add require that now the balance increased as expected
        require(balance0() >= token0Balance.add(amount0));
        require(balance1() >= token1Balance.add(amount1));
    }

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override returns (uint128 amount0, uint128 amount1) {
        if (amount0Requested >= owed0) {
            amount0 = owed0;
            owed0 = 0;
        } else {
            owed0 = owed0.sub128(amount0Requested);
            amount0 = amount0Requested;
        }
        IERC20(token0).transfer(recipient, amount0);
        if (amount1Requested >= owed1) {
            amount1 = owed1;
            owed1 = 0;
        } else {
            owed1 = owed1.sub128(amount1Requested);
            amount1 = amount1Requested;
        }
        IERC20(token1).transfer(recipient, amount1);
    }

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external override returns (uint256 amount0, uint256 amount1) {
        require(ratio == 1 || ratio == 2 || ratio == 4);
        require(liquidity >= amount);
        amount0 = amount;
        amount1 = amount.mul(ratio);
        liquidity = liquidity.sub(amount);

        require(amount0 < 2**128);
        require(amount1 < 2**128);

        owed0 = owed0.add128(uint128(amount0));
        owed1 = owed1.add128(uint128(amount1));
    }

    /// @notice Swap token0 for token1, or token1 for token0, rate does not change so limit amout to 100, and pool creator must tarnsfer to it huge amount of token0 and token1
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external override returns (int256 amount0, int256 amount1) {
        bool exactInput = amountSpecified > 0;
        if (!exactInput) amountSpecified = -amountSpecified;
        int256 amountToPay = exactInput
            ? amountSpecified
            : (
                zeroForOne
                    ? amountSpecified / int256(ratio)
                    : amountSpecified.mul(int256(ratio))
            );
        int256 amountToGet = exactInput
            ? (
                zeroForOne
                    ? amountSpecified.mul(int256(ratio))
                    : amountSpecified / int256(ratio)
            )
            : amountSpecified;
        // do the transfers and collect payment
        // amountToGet = amountToGet.mul(99) / 100;
        if (zeroForOne) {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed1 = owed1.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token1).transfer(recipient, uint256(amountToGet));
            uint256 balance0Before = balance0();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                amountToPay,
                -amountToGet,
                data
            );
            require(
                balance0Before.add(uint256(amountToPay)) <= balance0(),
                ""IIA""
            );
        } else {
            require(amountToGet >= 0);
            uint256 temp = uint256(amountToGet);
            require(temp < 2**128);
            // owed0 = owed0.add128(uint128(uint256(amountToGet) / 100));
            IERC20(token0).transfer(recipient, uint256(amountToGet));
            uint256 balance1Before = balance1();
            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
                -amountToGet,
                amountToPay,
                data
            );
            require(
                balance1Before.add(uint256(amountToPay)) <= balance1(),
                ""IIA""
            );
        }
        if (ratio == 4) {
            ratio = 2;
        } else if (ratio == 2) {
            ratio = 1;
        } else {
            ratio = 4;
        }
    }

    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgo = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgo From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgo` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgo` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgo)
        external
        view
        override
        returns (
            int56[] memory tickCumulatives,
            uint160[] memory secondsPerLiquidityCumulativeX128s
        )
    {
        tickCumulatives = new int56[](secondsAgo.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgo.length);
    }

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view override returns (int24) {
        return 2;
    }

    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        override
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        return (uint160(ratio), 13863, 0, 0, 0, 0, true);
    }

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        override
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        // return (
        //     uint128(liquidity),
        //     uint256(0),
        //     uint256(0),
        //     uint128(owed0),
        //     uint128(owed1)
        // );
        require(liquidity < 2**128);
        _liquidity = uint128(liquidity);
        feeGrowthInside0LastX128 = 0;
        feeGrowthInside1LastX128 = 0;
        tokensOwed0 = owed0;
        tokensOwed1 = owed1;
    }
}
 |     function acceptGovernance() external {
        require(msg.sender == pendingGovernance, ""PG"");
        emit TransferGovernance(governance, pendingGovernance);
        pendingGovernance = address(0);
        governance = msg.sender;
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Implement a mock version of a Uniswap V3 Pool, allowing actions like minting liquidity, burning liquidity, swapping tokens, collecting fees, and observing pool conditions. This contract simulates pool interactions for testing purposes, using a modified price ratio that dynamically changes with swaps."
db5d6df99b53dc81261649d55d1a7956,2228,rule,zeroBalancesAfterRebalance,458,463,rebalance,"/* rule zeroBalancesAfterRebalance(){
    env e;
    rebalance(e);
    assert (token0.balanceOf(e, currentContract)==0 && 
                             token1.balanceOf(e, currentContract)==0);
} */
","rebalance (Lines 2375-2438), ","    function rebalance() external override nonReentrant checkDeviation {
        require(_operatorApproved[msg.sender], ""ONA"");
        _earnFees();
        //Burn all liquidity from pool to rerange for Optimizer's balances.
        pool.burnAllLiquidity(tickLower, tickUpper);
        
        //Calc base ticks
        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
        PoolVariables.Info memory cache;
        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);
        
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        // Calc liquidity for base ticks
        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);

        // Get exact amounts for base ticks
        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);

        // Get imbalanced token
        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio
        int256 amountSpecified = 
            zeroForOne
                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))
                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. ""overflow"" safe convertion cuz we are dividing by 2

        // Calculate Price limit depending on price impact
        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;
        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);

        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit
        pool.swap(
            address(this),
            zeroForOne,
            amountSpecified,
            sqrtPriceLimitX96,
            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))
        );


        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();

        // Emit snapshot to record balances
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        //Get exact ticks depending on Optimizer's new balances
        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);

        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);

        // Add liquidity to the pool
        (cache.amount0, cache.amount1) = pool.mint(
            address(this),
            tickLower,
            tickUpper,
            cache.liquidity,
            abi.encode(MintCallbackData({payer: address(this)})));

        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Manage and optimize liquidity pool positions by firstly burning all existing liquidity, recalculating optimal tick ranges based on current market conditions, adjusting token balances through swaps to correct imbalances, and finally adding liquidity back into the pool within the newly calculated optimal tick ranges."
e46677da2aa46d0434d5704fb41edc63,2206,invariant,total_vs_protocol_Fees,233,243,deposit,"    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
    }
","deposit (Lines 53-57), ","    function deposit() external payable {
        // assume succeeds
        supply = supply.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Accept ether from external callers, increasing the contract's total supply by the sent amount while also crediting the same amount to the sender's balance. This operation requires the function to be payable to handle ether transactions successfully."
db5d6df99b53dc81261649d55d1a7956,2228,rule,zeroBalancesAfterRebalance,458,463,rebalance,"/* rule zeroBalancesAfterRebalance(){
    env e;
    rebalance(e);
    assert (token0.balanceOf(e, currentContract)==0 && 
                             token1.balanceOf(e, currentContract)==0);
} */
","rebalance (Lines 2375-2438), ","    function rebalance() external override nonReentrant checkDeviation {
        require(_operatorApproved[msg.sender], ""ONA"");
        _earnFees();
        //Burn all liquidity from pool to rerange for Optimizer's balances.
        pool.burnAllLiquidity(tickLower, tickUpper);
        
        //Calc base ticks
        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
        PoolVariables.Info memory cache;
        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();
        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);
        
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        // Calc liquidity for base ticks
        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);

        // Get exact amounts for base ticks
        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);

        // Get imbalanced token
        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);
        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio
        int256 amountSpecified = 
            zeroForOne
                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))
                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. ""overflow"" safe convertion cuz we are dividing by 2

        // Calculate Price limit depending on price impact
        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;
        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);

        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit
        pool.swap(
            address(this),
            zeroForOne,
            amountSpecified,
            sqrtPriceLimitX96,
            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))
        );


        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();

        // Emit snapshot to record balances
        cache.amount0Desired = _balance0();
        cache.amount1Desired = _balance1();
        emit Snapshot(cache.amount0Desired, cache.amount1Desired);
        //Get exact ticks depending on Optimizer's new balances
        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);

        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);

        // Add liquidity to the pool
        (cache.amount0, cache.amount1) = pool.mint(
            address(this),
            tickLower,
            tickUpper,
            cache.liquidity,
            abi.encode(MintCallbackData({payer: address(this)})));

        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Validate operator, collect fees, burn current liquidity, and recalculate optimal liquidity parameters for rebalancing. Swap tokens to balance the portfolio, recalibrate price limits, and then readd liquidity with updated parameters, ensuring the DeFi strategy aligns with the target asset allocation and market conditions."
e46677da2aa46d0434d5704fb41edc63,2206,invariant,total_vs_protocol_Fees,233,243,deposit,"    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
    }
","deposit (Lines 53-57), ","    function deposit() external payable {
        // assume succeeds
        supply = supply.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
",./popsicle_v3_optimizer/spec/PopsicleV3Optimizer.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Accept an ether payment from the caller, increment the total supply with the received amount, and update the caller's balance in the contract with the same amount, ensuring both the total supply and individual balance accurately reflect the new deposit."
45525100b586c92f5f0ca2143f7b4cc8,2182,rule,checkBurnExactLiquidity,29,45,callBurnExactLiquidity,"rule checkBurnExactLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity
    ){
        env e;
        require to == e.msg.sender;
        uint256 amount0;
        uint256 amount1;
        amount0, amount1 = callBurnExactLiquidity(e,
            tickLower,
            tickUpper,
            liquidity,
            e.msg.sender);
        assert liquidity == 0 => amount0 == 0 && amount1 == 0;
        assert liquidity > 0 => amount0 > 0 || amount1 > 0;// && (amount0 <= liquidity || amount1 <= liquidity);
}
","callBurnExactLiquidity (Lines 33-41), ","    function callBurnExactLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity,
        address to
    ) external returns (uint256 amount0, uint256 amount1) {
        
        (amount0 , amount1) = PoolActions.burnExactLiquidity(pool, tickLower, tickUpper, liquidity, to);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Burn an exact amount of liquidity from a specified position within a pool, defined by `tickLower` and `tickUpper`, and transfer the resulting tokens to the address provided. Return the amounts of token0 and token1 received from the burn operation."
64845f8efd52f59bd0979436c555f5b5,2183 | 2184,rule,checkBurnAllLiquidity,47,52,pool.positionLiquidity | callBurnAllLiquidity,"rule checkBurnAllLiquidity(int24 tickLower,
                        int24 tickUpper){
    callBurnAllLiquidity(tickLower, tickUpper);
    // uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
    // assert(liquidity ==0);
}","positionLiquidity (Lines 95-108),  | callBurnAllLiquidity (Lines 43-48), ","    function positionLiquidity(
        IUniswapV3Pool pool,
        int24 _tickLower,
        int24 _tickUpper
    ) internal view returns (uint128 liquidity) {
        //Compute position key
        bytes32 positionKey = PositionKey.compute(
            address(this),
            _tickLower,
            _tickUpper
        );
        //Get liquidity stored in position
        (liquidity, , , , ) = pool.positions(positionKey);
    }
 |     function callBurnAllLiquidity(
        int24 tickLower,
        int24 tickUpper
    ) external {
        PoolActions.burnAllLiquidity(pool, tickLower, tickUpper);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Calculate the liquidity amount of a position within a Uniswap V3 pool by computing the position's key based on the contract's address and specified tick boundaries, then retrieve the liquidity value from the pool's position data. Additionally, provide a mechanism to burn all liquidity in a specified range through an external call."
a16ef090685136f240e8ba864d1a5c94,2181,rule,checkBurnLiquidityShare,10,25,callBurnLiquidityShare,"rule checkBurnLiquidityShare(
        int24 tickLower,
        int24 tickUpper,
        uint256 share,
        address to){
    env e;
    require (share > 0 && share <= totalSupply());
    uint256 totalSupplyBefore = totalSupply();
    uint256 amount0;
    uint256 amount1;
    amount0, amount1 = callBurnLiquidityShare(e, tickLower, tickUpper, share, 
                       e.msg.sender);
    assert(totalSupply() == totalSupplyBefore);
    assert(!lastReverted);
    
}
","callBurnLiquidityShare (Lines 21-30), ","    function callBurnLiquidityShare(
        int24 tickLower,
        int24 tickUpper,       
        uint256 share,
        address to   
    ) external returns (uint256 amount0, uint256 amount1) {
        // uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);
        (amount0 , amount1) = PoolActions.burnLiquidityShare(pool, tickLower, tickUpper, 
                                  totalSupply, share, to, protocolLiquidity);
    }
",./popsicle_v3_optimizer/spec/PoolActions.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Burn a specified share of liquidity from a Uniswap V3 pool within a given tick range and credit the burned liquidity's corresponding amount of tokens to a specified address, returning the amounts of tokens received from the transaction."
3636124e7393cd91814d234bf7aaae1f,2229,rule,integrityOfMulDivNoOverflow,2,19,callMulDiv,"rule integrityOfMulDivNoOverflow(uint256 a,
rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
    require(denominator > 0x0 && a*b <= max_uint256);
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    /*
    assert ((denominator > 0 &&
    (denominator < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) => (result == truncated/denominator));
    */
    assert (result == a*b/denominator);
","callMulDiv (Lines 8-13), ","    function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Calculate the result of multiplying two unsigned integers, 'a' and 'b', then dividing the product by another unsigned integer 'denominator' using the FullMath's mulDiv function, and return the resulting value as 'mulDivResult'."
4727fab67f7fc19673fcc5577ffb230f,2230,rule,integrityOfMulDiv,22,38,callMulDiv,"rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
","callMulDiv (Lines 8-13), ","    function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Calculate the result of multiplying `a` by `b` and then dividing the product by `denominator` using the `FullMath.mulDiv` function, ensuring high precision in mathematical operations involving potentially large numbers, and return this calculated value as `mulDivResult`."
5e04386fa8d2f79a3ea5cd6c0eb5c777,2231 | 2232 | 2233,rule,integrityOfSafeMulDiv,41,57,mul | div | callMulDiv,"rule integrityOfSafeMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0 && 
            mul(a , div(b , denominator)) <= max_uint256 &&
            mul(b , div(a , denominator)) <= max_uint256);
    env e;

    uint256 mul = a * b;
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator);
}
","mul (Lines 16-25),  | div (Lines 27-33),  | callMulDiv (Lines 8-13), ","    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }
 |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;

        return c;
    }
 |     function callMulDiv(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDiv(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,popsicle_v3_optimizer,,Yes,,"Functionality: The code implements two arithmetic operations, multiplication and division, with checks to ensure safety against overflow and division by zero respectively. It also introduces a `callMulDiv` function that utilizes a hypothetical `FullMath.mulDiv` method to calculate the product of two numbers divided by a denominator."
71c79ae268e4e271bdc40ab9946cfbd6,2234,rule,checkMulDivRoundingUp,60,72,callMulDivRoundingUp,"rule checkMulDivRoundingUp(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0x0 && 
             a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
             b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    env e;
    uint256 result = callMulDivRoundingUp(e , a,
             b,
             denominator);
     assert ((a *b % denominator == 0) && result == (a*b)/denominator ||
              (a *b % denominator> 0) && result == (a*b)/denominator + 1);
}
","callMulDivRoundingUp (Lines 15-20), ","    function callMulDivRoundingUp(uint256 a,
             uint256 b,
             uint256 denominator
    ) public pure returns (uint256 mulDivResult){
        mulDivResult = FullMath.mulDivRoundingUp(a, b, denominator);
    }
",./popsicle_v3_optimizer/spec/FullMathWrapper.spec,popsicle_v3_optimizer,,Yes,,"Functionality: Calculate the result of multiplying two unsigned integers (`a` and `b`), then dividing by a third unsigned integer (`denominator`), ensuring the result is rounded up in cases where division would lead to a remainder."
06f4591b7c5302174fab9bad22859e7f,2166,rule,burnDoesNotIncreaseBalance,188,197,changeSupply,"rule burnDoesNotIncreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, amount);
	uint after = balanceOf(burned);
	assert before >= after;
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of a token to a new value, capped at `MAX_SUPPLY`, recalculating key metrics like the ratio of rebasing credits to token supply. It ensures supply changes are significant, preventing updates for unchanged or invalid new supplies, and emits an event with updated statistics."
0ab50333e9e0f234a3fc8d7851508941,2150 | 2153,rule,mintDoesNotDecreaseBalance,143,152,mint | changeSupply,"rule mintDoesNotDecreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	mint(e, burned, amount);
	uint after = balanceOf(burned);
	assert after >= before;
","mint (Lines 42-87),  | changeSupply (Lines 472-507), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Allow users to mint a stablecoin (OUSD) by depositing supported assets, ensuring the mint amount is not less than a minimum requirement based on asset price. It also handles supply adjustments, maintaining a stable value through rebasing while ensuring supply changes respect a maximum limit."
172b126d74fd4b7f46a10cdaadc8bd21,2140 | 2141,rule,changesRebaseState,79,90,rebaseOptIn | rebaseOptOut,"rule changesRebaseState(method f) {
	address who;
	
	uint8 _rebaseState = rebaseState(who);
	executeAFunction(f);
	uint8 rebaseState_ = rebaseState(who);
	assert _rebaseState == rebaseState_ 
			|| f.selector == rebaseOptIn().selector 
			|| f.selector == rebaseOptOut().selector;
}
","rebaseOptIn (Lines 424-445),  | rebaseOptOut (Lines 450-464), ","    function rebaseOptIn() public nonReentrant {
        require(_isNonRebasingAccount(msg.sender), ""Account has not opted out"");

        // Convert balance into the same amount at the current exchange rate
        uint256 newCreditBalance = _creditBalances[msg.sender]
            .mul(rebasingCreditsPerToken)
            .div(_creditsPerToken(msg.sender));

        // Decreasing non rebasing supply
        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));

        _creditBalances[msg.sender] = newCreditBalance;

        // Increase rebasing credits, totalSupply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.add(_creditBalances[msg.sender]);

        rebaseState[msg.sender] = RebaseOptions.OptIn;

        // Delete any fixed credits per token
        delete nonRebasingCreditsPerToken[msg.sender];
    }
 |     function rebaseOptOut() public nonReentrant {
        require(!_isNonRebasingAccount(msg.sender), ""Account has not opted in"");

        // Increase non rebasing supply
        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));
        // Set fixed credits per token
        nonRebasingCreditsPerToken[msg.sender] = rebasingCreditsPerToken;

        // Decrease rebasing credits, total supply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.sub(_creditBalances[msg.sender]);

        // Mark explicitly opted out of rebasing
        rebaseState[msg.sender] = RebaseOptions.OptOut;
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Provide users the ability to opt in or out of a rebasing mechanism. When opting in, convert user's balance to the current exchange rate, adjusting the non-rebasing and rebasing supplies accordingly. For opting out, increase the non-rebasing supply and set a fixed credit per token rate, while adjusting the rebasing credits."
43629d13110e25cce99299a81b48fdc5,2142 | 2143 | 2146,rule,reverseOptInThenOut,96,119,rebaseOptIn | rebaseOptOut | changeSupply,"rule reverseOptInThenOut(address u) {
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0(); // had typo, TODO rerun
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	env eF;
	require eF.msg.sender == u;
	uint256 _nonRebasingSupply = nonRebasingSupply();
	uint256 _rebasingCredits = rebasingCredits();
	uint256 _balance = balanceOf(u);
	uint256 _nonRebasingCreditsPerToken = nonRebasingCreditsPerToken(u);
	// assume currently not opt-in // TODO: Strengthen - should be explicity it's opt-out or require that it is not rebasing at the moment it's run
	require rebaseState(u) != OPT_IN();
	sinvoke rebaseOptIn(eF);
	sinvoke rebaseOptOut(eF);
	uint256 nonRebasingSupply_ = nonRebasingSupply();
	assert _nonRebasingSupply == nonRebasingSupply_, ""non rebasing supply must be preserved when opting-in and immediately opting-out"";
	uint256 rebasingCredits_ = rebasingCredits();
	assert _rebasingCredits == rebasingCredits_, ""rebasing credits must be preserved when opting-in and immediately opting-out"";
	uint256 balance_ = balanceOf(u);
	assert _balance == balance_, ""balance of user must be preserved if user opts-in and immediately opts-out"";
","rebaseOptIn (Lines 424-445),  | rebaseOptOut (Lines 450-464),  | changeSupply (Lines 472-507), ","    function rebaseOptIn() public nonReentrant {
        require(_isNonRebasingAccount(msg.sender), ""Account has not opted out"");

        // Convert balance into the same amount at the current exchange rate
        uint256 newCreditBalance = _creditBalances[msg.sender]
            .mul(rebasingCreditsPerToken)
            .div(_creditsPerToken(msg.sender));

        // Decreasing non rebasing supply
        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));

        _creditBalances[msg.sender] = newCreditBalance;

        // Increase rebasing credits, totalSupply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.add(_creditBalances[msg.sender]);

        rebaseState[msg.sender] = RebaseOptions.OptIn;

        // Delete any fixed credits per token
        delete nonRebasingCreditsPerToken[msg.sender];
    }
 |     function rebaseOptOut() public nonReentrant {
        require(!_isNonRebasingAccount(msg.sender), ""Account has not opted in"");

        // Increase non rebasing supply
        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));
        // Set fixed credits per token
        nonRebasingCreditsPerToken[msg.sender] = rebasingCreditsPerToken;

        // Decrease rebasing credits, total supply remains unchanged so no
        // adjustment necessary
        rebasingCredits = rebasingCredits.sub(_creditBalances[msg.sender]);

        // Mark explicitly opted out of rebasing
        rebaseState[msg.sender] = RebaseOptions.OptOut;
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: The code implements mechanisms for users to opt in or out of rebasing for a token, adjusting their balance and the overall token supply metrics accordingly, and allows for the supply of the token to be changed, maintaining the integrity of the total and non-rebasing supplies throughout."
4b64abcbac1abba4a89abd58adb082d2,2136,rule,totalSupplyIntegrity,54,62,changeSupply,"rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjusts the total supply of a token to a specified value, with limitations set by a maximum supply threshold, ensuring no adjustment to zero or negative values. It recalculates a proportionate credit per token, ensuring the change is valid and emitting an event to signal the update."
4c159c21e7a59af1463f4d50a3c91157,2173,rule,transferCheckPreconditions,214,227,transfer,"rule transferCheckPreconditions(env e, address to, uint256 value)
{
	require to != 0;
	require value != 0;
	
	address from = e.msg.sender;
	bool precondition = balanceOf(from) >= value;

	bool result = transfer@withrevert(e, to, value);
	bool transferReverted = lastReverted; // loading transferReverted
	// The transfer function must meet the precondition, or to revert.
	assert !precondition => (transferReverted || !result), ""If transfer() precondition does not hold, must either revert or return 0"";
}
","transfer (Lines 109-121), ","    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Transfer to zero address"");
        require(
            _value <= balanceOf(msg.sender),
            ""Transfer greater than balance""
        );

        _executeTransfer(msg.sender, _to, _value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Validate that the recipient's address is not zero and the sender has enough balance before executing a transfer of a specified value from the sender's to the recipient's account, and emit a Transfer event documenting the transaction."
73689d9fc34026be926eb7e27b25c843,2148,rule,additiveMint,125,141,mint,"rule additiveMint(address minter, uint256 x, uint256 y) {
	env e;
    storage init = lastStorage;	

    mint(e, minter, x);
    mint(e, minter, y);
    uint b1 = balanceOf(minter);
    
    require x+y <= MAX_UINT256();
    uint sumXY = x+y;
    mint(e, minter, sumXY) at init;
    uint b2 = balanceOf(minter);
    assert b1 == b2, ""mint is not additive in balance of burned"";
}
","mint (Lines 42-87), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Validate the asset and amount for minting, calculating its price and adjusting for decimals to ensure it meets the minimum required OUSD amount. Emit a Mint event, potentially trigger a rebase if above threshold, mint OUSD to the sender, transfer deposited assets to the contract, and possibly initiate allocation if above a defined threshold."
8971fb1874e7a89ff1c97e87fa8b565f,2127,invariant,optingInAndOutSyncdWithNonRebasingState,344,366,changeSupply,"invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of a token within predefined limits, ensuring it cannot exceed a maximum value or drop to zero. It recalculates a per-token credit value, ensuring it remains positive, and emits an event detailing the adjusted supply, total credits, and the calculated per-token credit value."
9101b5f85c42cb7c398b9205c0f0ae30,2118,invariant,totalSupplyIsBelowMaxSupply,29,39,changeSupply,"invariant totalSupplyIsBelowMaxSupply() 
	totalSupply() <= Certora_maxSupply()

rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of a token, ensuring it does not exceed a maximum limit and maintaining a balance with non-rebasing supply. It recalculates the per-token credit based on the new total supply, validating the operation does not result in a zero or negative supply adjustment, and emits an event detailing the update."
bce514d6299a44b797bfb87ba29e53d5,2177,rule,isRebasingPredicateSynchronized,348,366,changeSupply,"rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply to a new value, ensuring it does not exceed a predefined maximum, while maintaining the proportionate allocation of rebasing credits per token. Emit an event documenting the change in total supply, rebasing credits, and rebasing credits per token."
c6bd4fc19bed3b4f9e4bba2912b893be,2123,invariant,rebasingCreditsPerTokenMustBeGreaterThan0,34,62,changeSupply,"	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of a cryptocurrency, ensuring it does not exceed a preset maximum. If the new supply is different, it recalculates the per-token credit based on rebasable and non-rebasable supplies, validating that the change preserves a positive credit value, and emits an event to log the update."
edfff2a81ec7a1cafbc532a35123aaa0,2132,rule,neverRevert_BalanceOf,33,39,changeSupply,"rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total token supply to a new value, within the bounds of a maximum supply limit, recalculating a per-token credit ratio. This adjustment restricts changes to a non-zero supply and ensures the recalculated credits per token remain positive, emitting an updated supply event upon change."
f42822566974f4f8ba598551edb94bb1,2155 | 2158,rule,zeroMintDoesNotIncreaseBalance,154,163,mint | changeSupply,"rule zeroMintDoesNotIncreaseBalance(address user) {
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(user);
	mint(e, user, 0);
	uint after = balanceOf(user);
	assert after == before;
","mint (Lines 42-87),  | changeSupply (Lines 472-507), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: The code allows users to mint a new asset (OUSD) by depositing a supported asset, ensuring the deposited amount meets a minimum OUSD value threshold. It optionally triggers a rebase and allocation of funds based on thresholds, after adjusting for price and decimals precision. Additionally, it permits authorized entities to adjust the total supply of a system's internal credits, ensuring the new supply does not invalidate the credits-to-token ratio."
f4466f865ca52d7ffa25b07318044952,2171,rule,zeroBurnDoesNotDecreaseBalance,199,208,changeSupply,"rule zeroBurnDoesNotDecreaseBalance(address burned){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, 0);
	uint after = balanceOf(burned);
	assert before == after;
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of tokens, ensuring it does not exceed a maximum limit and maintaining the relationship between rebasing credits and supply. It recalculates rebasing credits per token and updates the total supply accordingly, emitting an event with the updated values."
edfff2a81ec7a1cafbc532a35123aaa0,2132,rule,neverRevert_BalanceOf,33,39,changeSupply,"rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Safely adjust the total supply of a token, ensuring it does not exceed a maximum limit, and update its rebasing credits per token proportionally. It emits an event upon successful supply adjustment or in case the new supply matches the current, without making changes."
f42822566974f4f8ba598551edb94bb1,2155 | 2158,rule,zeroMintDoesNotIncreaseBalance,154,163,mint | changeSupply,"rule zeroMintDoesNotIncreaseBalance(address user) {
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(user);
	mint(e, user, 0);
	uint after = balanceOf(user);
	assert after == before;
","mint (Lines 42-87),  | changeSupply (Lines 472-507), ","    function mint(
        address _asset,
        uint256 _amount,
        uint256 _minimumOusdAmount
    ) external whenNotCapitalPaused nonReentrant {
        require(assets[_asset].isSupported, ""Asset is not supported"");
        require(_amount > 0, ""Amount must be greater than 0"");

        uint256 price = IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        );
        if (price > 1e8) {
            price = 1e8;
        }
        uint256 assetDecimals = Helpers.getDecimals(_asset);
        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**assetDecimals
        );

        if (_minimumOusdAmount > 0) {
            require(
                priceAdjustedDeposit >= _minimumOusdAmount,
                ""Mint amount lower than minimum""
            );
        }

        emit Mint(msg.sender, priceAdjustedDeposit);

        // Rebase must happen before any transfers occur.
        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {
            _rebase();
        }

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        if (unitAdjustedDeposit >= autoAllocateThreshold) {
            _allocate();
        }
    }
 |     function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Enable users to mint a new digital asset (OUSD) by depositing a supported asset, after calculating its value based on current market prices, ensuring the deposit meets a minimum value, and potentially triggering a rebase to adjust the supply if certain thresholds are met."
f4466f865ca52d7ffa25b07318044952,2171,rule,zeroBurnDoesNotDecreaseBalance,199,208,changeSupply,"rule zeroBurnDoesNotDecreaseBalance(address burned){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, 0);
	uint after = balanceOf(burned);
	assert before == after;
","changeSupply (Lines 472-507), ","    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        nonReentrant
    {
        require(_totalSupply > 0, ""Cannot increase 0 supply"");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                rebasingCredits,
                rebasingCreditsPerToken
            );
            return;
        }

        _totalSupply = _newTotalSupply > MAX_SUPPLY
            ? MAX_SUPPLY
            : _newTotalSupply;

        rebasingCreditsPerToken = rebasingCredits.divPrecisely(
            _totalSupply.sub(nonRebasingSupply)
        );

        require(rebasingCreditsPerToken > 0, ""Invalid change in supply"");

        _totalSupply = rebasingCredits
            .divPrecisely(rebasingCreditsPerToken)
            .add(nonRebasingSupply);

        emit TotalSupplyUpdated(
            _totalSupply,
            rebasingCredits,
            rebasingCreditsPerToken
        );
    }
",./ousd/spec/ousd.spec,ousd,,Yes,,"Functionality: Adjust the total supply of a token, not exceeding a maximum limit, and recalibrate the per-token value based on rebasing credits. Emit an event to document the updated total supply, ensuring changes reflect the correct proportion of non-rebasing supply to maintain integrity and prevent invalid supply adjustments."
60186133244f5a189bb6ab2192425b52,2115,rule,mathOfChangeSupply,38,49,divPrecisely,"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= T || T2 == NR;
}
","divPrecisely (Lines 102-111), ","    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
",./ousd/spec/math.spec,ousd,,Yes,,"Functionality: Multiply the first input, \(x\), by a predefined constant, \(FULL\_SCALE\), to scale up the precision of the division, and then divide this product by the second input, \(y\), to compute the result with enhanced precision, returning this value."
b83a4d1b5304b0bec228d2b8bf703b31,2114,rule,mathOfChangeSupply,24,35,divPrecisely,"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= MAX_SUPPLY();
}
","divPrecisely (Lines 102-111), ","    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
",./ousd/spec/math.spec,ousd,,Yes,,"Functionality: Multiply the first argument `x` by a constant factor `FULL_SCALE` to upscale the precision, and then divide the result by the second argument `y` to achieve precise division. This method is used to prevent loss of precision during division operations in Solidity."
050a1318d8f5f1f966d841830505720e,1956,rule,onlyValidOtoken,274,293,smallVault,"rule onlyValidOtoken(address owner, uint256 vaultId, uint256 index, address otoken, method f) {
    links();
    require shortOtoken.underlyingAsset() == underlying;
    require longOtoken.underlyingAsset() == underlying;
    require shortOtoken.strikeAsset() == strike;
    require longOtoken.strikeAsset() == strike;
    require shortOtoken.collateralAsset() == collateralToken;
    require longOtoken.collateralAsset() == collateralToken;
    require smallVault(owner, vaultId, 1);
    require (otoken == shortOtoken || otoken == longOtoken );
    require ( getVaultShortOtoken(owner, vaultId, index) == otoken || getVaultLongOtoken(owner, vaultId, index) == otoken) 
            => whitelist.isWhitelistedOtoken(otoken);
    uint256 before = pool.getStoredBalance(otoken);
    uint256 totalSupplyBefore = assetTotalSupply(otoken);
    require !whitelist.isWhitelistedCollateral(otoken);
    callFunctionWithParameters(f, owner, vaultId, index);
    uint256 after = pool.getStoredBalance(otoken);
    uint256 totalSupplyAfter = assetTotalSupply(otoken);
    assert ( before != after || totalSupplyBefore != totalSupplyAfter) => whitelist.isWhitelistedOtoken(otoken);
}
","smallVault (Lines 53-66), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Determine if a specified `vault` belonging to an `owner` with a unique `vaultId` contains equal to or fewer `shortOtokens`, `longOtokens`, `collateralAssets`, `longAmounts`, `shortAmounts`, and `collateralAmounts` than a given count `c`, returning `true` or `false` accordingly."
49a3f5a95b99d82d25e19278dac469be,1950 | 1952,rule,cantSettleUnexpiredVault,242,251,smallVault | settleVault,"rule cantSettleUnexpiredVault(address owner, uint256 vaultId)
{
    links();
    env e;
    require !isVaultExpired(e, owner, vaultId);
    require smallVault(owner, vaultId, 1);
    address whoever;
    sinvoke settleVault(e, owner, vaultId, whoever);
    assert false; // will pass because cannot sinvoke settleVault when dealing with a non-expired vault
}
","smallVault (Lines 53-66),  | settleVault (Lines 360-367), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Determine if a vault, identified by its owner and vaultId, meets specific size criteria based on the count 'c' for each of its components (shortOtokens, longOtokens, collateralAssets, longAmounts, shortAmounts, collateralAmounts), and enable the settling of a specified vault by transferring its assets to a designated address."
512a4fbcaafc8e04288ecaae97ea81a9,1934 | 1935 | 1941 | 1942 | 1943 | 1944 | 1945 | 1946,rule,validBalanceTotalCollateralPostExpiry,217,240,smallVault | isValidVault | depositCollateral | withdrawCollateral | redeemA | redeemB | settleVault | getProceed,"// rule validBalanceTotalCollateralPostExpiry(address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
    // env e;
    // require oToken == shortOtoken;
    // require collateral == collateralToken;
    // require isValidVault(owner, vaultId); 
    // require getVaultShortOtoken(owner, vaultId, index) == oToken;
    // require getVaultCollateralAsset(owner, vaultId, index) == collateral;
    // uint256 collateralVaultBefore = getProceed(owner, vaultId);
    // uint256 supplyBefore = shortOtoken.totalSupply();
    // // uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);

    // sinvoke settleVault(e, owner, vaultId, to);
    // uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    // uint256 supplyAfter = shortOtoken.totalSupply();
    // // uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);
    // assert shortVaultAfter == 0;
    // assert supplyAfter == supplyBefore;
    // // assert collateralBalanceBefore - collateralBalanceAfter == collateralVaultBefore;
    
    // 1. in a single tx only 1 vault can be modified 
    // 
// }
","smallVault (Lines 53-66),  | isValidVault (Lines 79-88),  | depositCollateral (Lines 230-247),  | withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function isValidVault(address owner, uint256 vaultId) external view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    (, bool isValidVault) = calculator.getExcessCollateral(
      _vault.shortAmounts[0],
      _vault.longAmounts[0],
      _vault.collateralAmounts[0],
      vaultType[owner][vaultId]
    );
    return isValidVault;
  }
 |   function depositCollateral(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _depositCollateral(args);
  }
 |   function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a financial vault to ensure secure collateral operations like deposits and withdrawals, validate vault storage criteria, redeem financial instruments, and settle vaults for users. It includes checking if a vault is valid based on collateral sufficiency and retrieving net collateral value if excess exists."
5ce0b2474c274690848c224da7ba774c,1911 | 1915 | 1916 | 1917 | 1918 | 1919,rule,validBalanceTotalCollateral,111,142,smallVault | depositCollateral | withdrawCollateral | redeemA | redeemB | settleVault,"rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
","smallVault (Lines 53-66),  | depositCollateral (Lines 230-247),  | withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositCollateral(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _depositCollateral(args);
  }
 |   function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Implement restrictions and actions on a financial vault. Restrict collateral deposits and withdrawals to small vaults, enable the redemption of specific tokens, and allow settling of vaults. This ensures controlled interactions based on the vault size and predefined conditions for asset management and redemption."
650a8ad637770c08c9dff6bd1ba25058,1930 | 1931 | 1932,rule,validBalanceTotalShort,190,215,mintOtokenA | redeemA | settleVault,"rule validBalanceTotalShort(address owner, uint256 vaultId, uint256 index, address secondAddress, address oToken, method f, uint256 amount)
description ""$f breaks the validity of stored balance of short asset""
{
    links();
    env e;
    calldataarg arg;
    require oToken == shortOtoken;
    require !isVaultExpired(e, owner, vaultId);
    require getVaultShortOtoken(owner, vaultId, index) == oToken;
    uint256 shortVaultBefore = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyBefore = shortOtoken.totalSupply();
    // only test the cases before expiry
    if (f.selector == settleVault(address,uint256,address).selector) ||  (f.selector == redeemA(address,uint256).selector) {
        assert true;
    } else if (f.selector == mintOtokenA(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenA(e, owner, vaultId, secondAddress, index, amount);
	} else {
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyAfter = shortOtoken.totalSupply();
    assert shortVaultBefore != shortVaultAfter => (supplyAfter - supplyBefore ==  shortVaultAfter - shortVaultBefore);
    assert supplyAfter != supplyBefore => ( supplyAfter - supplyBefore  ==  shortVaultAfter - shortVaultBefore);
}
","mintOtokenA (Lines 268-285),  | redeemA (Lines 344-347),  | settleVault (Lines 360-367), ","  function mintOtokenA(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.MintArgs memory args = Actions.MintArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      otoken: anOtokenA,
      index: index,
      amount: amount
    });
    _mintOtoken(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: The provided code implements three operations related to managing tokens and vaults within a finance-oriented smart contract: minting a specific type of oToken (`anOtokenA`) into a designated account, redeeming said oToken for an underlying asset, and settling a vault by transferring its contents or obligations to another account."
ae94560add7fa0d990dce0ccd9050ce5,1900 | 1907 | 1908 | 1909,rule,validState,72,99,smallVault | depositLongB | redeemA | redeemB,"rule validState(address owner, uint256 vaultId, uint256 index,  method f) 
{
    links();
    /* TODO: Redeem */
    require f.selector != redeemA(address,uint256).selector && f.selector != redeemB(address,uint256).selector;
    /* TODO: depositLongB */
    require f.selector != depositLongB(address,uint256,address,uint256,uint256).selector;
    
    require smallVault(owner, vaultId, 1);
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index) &&
            longOtoken == getVaultLongOtoken(owner, vaultId, index) &&
            collateralToken == getVaultCollateralAsset(owner, vaultId, index) 
    ;
    require assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
            assetTotalSupply(longOtoken) >= pool.getStoredBalance(longOtoken) &&
            pool.getStoredBalance(longOtoken) >= getVaultLongAmount(owner, vaultId, index) &&
            pool.getStoredBalance(collateralToken) >= getVaultCollateralAmount(owner, vaultId, index) 
    callFunctionWithParameters(f, owner, vaultId, index);
    assert  assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
}
","smallVault (Lines 53-66),  | depositLongB (Lines 176-192),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositLongB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Check if a vault is considered ""small"" based on a limit, deposit an asset into a specified vault, and redeem specific oTokens for a receiver. The code facilitates interactions with vault structures, allowing operations such as asset deposition and token redemption based on predefined conditions."
d962e3e79c34af762c0fcb779b48018b,1921 | 1924 | 1925,rule,validBalanceTotalLong,151,181,smallVault | depositLongB | mintOtokenB,"rule validBalanceTotalLong(address owner, uint256 vaultId, uint256 index, method f, address secondAddress, uint256 amount, address asset)
description ""$f breaks the validity of stored balance of long asset""
{
    links();
    env e;
    require asset == longOtoken;
    require getVaultLongOtoken(owner, vaultId, index) == asset;
    uint256 longVaultBefore = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = longOtoken.balanceOf(pool);
    // the margin pool can neither be the owner nor the msg sender since it is a contract. 
    require (owner != pool);
    require (e.msg.sender != pool);

    if (f.selector == depositLongB(address,uint256,address,uint256,uint256).selector) {
        sinvoke depositLongB(e, owner, vaultId, secondAddress, index, amount);
	} else if (f.selector == mintOtokenB(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenB(e, owner, vaultId, secondAddress, index, amount);
	} else {
        require smallVault(owner, vaultId, 1);
        require longOtoken.collateralAsset() == collateralToken;
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    
    uint256 longVaultAfter = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = longOtoken.balanceOf(pool);
    assert longVaultBefore != longVaultAfter => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
    assert poolBalanceAfter != poolBalanceBefore => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
}
","smallVault (Lines 53-66),  | depositLongB (Lines 176-192),  | mintOtokenB (Lines 287-304), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositLongB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
 |   function mintOtokenB(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.MintArgs memory args = Actions.MintArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      otoken: anOtokenB,
      index: index,
      amount: amount
    });
    _mintOtoken(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Ensure that a vault owned by a specified address and identified by a vaultId is considered ""small"" based on a given capacity, support deposits of a specified long option (""anOtokenB""), and allow minting of a specific option (""anOtokenB"") if the vault meets the ""small"" criteria."
d962e3e79c34af762c0fcb779b48018b,1921 | 1924 | 1925,rule,validBalanceTotalLong,151,181,smallVault | depositLongB | mintOtokenB,"rule validBalanceTotalLong(address owner, uint256 vaultId, uint256 index, method f, address secondAddress, uint256 amount, address asset)
description ""$f breaks the validity of stored balance of long asset""
{
    links();
    env e;
    require asset == longOtoken;
    require getVaultLongOtoken(owner, vaultId, index) == asset;
    uint256 longVaultBefore = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = longOtoken.balanceOf(pool);
    // the margin pool can neither be the owner nor the msg sender since it is a contract. 
    require (owner != pool);
    require (e.msg.sender != pool);

    if (f.selector == depositLongB(address,uint256,address,uint256,uint256).selector) {
        sinvoke depositLongB(e, owner, vaultId, secondAddress, index, amount);
	} else if (f.selector == mintOtokenB(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenB(e, owner, vaultId, secondAddress, index, amount);
	} else {
        require smallVault(owner, vaultId, 1);
        require longOtoken.collateralAsset() == collateralToken;
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    
    uint256 longVaultAfter = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = longOtoken.balanceOf(pool);
    assert longVaultBefore != longVaultAfter => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
    assert poolBalanceAfter != poolBalanceBefore => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
}
","smallVault (Lines 53-66),  | depositLongB (Lines 176-192),  | mintOtokenB (Lines 287-304), ","  function smallVault(
    address owner,
    uint256 vaultId,
    uint256 c
  ) public view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    return
      _vault.shortOtokens.length <= c &&
      _vault.longOtokens.length <= c &&
      _vault.collateralAssets.length <= c &&
      _vault.longAmounts.length <= c &&
      _vault.shortAmounts.length <= c &&
      _vault.collateralAmounts.length <= c;
  }
 |   function depositLongB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
 |   function mintOtokenB(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.MintArgs memory args = Actions.MintArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      otoken: anOtokenB,
      index: index,
      amount: amount
    });
    _mintOtoken(args);
  }
",./opyn_gamma_protocol/specs/ValidBalances.spec,opyn_gamma_protocol,,Yes,,"Functionality: Ensure that a given vault, identified by its owner and vaultId, does not exceed a certain capacity (c) in terms of otokens, collateral, and amounts stored. Additionally, facilitate the deposit of a long position and mint a specific otokenB if the vault is within the defined limits."
3e0697cfaa867b0fa785a2bcec4afbb0,2104 | 2105,rule,putOptionsPreExpiryCase3StartingWithAllCasesNoCode,600,692,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase3StartingWithAllCasesNoCode(
rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
     require shortPrice != longPrice; // <============= make sure this is a valid requirement ADD rule
    //everything changed beside:
    // 1. total supply of long (it changes only when minting - adding as short) 
    require totalSupplyLongOtoken_ == _totalSupplyLongOtoken;
    // 2.  pool holding of short (it changes only when adding as long) 
    require poolShortOtokenBalance_  == _poolShortOtokenBalance;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Modify the total supply of a digital asset and update specific amounts within a margin vault. The first function allows the setting of a new total supply, while the second updates short, long, and collateral amounts in a specified vault position for an owner."
69378398b8133fca749db4dfe0a432a4,2044 | 2045,invariant,putOptionsPreExpiryCase1StartingWithAllCases,679,698,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
function links() {
    require anOtokenA() == shortOtoken;
    require anOtokenB() == longOtoken;
    require dummyERC20C() == collateralToken;
}","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Modify the value of the total supply of tokens and perform alterations on a specified vault's contents, including its short amounts, long amounts, and collateral amounts, based on the parameters provided by the caller."
97f057cfc07a41d098ca4640b36edaa3,2068 | 2069,rule,putOptionsPreExpiryCase2StartingWithAllCases,197,316,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase2StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of a token and modify the properties of a specific margin vault within a decentralized finance (DeFi) protocol. This involves adjusting the amounts of short positions, long positions, and collateral held within a given vault based on specified indices."
9e6cad8ea296e3dfc508d6ec1acb4954,2019 | 2020,invariant,putOptionsPreExpiryCase1StartingWithAllCases,303,441,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase3StartingWithAllCases(
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of a token to a new value. Modify specific values within a margin trading vault, including the amounts for short positions, long positions, and collateral, based on the provided indexes and amounts for a given vault owned by a user."
a84864f216889eba754fa9b5c7c0de37,2056 | 2057,rule,putOptionsPreExpiryCase1StartingWithAllCases,60,194,shortOtoken.havocTotalSupply | havocVault,"This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Modify the total supply of a cryptocurrency and adjust the content of a specified vault by updating the amounts of short positions, long positions, and collateral held at a given index within the vault, for a particular owner and vault ID."
ab45c728ea5bd7fbe18def86689e2164,2031 | 2032,invariant,putOptionsPreExpiryCase1StartingWithAllCases,428,595,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
/** For put options before expiry (strong bound): 
  obligation(o)   (o.totalSupply() - storedBalance(o)) 
  The debt computation is also different 
rule callOptionsPreExpiry(
   // assume before expiry
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of a currency and modify the amounts within a specific trader's margin vault, adjusting their short positions, long positions, and collateral amounts at a designated index, thereby allowing dynamic management of trading strategies and margin requirements."
c722d9326bf19a90005f2ac4c3eb3acf,2080 | 2081,rule,putOptionsPreExpiryCase3StartingWithAllCases,318,441,shortOtoken.havocTotalSupply | havocVault,"rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of tokens to a new value and modify the amounts of shorts, longs, and collateral within a specific vault for a given user. This is achieved by directly setting new amounts in the specified index of the vault's arrays."
e4b457b6683f6db56193b1e3763565fb,2007 | 2008,invariant,putOptionsPreExpiryCase1StartingWithAllCases,181,316,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Modify the total supply of an asset and adjust the contents of a specified vault by setting new amounts for shorts, longs, and collateral at a given index. This allows updating the asset's supply and the specific allocations within a user's vault."
ea3d83ed976940e0ddc7cfb8b3596b17,2092 | 2093,rule,callOptionsPreExpiry,449,595,shortOtoken.havocTotalSupply | havocVault,"rule callOptionsPreExpiry(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
   // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume before expiry
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of a smart contract's token and modify specific properties (short amounts, long amounts, and collateral amounts) of a particular vault identified by its owner and ID within a decentralized finance (DeFi) platform or protocol."
e4b457b6683f6db56193b1e3763565fb,2007 | 2008,invariant,putOptionsPreExpiryCase1StartingWithAllCases,181,316,shortOtoken.havocTotalSupply | havocVault,"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Modify the total supply of a token and update the composition of a specific vault within a margin trading system. This involves adjusting the amounts of short positions, long positions, and collateral associated with a given vault index for a particular user."
ea3d83ed976940e0ddc7cfb8b3596b17,2092 | 2093,rule,callOptionsPreExpiry,449,595,shortOtoken.havocTotalSupply | havocVault,"rule callOptionsPreExpiry(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
   // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume before expiry
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","havocTotalSupply (Lines 5-7),  | havocVault (Lines 24-36), ","  function havocTotalSupply(uint256 newVal) public {
    _totalSupply = newVal;
  }
 |   function havocVault(
    address owner,
    uint256 vaultId,
    uint256 i,
    uint256 newShortAmount,
    uint256 newLongAmount,
    uint256 newcollateralAmount
  ) external {
    MarginVault.Vault storage vault = cheapGetVault(owner, vaultId);
    vault.shortAmounts[i] = newShortAmount;
    vault.longAmounts[i] = newLongAmount;
    vault.collateralAmounts[i] = newcollateralAmount;
  }
",./opyn_gamma_protocol/specs/NoBankruptcy.spec,opyn_gamma_protocol,,Yes,,"Functionality: Update the total supply of a token to a new value and modify specific attributes of a vault associated with a user, including short amounts, long amounts, and collateral amounts, based on indices within the vault's storage structure."
02ca98dfad2c23841fca242854819613,1737 | 1738 | 1739,rule,successOfAddCollateral,101,123,addShort | addLong | addCollateral,"rule successOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	require x > 0;
	require index < MAXINT();
	// require index <= collateralAmountLength();
	if (index < collateralAmountLength()) {
		require asset == getCollateralAsset(index);
		require getCollateralAmount(index) + x < MAXINT();

		invoke addCollateral(asset, x, index);
		assert !lastReverted, ""addCollateral may revert when precondition holds"";
	else if ((index == collateralAmountLength())) {
	else {
		assert lastReverted, ""addCollateral may not revert when precondition not holds"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage positions within a financial vault by allowing the addition of short, long, and collateral token amounts. The code handles array indexing to ensure valid operations, supports incrementing existing positions, and safeguards against adding incompatible token types to specified positions."
236167c16e7e7307b4deb55ee73eafc8,1866 | 1867 | 1868 | 1877,rule,additiveAddLong,251,270,addShort | addLong | addCollateral | totalLongAmount,"rule additiveAddLong(address longOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addLong(longOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addLong(longOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 longAmountScenario1 = totalLongAmount();
	invoke addLong(longOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 longAmountScenario2 = totalLongAmount();
	assert (call1 && call2) <=> call3, ""addLong is not additive, one scenario reverts"" ;
	assert call3 => longAmountScenario1 == longAmountScenario2, ""addLong is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a financial vault that handles short options, long options, and collateral. It allows users to add new options or collateral, increase the amounts of existing ones at specified indexes, and calculate the total amount of long options within the vault."
39c3a9fccc4fb5b981ef0f2785f0a014,1882 | 1883 | 1884 | 1885 | 1894,rule,inverseAddRemoveLong,275,282,addShort | addLong | removeLong | addCollateral | totalLongAmount,"rule inverseAddRemoveLong(address longOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	invoke removeLong(longOtoken, x, index);
	assert !lastReverted && totalLongAmount() == longAmountBefore, ""removeLong is not inverse of addLong""; 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | removeLong (Lines 142-158),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function removeLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed long oToken exists in the vault at the specified index
        require(_index < _vault.longOtokens.length, ""V5"");
        require(_vault.longOtokens[_index] == _longOtoken, ""V6"");

        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);

        if (newLongAmount == 0) {
            delete _vault.longOtokens[_index];
        }
        _vault.longAmounts[_index] = newLongAmount;
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a trading vault where you can add or remove options tokens (shorts, longs) and collateral. Ensure additions are valid, increase token amounts, allow removals, respect indexing, and calculate the total value of long positions. Enforce validation for token existence, ensure non-zero amounts, and maintain array integrity."
3ad2a8378261e379ed62392d65de0601,1817 | 1818 | 1819 | 1824,rule,additiveAddShort,201,220,addShort | addLong | addCollateral | totalShortAmount,"rule additiveAddShort(address shortOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addShort(shortOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addShort(shortOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 shortAmountScenario1 = totalShortAmount();
	invoke addShort(shortOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 shortAmountScenario2 = totalShortAmount();
	assert (call1 && call2) <=> call3, ""addShort is not additive, one scenario reverts"" ;
	assert call3 => shortAmountScenario1 == shortAmountScenario2, ""addShort is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage the composition of a financial vault by adding short, long positions, and collateral. It ensures positions and collateral are validly indexed and amounts are non-zero before updating or adding them. Additionally, it calculates the total amount of short positions within the vault."
4b38832ee95c4814758b06189b7a4033,1707 | 1708 | 1709,invariant,validEntityIndex,39,66,addShort | addLong | addCollateral,"invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage the composition of a financial vault by adding short positions, long positions, and collateral. The code ensures new positions are correctly added or existing positions are accurately updated based on the provided indexes, amounts, and asset addresses, enforcing specific validation rules."
54b857c4706c889257933f670394ab53,1752 | 1753 | 1754 | 1755,rule,integrityOfAddCollateral,133,140,addShort | addLong | addCollateral | totalCollateral,"rule integrityOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	assert totalCollateral() == collateralBefore + x, ""integirty break of addCollateral"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage assets within a structured vault by allowing the addition of short positions, long positions, and collateral through respective functions. This involves validating inputs, updating records by either appending new entries or incrementing existing ones, and calculating the total collateral value."
71637656ffd1b79750231b8ee301a89b,1850 | 1851 | 1852 | 1861,rule,integrityOfAddLong,238,246,addShort | addLong | addCollateral | totalLongAmount,"rule integrityOfAddLong(address longOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	assert totalLongAmount() == longAmountBefore + x &&
		getLongOtoken(index) == longOtoken, ""integirty break of addLong"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalLongAmount (Lines 117-123), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalLongAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.longAmounts.length; i++) {
      total = total.add(vault.longAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a financial vault's assets by adding short positions, long positions, and collateral with specific amounts and at certain indexes. Additionally, calculate the total amount of long positions. Ensure validations for amount inputs, index ranges, and matching asset addresses before modifications."
9ee564552c028dccb08431b2936866ef,1768 | 1769 | 1770 | 1771,rule,additiveAddCollateral,148,167,addShort | addLong | addCollateral | totalCollateral,"rule additiveAddCollateral(address asset, uint256 x, uint256 y, uint256 index)
{
		requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
    	require index < MAXINT(); // no violation when limiting index
    	require x > 0 && y > 0 ;
    	uint256 t = x + y ;
        require( t >= x && t >= y); //no overflow
        storage initialStorage = lastStorage;
    	invoke addCollateral(asset, x, index);
    	bool call1 = !lastReverted;
    	invoke addCollateral(asset, y, index);
    	bool call2 = !lastReverted;
    	uint256 collateralAmountScenario1 = totalCollateral();
    	invoke addCollateral(asset, t, index) at initialStorage;
    	bool call3 = !lastReverted;
    	uint256 collateralAmountScenario2 = totalCollateral();
    	assert (call1 && call2) <=> call3, ""addCollateral is not additive, one scenario reverts"" ;
    	assert call3 => collateralAmountScenario1 == collateralAmountScenario2, ""addCollateral is not additive"" ;
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a financial vault's assets by allowing the addition of short positions, long positions, and collateral with specified amounts and indexes. Ensure the integrity of updates through checks on index validity and asset correspondence. Calculate the total collateral held within the vault."
acecab60d64251baad74aa2bfa76e154,1784 | 1785 | 1786 | 1787 | 1788,rule,inverseAddRemoveCollateral,176,183,addShort | addLong | addCollateral | removeCollateral | totalCollateral,"rule inverseAddRemoveCollateral(address asset, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	invoke removeCollateral(asset, x, index);
	assert !lastReverted && totalCollateral() == collateralBefore, ""removeCollateral is not inverse of addCollateral""; 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | removeCollateral (Lines 197-213),  | totalCollateral (Lines 65-71), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |     function removeCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed collateral exists in the vault at the specified index
        require(_index < _vault.collateralAssets.length, ""V8"");
        require(_vault.collateralAssets[_index] == _collateralAsset, ""V9"");

        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);

        if (newCollateralAmount == 0) {
            delete _vault.collateralAssets[_index];
        }
        _vault.collateralAmounts[_index] = newCollateralAmount;
    }
 |   function totalCollateral() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.collateralAmounts.length; i++) {
      total = total.add(vault.collateralAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a vault's assets by adding or removing short positions, long positions, and collateral. The code allows for the insertion or updating of asset amounts at specified indices, ensures consistency in asset indexing, and calculates the total collateral within a vault."
bde417a50b4ad4f79fb7d8b4809fca07,1801 | 1802 | 1803 | 1808,rule,integrityOfAddShort,188,196,addShort | addLong | addCollateral | totalShortAmount,"rule integrityOfAddShort(address shortOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	assert  totalShortAmount() == shortAmountBefore + x &&
		    getShortOtoken(index) == shortOtoken, ""integrity break of addShort"";
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Add assets (long, short, or collateral) to a vault at a specified index, ensuring valid amounts and indices are provided, then potentially update existing entries or append new ones. Also, calculate the total amount of short positions in the vault."
f0f9f49ffb6aedfa59f3920098039328,1833 | 1834 | 1835 | 1836 | 1841,rule,inverseAddRemoveShort,225,232,addShort | removeShort | addLong | addCollateral | totalShortAmount,"rule inverseAddRemoveShort(address shortOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	invoke removeShort(shortOtoken, x, index);
	assert !lastReverted && totalShortAmount() == shortAmountBefore, ""removeShort is not inverse of addShort""; 
","addShort (Lines 57-78),  | removeShort (Lines 87-103),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function removeShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed short oToken exists in the vault at the specified index
        require(_index < _vault.shortOtokens.length, ""V2"");
        require(_vault.shortOtokens[_index] == _shortOtoken, ""V3"");

        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);

        if (newShortAmount == 0) {
            delete _vault.shortOtokens[_index];
        }
        _vault.shortAmounts[_index] = newShortAmount;
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage the composition of a financial Vault by adding or removing short positions, long positions, and collateral assets through specific operations that validate the transaction's index and amount, ensuring adherence to the vault's current state and structure constraints."
f10873924b8c60246813e7ff872ad5fd,1722 | 1723 | 1724,rule,changeToOneEntity,71,89,addShort | addLong | addCollateral,"This is a parametic rule where f is any of the external/public functions of the contract
*/
rule changeToOneEntity(uint256 shortIndex, uint256 longIndex, uint256 collateralIndex, method f ) {
	
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = getLongAmount(longIndex);
	uint256 shortAmountBefore = getShortAmount(shortIndex);
	uint256 collateralAmountBefore = getCollateralAmount(collateralIndex);
	calldataarg args;
	env e;
	sinvoke f(e,args);
	uint256 longAmountAfter = getLongAmount(longIndex);
	uint256 shortAmountAfter = getShortAmount(shortIndex);
	uint256 collateralAmountAfter = getCollateralAmount(collateralIndex);

	assert (longAmountBefore != longAmountAfter => (shortAmountBefore == shortAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (shortAmountBefore != shortAmountAfter  => (longAmountBefore == longAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (collateralAmountBefore != collateralAmountAfter  => (longAmountBefore == longAmountAfter && shortAmountBefore == shortAmountAfter)); 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: The code extends the functionality of a cryptocurrency vault by allowing the addition of short positions, long positions, and collateral, ensuring validity through checks on amounts, indices, and asset consistency, while leveraging existing positions if applicable."
f0f9f49ffb6aedfa59f3920098039328,1833 | 1834 | 1835 | 1836 | 1841,rule,inverseAddRemoveShort,225,232,addShort | removeShort | addLong | addCollateral | totalShortAmount,"rule inverseAddRemoveShort(address shortOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	invoke removeShort(shortOtoken, x, index);
	assert !lastReverted && totalShortAmount() == shortAmountBefore, ""removeShort is not inverse of addShort""; 
","addShort (Lines 57-78),  | removeShort (Lines 87-103),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188),  | totalShortAmount (Lines 91-97), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function removeShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        // check that the removed short oToken exists in the vault at the specified index
        require(_index < _vault.shortOtokens.length, ""V2"");
        require(_vault.shortOtokens[_index] == _shortOtoken, ""V3"");

        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);

        if (newShortAmount == 0) {
            delete _vault.shortOtokens[_index];
        }
        _vault.shortAmounts[_index] = newShortAmount;
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
 |   function totalShortAmount() external returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < vault.shortAmounts.length; i++) {
      total = total.add(vault.shortAmounts[i]);
    }
    return total;
  }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: Manage a vault's positions in options contracts by adding or removing short, long positions, and collateral. It ensures operations are valid through checks for index range, amount positivity, and matching existing positions, and calculates the total amount in short positions."
f10873924b8c60246813e7ff872ad5fd,1722 | 1723 | 1724,rule,changeToOneEntity,71,89,addShort | addLong | addCollateral,"This is a parametic rule where f is any of the external/public functions of the contract
*/
rule changeToOneEntity(uint256 shortIndex, uint256 longIndex, uint256 collateralIndex, method f ) {
	
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = getLongAmount(longIndex);
	uint256 shortAmountBefore = getShortAmount(shortIndex);
	uint256 collateralAmountBefore = getCollateralAmount(collateralIndex);
	calldataarg args;
	env e;
	sinvoke f(e,args);
	uint256 longAmountAfter = getLongAmount(longIndex);
	uint256 shortAmountAfter = getShortAmount(shortIndex);
	uint256 collateralAmountAfter = getCollateralAmount(collateralIndex);

	assert (longAmountBefore != longAmountAfter => (shortAmountBefore == shortAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (shortAmountBefore != shortAmountAfter  => (longAmountBefore == longAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (collateralAmountBefore != collateralAmountAfter  => (longAmountBefore == longAmountAfter && shortAmountBefore == shortAmountAfter)); 
","addShort (Lines 57-78),  | addLong (Lines 112-133),  | addCollateral (Lines 167-188), ","    function addShort(
        Vault storage _vault,
        address _shortOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V1"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {
            _vault.shortOtokens.push(_shortOtoken);
            _vault.shortAmounts.push(_amount);
        } else {
            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), ""V2"");
            address existingShort = _vault.shortOtokens[_index];
            require((existingShort == _shortOtoken) || (existingShort == address(0)), ""V3"");

            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);
            _vault.shortOtokens[_index] = _shortOtoken;
        }
    }
 |     function addLong(
        Vault storage _vault,
        address _longOtoken,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V4"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {
            _vault.longOtokens.push(_longOtoken);
            _vault.longAmounts.push(_amount);
        } else {
            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), ""V5"");
            address existingLong = _vault.longOtokens[_index];
            require((existingLong == _longOtoken) || (existingLong == address(0)), ""V6"");

            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);
            _vault.longOtokens[_index] = _longOtoken;
        }
    }
 |     function addCollateral(
        Vault storage _vault,
        address _collateralAsset,
        uint256 _amount,
        uint256 _index
    ) external {
        require(_amount > 0, ""V7"");

        // valid indexes in any array are between 0 and array.length - 1.
        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1
        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {
            _vault.collateralAssets.push(_collateralAsset);
            _vault.collateralAmounts.push(_amount);
        } else {
            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), ""V8"");
            address existingCollateral = _vault.collateralAssets[_index];
            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), ""V9"");

            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);
            _vault.collateralAssets[_index] = _collateralAsset;
        }
    }
",./opyn_gamma_protocol/specs/MarginVault.spec,opyn_gamma_protocol,,Yes,,"Functionality: The code defines three functions to add short positions, long positions, and collateral to a structured data type called a vault. Each function validates input, checks if it's adding to an existing position or introducing a new one, and then updates the vault with the specified amount and asset type."
186d1216c00af5831102e098398b90a7,1971,rule,redeem,74,99,redeemA,"rule redeem (address oToken, address to, address collateral, uint256 amount) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;

    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
}
","redeemA (Lines 344-347), ","  function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
",./opyn_gamma_protocol/specs/controller.spec,opyn_gamma_protocol,,Yes,,"Functionality: Initialize arguments for a redemption operation using a specific oToken (`anOtokenA`) and a specified `amount`, then call the `_redeem` function with these arguments to execute the redemption process for the `receiver`."
740e70dd3578dae8b90839289bdb1b5b,1978 | 1979 | 1980 | 1981 | 1982,rule,collateralWithdrawsRestricted,122,133,withdrawCollateral | redeemA | redeemB | settleVault | getProceed,"rule collateralWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, method f) {
    env e;
    uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);
    calldataarg arg;
    sinvoke f(e, arg);
    uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);

    assert collateralBalanceAfter < collateralBalanceBefore => (f.selector == settleVault(address,uint256,address).selector) 
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
                                                            || (f.selector == redeemB(address,uint256).selector)
rule redeem (address oToken, address to, address collateral, uint256 amount) {
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
                                                            || (f.selector == redeemA(address,uint256).selector)
                                                            || (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector);
","withdrawCollateral (Lines 249-266),  | redeemA (Lines 344-347),  | redeemB (Lines 349-352),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function withdrawCollateral(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: dummyERC20C,
      index: index,
      amount: amount
    });
    _withdrawCollateral(args);
  }
 |   function redeemA(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenA, amount: amount});
    _redeem(args);
  }
 |   function redeemB(address receiver, uint256 amount) external {
    Actions.RedeemArgs memory args = Actions.RedeemArgs({receiver: receiver, otoken: anOtokenB, amount: amount});
    _redeem(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,opyn_gamma_protocol,,Yes,,"Functionality: Enable users to withdraw collateral from a vault, redeem specific oTokens, settle a vault by transferring its contents to a specified address, and calculate the net value of a vault's excess collateral, returning it if present."
85ea85426e0fbbed91f41eef0e3e9ef8,1988 | 1989 | 1990 | 1991,rule,optionWithdrawsRestricted,135,152,withdrawLongB | burnOtokenB | settleVault | getProceed,"rule optionWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, address from, address amount, method f) {
    env e;
    // The pool cannot really call any of these functions
    require (e.msg.sender != pool);
    require (!whitelist.isWhitelistedCollateral(longOtoken));
    uint256 otokenBalanceBefore = longOtoken.balanceOf(pool);
    if (f.selector == burnOtokenB(address,uint256,address,uint256,uint256).selector) {
        require(owner != pool);
        sinvoke burnOtokenB(e, owner, vaultId, from, index, amount);
    } else {
        calldataarg arg;
        sinvoke f(e, arg);
    }
    uint256 otokenBalanceAfter = longOtoken.balanceOf(pool);
    // or settle vault 
    assert otokenBalanceAfter < otokenBalanceBefore => (f.selector == withdrawLongB(address, uint256, address, uint256, uint256).selector) 
                                                    || (f.selector == settleVault(address,uint256,address).selector);
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","withdrawLongB (Lines 212-228),  | burnOtokenB (Lines 325-342),  | settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function withdrawLongB(
    address owner,
    uint256 vaultId,
    address to,
    uint256 index,
    uint256 amount
  ) external {
    Actions.WithdrawArgs memory args = Actions.WithdrawArgs({
      owner: owner,
      vaultId: vaultId,
      to: to,
      asset: anOtokenB,
      index: index,
      amount: amount
    });
    _withdrawLong(args);
  }
 |   function burnOtokenB(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    require(smallVault(owner, vaultId, 1));
    Actions.BurnArgs memory args = Actions.BurnArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      otoken: anOtokenB,
      index: index,
      amount: amount
    });
    _burnOtoken(args);
  }
 |   function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,opyn_gamma_protocol,,Yes,,"Functionality: Enable the manipulation and settlement of vaults containing options, specifically for withdrawing long positions, burning options, and settling vaults post-expiry. It also allows users to query the net value of a vault's excess collateral, ensuring operations respect the underlying collateralization and ownership rules."
b627e8103af6b181da693b2ec33b159a,1995 | 1997,rule,inverse,156,185,isValidVault | depositLongA,"// rule inverse (address owner, uint256 vaultId, address from, uint256 index, uint256 amount) { 
//     require(isValidVault(owner, vaultId));

//     storage initialStorage = lastStorage;
//     env e1; 
//     calldataarg arg1;
//     sinvoke f1(e1, arg1);
//     env e2;
//     calldataarg arg2;
//     sinvoke f2(e2, arg2);
//     function depositLongA(
//     address owner,
//     uint256 vaultId,
//     address from,
//     uint256 index,
//     uint256 amount
//   ) 
    
//     uint256 vaultCollateralAmount1 = getVaultCollateralAmount(owner, vaultId,0);
//     sinvoke f2(e2, arg2) at initialStorage;
//     sinvoke f2(e1, arg1);
//     uint256 vaultCollateralAmount2 = getVaultCollateralAmount(owner, vaultId,0);
//     assert vaultCollateralAmount1 == vaultCollateralAmount1;
//     // run first method and then second method and store the result 
//     // run the second method then first method and compare result 
// }
","isValidVault (Lines 79-88),  | depositLongA (Lines 158-174), ","  function isValidVault(address owner, uint256 vaultId) external view returns (bool) {
    MarginVault.Vault storage _vault = cheapGetVault(owner, vaultId);
    (, bool isValidVault) = calculator.getExcessCollateral(
      _vault.shortAmounts[0],
      _vault.longAmounts[0],
      _vault.collateralAmounts[0],
      vaultType[owner][vaultId]
    );
    return isValidVault;
  }
 |   function depositLongA(
    address owner,
    uint256 vaultId,
    address from,
    uint256 index,
    uint256 amount
  ) external {
    Actions.DepositArgs memory args = Actions.DepositArgs({
      owner: owner,
      vaultId: vaultId,
      from: from,
      asset: anOtokenA,
      index: index,
      amount: amount
    });
    _depositLong(args);
  }
",./opyn_gamma_protocol/specs/controller.spec,opyn_gamma_protocol,,Yes,,"Functionality: Validate the stability of a specific vault by determining if there is excessive collateral relative to its short and long positions based on vault type, and allow a user to deposit a long asset into a vault by specifying the owner, vault ID, asset index, and amount."
bac57955ecb800bfe75fc177616b4b39,1967 | 1968,rule,settleVault,52,72,settleVault | getProceed,"rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","settleVault (Lines 360-367),  | getProceed (Lines 467-475), ","  function settleVault(
    address owner,
    uint256 vaultId,
    address to
  ) external {
    Actions.SettleVaultArgs memory args = Actions.SettleVaultArgs({owner: owner, vaultId: vaultId, to: to});
    _settleVault(args);
  }
 |     function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {
        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);

        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);

        if (!isExcess) return 0;

        return netValue;
    }
",./opyn_gamma_protocol/specs/controller.spec,opyn_gamma_protocol,,Yes,,"Functionality: Enable the settlement of a user's vault by specifying the vault owner, the vault's ID, and the destination address for the settlement process. Additionally, calculate and return the net value of excess collateral in a vault, if any, for a given vault owned by a user."
082d9e27f9db703fd254e9be3ecd63ff,1698 | 1700,rule,cooldown,266,279,isOperationReady | schedule,"rule cooldown(method f, env e, env e2){
    bytes32 id;
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    uint256 minDelay = getMinDelay();

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    calldataarg args;
    f(e, args);
    assert isOperationReady(e2, id) => (e2.block.timestamp - e.block.timestamp >= minDelay), ""No rush! When I'm ready, I'm ready"";
}
","isOperationReady (Lines 148-151),  | schedule (Lines 214-225), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
 |     function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Determine if an operation identified by its `id` is ready based on its timestamp being after a predefined ""_DONE_TIMESTAMP"" and on or before the current block timestamp. Additionally, schedule a new operation with specified parameters, ensuring the caller has the `PROPOSER_ROLE`, and emit a scheduling event."
2dc81b2563fd1ccf11228b5f8066c8a9,1677 | 1678,rule,unsetPendingTransitionMethods,91,101,schedule | scheduleBatch,"rule unsetPendingTransitionMethods(method f, env e){
    bytes32 id;

    require !isOperation(id);
    calldataarg args;
    f(e, args);
    assert isOperationPending(id) => (f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector 
                                || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector), ""Why do we need to follow the schedule?"";
}
","schedule (Lines 214-225),  | scheduleBatch (Lines 236-252), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
 |     function scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata payloads,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == payloads.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
        _schedule(id, delay);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);
        }
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Schedule operations and batches of operations to be executed after a specified delay. This involves calculating a unique ID for each operation or batch, verifying role permissions, ensuring the passed arrays match in length, and emitting events with details of the scheduled operations."
2dc9eeb128ec937be8fff8601bebfddb,1703,rule,executeChange,300,310,execute,"rule executeChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt;
    uint256 otherIdTimestampBefore = getTimestamp(otherId);

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    execute(e, target, value, data, predecessor, salt);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Retrieve the details of a specified proposal using its unique identifier (proposalId), then execute the proposal by calling an overloaded execute function with the targets, values, signatures, calldatas, and description hash extracted from the retrieved proposal details."
68c405f691ebca7a88d7a5625268efc7,1683,rule,pendingCancelledTransition,121,130,cancel,"rule pendingCancelledTransition(method f, env e){
    bytes32 id;

    require isOperationPending(id);
    calldataarg args;
    f(e, args);
    assert !isOperation(id) => f.selector == cancel(bytes32).selector, ""How you dare to cancel me?"";
}
","cancel (Lines 106-120), ","    function cancel(uint256 proposalId) public virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];

        require(
            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),
            ""GovernorBravo: proposer above threshold""
        );

        _cancel(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Cancel a proposal based on its ID. It allows the cancellation if the caller is the original proposer or the proposer's current voting power is below the required threshold. The cancellation is performed by internal calling a function with specified targets, values, encoded calldata, and the description hash."
79c524f8a84ddc64b50a9f4ca5c8812e,1705,rule,cancelChange,315,323,cancel,"rule cancelChange(env e){
    bytes32 id;  bytes32 otherId; 

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    cancel(e, id);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","cancel (Lines 106-120), ","    function cancel(uint256 proposalId) public virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];

        require(
            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),
            ""GovernorBravo: proposer above threshold""
        );

        _cancel(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Cancel a governance proposal identified by `proposalId`. This is allowed only if the caller is the proposer or if the proposer's voting power has dropped below the proposal threshold. It internally executes a cancellation process involving the original proposal's targets, values, calldatas, and description hash."
8bf1981a6821c7253d045c1fb73f5a78,1669,invariant,readyCheck,53,55,isOperationReady,"invariant readyCheck(env e, bytes32 id)
    (e.block.timestamp >= getTimestamp(id) && getTimestamp(id) > 1) <=> isOperationReady(e, id)
filtered { f -> !f.isView }
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Check if an operation identified by its `id` is ready by verifying that its associated timestamp is greater than a predefined ""_DONE_TIMESTAMP"" and less than or equal to the current block timestamp, returning a boolean indicating this state."
8d7515f99321318a1a0d06b4e7df8d52,1696 | 1697,rule,onlyProposer,245,246,schedule | scheduleBatch,"rule onlyProposer(method f, env e) filtered { f -> f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector
                                                    || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector } {
","schedule (Lines 214-225),  | scheduleBatch (Lines 236-252), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
 |     function scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata payloads,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == payloads.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
        _schedule(id, delay);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);
        }
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Implement scheduling of single or batch operations on a target contract or contracts with specifics such as value and calldata, by a user with the PROPOSER_ROLE, while enforcing delay requirements and emitting events for tracking each scheduled call."
9e33dbf51b6c45ae4362b637c7720d27,1690,rule,cannotCallExecute,184,194,isOperationReady,"rule cannotCallExecute(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    assert lastReverted, ""you go against execution nature"";
}
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Determine if an operation, identified by its unique `id`, is ready for execution. This is achieved by checking if the operation's timestamp is greater than a predefined `_DONE_TIMESTAMP` and less than or equal to the current blockchain timestamp."
a018c4072e128e5afeff827646d6ee58,1679 | 1680,rule,readyDoneTransition,106,116,execute | isOperationReady,"rule readyDoneTransition(method f, env e){
    bytes32 id;

    require isOperationReady(e, id);
    calldataarg args;
    f(e, args);
    assert isOperationDone(id) => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector , ""It's not isOperationDone yet!"";
}
","execute (Lines 96-104),  | isOperationReady (Lines 148-151), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Execute a specified proposal by calling an internal `execute` method with parameters aggregated from stored proposal details, including target addresses, values, encoded function calls, and a description hash, while the `isOperationReady` function checks if a given operation is ready based on its timestamp relative to the current block timestamp."
a9ad2fb52b9f699a195da63275d122d9,1688,rule,scheduleCheck,169,179,schedule,"rule scheduleCheck(method f, env e){
    bytes32 id;

    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert getTimestamp(id) == to_uint256(e.block.timestamp + delay), ""Time doesn't obey to mortal souls"";
}
","schedule (Lines 214-225), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Schedule a deferred transaction with a specific delay, targeting a certain address with data and value, only if the caller has the required proposer role. It calculates a unique operation ID based on the target, value, data, predecessor, and salt, then schedules the operation and emits a corresponding event."
ae9d09f4d37924594efc02762da0657e,1702,rule,scheduleChange,284,295,schedule,"rule scheduleChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","schedule (Lines 214-225), ","    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Schedule a call to a target address with specified value and data after a delay, ensuring the caller has the PROPOSER_ROLE. Generate an operation id based on parameters, schedule it, and emit a CallScheduled event with details of the operation and delay."
ed3609e590bd867ab7ed1433037a85c1,1693,rule,executeRevertsEffectCheck,214,225,isOperationReady,"rule executeRevertsEffectCheck(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    bool reverted = lastReverted;
    assert lastReverted => isOperationPending(id) && !isOperationReady(e, id), ""you go against execution nature"";
}
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Determine if an operation, identified by its `id`, is ready by checking if its timestamp is greater than a predefined `_DONE_TIMESTAMP` and if it falls on or before the current block timestamp, thereby indicating the operation's eligibility for execution based on timing criteria."
ed3609e590bd867ab7ed1433037a85c1,1693,rule,executeRevertsEffectCheck,214,225,isOperationReady,"rule executeRevertsEffectCheck(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    bool reverted = lastReverted;
    assert lastReverted => isOperationPending(id) && !isOperationReady(e, id), ""you go against execution nature"";
}
","isOperationReady (Lines 148-151), ","    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }
",./openzepplin/specs/TimelockController.spec,openzepplin,,Yes,,"Functionality: Determine if an operation is ready by checking if its associated timestamp surpasses a predefined _DONE_TIMESTAMP and if it falls on or before the current blockchain timestamp, thereby indicating readiness based on specific timing criteria."
059592ec74f63bea30abb9ca75fc8e1a,1552 | 1555 | 1557,rule,possibleTotalVotes,116,139,execute | castVote | proposalVotes,"rule possibleTotalVotes(uint256 pId, uint8 sup, env e, method f) {

    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));
    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
","execute (Lines 96-104),  | castVote (Lines 413-416),  | proposalVotes (Lines 50-62), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {
        address voter = _msgSender();
        return _castVote(proposalId, voter, support, """");
    }
 |     function proposalVotes(uint256 proposalId)
        public
        view
        virtual
        returns (
            uint256 againstVotes,
            uint256 forVotes,
            uint256 abstainVotes
        )
    {
        ProposalVote storage proposalvote = _proposalVotes[proposalId];
        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);
    }
",./openzepplin/specs/RulesInProgress.spec,openzepplin,,Yes,,"Functionality: Execute a proposed action by sending transactions to specified targets with given values, calldata, and description hash; enable voting on a proposal by casters and return vote results; retrieve and return the total number of against, for, and abstain votes for a specific proposal."
4492ae36303c48e811fd9b38a8d238a1,1546 | 1549 | 1551,invariant,VotingWeightConsistency,118,156,execute | castVote | proposalVotes,"    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));

    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
","execute (Lines 96-104),  | castVote (Lines 413-416),  | proposalVotes (Lines 50-62), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {
        address voter = _msgSender();
        return _castVote(proposalId, voter, support, """");
    }
 |     function proposalVotes(uint256 proposalId)
        public
        view
        virtual
        returns (
            uint256 againstVotes,
            uint256 forVotes,
            uint256 abstainVotes
        )
    {
        ProposalVote storage proposalvote = _proposalVotes[proposalId];
        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);
    }
",./openzepplin/specs/RulesInProgress.spec,openzepplin,,Yes,,"Functionality: Allow the execution of a specific proposal identified by its ID, facilitate the casting of votes by users on proposals, and provide the ability to retrieve the voting results for a particular proposal, including the counts of against, for, and abstain votes."
fb662f94e73e4ad3319e6a499631686e,1558,rule,getTimestampOnlyChange,160,175,execute,"rule getTimestampOnlyChange(method f, env e){
    bytes32 id;
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt; uint256 delay;
    address[] targets; uint256[] values; bytes[] datas;

    require (targets[0] == target && values[0] == value && datas[0] == data)
                || (targets[1] == target && values[1] == value && datas[1] == data)
                || (targets[2] == target && values[2] == value && datas[2] == data);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    executionsCall(f, e, target, value, data, predecessor, salt, delay, targets, values, datas);
    assert getTimestamp(id) == 1 => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                        || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector, ""Did you find a way to break the system?"";
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/RulesInProgress.spec,openzepplin,,Yes,,"Functionality: Execute a proposal identified by its unique `proposalId` by calling an execute function with specific parameters: target contracts, values to be sent, encoded function signatures and calldata corresponding to the proposal actions, and a unique description hash for verification."
fb662f94e73e4ad3319e6a499631686e,1558,rule,getTimestampOnlyChange,160,175,execute,"rule getTimestampOnlyChange(method f, env e){
    bytes32 id;
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt; uint256 delay;
    address[] targets; uint256[] values; bytes[] datas;

    require (targets[0] == target && values[0] == value && datas[0] == data)
                || (targets[1] == target && values[1] == value && datas[1] == data)
                || (targets[2] == target && values[2] == value && datas[2] == data);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    executionsCall(f, e, target, value, data, predecessor, salt, delay, targets, values, datas);
    assert getTimestamp(id) == 1 => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                        || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector, ""Did you find a way to break the system?"";
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/RulesInProgress.spec,openzepplin,,Yes,,"Functionality: Execute a proposal by retrieving its details based on a provided proposalId, including targets, values, signatures, and calldatas. Construct the transaction calldata by encoding signatures and calldatas, and then execute the transaction using these details along with the descriptionHash."
c9cc248456b22aa33f9b45d687f3f7d9,1586,rule,reinitVersionCheckGrandchild,146,151,initialize,"rule reinitVersionCheckGrandchild {
/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
    uint8 n;
    returnsBVN(n);
    assert initialized() == n, ""gransdchild contract's version n functions must only be callable in version n"";
","initialize (Lines 14-16), ","    function initialize(uint256 value) public payable initializer {
        x = value;
    }
",./openzepplin/specs/Initializable.spec,openzepplin,,Yes,,"Functionality: Initialize a contract with a specific value. Specifically, the function sets the variable 'x' to the value provided as an argument. It is marked as payable, allowing it to receive Ether, and can only be called once upon contract creation due to the 'initializer' modifier."
d23e3f1d348d28f9b57dd2f5fb93cd55,1585,rule,initalizeEffects,67,74,initialize,"/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
","initialize (Lines 14-16), ","    function initialize(uint256 value) public payable initializer {
        x = value;
    }
",./openzepplin/specs/Initializable.spec,openzepplin,,Yes,,"Functionality: Initialize a smart contract with a specific value. This function sets the internal variable 'x' to the provided 'value'. It is restricted to be called only once, ensuring the initial setup is secure and cannot be altered post-deployment."
0bd3852a73d6b3f83a0575d529735d41,1449 | 1450 | 1451,rule,executedOnlyAfterExecuteFunc,281,293,queue | execute | __acceptAdmin," // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","queue (Lines 90-107),  | execute (Lines 96-104),  | __acceptAdmin (Lines 168-170), ","    function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,openzepplin,,Yes,,"Functionality: Queue proposals for execution by calculating their ID, checking if they've succeeded, and scheduling them with a delay via a timelock. Allow for the execution of proposals by processing their details and calling another execute function. Enable the contract to accept timelock administration changes."
5c087f296552ff2cf5bd8a745882165c,1440 | 1441 | 1442 | 1444,rule,noStartBeforeCreation,230,242,propose | queue | execute | __acceptAdmin,"rule noStartBeforeCreation(uint256 pId) {
    uint256 previousStart = proposalSnapshot(pId);
    // This line makes sure that we see only cases where start date is changed from 0, i.e. creation of proposal
 // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
    // We proved in immutableFieldsAfterProposalCreation that once dates set for proposal, it cannot be changed
rule immutableFieldsAfterProposalCreation(uint256 pId, method f) {
    uint256 _voteStart = proposalSnapshot(pId);
    uint256 _voteEnd = proposalDeadline(pId);
    require proposalCreated(pId); // startDate > 0
    
    env e; calldataarg arg;
    f(e, arg);
    uint256 voteStart_ = proposalSnapshot(pId);
    uint256 voteEnd_ = proposalDeadline(pId);
    assert _voteStart == voteStart_, ""Start date was changed"";
    assert _voteEnd == voteEnd_, ""End date was changed"";
    require !proposalCreated(pId); // previousStart == 0;
    propose(e, args);
    uint256 newStart = proposalSnapshot(pId);
    // if created, start is after current block number (creation block)
    assert(newStart != previousStart => newStart >= e.block.number);
","propose (Lines 15-22),  | queue (Lines 90-107),  | execute (Lines 96-104),  | __acceptAdmin (Lines 168-170), ","    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public virtual override returns (uint256) {
        return super.propose(targets, values, calldatas, description);
    }
 |     function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,openzepplin,,Yes,,"Functionality: Enable governance by allowing the proposal, queuing, and execution of multi-step transactions on the blockchain. Proposals are made, queued upon successful voting, and executed with built-in delay, ensuring administrative changes, like accepting a new admin for a timelock contract, are conducted securely and transparently."
902e197aa01c1da4bca7b403836c67b4,1455 | 1456,rule,allFunctionsRevertIfCanceled,308,316,queue | __acceptAdmin,"rule allFunctionsRevertIfCanceled(method f) filtered {
    f -> !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","queue (Lines 90-107),  | __acceptAdmin (Lines 168-170), ","    function queue(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);

        require(state(proposalId) == ProposalState.Succeeded, ""Governor: proposal not successful"");

        uint256 delay = _timelock.getMinDelay();
        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);
        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);

        emit ProposalQueued(proposalId, block.timestamp + delay);

        return proposalId;
    }
 |     function __acceptAdmin() public {
        _timelock.acceptAdmin();
    }
",./openzepplin/specs/GovernorBase.spec,openzepplin,,Yes,,"Functionality: Queue a proposal for execution after checking it has succeeded by generating a unique proposal ID and scheduling the execution with a predefined delay via a timelock contract. Additionally, allow the caller to accept the role of admin in the timelock contract."
d6d6c1363864791e50a3dad38316faae,1460,rule,executedOnlyAfterExecuteFunc,331,341,execute,"rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
","execute (Lines 96-104), ","    function execute(uint256 proposalId) public payable virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];
        execute(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
",./openzepplin/specs/GovernorBase.spec,openzepplin,,Yes,,"Functionality: Execute a proposal identified by its `proposalId` by calling an `execute` function with specific parameters. These parameters include the proposal's targets, values, encoded calldatas constructed from the proposal's signatures and calldatas, and the proposal's description hash, stored within `_proposalDetails`."
0c4d061b17506aa71a5dcf237c7ac35c,1613 | 1617,rule,delegate_no_frontrunning,236,271,balanceOf | _delegate,"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
}","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,openzepplin,,Yes,,"Functionality: Check the balance of a specific token (identified by `id`) for a given account address, ensuring the account address is not zero. It also facilitates the delegation of voting rights from one account to another, updating the delegation records and transferring the delegate votes accordingly."
124a439d5ddf3f04341d81deabc44736,1604 | 1608,rule,unique_checkpoints_rule,200,217,balanceOf | _delegate,"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) for a given account in an ERC1155 contract, ensuring the account address is not zero. Separately, change a user's delegate in a voting system, updating the delegation record, and adjusting delegate votes accordingly, while emitting relevant event changes."
5482195dc811971ad08ec18f89a78ecd,1599 | 1603,rule,unique_checkpoints_rule,181,198,balanceOf | _delegate,"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token ID for a given account, ensuring the account address is not zero, and internally assign a delegate to an account, recording the delegation change and adjusting the vote counts of the old and new delegates based on the delegator's voting power."
b6c33512f326ede7ddae2b5db483d687,1595 | 1597 | 1598,rule,delegates_safe,165,167,delegate | delegateBySig | _delegate,"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
","delegate (Lines 95-98),  | delegateBySig (Lines 103-120),  | _delegate (Lines 127-133), ","    function delegate(address delegatee) public virtual override {
        address account = _msgSender();
        _delegate(account, delegatee);
    }
 |     function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= expiry, ""Votes: signature expired"");
        address signer = ECDSA.recover(
            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),
            v,
            r,
            s
        );
        require(nonce == _useNonce(signer), ""Votes: invalid nonce"");
        _delegate(signer, delegatee);
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,openzepplin,,Yes,,"Functionality: Enable users to delegate their voting power to another account either directly using the `delegate` function or by signature with `delegateBySig`, ensuring transactions are secure and non-repetitive by verifying expiry, nonce, and signer identity, then transferring the delegator's votes correspondingly."
caab3daedd7ef4870bc377e0d46353c9,1612,rule,unique_checkpoints_rule,219,234,_delegate,"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","_delegate (Lines 127-133), ","    function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC721Votes.spec,openzepplin,,Yes,,"Functionality: Assign a new delegate to an account, updating the account's delegation mapping. It triggers an event to log the change in delegation from the old delegate to the new one and updates the vote count associated with both the old and new delegates based on the account's voting units."
2ea6cd307cf56934d0ec505ce2d623c5,1570,rule,depositForSpecBasic,44,63,depositFor,"rule depositForSpecBasic(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    depositFor(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert wrapperTotalBefore == wrapperTotalAfter - amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
    assert underlyingThisBalanceBefore == underlyingThisBalanceAfter - amount, ""underlying this balance wrong update"";
}
","depositFor (Lines 39-43), ","    function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Safely transfer a specified amount of the underlying token from the function caller to the contract itself, then mint an equivalent amount of another token or credit for the specified account, effectively crediting the account with the deposited amount."
59eebaaa170cc4aa596a032c8930aebc,1580,rule,recoverSpec,192,214,balanceOf,"rule recoverSpec(env e){
    address account; uint256 amount;

    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    mathint value = underlyingThisBalanceBefore - wrapperTotalBefore;
    _recover(e, account);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert wrapperTotalBefore == wrapperTotalAfter - value, ""wrapper total wrong update"";
    assert e.msg.sender == account => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - value, ""wrapper balances wrong update"";
    assert e.msg.sender != account => wrapperUserBalanceBefore == wrapperUserBalanceAfter - value
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Check the balance of a specific token, identified by `id`, for a given account. It first ensures the account provided is not the zero address, as that is invalid. If valid, it retrieves and returns the current token balance from a mapping of token IDs to account balances."
6ad466081a4377f21abe780a7723c52c,1571 | 1572,rule,depositForSpecWrapper,68,86,balanceOf | depositFor,"rule depositForSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    depositFor(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore 
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter 
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount, ""wrapper balances wrong update"";
    assert account != e.msg.sender => wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}
","balanceOf (Lines 70-73),  | depositFor (Lines 39-43), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Check the token balance of a specific address for a particular token ID in an ERC1155 contract, ensuring the address is not zero. Additionally, enable deposit of a specified token amount into the contract from the caller's account, minting an equivalent amount of another token or representation to the specified account, using the SafeERC20 library for secure token transfer."
6dd5070c3d1c501df925e30e4b4b2489,1573,rule,depositForSpecUnderlying,91,114,depositFor,"rule depositForSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    depositFor(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount, ""underlying balances wrong update"";
    
    assert account != e.msg.sender && account == currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update"";
    assert account != e.msg.sender && account != currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter, ""underlying balances wrong update"";
}
","depositFor (Lines 39-43), ","    function depositFor(address account, uint256 amount) public virtual returns (bool) {
        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);
        _mint(account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Transfer a specified amount of tokens from the caller's address to the contract, using the SafeERC20 library to safely perform the transfer. Then, mint an equivalent amount of new tokens to a specified account, signifying a successful deposit into the contract."
75b64181d082cdfc1a38746b3922a272,1575,rule,withdrawToSpecBasic,119,134,withdrawTo,"rule withdrawToSpecBasic(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    withdrawTo(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    assert wrapperTotalBefore == wrapperTotalAfter + amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
}
","withdrawTo (Lines 48-52), ","    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Burn a specified amount of tokens from the caller's balance, then securely transfer an equivalent amount of the underlying asset to a specified account. This effectively allows the caller to redeem their tokens for the underlying asset."
8ec8f69b2e1b782f09b0e89868926530,1578,rule,withdrawToSpecUnderlying,162,187,withdrawTo,"rule withdrawToSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    withdrawTo(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore 
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter 
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update (acc == sender)"";
    
    assert account != e.msg.sender && account == currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter, ""underlying balances wrong update (acc == contract)""; 
    assert account != e.msg.sender && account != currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter
                && underlyingThisBalanceBefore == underlyingThisBalanceAfter + amount, ""underlying balances wrong update (acc != contract)"";   
}
","withdrawTo (Lines 48-52), ","    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,"Functionality: Burn a specified amount of tokens from the caller's balance, then safely transfer an equivalent amount of the underlying asset to a designated account. This effectively withdraws the specified amount from the caller's holdings in the contract, facilitating asset redemption."
94138ade9c9a6d5f3e739f3d62bfdeb1,1576 | 1577,rule,withdrawToSpecWrapper,139,157,balanceOf | withdrawTo,"rule withdrawToSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    withdrawTo(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter + amount, ""wrapper user balance wrong update"";
    assert account != e.msg.sender => wrapperSenderBalanceBefore == wrapperSenderBalanceAfter + amount
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter, ""wrapper user balance wrong update"";
}
","balanceOf (Lines 70-73),  | withdrawTo (Lines 48-52), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function withdrawTo(address account, uint256 amount) public virtual returns (bool) {
        _burn(_msgSender(), amount);
        SafeERC20.safeTransfer(underlying, account, amount);
        return true;
    }
",./openzepplin/specs/ERC20Wrapper.spec,openzepplin,,Yes,,Functionality: Check the balance of a specific token ID for a given account and ensure the account address is valid. Allow the message sender to withdraw a specified amount from their balance by burning the amount from their account and transferring equivalent value to a specified account safely.
028f3b83f905d744d2450dcd6fbf4e4a,1629 | 1631 | 1632,rule,delegates_safe,167,169,delegate | delegateBySig | _delegate,"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
","delegate (Lines 95-98),  | delegateBySig (Lines 103-120),  | _delegate (Lines 127-133), ","    function delegate(address delegatee) public virtual override {
        address account = _msgSender();
        _delegate(account, delegatee);
    }
 |     function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= expiry, ""Votes: signature expired"");
        address signer = ECDSA.recover(
            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),
            v,
            r,
            s
        );
        require(nonce == _useNonce(signer), ""Votes: invalid nonce"");
        _delegate(signer, delegatee);
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Implement delegate actions within a voting system, allowing a user to delegate their voting power directly or via signature. It verifies delegation requests, tracks and updates delegate addresses, and adjusts vote counts accordingly, ensuring secure and authorized delegation transitions."
5580f1ebc1ec98391171bafc1a981970,1646,rule,unique_checkpoints_rule,219,234,_delegate,"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","_delegate (Lines 127-133), ","    function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Assign a new delegate to an account, record the change, and adjust the delegate vote counts based on the voting units associated with the account. Emit events to log the delegation change and the movement of delegate votes from the old delegate to the new one."
6e87cf03c73c45468b74d527e58fafa9,1638 | 1642,rule,fromBlock_greaterThanEq_pos,200,217,balanceOf | _delegate,"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (by its ID) owned by a given account, ensuring the account address is valid and not zero. Additionally, Delegate voting power from one account to another, updating the delegation status and adjusting the vote counts based on the account's voting units."
72cfa390769c4fdec5227bfb1e8e2c87,1619,invariant,votes_solvency,69,71,_burn,"invariant votes_solvency()
    totalSupply() >= to_uint256(totalVotes())
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
filtered { f -> f.selector != _burn(address, uint256).selector}
","_burn (Lines 333-355), ","    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");

        address operator = _msgSender();
        uint256[] memory ids = _asSingletonArray(id);
        uint256[] memory amounts = _asSingletonArray(amount);

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, """");

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, ""ERC1155: burn amount exceeds balance"");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }

        emit TransferSingle(operator, from, address(0), id, amount);

        _afterTokenTransfer(operator, from, address(0), ids, amounts, """");
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Validate the caller's intention to burn a specific quantity of a token from a given address within an ERC1155 contract framework, update the corresponding balance, and emit a transfer event indicating a burn operation from the specified address to a zero address."
8a1555c9c53bac4a954abb8e656f8e62,1633 | 1637,rule,unique_checkpoints_rule,179,198,balanceOf | _delegate,"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    require lastIndex(delegatee) < 1000000;
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Verify a valid owner and return their balance for a specified token ID with `balanceOf`. In `_delegate`, change an account's vote delegation to another address, emitting a change event, and transferring the delegator's voting power accordingly."
e5c1003fa926635a164cb5ca90a76138,1647 | 1651,rule,delegate_no_frontrunning,236,271,balanceOf | _delegate,"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Check the balance of a specific token (identified by `id`) for a given account in an ERC1155 contract while ensuring the account isn't a zero address. Additionally, manage the delegation of voting power from one account to another, updating their delegation status and redistributing voting units accordingly."
e5c1003fa926635a164cb5ca90a76138,1647 | 1651,rule,delegate_no_frontrunning,236,271,balanceOf | _delegate,"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
","balanceOf (Lines 70-73),  | _delegate (Lines 127-133), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function _delegate(address account, address delegatee) internal virtual {
        address oldDelegate = delegates(account);
        _delegation[account] = delegatee;

        emit DelegateChanged(account, oldDelegate, delegatee);
        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
    }
",./openzepplin/specs/ERC20Votes.spec,openzepplin,,Yes,,"Functionality: Verify the validity of an account address before returning the associated balance of a specific token id within an ERC1155 smart contract. Additionally, delegate the voting authority of an account to another, updating delegate records and redistributing voting power accordingly."
0eca4799213831ac2a589eb398a724fb,1414,invariant,balanceOfZeroAddressIsZero,56,71,balanceOf,"invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its ID, held by a particular account address. Ensure that the account address is not a zero address, as that is considered invalid for token ownership queries in the ERC1155 standard."
3c234b5983644ac421d72d63c8920cd0,1417,rule,held_tokens_should_exist,60,71,balanceOf,"rule held_tokens_should_exist {
    address user; uint256 token;

    requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0
/// If a user has a token, then the token should exist.
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) owned by a specified user account. Ensure that the queried account is not the zero address, as it is considered invalid. Return the token balance associated with the account and token ID."
7c0a0d1a5bedd3bc35df93346b47a0f2,1415,rule,token_totalSupply_independence,11,14,safeBatchTransferFrom,"rule token_totalSupply_independence(method f)
filtered {
    f -> f.selector != safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155Supply.spec,openzepplin,,Yes,,"Functionality: Validate that the caller is the token owner or has approval to manage the owner's tokens, then execute a secure batch transfer of multiple token IDs and their respective amounts from one address to another, including additional data if provided."
c9dae76e519769a4a4e2e7dcb378f0be,1412,invariant,total_supply_is_sum_of_balances,45,51,balanceOf,"invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Supply.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its ID, for a given account address. Ensure that the account address is valid and not the zero address, then return the token balance from the stored balances mapping."
008d968f71dbd1a067728b60378ee86d,1420 | 1421,rule,transferMethodsRevertWhenPaused,24,28,safeTransferFrom | safeBatchTransferFrom,"rule transferMethodsRevertWhenPaused (method f)
filtered {
    f -> f.selector == safeTransferFrom(address,address,uint256,uint256,bytes).selector
      || f.selector == safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
","safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155Pausable.spec,openzepplin,,Yes,,"Functionality: Enable secure transfer of individual or batches of ERC1155 tokens from one account to another by verifying that the caller is the token owner or authorized. It utilizes internal functions to complete the transfer process, reinforcing smart contract security and compliance with ERC1155 standards."
7241f26a605c235a7160dca67c904554,1418,rule,balancesUnchangedWhenPaused,8,21,balanceOf,"rule balancesUnchangedWhenPaused() {
    address user; uint256 token;
    uint256 balanceBefore = balanceOf(user, token);

    require paused();
    method f; calldataarg arg; env e;
    f(e, arg);
    uint256 balanceAfter = balanceOf(user, token);
    assert balanceBefore == balanceAfter, 
        ""Token balance for a user must not change in a paused contract"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Pausable.spec,openzepplin,,Yes,,"Functionality: Verify the specified account address is not zero, ensuring it represents a valid owner, then return the balance of a specific token (identified by its ID) that the account holds. This operation is read-only and does not modify state."
32f2adaa07cc70a4cdecd9344f8db08c,1466,rule,sequentialBurnsEquivalentToSingleBurnOfSum,49,71,balanceOf,"/// This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule sequentialBurnsEquivalentToSingleBurnOfSum {
    storage beforeBurns = lastStorage;
    env e;

    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;
    require sumBurn == firstBurn + secondBurn;
    // sequential burns
    burn(e, holder, token, firstBurn) at beforeBurns;
    burn(e, holder, token, secondBurn);
    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);
    // burn of sum of sequential burns
    burn(e, holder, token, sumBurn) at beforeBurns;
    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, 
        ""Sequential burns must be equivalent to a burn of their sum"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) owned by a given account. Ensure the given account address is not the zero address, as it is not considered a valid owner, then return the account's token balance from the contract's stored balances."
3ad8b66130807da0536c9116302c52e3,1461,rule,onlyHolderOrApprovedCanReduceBalance,8,20,balanceOf,"rule onlyHolderOrApprovedCanReduceBalance(method f) 
{
    address holder; uint256 token; uint256 amount;
    uint256 balanceBefore = balanceOf(holder, token);

    env e; calldataarg args;
    f(e, args);
    uint256 balanceAfter = balanceOf(holder, token);
    assert balanceAfter < balanceBefore => e.msg.sender == holder || isApprovedForAll(holder, e.msg.sender), 
        ""An account balance may only be reduced by the holder or a holder-approved agent"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its ID, held by a specified account address. It ensures the account address is not zero, enforcing that only valid owners can query their holdings, and returns the token balance from the internal balances mapping."
3b46de187a09f7f67a6debd54638f799,1474,rule,burnBatchOnEmptyArraysChangesNothing,142,160,balanceOf,"rule burnBatchOnEmptyArraysChangesNothing {
    uint256 token; address nonHolderA; address nonHolderB;

    uint256 startingBalance = balanceOf(nonHolderA, token);
    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;
    require noTokens.length == 0; require noBurnAmounts.length == 0;
    burnBatch(e, holder, noTokens, noBurnAmounts);
    
    uint256 endingBalance = balanceOf(nonHolderA, token);
    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    assert startingBalance == endingBalance, 
        ""burnBatch must not change token balances if passed empty arrays"";
    assert startingPermission == endingPermission, 
        ""burnBatch must not change account permissions if passed empty arrays"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) owned by a given account. Ensure the account address is not the zero address, indicating it must be a valid owner, before returning the account's token balance from the internal balances mapping."
50a9fca8da61c5821b9b15f58b551b72,1472,rule,multipleTokenBurnBurnBatchEquivalence,102,138,balanceOf,"rule multipleTokenBurnBurnBatchEquivalence {
    storage beforeBurns = lastStorage;
    env e;

    address holder;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalanceA = balanceOf(holder, tokenA);
    mathint startingBalanceB = balanceOf(holder, tokenB);
    mathint startingBalanceC = balanceOf(holder, tokenC);
    require tokens.length == 3; require burnAmounts.length == 3;
    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;
    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;
    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;
    // burning via burn
    burn(e, holder, tokenA, burnAmountA) at beforeBurns;
    burn(e, holder, tokenB, burnAmountB);
    burn(e, holder, tokenC, burnAmountC);
    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;
    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    assert burnBalanceChangeA == burnBatchBalanceChangeA
        && burnBalanceChangeB == burnBatchBalanceChangeB
        && burnBalanceChangeC == burnBatchBalanceChangeC, 
        ""Burning multiple tokens via burn or burnBatch must be equivalent"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Check the token balance of a specific account for a given token ID. It validates that the account address is not zero, as zero is not a valid owner address. Then, it returns the account's balance for that specific token ID from a mapping."
f69e9d07328750a92075ba099b449aab,1469,rule,singleTokenBurnBurnBatchEquivalence,75,98,balanceOf,"rule singleTokenBurnBurnBatchEquivalence {
    storage beforeBurn = lastStorage;
    env e;

    address holder;
    uint256 token; uint256 burnAmount;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalance = balanceOf(holder, token);
    require tokens.length == 1; require burnAmounts.length == 1;
    require tokens[0] == token; require burnAmounts[0] == burnAmount;
    // burning via burn
    burn(e, holder, token, burnAmount) at beforeBurn;
    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;
    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);
    assert burnBalanceChange == burnBatchBalanceChange, 
        ""Burning a single token via burn or burnBatch must be equivalent"";
}   
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: The given code defines a function that retrieves the balance of a specific token, identified by its `id`, for a particular account. It ensures that the account is a valid non-zero address before returning the token's balance associated with that account from the contract's internal storage."
fd0d3a73d03f5c8ce35a376514ef27bd,1464,rule,burnAmountProportionalToBalanceReduction,24,45,balanceOf,"/// n.b. This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule burnAmountProportionalToBalanceReduction {
    storage beforeBurn = lastStorage;
    env e;
    
    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 smallBurn; uint256 largeBurn;
    require smallBurn < largeBurn;

    // smaller burn amount
    burn(e, holder, token, smallBurn) at beforeBurn;
    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);
    // larger burn amount
    burn(e, holder, token, largeBurn) at beforeBurn;
    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert smallBurnBalanceChange < largeBurnBalanceChange, 
        ""A larger burn must lead to a larger decrease in balance"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its `id`, for a given `account`. The function validates that the provided account address is not zero, ensuring it represents a valid owner, and then returns the respective token balance from the `_balances` storage."
f69e9d07328750a92075ba099b449aab,1469,rule,singleTokenBurnBurnBatchEquivalence,75,98,balanceOf,"rule singleTokenBurnBurnBatchEquivalence {
    storage beforeBurn = lastStorage;
    env e;

    address holder;
    uint256 token; uint256 burnAmount;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalance = balanceOf(holder, token);
    require tokens.length == 1; require burnAmounts.length == 1;
    require tokens[0] == token; require burnAmounts[0] == burnAmount;
    // burning via burn
    burn(e, holder, token, burnAmount) at beforeBurn;
    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;
    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);
    assert burnBalanceChange == burnBatchBalanceChange, 
        ""Burning a single token via burn or burnBatch must be equivalent"";
}   
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its id, for a given account. Ensure that the provided account address is not the zero address, validating it as a legitimate owner, before returning the token balance from a nested mapping structure."
fd0d3a73d03f5c8ce35a376514ef27bd,1464,rule,burnAmountProportionalToBalanceReduction,24,45,balanceOf,"/// n.b. This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule burnAmountProportionalToBalanceReduction {
    storage beforeBurn = lastStorage;
    env e;
    
    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 smallBurn; uint256 largeBurn;
    require smallBurn < largeBurn;

    // smaller burn amount
    burn(e, holder, token, smallBurn) at beforeBurn;
    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);
    // larger burn amount
    burn(e, holder, token, largeBurn) at beforeBurn;
    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert smallBurnBalanceChange < largeBurnBalanceChange, 
        ""A larger burn must lead to a larger decrease in balance"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155Burnable.spec,openzepplin,,Yes,,"Functionality: Verify the specified account address is not zero, then return the balance of a specified token, identified by its ID, owned by the given account. This is used to check how many units of a specific token an account holds in an ERC1155 contract."
03a901f0ba4251476606c302893e2f4b,1505,rule,noTransferEffectOnApproval,385,398,safeTransferFrom,"rule noTransferEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256 id; uint256 amount; 
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeTransferFrom(e, from, to, id, amount, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
","safeTransferFrom (Lines 117-129), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Ensure that the caller is either the token owner or approved by the token owner to transfer a specified amount of a specific token (identified by `id`) from one address to another, performing the transfer operation securely with accompanying data if the precondition is met."
08ed2ec1a9f33a399adf705dabed85ea,1539,rule,transfersHaveSameLengthInputArrays,861,878,safeBatchTransferFrom,"rule transfersHaveSameLengthInputArrays {
    env e;

    address recipient; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    uint max_int = 0xffffffffffffffffffffffffffffffff;
    require tokens.length >= 0 && tokens.length <= max_int;
    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;
    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);
    uint256 tokensLength = tokens.length;
    uint256 transferAmountsLength = transferAmounts.length;
    assert tokens.length == transferAmounts.length, 
        ""If transfer methods do not revert, the input arrays must be the same length"";
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Execute a secure batch transfer of multiple token types from a single sender to a recipient, verifying the invoking entity is either the token owner or authorized. This involves checking sender authorization, then performing the transfer, applying specified IDs, quantities, and additional data."
0945a51c6b396bbb7744303d2ce5b6a2,1499 | 1500,rule,transferBatchBalanceFromEffect,300,321,balanceOf | safeBatchTransferFrom,"rule transferBatchBalanceFromEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != to;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert from != other => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify ownership or approval before executing batch transfers of multiple token IDs and their respective quantities from one address to another, and ensure a non-zero account address before retrieving the balance of a specific token ID for a given account."
13fea1ece0eb313798889889295526d2,1501 | 1502,rule,transferBatchBalanceToEffect,326,347,balanceOf | safeBatchTransferFrom,"rule transferBatchBalanceToEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != from;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify the validity of an account address before returning the balance of a specific token. Ensure the caller has authorization before performing a batch transfer of multiple token types and respective quantities from one address to another, including a data payload for additional instructions or information."
2173e9563b0ef17a136246e536e1c92a,1522,rule,burnAdditivity,605,621,balanceOf,"rule burnAdditivity(env e){
    address from; uint256 id; uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    burn(e, from, id, amount);
    uint256 balanceAfterSingleTransaction = balanceOf(from, id);
    burn(e, from, id, amount1) at initialStorage;
    burn(e, from, id, amount2);
    uint256 balanceAfterDoubleTransaction = balanceOf(from, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Validate that the given account address is not the zero address, ensuring it represents a valid owner, and return the balance associated with a specific token ID for that account from the contract's internal storage mapping."
22b972732b1a264062ba062653d11621,1508,rule,noTransferBatchEffectOnApproval,403,416,safeBatchTransferFrom,"rule noTransferBatchEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256[] ids; uint256[] amounts;
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
","safeBatchTransferFrom (Lines 134-146), ","    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Perform a batch transfer of multiple token IDs and their corresponding amounts from one address to another, ensuring the caller is either the token owner or authorized to manage the owner's tokens, and execute this transfer safely by handling the batch operation internally."
29ab659edc48da3f1ccfd57291c9b148,1493,rule,cannotTransferMoreSingle,226,233,balanceOf,"rule cannotTransferMoreSingle(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;
    uint256 balanceBefore = balanceOf(from, id);

    safeTransferFrom@withrevert(e, from, to, id, amount, data);
    assert amount > balanceBefore => lastReverted, ""Achtung! Scammer!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify the validity of an account address before retrieving the quantity of a specific token (identified by `id`) owned by that account from a mapping structure (`_balances`). Ensure the account is not the zero address, enforcing it as a valid owner."
2d2ef8ef4cbb9344353c8041a70c3b20,1510,rule,mintAdditivity,427,443,balanceOf,"rule mintAdditivity(env e){
    address to; uint256 id; uint256 amount; uint256 amount1; uint256 amount2; bytes data;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    mint(e, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    mint(e, to, id, amount1, data) at initialStorage;
    mint(e, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its ID, owned by a provided account address. Ensure the provided address is not zero, validating it as a legitimate owner, before returning the token balance from a nested mapping structure."
2d7d850ef915c10e5c8af442ac7d845e,1514,rule,mintBatchCorrectWork,488,516,balanceOf,"rule mintBatchCorrectWork(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    bytes data;

    require ids.length == 3; 
    require amounts.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(to, id1);
    uint256 otherBalanceBefore2 = balanceOf(to, id2);
    uint256 otherBalanceBefore3 = balanceOf(to, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(to, id1);
    uint256 otherBalanceAfter2 = balanceOf(to, id2);
    uint256 otherBalanceAfter3 = balanceOf(to, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 - amount1
            && otherBalanceBefore2 == otherBalanceAfter2 - amount2
            && otherBalanceBefore3 == otherBalanceAfter3 - amount3
            , ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check the balance of a specific token (identified by `id`) for a given account (`account`). It first validates that the account address is not zero, ensuring it's a legitimate owner, then returns the token balance from the internal mappings."
41259f74d90666460170f6c3f7cde3b8,1497 | 1498,rule,transferBalanceIncreaseEffect,281,295,balanceOf | safeTransferFrom,"rule transferBalanceIncreaseEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require from != other;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check an account's balance for a specific token ID and safely transfer a specified amount of a token from one account to another, ensuring the sender is authorized through ownership or approval, and validating address integrity to prevent transfers to the zero address."
5361a18372eabd106947b6ce8348610a,1518,rule,cantMintOtherBalances,558,569,balanceOf,"rule cantMintOtherBalances(env e){
    address to; uint256 id; uint256 amount; bytes data;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check the token balance of a specified account for a particular ID in an ERC1155 smart contract. It first ensures the account is not the zero address, as that is invalid, then returns the balance for that account and ID from a mapping."
7a0e8380f35b696c56504691cf006d5a,1494,rule,cannotTransferMoreBatch,238,257,balanceOf,"rule cannotTransferMoreBatch(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    uint256 balanceBefore1 = balanceOf(from, idToCheck1);
    uint256 balanceBefore2 = balanceOf(from, idToCheck2);
    uint256 balanceBefore3 = balanceOf(from, idToCheck3);
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    safeBatchTransferFrom@withrevert(e, from, to, ids, amounts, data);
    assert (amountToCheck1 > balanceBefore1 || amountToCheck2 > balanceBefore2 || amountToCheck3 > balanceBefore3) => lastReverted, ""Achtung! Scammer!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify that the specified account address is not a zero address to ensure it's a valid owner, then retrieve and return the balance of a specific token (identified by `id`) that is held by the given account from the internal `_balances` mapping."
857b9accdefcdde57fe15d6d4a236c7d,1530,rule,cantBurnOtherBalances,733,744,balanceOf,"rule cantBurnOtherBalances(env e){
    address from; uint256 id; uint256 amount;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != from => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Validate that the provided account address is not the zero address, ensuring it is a valid owner, then return the balance of the specified token (identified by its unique ID) that the account holds, utilizing a mapping structure for storage."
90864081139856a10b556b9454f399d3,1487 | 1488,rule,transferAdditivity,140,157,balanceOf | safeTransferFrom,"rule transferAdditivity(env e){
    address from; address to; uint256 id; bytes data;
    uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount1, data) at initialStorage;
    safeTransferFrom(e, from, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify token ownership or approval before transferring a specified amount of a token (identified by its ID) from one address to another, ensuring the sender owns the token or is duly approved. Also, return the balance of a given token for a specified account, with validation against zero addresses."
a3d98dd4348ef5777d0e3f5e6dd2f55b,1536 | 1537 | 1538,rule,multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence,810,858,balanceOf | safeTransferFrom | safeBatchTransferFrom,"rule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfers = lastStorage;
    env e;

    address holder; address recipient; bytes data;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalanceA = balanceOf(holder, tokenA);
    mathint holderStartingBalanceB = balanceOf(holder, tokenB);
    mathint holderStartingBalanceC = balanceOf(holder, tokenC);
    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);
    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);
    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);
    require tokens.length == 3; require transferAmounts.length == 3;
    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;
    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;
    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;
    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);
    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);
    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;
    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA
        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB
        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC
        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA
        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB
        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, 
        ""Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,Functionality: Validate token ownership or approval before transferring a single token or a batch of tokens from one address to another. It checks that the address is not zero and ensures the caller is either the token owner or has been granted approval to act on the owner's behalf.
a5e8f016e661d23363a7190567c5cdf6,1516,rule,cantMintMoreBatch,534,553,balanceOf,"rule cantMintMoreBatch(env e){
    address to; bytes data;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require amounts.length == 3;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(to, id1) + amount1) > max_uint256 
                || to_mathint(balanceOf(to, id2) + amount2) > max_uint256
                || to_mathint(balanceOf(to, id3) + amount3) > max_uint256;
    mintBatch@withrevert(e, to, ids, amounts, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by `id`, owned by a given `account`. Ensure the provided account address is not the zero address, indicating an invalid owner, before returning the token balance from the internal mapping `_balances`."
b202b77779ae58a4578fda0cdbce1ccd,1491 | 1492,rule,transferBatchCorrectness,182,221,balanceOf | safeBatchTransferFrom,"rule transferBatchCorrectness(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    require to != from;
    require idToCheck1 != idToCheck2 && idToCheck3 != idToCheck2 && idToCheck1 != idToCheck3;
    
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    uint256 fromBalanceBefore1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceBefore2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceBefore3 = balanceOf(from, idToCheck3);
    uint256 toBalanceBefore1 = balanceOf(to, idToCheck1);
    uint256 toBalanceBefore2 = balanceOf(to, idToCheck2);
    uint256 toBalanceBefore3 = balanceOf(to, idToCheck3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 fromBalanceAfter1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceAfter2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceAfter3 = balanceOf(from, idToCheck3);
    uint256 toBalanceAfter1 = balanceOf(to, idToCheck1);
    uint256 toBalanceAfter2 = balanceOf(to, idToCheck2);
    uint256 toBalanceAfter3 = balanceOf(to, idToCheck3);
    assert (fromBalanceBefore1 == fromBalanceAfter1 + amountToCheck1)
                && (fromBalanceBefore2 == fromBalanceAfter2 + amountToCheck2)
                && (fromBalanceBefore3 == fromBalanceAfter3 + amountToCheck3), ""Something wet wrong"";
    assert (toBalanceBefore1 == toBalanceAfter1 - amountToCheck1)
                && (toBalanceBefore2 == toBalanceAfter2 - amountToCheck2)
                && (toBalanceBefore3 == toBalanceAfter3 - amountToCheck3), ""Something wet wrong"";
}
","balanceOf (Lines 70-73),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Validate an account's ownership or approval to transfer multiple token types in a batch, ensuring the account is not zero and the caller is authorized. Then, execute the transfer of specified amounts of each token type to a designated recipient, including accompanying data if provided."
c2f2be2923bb5de563358e212905750d,1532,rule,cantBurnBatchOtherBalances,749,770,balanceOf,"rule cantBurnBatchOtherBalances(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    address other;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != from => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token, identified by its `id`, for a given account address. It first checks to ensure the account address is not the null address, raising an error if it is, then returns the user's token balance from the internal record."
c81addfa914c68cf6bb8c597f9c806b3,1526,rule,burnBatchCorrectWork,666,692,balanceOf,"rule burnBatchCorrectWork(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(from, id1);
    uint256 otherBalanceBefore2 = balanceOf(from, id2);
    uint256 otherBalanceBefore3 = balanceOf(from, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(from, id1);
    uint256 otherBalanceAfter2 = balanceOf(from, id2);
    uint256 otherBalanceAfter3 = balanceOf(from, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 + amount1
            && otherBalanceBefore2 == otherBalanceAfter2 + amount2
            && otherBalanceBefore3 == otherBalanceAfter3 + amount3
            , ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify the non-nullity of an account address, ensuring it's a valid owner before returning the balance. Specifically, it retrieves and returns the balance of a specific token (identified by `id`) held by the given account."
cf609edc79b5d7ec679714c6d7bc6f63,1512,rule,mintCorrectWork,473,483,balanceOf,"rule mintCorrectWork(env e){
    address to; uint256 id; uint256 amount; bytes data;

    uint256 otherBalanceBefore = balanceOf(to, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(to, id);
    
    assert otherBalanceBefore == otherBalanceAfter - amount, ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,Functionality: Retrieve the balance of a specific token identified by `id` for a given `account` address in an ERC1155 token contract. It verifies that the provided account address is not the zero address before returning the token balance from the contract's internal storage.
d2944a711af9be78ad79ef95920a6d33,1495 | 1496,rule,transferBalanceReduceEffect,262,276,balanceOf | safeTransferFrom,"rule transferBalanceReduceEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require other != to;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert from != other => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check an account's balance for a specific token ID using `balanceOf`, ensuring the account is valid. Allow token transfers with `safeTransferFrom` by verifying the caller is the token owner or an approved delegate, then executing the transfer safely, considering ERC1155's multi-token standard requirements."
d37c0dd25e371ea38fa91d5158d92698,1520,rule,cantMintBatchOtherBalances,574,595,balanceOf,"rule cantMintBatchOtherBalances(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256[] ids; uint256[] amounts;
    address other;
    bytes data;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify the validity of an account address, ensuring it is not a zero address, to prevent operations involving invalid ownership. Subsequently, retrieve and return the balance of a specific token, identified by `id`, owned by the specified `account`."
d805d65c2b4b75ede56d0b87690dae6f,1527,rule,cantBurnMoreSingle,697,705,balanceOf,"rule cantBurnMoreSingle(env e){
    address from; uint256 id; uint256 amount;

    require to_mathint(balanceOf(from, id) - amount) < 0;
    burn@withrevert(e, from, id, amount);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) owned by a given address (`account`). Ensure the provided address is non-zero, indicating a valid owner, before returning the token's balance from the internal storage mapping `_balances`."
dac13993d398b877f17f0aeb49311404,1528,rule,cantBurnMoreBatch,710,728,balanceOf,"rule cantBurnMoreBatch(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(from, id1) - amount1) < 0 
                || to_mathint(balanceOf(from, id2) - amount2) < 0 
                || to_mathint(balanceOf(from, id3) - amount3) < 0 ;
    burnBatch@withrevert(e, from, ids, amounts);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,Functionality: Retrieve the balance of a specific token (identified by `id`) held by a given account address. It ensures that the provided account address is valid (not the zero address) before returning the token balance from a stored mapping of token IDs to account balances.
dac6549e983a6d48333be7dc3ab27658,1524,rule,burnCorrectWork,651,661,balanceOf,"rule burnCorrectWork(env e){
    address from; uint256 id; uint256 amount;

    uint256 otherBalanceBefore = balanceOf(from, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(from, id);
    
    assert otherBalanceBefore == otherBalanceAfter + amount, ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token (identified by `id`) held by a given account address. Ensure the account address is not zero, signaling it's a valid owner, before returning the corresponding token balance from the internal storage."
e2e9909b0532a2eb9a695c7512179354,1515,rule,cantMintMoreSingle,521,529,balanceOf,"rule cantMintMoreSingle(env e){
    address to; uint256 id; uint256 amount; bytes data;

    require to_mathint(balanceOf(to, id) + amount) > max_uint256;
    mint@withrevert(e, to, id, amount, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Retrieve the balance of a specific token identified by its ID for a given account. The function ensures the provided account address is valid and not zero, then accesses a mapping to return the corresponding token balance for that account."
e6933cd94304141775079e9eff6f76d6,1489 | 1490,rule,transferCorrectness,162,177,balanceOf | safeTransferFrom,"rule transferCorrectness(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;

    require to != from;
    uint256 fromBalanceBefore = balanceOf(from, id);
    uint256 toBalanceBefore = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 fromBalanceAfter = balanceOf(from, id);
    uint256 toBalanceAfter = balanceOf(to, id);
    assert fromBalanceBefore == fromBalanceAfter + amount, ""Something wet wrong"";
    assert toBalanceBefore == toBalanceAfter - amount, ""Something wet wrong"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check the balance of a specific token (identified by 'id') for a given account address, ensuring the address is valid. Enable a token transfer from one address to another, given the sender has ownership or approval, while validating the transaction parameters and performing the transfer securely."
ec94157365af0a8d8ad4ed57ec684886,1485 | 1486,rule,unexpectedBalanceChange,87,93,safeTransferFrom | safeBatchTransferFrom,"rule unexpectedBalanceChange(method f, env e) 
    filtered { f -> f.selector != safeTransferFrom(address, address, uint256, uint256, bytes).selector
                        && f.selector != safeBatchTransferFrom(address, address, uint256[], uint256[], bytes).selector 
                        && f.selector != mint(address, uint256, uint256, bytes).selector 
                        && f.selector != mintBatch(address, uint256[], uint256[], bytes).selector  
                        && f.selector != burn(address, uint256, uint256).selector 
                        && f.selector != burnBatch(address, uint256[], uint256[]).selector } {
","safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: The code defines two functions for transferring ERC1155 tokens. The `safeTransferFrom` function allows for the transfer of a single token type, while the `safeBatchTransferFrom` function enables the transfer of multiple token types in one transaction, enforcing ownership or approval verification before proceeding."
f756903d59f2aed80775848b57232223,1533 | 1534 | 1535,rule,singleTokenSafeTransferFromSafeBatchTransferFromEquivalence,779,806,balanceOf | safeTransferFrom | safeBatchTransferFrom,"rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfer = lastStorage;
    env e;

    address holder; address recipient;
    uint256 token; uint256 transferAmount; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalance = balanceOf(holder, token);
    mathint recipientStartingBalance = balanceOf(recipient, token);
    require tokens.length == 1; require transferAmounts.length == 1;
    require tokens[0] == token; require transferAmounts[0] == transferAmount;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;
    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;
    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange
        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, 
        ""Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}   
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Validate token ownership or approval before executing token transfers in the ERC1155 standard. Specifically, it checks for valid non-zero addresses, owner or approved caller status, then performs either a single or batch transfer of tokens, including accompanying data."
dac13993d398b877f17f0aeb49311404,1528,rule,cantBurnMoreBatch,710,728,balanceOf,"rule cantBurnMoreBatch(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(from, id1) - amount1) < 0 
                || to_mathint(balanceOf(from, id2) - amount2) < 0 
                || to_mathint(balanceOf(from, id3) - amount3) < 0 ;
    burnBatch@withrevert(e, from, ids, amounts);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Return the balance of a specific token (identified by its ID) owned by a given account. It first ensures that the provided account address is not the zero address, as such an address is not considered a valid owner in the ERC1155 standard."
dac6549e983a6d48333be7dc3ab27658,1524,rule,burnCorrectWork,651,661,balanceOf,"rule burnCorrectWork(env e){
    address from; uint256 id; uint256 amount;

    uint256 otherBalanceBefore = balanceOf(from, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(from, id);
    
    assert otherBalanceBefore == otherBalanceAfter + amount, ""Something is wrong"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify that the specified account address is not zero, ensuring it is a valid owner, then return the balance of a specific token (identified by its `id`) that the account holds within the context of an ERC1155 smart contract."
e2e9909b0532a2eb9a695c7512179354,1515,rule,cantMintMoreSingle,521,529,balanceOf,"rule cantMintMoreSingle(env e){
    address to; uint256 id; uint256 amount; bytes data;

    require to_mathint(balanceOf(to, id) + amount) > max_uint256;
    mint@withrevert(e, to, id, amount, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
","balanceOf (Lines 70-73), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Return the balance of a specific token (identified by `id`) owned by a given address (`account`). It first verifies that the provided address is not the zero address, ensuring it represents a valid token owner, before accessing the balance from a mapping."
e6933cd94304141775079e9eff6f76d6,1489 | 1490,rule,transferCorrectness,162,177,balanceOf | safeTransferFrom,"rule transferCorrectness(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;

    require to != from;
    uint256 fromBalanceBefore = balanceOf(from, id);
    uint256 toBalanceBefore = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 fromBalanceAfter = balanceOf(from, id);
    uint256 toBalanceAfter = balanceOf(to, id);
    assert fromBalanceBefore == fromBalanceAfter + amount, ""Something wet wrong"";
    assert toBalanceBefore == toBalanceAfter - amount, ""Something wet wrong"";
}
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Verify ownership or approval before executing a token transfer; ensure a valid owner address and provide the ability to transfer a specified amount of a token (by ID) between accounts, incorporating safe transfer practices and custom logic interactions through data."
ec94157365af0a8d8ad4ed57ec684886,1485 | 1486,rule,unexpectedBalanceChange,87,93,safeTransferFrom | safeBatchTransferFrom,"rule unexpectedBalanceChange(method f, env e) 
    filtered { f -> f.selector != safeTransferFrom(address, address, uint256, uint256, bytes).selector
                        && f.selector != safeBatchTransferFrom(address, address, uint256[], uint256[], bytes).selector 
                        && f.selector != mint(address, uint256, uint256, bytes).selector 
                        && f.selector != mintBatch(address, uint256[], uint256[], bytes).selector  
                        && f.selector != burn(address, uint256, uint256).selector 
                        && f.selector != burnBatch(address, uint256[], uint256[]).selector } {
","safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Enable the secure transfer of single or multiple token types from one address to another, contingent on the initiator being the token holder or an approved delegate, through checks ensuring authorization before leveraging internal functions that actually facilitate the transfer process."
f756903d59f2aed80775848b57232223,1533 | 1534 | 1535,rule,singleTokenSafeTransferFromSafeBatchTransferFromEquivalence,779,806,balanceOf | safeTransferFrom | safeBatchTransferFrom,"rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfer = lastStorage;
    env e;

    address holder; address recipient;
    uint256 token; uint256 transferAmount; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalance = balanceOf(holder, token);
    mathint recipientStartingBalance = balanceOf(recipient, token);
    require tokens.length == 1; require transferAmounts.length == 1;
    require tokens[0] == token; require transferAmounts[0] == transferAmount;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;
    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;
    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange
        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, 
        ""Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}   
","balanceOf (Lines 70-73),  | safeTransferFrom (Lines 117-129),  | safeBatchTransferFrom (Lines 134-146), ","    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), ""ERC1155: address zero is not a valid owner"");
        return _balances[id][account];
    }
 |     function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }
 |     function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not token owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }
",./openzepplin/specs/ERC1155.spec,openzepplin,,Yes,,"Functionality: Check if an account owns a specific token and its balance, enable secure transfer of a token from one account to another, and allow for the safe transfer of multiple token types in batches between accounts, ensuring that the caller is authorized to make such transfers."
8175e7f417c1a39d8d4ac967519a4c14,1374 | 1375 | 1376,rule,updateDepositParametersSetsProperly,19,31,getDepositParameters | getMaxMarketIndex | updateDepositParameters,"rule updateDepositParametersSetsProperly(
    uint16 currencyId,
    uint32[] _depositShares,
    uint32[] _leverageThresholds
) {
    env e;
    require getMaxMarketIndex() <= MAX_MARKET_INDEX();
    require _depositShares.length == getMaxMarketIndex();
    require _depositShares.length == _leverageThresholds.length;
    updateDepositParameters(currencyId, _depositShares, _leverageThresholds);
    // TODO: move the checking into solidity and return a bool on success.
    int256[] depositShares, int256[] leverageThresholds = getDepositParameters(currencyId)
}
","getDepositParameters (Lines 119-130),  | getMaxMarketIndex (Lines 273-276),  | updateDepositParameters (Lines 118-129), ","    function getDepositParameters(uint16 currencyId)
        external
        view
        override
        returns (int256[] memory depositShares, int256[] memory leverageThresholds)
    {
        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);
        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(
            currencyId,
            maxMarketIndex
        );
    }
 |     function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        return uint8(data[31]);
    }
 |     function updateDepositParameters(
        uint16 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) external override onlyOwner {
        require(
            depositShares.length == CashGroup.getMaxMarketIndex(currencyId),
            ""Invalid array length""
        );
        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);
        emit UpdateDepositParameters(currencyId);
    }
",./notional_finance_v2/certora/governance/GovernanceAction.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve and update deposit parameters for a specific currency ID. It calculates the maximum market index for the currency, obtains deposit shares and leverage thresholds, and ensures updates match the current market index, enforcing array length consistency for updates."
9ca45bf5e5ee2b926f8d318e1dfa4575,1378 | 1379,rule,updateInitializationParametersSetsProperly,33,45,getNTokenAccount | updateIncentiveEmissionRate,"// rule updateInitializationParametersSetsProperly;

rule updateIncentiveEmissionRateSetsProperly(
    uint16 currencyId,
    uint32 newEmissionRate,
    address nTokenAddress
) {
    env e;
    require nTokenAddress(currencyId) == nTokenAddress;
    updateIncentiveEmissionRate(currencyId, newEmissionRate);
    _, uint256 incentiveEmissionRate = getNTokenAccount(nTokenAddress);
    assert incentiveEmissionRate == newEmissionRate;
}
","getNTokenAccount (Lines 234-262),  | updateIncentiveEmissionRate (Lines 159-171), ","    function getNTokenAccount(address tokenAddress)
        external
        view
        override
        returns (
            uint256 currencyId,
            uint256 totalSupply,
            uint256 incentiveAnnualEmissionRate,
            uint256 lastInitializedTime,
            bytes6 nTokenParameters,
            int256 cashBalance
        )
    {
        (
            currencyId,
            totalSupply,
            incentiveAnnualEmissionRate,
            lastInitializedTime,
            nTokenParameters
        ) = nTokenHandler.getNTokenContext(tokenAddress);

        // prettier-ignore
        (
            cashBalance,
            /* */,
            /* */,
            /* */
        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);
    }
 |     function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)
        external
        override
        onlyOwner
    {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(nTokenAddress != address(0), ""Invalid currency"");
        // Sanity check that emissions rate is not specified in 1e8 terms.
        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, ""Invalid rate"");

        nTokenHandler.setIncentiveEmissionRate(nTokenAddress, newEmissionRate);
        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);
    }
",./notional_finance_v2/certora/governance/GovernanceAction.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve specific information about an nToken (like currency ID, total supply, and balance) and allows only the owner to update the incentive emission rate for a given currency, ensuring the rate adheres to predefined precision limits and the currency is valid."
75c1bbea77034c10a732ea69fe4a649f,1382 | 1389 | 1390,rule,cashGroupGetterSetters,19,67,getLiquidityHaircut | getMaxMarketIndex | setCashGroupStorage,"rule cashGroupGetterSetters(
    uint256 currencyId,
    uint8 maxMarketIndex,
    uint8 rateOracleTimeWindowMin,
    uint8 totalFeeBPS,
    uint8 reserveFeeShare,
    uint8 debtBuffer5BPS,
    uint8 fCashHaircut5BPS,
    uint8 settlementPenaltyRate5BPS,
    uint8 liquidationfCashHaircut5BPS,
    uint8 liquidationDebtBuffer5BPS,
    uint8[] liquidityTokenHaircuts,
    uint8[] rateScalars,
    uint256 assetType
) {
    env e;
    require MIN_CURRENCY_ID() <= currencyId && currencyId <= MAX_CURRENCY_ID();
    require MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX();
    require MIN_MARKET_INDEX() + 1 <= assetType && assetType <= marketIndex + 1;

    setCashGroupStorage(
        e,
        currencyId,
        maxMarketIndex,
        rateOracleTimeWindowMin,
        totalFeeBPS,
        reserveFeeShare,
        debtBuffer5BPS,
        fCashHaircut5BPS,
        settlementPenaltyRate5BPS,
        liquidationfCashHaircut5BPS,
        liquidationDebtBuffer5BPS,
        liquidityTokenHaircuts,
        rateScalars
    );
    assert maxMarketIndex == getMaxMarketIndex(currencyId), ""max market index does not match"";
    assert rateOracleTimeWindowMin * 60 == getRateOracleTimeWindow(currencyId), ""rate oracle not returned in seconds"";
    assert totalFeeBPS * BASIS_POINTS() == getTotalFee(currencyId), ""total fee does not match""
    assert reserveFeeShare == getReserveFeeShare(currencyId), ""reserve fee share does not match""
    assert debtBuffer5BPS * 5 * BASIS_POINTS() == getDebtBuffer(currencyId), ""debt buffer does not match""
    assert fCashHaircut5BPS * 5 * BASIS_POINTS() == getfCashHaircut(currencyId), ""fCash haircut does not match""
    assert settlementPenaltyRate5BPS * 5 * BASIS_POINTS() == getSettlementPenalty(currencyId), ""settlement penalty does not match""
    assert liquidationfCashHaircut5BPS * 5 * BASIS_POINTS() == getLiquidationfCashHaircut(currencyId), ""liquidation fcash haircut does not match""
    assert liquidationDebtBuffer5BPS * 5 * BASIS_POINTS() == getLiquidationDebtBuffer(currencyId), ""liquidation debt buffer does not match""
    assert liquidityTokenHaircuts[assetType - 1] == getLiquidityHaircut(currencyId, assetType), ""liquidity token haircut does not match"";
    // rate scalars, todo, what do we want to test here?
}
","getLiquidityHaircut (Lines 73-83),  | getMaxMarketIndex (Lines 273-276),  | setCashGroupStorage (Lines 279-344), ","    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)
        internal
        pure
        returns (uint256)
    {
        require(assetType > 1); // dev: liquidity haircut invalid asset type
        uint256 offset =
            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);
        uint256 liquidityTokenHaircut = uint256(uint8(uint256(cashGroup.data >> offset)));
        return liquidityTokenHaircut;
    }
 |     function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        return uint8(data[31]);
    }
 |     function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)
        internal
    {
        bytes32 slot = keccak256(abi.encode(currencyId, Constants.CASH_GROUP_STORAGE_OFFSET));
        require(
            cashGroup.maxMarketIndex >= 0 &&
                cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,
            ""CG: invalid market index""
        );
        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.
        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month
        // fixed. It also complicates the logic in the nToken initialization method
        require(cashGroup.maxMarketIndex != 1, ""CG: invalid market index"");
        require(
            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,
            ""CG: invalid reserve share""
        );
        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);
        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);
        // This is required so that fCash liquidation can proceed correctly
        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);
        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);

        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve
        uint8 previousMaxMarketIndex = uint8(uint256(_getCashGroupStorageBytes(currencyId)));
        require(
            previousMaxMarketIndex <= cashGroup.maxMarketIndex,
            ""CG: market index cannot decrease""
        );

        // Per cash group settings
        bytes32 data =
            (bytes32(uint256(cashGroup.maxMarketIndex)) |
                (bytes32(uint256(cashGroup.rateOracleTimeWindowMin)) << RATE_ORACLE_TIME_WINDOW) |
                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |
                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |
                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |
                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |
                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<
                    LIQUIDATION_FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));

        // Per market group settings
        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) {
            require(
                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,
                ""CG: invalid token haircut""
            );

            data =
                data |
                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<
                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));
        }

        for (uint256 i; i < cashGroup.rateScalars.length; i++) {
            // Causes a divide by zero error
            require(cashGroup.rateScalars[i] != 0, ""CG: invalid rate scalar"");
            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));
        }

        assembly {
            sstore(slot, data)
        }
    }
",./notional_finance_v2/certora/governance/CashGroup.spec,notional_finance_v2,,Yes,,"Functionality: Calculate and set liquidity haircuts and market indices for currency in a decentralized finance (DeFi) protocol, ensuring constraints like market index validity, fee shares, and liquidity parameters are met, to manage the risk and liquidity provision of different financial assets."
261ee3c4b34293a73a7e6204d4ed041e,1307 | 1308 | 1309,invariant,portfolioIsAlwaysSorted,219,250,getNetCashGroupValue | checkPortfolioSorted | getPortfolioCurrencyIdAtIndex,"invariant portfolioIsAlwaysSorted (address account)
    // Get portfolio from harness and test if assets are sorted, do this
    // inside a harness
    checkPortfolioSorted(account)

// TODO: below here I'm not sure how we actually do this
// Set up a portfolio such that every asset's value is equal to 1e8 and then assert
rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02
    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
","getNetCashGroupValue (Lines 219-274),  | checkPortfolioSorted (Lines 122-133),  | getPortfolioCurrencyIdAtIndex (Lines 135-145), ","    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
 |     function checkPortfolioSorted(address account) external view returns (bool) {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        for (uint256 i; i < assets.length; i++) {
            if (i == 0) continue;
            assert(assets[i - 1].currencyId <= assets[i].currencyId);
            assert(assets[i - 1].maturity <= assets[i].maturity);
            assert(assets[i - 1].assetType <= assets[i].assetType);
        }
    }
 |     function getPortfolioCurrencyIdAtIndex(address account, uint256 index)
        external
        view
        returns (uint256)
    {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        return assets[index].currencyId;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the net cash group value in a portfolio by aggregating the present value of liquidity tokens and fCash assets, taking into account their currency ID and adjusting for risk. Ensure portfolios are sorted by currency ID, maturity, and asset type, and retrieve the currency ID at a specified portfolio index."
326d46dbca34a6f6e0277731055479f6,1325 | 1326,rule,netCashGroupValueAccountsForAllAssets,226,250,getNetCashGroupValue | getPortfolioCurrencyIdAtIndex,"rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02

    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
","getNetCashGroupValue (Lines 219-274),  | getPortfolioCurrencyIdAtIndex (Lines 135-145), ","    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
 |     function getPortfolioCurrencyIdAtIndex(address account, uint256 index)
        external
        view
        returns (uint256)
    {
        PortfolioAsset[] memory assets = PortfolioHandler.getSortedPortfolio(
            account,
            symbolicAccountContext.assetArrayLength
        );
        return assets[index].currencyId;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the net cash value of a group within a portfolio based on specific asset and market parameters, taking into account both liquidity tokens and fCash assets. Adjust values for risk and convert underlying values to asset rates, supporting efficient portfolio management and valuation."
734e363718c8ba5a0f2add8350e62d78,1313,rule,riskAdjustedPresentValueDecreasesForLongerMaturities,120,134,getRiskAdjustedPresentValue,"rule riskAdjustedPresentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturity,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getRiskAdjustedPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);

    // PV cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getRiskAdjustedPresentValue (Lines 76-104), ","    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the risk-adjusted present value of a cash flow, considering the time to maturity, oracle rate, and adjustments for either positive or negative notional based on cash group parameters, ensuring the adjusted value does not exceed defined constants."
87e84c8405006bfb0d5c4ea0b51ab6d0,1327 | 1328,rule,ifCashNetPresentValueAccountsForAllAssets,252,261,getifCashNetPresentValue | getNumBitmapAssets,"rule ifCashNetPresentValueAccountsForAllAssets(address account) {
    env e;
    // TODO: need to make these asumptions in the code
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;

    // If each asset is valued at 1 then the total value should be the number of assets
    int256 underlyingPV = getifCashNetPresentValue(account, e.block.timestamp, true);
    assert underlyingPV == getNumBitmapAssets(account);
}
","getifCashNetPresentValue (Lines 196-231),  | getNumBitmapAssets (Lines 192-200), ","    function getifCashNetPresentValue(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime,
        uint256 blockTime,
        bytes32 assetsBitmap,
        CashGroupParameters memory cashGroup,
        bool riskAdjusted
    ) internal view returns (int256, bool) {
        int256 totalValueUnderlying;
        uint256 bitNum = 1;
        bool hasDebt;

        while (assetsBitmap != 0) {
            if (assetsBitmap & Constants.MSB == Constants.MSB) {
                uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);
                int256 pv =
                    getPresentValue(
                        account,
                        currencyId,
                        maturity,
                        blockTime,
                        cashGroup,
                        riskAdjusted
                    );
                totalValueUnderlying = totalValueUnderlying.add(pv);

                if (pv < 0) hasDebt = true;
            }

            assetsBitmap = assetsBitmap << 1;
            bitNum += 1;
        }

        return (totalValueUnderlying, hasDebt);
    }
 |     function getNumBitmapAssets(address account) external view returns (int256) {
        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(
            account,
            symbolicAccountContext.bitmapCurrencyId
        );

        // Return int256 for comparison
        return int256(assetsBitmap.totalBitsSet());
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the net present value of the cash flows associated with an account's assets denoted in a specific currency, and identify if the account has any debt. It iterates through each asset indicated by a bitmap, computes its present value, and accumulates this to obtain the total value and debt status."
8ca2ef6914fb211e7306493314d1f709,1314 | 1315,rule,riskAdjustedPresentValueIsLessThanPresentValue,138,149,getPresentValue | getRiskAdjustedPresentValue,"rule riskAdjustedPresentValueIsLessThanPresentValue(
    int256 notional,
    uint256 maturity,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 pv = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 riskAdjustedPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);

    assert riskAdjustedPV <= pv;
}
","getPresentValue (Lines 59-72),  | getRiskAdjustedPresentValue (Lines 76-104), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the present value of a notional amount by applying a discount based on time to maturity and an oracle rate, and adjust the calculation for risk by modifying the rate for positive or negative notionals using cash group parameters."
9a7e907d9743bf621b59aa949d017447,1316 | 1317 | 1318 | 1319 | 1320,rule,riskAdjustedLiquidityTokenValueMatchesClaims,155,186,getRiskAdjustedPresentValue | getLiquidityHaircut | calculateOracleRate | getLiquidityTokenValue | getMarketValues,"rule riskAdjustedLiquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 tokenHaircut;
    tokenHaircut = getLiquidityHaircut(assetType);
    require tokenHaircut <= 100;
    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        true // risk adjusted
    );
    mathint netfCash = (totalfCash * tokens * tokenHaircut) / (100 * totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens * tokenHaircut) / (100 * totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getRiskAdjustedPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","getRiskAdjustedPresentValue (Lines 76-104),  | getLiquidityHaircut (Lines 73-83),  | calculateOracleRate (Lines 221-259),  | getLiquidityTokenValue (Lines 151-216),  | getMarketValues (Lines 37-55), ","    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)
        internal
        pure
        returns (uint256)
    {
        require(assetType > 1); // dev: liquidity haircut invalid asset type
        uint256 offset =
            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);
        uint256 liquidityTokenHaircut = uint256(uint8(uint256(cashGroup.data >> offset)));
        return liquidityTokenHaircut;
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }
 |     function getMarketValues()
        external
        view
        returns (
            uint256 totalfCash,
            uint256 totalAssetCash,
            uint256 totalLiquidity,
            uint256 maturity
        )
    {
        require(symbolicMarket.totalfCash >= 0);
        require(symbolicMarket.totalAssetCash >= 0);
        require(symbolicMarket.totalLiquidity >= 0);

        totalfCash = uint256(symbolicMarket.totalfCash);
        totalAssetCash = uint256(symbolicMarket.totalAssetCash);
        totalLiquidity = uint256(symbolicMarket.totalLiquidity);
        maturity = symbolicMarket.maturity;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the risk-adjusted present value of a notional amount given cash group parameters, maturity, block time, and oracle rate. It adjusts for debt buffer or fCash haircut based on the notional's sign, enforcing a maximum valid discount factor."
9d6239cdf289a127b6fdad6ef12b76a7,1321 | 1322 | 1323 | 1324,rule,liquidityTokenValueMatchesClaims,188,216,getPresentValue | calculateOracleRate | getLiquidityTokenValue | getMarketValues,"rule liquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        false // non risk adjusted
    );
    mathint netfCash = (totalfCash * tokens) / (totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens) / (totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getLiquidityTokenValue (Lines 151-216),  | getMarketValues (Lines 37-55), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }
 |     function getMarketValues()
        external
        view
        returns (
            uint256 totalfCash,
            uint256 totalAssetCash,
            uint256 totalLiquidity,
            uint256 maturity
        )
    {
        require(symbolicMarket.totalfCash >= 0);
        require(symbolicMarket.totalAssetCash >= 0);
        require(symbolicMarket.totalLiquidity >= 0);

        totalfCash = uint256(symbolicMarket.totalfCash);
        totalAssetCash = uint256(symbolicMarket.totalAssetCash);
        totalLiquidity = uint256(symbolicMarket.totalLiquidity);
        maturity = symbolicMarket.maturity;
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the present value of notional financial instruments based on their maturity and market conditions, interpolate oracle rates for specific timelines, evaluate liquidity token values in both risk-adjusted and standard scenarios, and provide market values including total cash, asset cash, liquidity, and maturity."
9f9fd761bd55191d7ed838aed41e5af5,1304 | 1305 | 1306,invariant,calculateOracleRateIsBetweenOnChainRates,82,117,getPresentValue | calculateOracleRate | getMaturityAtMarketIndex,"invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )

// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getMaturityAtMarketIndex (Lines 21-27), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getMaturityAtMarketIndex(uint256 marketIndex, uint256 blockTime)
        external
        pure
        returns (uint256)
    {
        return DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the present value of a notional amount by applying a discount factor derived from the oracle rate and the time to maturity. Also, compute the oracle rate considering market conditions and interpolate between short and long rates for certain cases, along with determining maturity based on the market index."
a48f20eb4cbf175c9ee7e2b5548a032d,1310 | 1311 | 1312,rule,oracleRatesAreBlendedIntoTheRateWindow,79,117,getPresentValue | calculateOracleRate | getMaturityAtMarketIndex,"// rule oracleRatesAreBlendedIntoTheRateWindow will cover `getOracleRate`

// This should show that the oracle rate is the linear interpolation between two on chain rates.
invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )
// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","getPresentValue (Lines 59-72),  | calculateOracleRate (Lines 221-259),  | getMaturityAtMarketIndex (Lines 21-27), ","    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mul(discountFactor).div(Constants.RATE_PRECISION);
    }
 |     function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }
 |     function getMaturityAtMarketIndex(uint256 marketIndex, uint256 blockTime)
        external
        pure
        returns (uint256)
    {
        return DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
    }
",./notional_finance_v2/certora/asset/Valuation.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the present value of a financial instrument based on its notional amount, maturity, block time, and an oracle-determined interest rate, accounting for differences in maturity timelines through interpolation of oracle rates for both idiosyncratic and standard market instruments."
520c1ea3bc22b21cfd9a92829cc305e1,1297 | 1298 | 1299,rule,assetsConvertToCashAtSettlementRate,37,50,getCashBalance | getAmountToSettle | settleAccount,"// The intent of a rule like this is to ensure that when we settle fCash or liquidity tokens
// we do the correct calculation to return the settlement balance. The settlement balance for fCash
// will simply be an asset cash amount based on the settlement rate. The settlement logic for liquidity
// tokens has two potential outcomes. We may want to have three separate rules for this.
// rule assetsConvertToCashAtSettlementRate(address account, uint256 currencyId) {
//     env e;
//     int256 cashBefore = getCashBalance(currencyId, account);
//     // This should get the amount of cash back, would we really be proving anything
//     // with this approach? It's quite circular if we need to write another harness...
//     int256 amountToSettle = getAmountToSettle(currencyId, account, e.block.timestamp);
//     settleAccount(e, account);
//     int256 cashAfter = getCashBalance(currencyId, account);
//     assert cashAfter - cashBefore == amountToSettle;
// }
","getCashBalance (Lines 80-84),  | getAmountToSettle (Lines 67-83),  | settleAccount (Lines 34-40), ","    function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
 |     function getAmountToSettle(
        uint256 currencyId,
        address account,
        uint256 blockTime
    ) external view returns (int256) {
        int256 amountToSettle;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            // TODO: incomplete, but is this even the right approach?
            if (assets[i].getSettlementDate() <= blockTime && assets[i].currencyId == currencyId) {
                // AssetRate memory ar = AssetRate.buildSettlementRateView(currencyId, maturity);
            }
        }

        return amountToSettle;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve an account's cash balance for a specific currency, determine the amount to settle for a given currency at a specified block time by evaluating the account's assets, and settle an account's assets when required by updating the account context post-settlement."
7a38d364b8803f7a048af5e27123090e,1293 | 1294,rule,settleAssetsDeletesSettleableAssets,13,17,getNumSettleableAssets | settleAccount,"rule settleAssetsDeletesSettleableAssets(address account) {
    env e;
    settleAccount(e, account);
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}
","getNumSettleableAssets (Lines 52-65),  | settleAccount (Lines 34-40), ","    function getNumSettleableAssets(address account, uint256 blockTime)
        external
        view
        returns (uint256)
    {
        uint256 numSettleableAssets;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            if (assets[i].getSettlementDate() <= blockTime) numSettleableAssets++;
        }

        return numSettleableAssets;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,notional_finance_v2,,Yes,,"Functionality: Determine the number of settleable assets for a given account based on a specific block time by checking their settlement dates. Additionally, settle the account's assets and finalize its context if there are any assets that require settlement."
90603630825667ac21f361f75cd5b4dc,1301 | 1302 | 1303,rule,settlingBitmapAssetsDoesNotLoseTrack,57,70,getNumSettleableAssets | getNumAssets | settleAccount,"rule settlingBitmapAssetsDoesNotLoseTrack(address account) {
    env e;
    // This is only true for bitmap currencies, it's mostly true for array portfolios but there
    // is an edge case where liquidity tokens net off against fCash exactly.
    require getBitmapCurrencyId(account) != 0;
    uint256 numAssets;
    uint256 numSettleAssets;
    numAssets = getNumAssets(account);
    numSettleAssets = getNumSettleableAssets(account, e.block.timestamp);

    settleAccount(e, account);
    assert getNumAssets(account) == numAssets - numSettleAssets;
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}","getNumSettleableAssets (Lines 52-65),  | getNumAssets (Lines 85-90),  | settleAccount (Lines 34-40), ","    function getNumSettleableAssets(address account, uint256 blockTime)
        external
        view
        returns (uint256)
    {
        uint256 numSettleableAssets;
        PortfolioAsset[] memory assets = _getAccountAssets(account);

        for (uint256 i; i < assets.length; i++) {
            if (assets[i].getSettlementDate() <= blockTime) numSettleableAssets++;
        }

        return numSettleableAssets;
    }
 |     function getNumAssets(address account) external view returns (uint256) {
        PortfolioAsset[] memory assets = _getAccountAssets(account);
        // Value of any asset should never be zero. If it is then it should not exist in the portfolio.
        for (uint256 i; i < assets.length; i++) assert(assets[i].notional != 0);
        return assets.length;
    }
 |     function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,notional_finance_v2,,Yes,,"Functionality: Determine the number of assets eligible for settlement based on a given block time for a specific account, count the total assets associated with an account ensuring none have a zero notional value, and settle an account's assets if required by updating its account context accordingly."
c7427c09db69e09eb025898c30b56571,1296,rule,settlementRatesAreNeverReset,23,35,settleAccount,"rule settlementRatesAreNeverReset(address account, uint256 currencyId, uint256 maturity) {
    env e;
    require maturity < e.block.timestamp;
    // TODO: need to specify that the asset that is being settled exists at the maturity provided here.
    int256 settlementRateBefore = getSettlementRate(currencyId, maturity);
    settleAccount(e, account);
    int256 settlementRateAfter = getSettlementRate(currencyId, maturity);

    // Settlement rates must always be set after settling accounts
    assert settlementRateAfter > 0;
    // If settlement rates were set before, then they must not change after
    assert settlementRateBefore == 0 => settlementRateBefore == settlementRateAfter;
}
","settleAccount (Lines 34-40), ","    function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account);
            accountContext.setAccountContext(account);
        }
    }
",./notional_finance_v2/certora/asset/Settlement.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve the account context for a specified address and check if assets need to be settled. If so, settle these assets and finalize the account state, then update the account context with the new state for that account."
43d0714ea3d88400a5cdb54353af5fd8,1365 | 1367,rule,impliedRateSlippageDoesNotChangeWithTime,237,261,getRateScalar | executeTrade,"rule impliedRateSlippageDoesNotChangeWithTime(
    int256 fCashToAccount,
    uint256 timeDelta
) {
    env e;
    // Ensure that the block time is within the tradeable region
    require timeDelta <= QUARTER() && e.block.timestamp + timeDelta < MATURITY();
    require fCashToAccount != 0;
    uint256 timeToMaturity_first = MATURITY() - e.block.timestamp;
    uint256 timeToMaturity_second = MATURITY() - e.block.timestamp - timeDelta;
    require getRateScalar(timeToMaturity_first) > 0;
    require getRateScalar(timeToMaturity_second) > 0;

    storage initStorage = lastStorage;
    executeTrade(timeToMaturity_first, fCashToAccount);
    uint256 lastImpliedRate_first = getLastImpliedRate();
    executeTrade(timeToMaturity_second, fCashToAccount) at initStorage;
    uint256 lastImpliedRate_second = getLastImpliedRate();
    require lastImpliedRate_first < 1000000 && lastImpliedRate_second < 1000000;
    assert absDiff(lastImpliedRate_first, lastImpliedRate_second) < basisPoint(),
        ""Last implied rate slippage increases with time"";
}
","getRateScalar (Lines 39-53),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Determine the rate scalar based on cash group parameters, market index, and time to maturity, ensuring it's positive and adjusts for market differences. Execute a trade by setting up cash group and market parameters based on predefined states, calculating net asset cash and reserve impacts through a market calculation, and updating market storage accordingly."
7449eb9a1db24038a2c6628f316df369,1329 | 1331 | 1335,invariant,oracleRatesAreBlendedIntoTheRateWindow,36,98,getRateScalar | getStoredOracleRate | executeTrade,"invariant oracleRatesAreBlendedIntoTheRateWindow(env e)
    (e.block.timestamp - getPreviousTradeTime() > getRateOracleTimeWindow()) ?
        getMarketOracleRate() == getLastImpliedRate() :
        isBetween(
            getStoredOracleRate(e),
            getMarketOracleRate(),
            getLastImpliedRate()
        )

rule oracleRatesBlandedIntoRateWindow(method f){
env e;
uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","getRateScalar (Lines 39-53),  | getStoredOracleRate (Lines 56-75),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Calculate a rate scalar based on cash group parameters, market index, and time to maturity, ensuring it's positive. Fetch stored oracle rates for a specific currency, settlement date, and maturity. Execute a trade by calculating the net asset cash and net asset cash to reserve based on the trade inputs and market conditions, updating market storage accordingly."
8fc106145c33d363a3e376ff60cff5a5,1350,rule,testAssetCash,149,160,executeTrade,"rule testAssetCash(int256 fCashToAccount, uint256 timeToMaturity){
    // require timeToMaturity <= 2^255-1;
    // require timeToMaturity > 0;
    // require fCashToAccount != 0;
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    assetCashToAccount, assetCashToReserve = executeTrade(timeToMaturity, fCashToAccount);
    // require (assetCashToReserve > 0, ""asset cash to reserve cannot be negative"");
    int256 marketAssetCashAfter = getMarketAssetCash();
    assert marketAssetCashAfter > marketAssetCashBefore;
}
","executeTrade (Lines 124-143), ","    function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Initialize the stateful construction of a cash group and load market parameters based on a given currency ID, then calculate the trade outcomes, including net asset cash and the amount to reserve, for a specified time to maturity and cash amount, finally updating the market storage with the trade results."
b3939dee3c4960f4083fbd98d5e872f2,1351 | 1352,rule,impliedRatesDoNotChangeOnAddLiquidity,162,193,addLiquidity | getStoredOracleRate,"rule impliedRatesDoNotChangeOnAddLiquidity(
    int256 cashAmount
) {
    env e;
    require cashAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    int256 liquidityTokens;
    int256 fCashToAccount;
    liquidityTokens, fCashToAccount = addLiquidity(e, cashAmount);
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
   assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    // assert getLastImpliedRate() == lastImpliedRate, ""last trade rate did update"";
    // assert to_mathint(marketAssetCashBefore) + to_mathint(cashAmount) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    // assert to_mathint(liquidityTokens) + to_mathint(marketLiquidityBefore) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    // assert getPreviousTradeTime() == previousTradeTime, ""previous trade time did update "";
}
","addLiquidity (Lines 34-53),  | getStoredOracleRate (Lines 56-75), ","    function addLiquidity(MarketParameters storage market, int256 assetCash)
        internal
        returns (int256, int256)
    {
        require(market.totalLiquidity > 0, ""M: zero liquidity"");
        if (assetCash == 0) return (0, 0);
        require(assetCash > 0); // dev: negative asset cash

        int256 liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);
        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.
        int256 fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);

        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);
        market.totalfCash = market.totalfCash.add(fCash);
        market.totalAssetCash = market.totalAssetCash.add(assetCash);
        market.storageState = updateLiquidity(market.storageState);
        // market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (liquidityTokens, fCash.neg());
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: The code facilitates the addition of liquidity to a market by calculating and issuing liquidity tokens and fCash in proportion to the added asset cash, updating market totals accordingly. It also provides a method to retrieve the stored oracle rate for a specific currency and maturity, leveraging either the stored rate directly or through assembly."
b3b55edaa1db879e83c221173a43288b,1358 | 1359,rule,impliedRatesDoNotChangeOnRemoveLiquidity,195,231,removeLiquidity | getStoredOracleRate,"rule impliedRatesDoNotChangeOnRemoveLiquidity(
    int256 tokenAmount
) {
    env e;
    require tokenAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    require marketLiquidityBefore >= tokenAmount;
    int256 assetCash;
    int256 fCashToAccount;
    assetCash, fCashToAccount = removeLiquidity(e, tokenAmount);
    require fCashToAccount != 0;
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
    uint256 previousTradeTimeAfter = getPreviousTradeTime();
    uint256 lastImpliedRateAfter = getLastImpliedRate();
    assert to_mathint(marketAssetCashBefore) - to_mathint(assetCash) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    assert to_mathint(marketLiquidityBefore) - to_mathint(tokenAmount) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    assert previousTradeTimeAfter == previousTradeTime, ""previous trade time did update"";
    assert lastImpliedRateAfter == lastImpliedRate, ""last trade rate did update"";
}
","removeLiquidity (Lines 57-74),  | getStoredOracleRate (Lines 56-75), ","    function removeLiquidity(MarketParameters storage market, int256 tokensToRemove)
        internal
        returns (int256, int256)
    {
        if (tokensToRemove == 0) return (0, 0);
        require(tokensToRemove > 0); // dev: negative tokens to remove

        int256 assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);
        int256 fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);

        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);
        market.totalfCash = market.totalfCash.subNoNeg(fCash);
        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);
        market.storageState = updateLiquidity(market.storageState);
        // market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (assetCash, fCash);
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Remove a specified amount of tokens from a liquidity pool, adjusting the total liquidity, total asset cash, and total fCash in the market parameters accordingly, and return the proportional amount of asset cash and fCash removed. Additionally, fetch and return the stored oracle rate for a specified currency and maturity based on settlement date calculations."
dc1ea7205620af6804566abac976f792,1343 | 1348,rule,executeTradeMovesImpliedRates,100,147,getRateScalar | executeTrade,"rule executeTradeMovesImpliedRates(
    int256 fCashToAccount,
    uint256 timeToMaturity
) {
    env e;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;

    assetCashToAccount, assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require assetCashToAccount != 0 && assetCashToReserve != 0;
    require (fCashToAccount < 0 => lastImpliedRate > getLastImpliedRate(),""last trade rate did not move in correct direction"");
    
    // assert fCashToAccount > 0 ? 
    //     // When fCashToAccount > 0 then lending, implied rates should decrease
    //     lastImpliedRate > getLastImpliedRate() :
    //     // When fCashToAccount < 0 then borrowing, implied rates should increase
    //     lastImpliedRate < getLastImpliedRate(),
    //     ""last trade rate did not move in correct direction"";
    require (fCashToAccount > 0 ? assetCashToAccount < 0 : assetCashToAccount > 0, ""incorrect asset cash for fCash"");
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
    require (getPreviousTradeTime() < e.block.timestamp, ""previous trade time did not update"");
    // assert  to_mathint(marketfCashBefore) ==  to_mathint(fCashToAccount) + to_mathint(marketfCashAfter), ""Market fCash does not net out"";
   
    // require marketfCashBefore < 1000 &&
    //         marketAssetCashBefore < 1000 &&
    //         assetCashToAccount < 1000 &&
    //         assetCashToReserve < 1000 &&
    //         marketfCashAfter < 1000 &&
    //         marketAssetCashAfter < 1000;
            
    // Jeff's NEW VERSION assert getMarketAssetCash() == marketAssetCashBefore - assetCashToAccount - assetCashToReserve;
    // int256 a_minus_b_minus_c = to_int256(marketAssetCashBefore - assetCashToAccount - assetCashToReserve);
    // int256 a_minus_b_minus_c = to_int256(to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve));
    // require a_minus_b_minus_c >= 0;
    // assert a_minus_b_minus_c == marketAssetCashAfter, //marketAssetCashBefore,
    //     ""Market asset cash does not net out"";
    assert to_mathint(marketAssetCashAfter) == to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve), //marketAssetCashBefore,
        ""Market asset cash does not net out"";
}
","getRateScalar (Lines 39-53),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Calculate a rate scalar based on cash group parameters, market index, and time to maturity, ensuring it's above zero. Additionally, conduct a trade by initializing stateful cash group and market parameters, calculating net assets from the trade, and updating market storage accordingly."
eaa3e8af391a273c9f785dc55ab14a78,1336 | 1338 | 1342,rule,oracleRatesBlandedIntoRateWindow,46,98,getRateScalar | getStoredOracleRate | executeTrade,"rule oracleRatesBlandedIntoRateWindow(method f){
env e;

uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","getRateScalar (Lines 39-53),  | getStoredOracleRate (Lines 56-75),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the rate scalar based on cash group parameters, market index, and time to maturity, ensuring it does not underflow. Retrieve stored oracle rates for specific market conditions. Execute trades by updating cash and reserve assets, leveraging symbolic market and cash group storages for calculation and storage updates."
dc1ea7205620af6804566abac976f792,1343 | 1348,rule,executeTradeMovesImpliedRates,100,147,getRateScalar | executeTrade,"rule executeTradeMovesImpliedRates(
    int256 fCashToAccount,
    uint256 timeToMaturity
) {
    env e;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;

    assetCashToAccount, assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require assetCashToAccount != 0 && assetCashToReserve != 0;
    require (fCashToAccount < 0 => lastImpliedRate > getLastImpliedRate(),""last trade rate did not move in correct direction"");
    
    // assert fCashToAccount > 0 ? 
    //     // When fCashToAccount > 0 then lending, implied rates should decrease
    //     lastImpliedRate > getLastImpliedRate() :
    //     // When fCashToAccount < 0 then borrowing, implied rates should increase
    //     lastImpliedRate < getLastImpliedRate(),
    //     ""last trade rate did not move in correct direction"";
    require (fCashToAccount > 0 ? assetCashToAccount < 0 : assetCashToAccount > 0, ""incorrect asset cash for fCash"");
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
    require (getPreviousTradeTime() < e.block.timestamp, ""previous trade time did not update"");
    // assert  to_mathint(marketfCashBefore) ==  to_mathint(fCashToAccount) + to_mathint(marketfCashAfter), ""Market fCash does not net out"";
   
    // require marketfCashBefore < 1000 &&
    //         marketAssetCashBefore < 1000 &&
    //         assetCashToAccount < 1000 &&
    //         assetCashToReserve < 1000 &&
    //         marketfCashAfter < 1000 &&
    //         marketAssetCashAfter < 1000;
            
    // Jeff's NEW VERSION assert getMarketAssetCash() == marketAssetCashBefore - assetCashToAccount - assetCashToReserve;
    // int256 a_minus_b_minus_c = to_int256(marketAssetCashBefore - assetCashToAccount - assetCashToReserve);
    // int256 a_minus_b_minus_c = to_int256(to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve));
    // require a_minus_b_minus_c >= 0;
    // assert a_minus_b_minus_c == marketAssetCashAfter, //marketAssetCashBefore,
    //     ""Market asset cash does not net out"";
    assert to_mathint(marketAssetCashAfter) == to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve), //marketAssetCashBefore,
        ""Market asset cash does not net out"";
}
","getRateScalar (Lines 39-53),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: The code calculates a rate scalar based on the parameters of a cash group and the time to maturity for a given market index, ensuring it does not round down to zero. Additionally, it executes a trade by calculating the net asset cash and net asset cash to reserve."
eaa3e8af391a273c9f785dc55ab14a78,1336 | 1338 | 1342,rule,oracleRatesBlandedIntoRateWindow,46,98,getRateScalar | getStoredOracleRate | executeTrade,"rule oracleRatesBlandedIntoRateWindow(method f){
env e;

uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","getRateScalar (Lines 39-53),  | getStoredOracleRate (Lines 56-75),  | executeTrade (Lines 124-143), ","    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * 10;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // At large time to maturities it's possible for the rate scalar to round down to zero
        require(rateScalar > 0, ""CG: rate scalar underflow"");
        return rateScalar;
    }
 |     function getStoredOracleRate() external view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(block.timestamp) + Constants.QUARTER;
        bytes32 marketSlot = Market.getMarketSlot(CURRENCY_ID, settlementDate, MATURITY);
        return Market.oracleRateStorage(marketSlot);
        
        // Instead we could write:
        // return symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY].oracleRateStorage;


        // bytes32 slot = Market.getSlot(CURRENCY_ID, settlementDate, MATURITY);
        // bytes32 data;

        // assembly {
        //     data := sload(slot)
        // }

        // uint256 oracleRate = uint256(uint32(uint256(data >> 192)));

        // return oracleRate;
    }
 |     function executeTrade(uint256 timeToMaturity, int256 fCashToAccount)
        external
        returns (int256, int256)
    {
        // CashGroupParameters memory cashGroup = symbolicCashGroup; //CashGroup.buildCashGroupStateful(CURRENCY_ID);
        // CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(CURRENCY_ID);
        symbolicCashGroupStorage._buildCashGroupStateful(CURRENCY_ID);
        // MarketParameters memory market = symbolicMarket; //_loadMarket();
        //MarketParameters memory market = _loadMarket();
        //  uint256 settlementDate = _loadMarket();
         _loadMarket();
        //  MarketParameters storage market = symbolicMarkets[CURRENCY_ID][settlementDate][MATURITY];
        (int256 netAssetCash, int256 netAssetCashToReserve) =
            Market.calculateTrade(symbolicMarket, symbolicCashGroupStorage, fCashToAccount, timeToMaturity, MARKET_INDEX);
        // Market.setMarketStorage(market);
        symbolicMarket.setMarketStorage();
        // symbolicMarket = market;
        // symbolicCashGroup = cashGroup;
        return (netAssetCash, netAssetCashToReserve);
    }
",./notional_finance_v2/certora/asset/LiquidityCurve.spec,notional_finance_v2,,Yes,,"Functionality: Calculate the rate scalar based on cash group parameters, market index, and time to maturity; retrieve stored oracle rates for specified market conditions; and execute a trade, updating market and cash group states accordingly, involving calculation of net asset cash and contributions to reserves."
57f037ca40cdff3366648467b86dcc7f,1368 | 1369,rule,bitNumAndMaturitiesMustMatch,21,33,getMaturityFromBitNum | getBitNumFromMaturity,"rule bitNumAndMaturitiesMustMatch(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    uint256 bitNum;
    bool isExact;
    bitNum, isExact = getBitNumFromMaturity(blockTime, maturity);
    uint256 calculatedMaturity = getMaturityFromBitNum(blockTime, bitNum);

    // If the bitnum is not exact then the calculated maturity will not match
    assert isExact => maturity == calculatedMaturity, ""maturity does not match calculated maturity"";
}
","getMaturityFromBitNum (Lines 150-188),  | getBitNumFromMaturity (Lines 95-146), ","    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        internal
        pure
        returns (uint256)
    {
        require(bitNum != 0); // dev: cash group get maturity from bit num is zero
        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);
        uint256 firstBit;

        if (bitNum <= Constants.WEEK_BIT_OFFSET) {
            return blockTimeUTC0 + bitNum * Constants.DAY;
        }

        if (bitNum <= Constants.MONTH_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_DAY_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.WEEK);
            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;
        }

        if (bitNum <= Constants.QUARTER_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_WEEK_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.MONTH);
            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;
        }

        firstBit =
            blockTimeUTC0 +
            Constants.MAX_MONTH_OFFSET *
            Constants.DAY -
            (blockTimeUTC0 % Constants.QUARTER);
        return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;
    }
 |     function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        internal
        pure
        returns (uint256, bool)
    {
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);

        if (maturity % Constants.DAY != 0) return (0, false);
        if (blockTimeUTC0 >= maturity) return (0, false);

        // Overflow check done above
        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;

        // These if statements need to fall through to the next one
        if (daysOffset <= Constants.MAX_DAY_OFFSET) {
            return (daysOffset, true);
        }

        if (daysOffset <= Constants.MAX_WEEK_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_DAY_OFFSET +
                    (blockTimeUTC0 % Constants.WEEK) /
                    Constants.DAY;
            // Ensures that the maturity specified falls on the actual day, otherwise division
            // will truncate it
            return (Constants.WEEK_BIT_OFFSET + offset / 6, (offset % 6) == 0);
        }

        if (daysOffset <= Constants.MAX_MONTH_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_WEEK_OFFSET +
                    (blockTimeUTC0 % Constants.MONTH) /
                    Constants.DAY;

            return (Constants.MONTH_BIT_OFFSET + offset / 30, (offset % 30) == 0);
        }

        if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_MONTH_OFFSET +
                    (blockTimeUTC0 % Constants.QUARTER) /
                    Constants.DAY;

            return (Constants.QUARTER_BIT_OFFSET + offset / 90, (offset % 90) == 0);
        }

        // This is the maximum 1-indexed bit num
        return (256, false);
    }
",./notional_finance_v2/certora/asset/DateTime.spec,notional_finance_v2,,Yes,,"Functionality: Convert between block time and a uniquely identified maturity encoded as a ""bit number"" and vice versa, considering different time offsets (days, weeks, months, quarters) while ensuring the calculations adhere to specific constraints, thereby facilitating the tracking and management of financial instruments over time."
8daf2b9ef2da2a5ce9364f0f9fa8c7ab,1372 | 1373,rule,validMarketMaturitesHaveAnIndex,57,71,isValidMarketMaturity | getMarketIndex,"rule validMarketMaturitesHaveAnIndex(
    uint256 maxMarketIndex,
    uint256 maturity,
    uint256 blockTime
) {
    // Respect time boundaries
    uint256 marketIndex;
    bool isIdiosyncratic;
    marketIndex, isIdiosyncratic = getMarketIndex(maxMarketIndex, maturity, blockTime);
    bool isValidMarket = isValidMarketMaturity(maxMarketIndex, maturity, blockTime);

    // If a market is a valid market maturity then the getMarketIndex should agree
    assert isValidMarket <=> !isIdiosyncratic, ""is valid market does not imply a market index"";
    assert MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX(), ""market index out of boundaries"";
}","isValidMarketMaturity (Lines 40-56),  | getMarketIndex (Lines 74-90), ","    function isValidMarketMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, ""CG: market index bound"");

        if (maturity % Constants.QUARTER != 0) return false;
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;
        }

        return false;
    }
 |     function getMarketIndex(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (uint256, bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, ""CG: market index bound"");
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));
            if (marketMaturity == maturity) return (i, false);
            if (marketMaturity > maturity) return (i, true);
        }

        revert(""CG: no market found"");
    }
",./notional_finance_v2/certora/asset/DateTime.spec,notional_finance_v2,,Yes,,"Functionality: Validate the maturity of a market against a set of criteria including index bounds and quarter alignment, then return either a boolean for validity or a tuple indicating the market index related to a given maturity and a flag indicating if the maturity has been surpassed."
d1f59659acdb5117edfd627a1777537d,1370 | 1371,rule,bitNumValidMaturitiesMustBeExact,39,52,getBitNumFromMaturity | isValidMaturity,"rule bitNumValidMaturitiesMustBeExact(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    require MIN_TIMESTAMP() <= blockTime && blockTime <= MAX_TIMESTAMP();
    require MIN_TIMESTAMP() <= maturity && maturity <= MAX_TIMESTAMP();
    require isValidMaturity(MAX_MARKET_INDEX(), maturity, blockTime);
    bool isExact;
    _, isExact = getBitNumFromMaturity(blockTime, maturity);

    // BitNums go out a bit past the max 20 year maturity, those bits are not valid
    assert isExact && maturity <= MAX_MARKET_MATURITY(blockTime), ""bitnum is valid does not match is valid maturity"";
}
","getBitNumFromMaturity (Lines 95-146),  | isValidMaturity (Lines 59-71), ","    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        internal
        pure
        returns (uint256, bool)
    {
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);

        if (maturity % Constants.DAY != 0) return (0, false);
        if (blockTimeUTC0 >= maturity) return (0, false);

        // Overflow check done above
        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;

        // These if statements need to fall through to the next one
        if (daysOffset <= Constants.MAX_DAY_OFFSET) {
            return (daysOffset, true);
        }

        if (daysOffset <= Constants.MAX_WEEK_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_DAY_OFFSET +
                    (blockTimeUTC0 % Constants.WEEK) /
                    Constants.DAY;
            // Ensures that the maturity specified falls on the actual day, otherwise division
            // will truncate it
            return (Constants.WEEK_BIT_OFFSET + offset / 6, (offset % 6) == 0);
        }

        if (daysOffset <= Constants.MAX_MONTH_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_WEEK_OFFSET +
                    (blockTimeUTC0 % Constants.MONTH) /
                    Constants.DAY;

            return (Constants.MONTH_BIT_OFFSET + offset / 30, (offset % 30) == 0);
        }

        if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_MONTH_OFFSET +
                    (blockTimeUTC0 % Constants.QUARTER) /
                    Constants.DAY;

            return (Constants.QUARTER_BIT_OFFSET + offset / 90, (offset % 90) == 0);
        }

        // This is the maximum 1-indexed bit num
        return (256, false);
    }
 |     function isValidMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        uint256 tRef = DateTime.getReferenceTime(blockTime);
        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));
        if (maturity > maxMaturity) return false;

        // prettier-ignore
        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);
        return isValid;
    }
",./notional_finance_v2/certora/asset/DateTime.spec,notional_finance_v2,,Yes,,"Functionality: Determine the bit position representing the maturity of a financial product given the current block time and maturity target, ensuring the maturity date is aligned with predefined intervals (days, weeks, months, quarters). Additionally, validate the maturity against a maximum market index based on a reference time."
5acbb5ad7fd15cd0514842f529f7edb4,1397 | 1398,rule,noChangeToOther,32,57,setAccountContext | getNextSettleTime,"rule noChangeToOther(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    address accountOther;
    require accountOther != account;
    require account != 0 && accountOther != 0;
    uint40 nextSettleTimeOther = getNextSettleTime(accountOther);
    uint8 hasDebtOther = getHasDebt(accountOther);
    uint8 assetArrayLengthOther = getAssetArrayLength(accountOther);
    uint16 bitmapCurrencyIdOther = getBitmapCurrency(accountOther);
    uint144 activeCurrenciesOther = getActiveCurrencies(accountOther);
        
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    
    assert getNextSettleTime(accountOther) == nextSettleTimeOther, ""next settle time does not match"";
    assert getHasDebt(accountOther) == hasDebtOther, ""has debt does not match"";
    assert getAssetArrayLength(accountOther) == assetArrayLengthOther, ""asset array length does not match"";
    assert getBitmapCurrency(accountOther) == bitmapCurrencyIdOther, ""bitmap currency id does not match"";
    assert getActiveCurrencies(accountOther) == activeCurrenciesOther, ""active currencies does not match"";
}
","setAccountContext (Lines 35-49),  | getNextSettleTime (Lines 393-396), ","    function setAccountContext(AccountContext memory accountContext, address account) internal {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data =
            (bytes32(uint256(accountContext.nextSettleTime)) |
                (bytes32(accountContext.hasDebt) >> 208) |
                (bytes32(uint256(accountContext.assetArrayLength)) << 48) |
                (bytes32(uint256(accountContext.bitmapCurrencyId)) << 56) |
                (bytes32(accountContext.activeCurrencies) >> 40));

        assembly {
            sstore(slot, data)
        }

        emit AccountContextUpdate(account);
    }
 |     function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {
        if (nToken.lastInitializedTime == 0) return 0;
        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;
    }
",./notional_finance_v2/certora/accountContext/SetAccountContext.spec,notional_finance_v2,,Yes,,"Functionality: The code updates an account's context in storage with a composite of various data elements (like next settle time, debt status, and currency IDs) packed into a single bytes32 slot, and emits an event signaling the update. It also calculates the next settlement time for an nToken based on its last initialized time and a constant quarter period."
ae6964f2084610ed6f2a9f00082c39a5,1391 | 1392,rule,getAndSetAccountContext,9,24,setAccountContext | getNextSettleTime,"rule getAndSetAccountContext(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    assert getNextSettleTime(account) == nextSettleTime, ""next settle time does not match"";
    assert getHasDebt(account) == hasDebt, ""has debt does not match"";
    assert getAssetArrayLength(account) == assetArrayLength, ""asset array length does not match"";
    assert getBitmapCurrency(account) == bitmapCurrencyId, ""bitmap currency id does not match"";
    assert getActiveCurrencies(account) == activeCurrencies, ""active currencies does not match"";
}
","setAccountContext (Lines 35-49),  | getNextSettleTime (Lines 393-396), ","    function setAccountContext(AccountContext memory accountContext, address account) internal {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data =
            (bytes32(uint256(accountContext.nextSettleTime)) |
                (bytes32(accountContext.hasDebt) >> 208) |
                (bytes32(uint256(accountContext.assetArrayLength)) << 48) |
                (bytes32(uint256(accountContext.bitmapCurrencyId)) << 56) |
                (bytes32(accountContext.activeCurrencies) >> 40));

        assembly {
            sstore(slot, data)
        }

        emit AccountContextUpdate(account);
    }
 |     function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {
        if (nToken.lastInitializedTime == 0) return 0;
        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;
    }
",./notional_finance_v2/certora/accountContext/SetAccountContext.spec,notional_finance_v2,,Yes,,"Functionality: Store an account's context data in Ethereum's storage using a specific slot derived from the account's address and a constant offset, and emit an event post-storage. Calculate the next settlement time for an `nToken` based on its last initialized time and a predefined constant quarter period."
0c6606566087fa6636e8ad8630a1b72e,1403 | 1404,rule,depositsMustIncreaseCashBalance,3,10,deposit | getCashBalance,"rule depositsMustIncreaseCashBalance(address account, uint256 depositAmount) {
    env e;
    int256 cashBalance = getCashBalance(account);
    deposit(e, account, depositAmount);
    // check balanceOf ERC20 on account and contract

    assert cashBalance + depositAmount == getCashBalance(account);
}
","deposit (Lines 34-37),  | getCashBalance (Lines 80-84), ","    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
 |     function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
",./notional_finance_v2/certora/accountContext/Balances.spec,notional_finance_v2,,Yes,,"Functionality: The code introduces two functions: `deposit`, which allows users to deposit ether into the contract and updates their balance accordingly while emitting a Deposit event, and `getCashBalance`, which retrieves and returns the cash balance of a specified account for a given currency."
f04c2fd6ddfa492cbed994f3f78a3c9f,1405,rule,withdrawsMustDecreaseCashBalance,12,16,getCashBalance,"rule withdrawsMustDecreaseCashBalance {
    env e;
    int256 cashBalance = getCashBalance(account);

}
","getCashBalance (Lines 80-84), ","    function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
",./notional_finance_v2/certora/accountContext/Balances.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve the cash balance for a specified account and currency ID. This operation involves calling `getBalanceStorage` from `BalanceHandler`, extracting the cash balance from the returned tuple, while ignoring the other returned values, and finally returning the cash balance."
f04c2fd6ddfa492cbed994f3f78a3c9f,1405,rule,withdrawsMustDecreaseCashBalance,12,16,getCashBalance,"rule withdrawsMustDecreaseCashBalance {
    env e;
    int256 cashBalance = getCashBalance(account);

}
","getCashBalance (Lines 80-84), ","    function getCashBalance(address account, uint256 currencyId) public returns (int256) {
        // prettier-ignore
        (int256 cashBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(account, currencyId);
        return cashBalance;
    }
",./notional_finance_v2/certora/accountContext/Balances.spec,notional_finance_v2,,Yes,,"Functionality: Retrieve the cash balance of a specific currency for a given account. The method calls `getBalanceStorage` from the `BalanceHandler`, passing the account address and currency ID, and returns only the cash balance portion from the resulting tuple."
0a5c17524fb37ed7f28eb74527c49da0,1224,rule,totalAssetsPreserved,215,225,seizeBond,"rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Deduct a specified amount from a locked bond based on a reference ID and an operator, and transfer the amount to a designated address. The function validates that the requested amount is non-zero and does not exceed the locked bond before executing the transfer."
1ac5088528f51eafddbd91fc9a7eb290,1215 | 1216 | 1217 | 1218 | 1221,rule,assetsLessThanEverDepositedAsRule,183,200,createBond | reassignBond | freeBond | seizeBond | bondAmount,"rule assetsLessThanEverDepositedAsRule(address operator, method f, mathint t, address holder, uint256 referenceID ) {
    env e;
    calldataarg args;
    require t == totalLockedBonds(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require totalLockedBonds(operator) >= bondAmount(operator, e.msg.sender, referenceID);
    require safeAdd(unbondedValue(operator), totalLockedBonds(operator));
    require everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
    require f.selector==init_state().selector => totalLockedBonds(operator)==0;
    uint256 before = bondAmount(operator, e.msg.sender, referenceID);
    f(e, args);
    require (f.selector==freeBond(address,uint256).selector                             ||
             f.selector==seizeBond(address,uint256,uint256,address).selector            ||
             f.selector==createBond(address,address,uint256,uint256,address).selector   ||
             f.selector==reassignBond(address, uint256, address, uint256).selector )    =>
             before != bondAmount(operator, e.msg.sender, referenceID);
    assert safeAdd(unbondedValue(operator), totalLockedBonds(operator)) &&
            everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
   }
","createBond (Lines 136-169),  | reassignBond (Lines 192-214),  | freeBond (Lines 222-232),  | seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function reassignBond(
        address operator,
        uint256 referenceID,
        address newHolder,
        uint256 newReferenceID
    ) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(lockedBonds[bondID] > 0, ""Bond not found"");

        bytes32 newBondID = getBondID(operator, newHolder, newReferenceID);

        require(
            lockedBonds[newBondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        lockedBonds[newBondID] = lockedBonds[bondID];
        lockedBonds[bondID] = 0;

        emit BondReassigned(operator, referenceID, newHolder, newReferenceID);
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Manage cryptographic bonds between operators and holders within a smart contract, supporting creation, reassignment, release, and seizure of bonds with specified amounts and reference IDs, while enforcing unique identifiers and sufficient unbonded values for operations."
1f09eb7d3bf45832714bdef157379f22,1257,rule,inverseOfDepositAndWithdraw,419,438,deposit,"rule inverseOfDepositAndWithdraw(address operator, address owner, address beneficiary, uint256 x) {
    require (ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary);
    require (beneficiary != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 u = unbondedValue(operator);
    uint256 b = balanceOf(currentContract);
    // successful deposit
    env eDeposit;
    require eDeposit.msg.value == x;
    require (eDeposit.msg.sender != currentContract);
    deposit(eDeposit, operator);
    env eWithdraw;
    require eWithdraw.msg.sender == operator || eWithdraw.msg.sender == owner;
    require eWithdraw.msg.value == 0;
    require _hasDelegationLockPassed(eWithdraw, operator);
    require safeAdd(balanceOf(beneficiary), x);
    invoke withdraw(eWithdraw, x, operator);
    bool success = !lastReverted;
    // verify that succeeded and the the value is as expected
    assert success &&  u  == unbondedValue(operator) && b == balanceOf(currentContract);
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Ensure an operator's designated beneficiary address is not zero before accepting a deposit in wei. It securely updates the operator's unbonded value with the deposited amount and emits an event detailing the deposit transaction, including the operator, beneficiary, and amount deposited."
4ae922ad792edd020b114056640e7d5a,1229,rule,totalAssetsPreservedOnWithdraw,236,244,seizeBond,"rule totalAssetsPreservedOnWithdraw(address operator, address owner, address beneficiary, uint256 amount) {
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
     env e;
     require beneficiaryOf(operator) == beneficiary;
     require beneficiary != currentContract;
     mathint totalAssets = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary);
     withdraw(e, amount, operator);
     assert totalAssets == totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary),
     ""withdraw can change the total assets of an operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: This function enables a user to seize a specified amount from a locked bond, given a unique reference ID, and transfer it to a designated address. It validates the requested amount against the bond's balance, performs the transfer, and emits an event documenting the seizure."
4c4f5c4d93c32aa5dbcae1eccc5aac54,1282,rule,validChangeToEverDeposited,550,560,deposit,"rule validChangeToEverDeposited(address o,  method f) {
    env e;
    calldataarg args;
    uint256 before = everDeposited(o);
    f(e, args);
    uint256 after = everDeposited(o);
    assert after == before ||
           ( ( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
               f.selector==delegate(address, address, address).selector ) &&
               after == before + e.msg.value );
}
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: The code allows an operator to deposit Ethereum into a smart contract provided they have a defined beneficiary, preventing deposits to a zero-address beneficiary. It updates the operator's unbonded value with the deposited amount and emits an event detailing the transaction."
4c9bcbb4e03d18334497bdd05364825a,1234,rule,totalAssetsPreservedOnSeizeBond,254,263,seizeBond,"rule totalAssetsPreservedOnSeizeBond(address operator, address owner, uint256 referenceID,
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
            uint256 amount, address destination) {
    require destination == otherBeneficiary;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    seizeBond(e, operator, referenceID, amount, destination);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    assert  totalAssetsBefore == totalAssetsAfter,
        ""seizeBond can change the total assets of operator in an unexpected way"";
","seizeBond (Lines 242-264), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Validate a request to seize a specified amount from a locked bond using a unique bondID, ensuring the amount is non-zero and does not exceed the bond's current value. Successfully transfer the specified amount to a requested destination, and log the transaction."
51b1f1455f13f4b8140c12cbb9b998b6,1195 | 1199,invariant,validOperator,104,150,seizeBond | bondAmount,"invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )

/**
    @title Valid state of an operator .
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();
    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
            ( ownerOf(o)  0  beneficiaryOf(o)  0  authorizerOf(o)  0 )
rule validState(address operator, uint unbonded, uint totalLocked) {
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Seize a specified amount of bond from a bondholder and transfer it to a destination address, ensuring the requested amount is non-zero, does not exceed the locked bond amount, and successfully completing the transfer, while emitting a BondSeized event. Additionally, provide the amount of a specific bond by referencing its unique ID."
8aefd3ab5b0425073c54cf52ac916733,1251 | 1254,rule,noFrontRunningOnWithdraw,360,402,seizeBond | bondAmount,"rule noFrontRunningOnWithdraw(address operator, address owner, address beneficiary, address otherOperator, uint256 x,
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
        method f) {
    env eF;
    calldataarg args;
    uint256 referenceID;
    require otherOperator != operator;
    require safeAdd(unbondedValue(operator), unbondedValue(otherOperator)) &&
            allUnbonded()  >= unbondedValue(operator) + unbondedValue(otherOperator);
    require safeAdd(totalLockedBonds(operator), totalLockedBonds(otherOperator)) &&
            allLockedBond()  >= totalLockedBonds(operator) + totalLockedBonds(otherOperator);
    require safeAdd(allUnbonded(), allLockedBond()) &&
            balanceOf(currentContract) >= allUnbonded() + allLockedBond();
    require totalLockedBonds(otherOperator) >= bondAmount(otherOperator, eF.msg.sender, referenceID);
    uint256 allUserAssets = allUnbonded() + allLockedBond();
    require safeAdd(balanceOf(currentContract), allUserAssets);
    uint256 allAssets = balanceOf(currentContract) + allUserAssets;
    require safeAdd(balanceOf(beneficiary), allAssets);
    storage init_storage = lastStorage;
    env eWithdraw;
    withdraw(eWithdraw, x, operator);
    bool succSceanrio1 = !lastReverted;
    // f should only change other operator and if changed totalLocked than the specific bondID used in the require
    uint256 u = unbondedValue(otherOperator) at init_storage;
    uint256 l = totalLockedBonds(otherOperator);
    uint256 bondBefore = bondAmount(otherOperator, eF.msg.sender, referenceID);
    f(eF, args);
    require u != unbondedValue(otherOperator) || l != totalLockedBonds(otherOperator);
    require f.selector==seizeBond(address,uint256,uint256,address).selector =>
                bondBefore != bondAmount(otherOperator, eF.msg.sender, referenceID);
    invoke withdraw(eWithdraw, x, operator);
    bool succSceanrio2 = !lastReverted;
    assert succSceanrio2;
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Allow a holder to seize a specified amount from a locked bond, transferring it to a destination address. This involves validating the requested amount is positive and available in the bond, updating the bond's stored amount, and ensuring successful transfer, emitting an event upon completion."
ab89eb3e35ead76ae09cb2b2a7b562fb,1263 | 1264,rule,validChangeToBalanceOf,456,472,deposit | seizeBond,"rule validChangeToBalanceOf(address o, method f) {
    env e;
    calldataarg args;
    require (o != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 before = balanceOf(o);
    f(e, args);
    uint256 after = balanceOf(o);
    assert before == after ||
        // depositing case
        ( (f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           after == before - e.msg.value ) ||
        // withdrawing case
           ( ( f.selector==seizeBond(address,uint256,uint256,address).selector ||
                f.selector==withdraw(uint256,address).selector) &&
           after >= before );
","deposit (Lines 81-93),  | seizeBond (Lines 242-264), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Enable operators to deposit funds to a designated beneficiary after confirming the beneficiary's existence to prevent unauthorized withdrawals, and allow authorized entities to seize a specified amount from an operator bond, transferring it to a designated destination, provided the requested amount is available and exceeds zero."
bbd7c3a4681b4e8cd87664c89eac7c8c,1269 | 1270 | 1271,rule,validChangeToTotalBondAmount,487,504,createBond | freeBond | seizeBond,"rule validChangeToTotalBondAmount(address o, method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 lockedBondsBefore = totalLockedBonds(o) ;
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 lockedBondsAfter = totalLockedBonds(o);
    assert lockedBondsBefore == lockedBondsAfter ||
           // case of unlocking
           ( (f.selector==freeBond(address,uint256).selector ||
              f.selector==seizeBond(address,uint256,uint256,address).selector ) &&
              lockedBondsAfter <= lockedBondsBefore )
           ||
           // case of locking
           ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
             lockedBondsAfter >= lockedBondsBefore && lockedBondsAfter <= lockedBondsBefore + unbondedBefore )
           ;
","createBond (Lines 136-169),  | freeBond (Lines 222-232),  | seizeBond (Lines 242-264), ","    function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
 |     function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Enable the creation, freeing, and seizing of bonds tied to operators and holders, adjusting the unbonded value accordingly. It ensures bond uniqueness through a unique ID, verifies sufficient unbonded value, and allows for the transfer of seized bond amounts to a specified destination."
c1ad2ca42005e4b192943b0553607e00,1207 | 1211,rule,additiveWithdraw,115,150,seizeBond | bondAmount,"rule validState(address operator, uint unbonded, uint totalLocked) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )
/**
    @title Valid state of an operator .
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 
            ( ownerOf(o)  0  beneficiaryOf(o)  0  authorizerOf(o)  0 )
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","seizeBond (Lines 242-264),  | bondAmount (Lines 176-183), ","    function seizeBond(
        address operator,
        uint256 referenceID,
        uint256 amount,
        address payable destination
    ) public {
        require(amount > 0, ""Requested amount should be greater than zero"");

        address payable holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] >= amount,
            ""Requested amount is greater than the bond""
        );

        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);

        (bool success, ) = destination.call.value(amount)("""");
        require(success, ""Transfer failed"");

        emit BondSeized(operator, referenceID, destination, amount);
    }
 |     function bondAmount(
        address operator,
        address holder,
        uint256 referenceID
    ) public view returns (uint256) {
        bytes32 bondID = getBondID(operator, holder, referenceID);
        return lockedBonds[bondID];
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Allow a bond holder to seize a specified amount from a bond, identified by a unique bond ID generated from an operator, holder, and referenceID, and transfer it to a designated destination, ensuring the requested amount is available and transfers successfully."
d63e42b2f617966804427550795fac40,1202,invariant,noBankruptcy,161,175,deposit,"invariant noBankruptcy()
    (allUnbonded() + allLockedBond()) <= balanceOf(currentContract) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    preserved deposit(env e, address operator) {
        require e.msg.sender != currentContract;
        require (allUnbonded() + allLockedBond()) <= balanceOf(currentContract);
    }
    preserved topUp(env e, address _) {
    preserved delegate(env e, address _1 ,address _2, address _3) {
","deposit (Lines 81-93), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Ensure an operator has an associated beneficiary before allowing them to deposit Ethereum (wei). Add the deposited amount to the operator's unbonded value and emit an event documenting the deposit, including the operator, beneficiary, and the amount."
f9c62852edca3b3f917987f696bd877a,1276 | 1277 | 1278,rule,validChangeToUnbondedValue,519,538,deposit | createBond | freeBond,"rule validChangeToUnbondedValue(address o, address owner,  method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 unbondedAfter = unbondedValue(o);
    assert  unbondedAfter  == unbondedBefore ||
        //cases for deposit
        (( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           unbondedAfter == unbondedBefore + e.msg.value ) ||
        //cases for withdraw
        ( f.selector==withdraw(uint256,address).selector && (e.msg.sender==o || e.msg.sender == ownerOf(o)) &&
          unbondedAfter <= unbondedBefore) ||
        // cases for holder free
        ( f.selector==freeBond(address,uint256).selector &&  unbondedAfter >= unbondedBefore ) ||
        // case for holder locking
        ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
           unbondedAfter <= unbondedBefore );
","deposit (Lines 81-93),  | createBond (Lines 136-169),  | freeBond (Lines 222-232), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
 |     function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Manage bonding and unbonding operations for operators within a system, including depositing funds, creating and freeing bonds, and ensuring the uniqueness and sufficiency of funds for operations, with safeguards against undefined beneficiaries and duplicate reference IDs."
f9c62852edca3b3f917987f696bd877a,1276 | 1277 | 1278,rule,validChangeToUnbondedValue,519,538,deposit | createBond | freeBond,"rule validChangeToUnbondedValue(address o, address owner,  method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 unbondedAfter = unbondedValue(o);
    assert  unbondedAfter  == unbondedBefore ||
        //cases for deposit
        (( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           unbondedAfter == unbondedBefore + e.msg.value ) ||
        //cases for withdraw
        ( f.selector==withdraw(uint256,address).selector && (e.msg.sender==o || e.msg.sender == ownerOf(o)) &&
          unbondedAfter <= unbondedBefore) ||
        // cases for holder free
        ( f.selector==freeBond(address,uint256).selector &&  unbondedAfter >= unbondedBefore ) ||
        // case for holder locking
        ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
           unbondedAfter <= unbondedBefore );
","deposit (Lines 81-93),  | createBond (Lines 136-169),  | freeBond (Lines 222-232), ","    function deposit(address operator) public payable {
        address beneficiary = beneficiaryOf(operator);
        // Beneficiary has to be set (delegation exist) before an operator can
        // deposit wei. It protects from a situation when an operator wants
        // to withdraw funds which are transfered to beneficiary with zero
        // address.
        require(
            beneficiary != address(0),
            ""Beneficiary not defined for the operator""
        );
        unbondedValue[operator] = unbondedValue[operator].add(msg.value);
        emit UnbondedValueDeposited(operator, beneficiary, msg.value);
    }
 |     function createBond(
        address operator,
        address holder,
        uint256 referenceID,
        uint256 amount,
        address authorizedSortitionPool
    ) public {
        require(
            availableUnbondedValue(
                operator,
                msg.sender,
                authorizedSortitionPool
            ) >= amount,
            ""Insufficient unbonded value""
        );

        bytes32 bondID = getBondID(operator, holder, referenceID);

        require(
            lockedBonds[bondID] == 0,
            ""Reference ID not unique for holder and operator""
        );

        unbondedValue[operator] = unbondedValue[operator].sub(amount);
        lockedBonds[bondID] = lockedBonds[bondID].add(amount);

        emit BondCreated(
            operator,
            holder,
            authorizedSortitionPool,
            referenceID,
            amount
        );
    }
 |     function freeBond(address operator, uint256 referenceID) public {
        address holder = msg.sender;
        bytes32 bondID = getBondID(operator, holder, referenceID);
        require(lockedBonds[bondID] > 0, ""Bond not found"");

        uint256 amount = lockedBonds[bondID];
        lockedBonds[bondID] = 0;
        unbondedValue[operator] = unbondedValue[operator].add(amount);

        emit BondReleased(operator, referenceID);
    }
",./keep_fully/specs/fullyBackedBonding.spec,keep_fully,,Yes,,"Functionality: Manage and track the bond and unbonded value transactions for operators and beneficiaries within a smart contract framework. This involves depositing funds, creating bonds, and freeing bonded value by interacting with mappings and emitting specific events to log these operations."
035afa2d61258cc3cf216c9998a162af,1019 | 1020,rule,disallowedFunctionalities,133,151,updateDiscountDistribution | rebalanceUserDiscountPercent,"use rule disallowedFunctionalities

/**
* @title proves that a user's discount rate can be updated only by calling rebalanceUserDiscountPercent
* This rule fails since updateDiscountDistribution, mint and burn can recalculate and update the user discount rate
**/
// rule onlyRebalanceCanUpdateUserDiscountRate(method f) {
// 	address user;
// 	uint256 discRateBefore = getUserDiscountRate(user);
// 	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	env e;
// 	calldataarg args;
// 	f(e,args);
// 	uint256 discRateAfter = getUserDiscountRate(user);
// 	assert(discRateAfter != discRateBefore => f.selector == rebalanceUserDiscountPercent(address).selector);
// }
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Accrue user-specific debt based on their scaled balance and discount percent, adjusting their discount percentages accordingly. Burn the calculated discount amount, update the user's discount percent based on their new balance, and emit corresponding events for transfers and mints."
14f64ff4da3c2454264de5bbcc9f4319,1029 | 1030,rule,onlyCertainFunctionsCanModifyScaledBalance,225,245,updateDiscountDistribution | rebalanceUserDiscountPercent,"rule onlyCertainFunctionsCanModifyScaledBalance(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = scaledBalanceOf(user);
	uint256 balanceAfterOp = scaledBalanceOf(user);
	assert(balanceAfterOp != balanceBeforeOp => (
		(f.selector == mint(address ,address ,uint256 ,uint256).selector) ||
		(f.selector == burn(address ,uint256 ,uint256).selector) ||
		(f.selector == updateDiscountDistribution(address ,address ,uint256 ,uint256 ,uint256).selector) ||
		(f.selector == rebalanceUserDiscountPercent(address).selector)));
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Accrue and adjust debt on user actions like transferring tokens by updating their discount percentage, burning the accrued discounted amount, and emitting relevant events for tracking these changes. It supports rebalancing discount percentages based on users' new token balances and their interaction with the system."
2223fbb44f021600cce9484f9365b865,1016,invariant,discountCantExceed100Percent,121,127,updateDiscountDistribution,"invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the discount distribution between a sender and recipient during a transaction. The function calculates the new balances, applies interest accrual based on their discount rates, updates their discount percentages, and emits events for balance increases due to the accrued interest."
38a24d91060ed776fb7366af573dfb12,1060,rule,integrityOfMint_cantDecreaseInterestWithMint,387,435,rebalanceUserDiscountPercent,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	env e = envAtTimestamp(ts2);
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
}
/**
* @title proves that a user can't decrease the ovelall interest of his position by taking more loans, compared to another user with the same initial position.
* This rule times out.
**/
// rule integrityOfMint_cantDecreaseInterestWithMint() {
// 	address user1;
// 	uint256 ts1;
// 	env e1 = envAtTimestamp(ts1);
// 	uint256 ts2;
// 	require(ts2 >= ts1);
// 	env e2 = envAtTimestamp(ts2);
// 	uint256 ts3;
// 	require(ts3 >= ts2);
// 	env e3 = envAtTimestamp(ts3);
// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));
// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: The code rebalances a user's discount percent by calculating their debt increase and adjusting their balance accordingly. It updates user's state by burning a portion of their debt and refreshing their discount rate based on their new balance, underlying asset index, and their holdings in a discount token, emitting relevant events for tracking."
3fadea93da0abc22743706ea48972a0c,1095 | 1096,rule,integrityOfRebalanceUserDiscountPercent_updateIndex,622,628,updateDiscountDistribution | rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_updateIndex() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	assert(getUserCurrentIndex(user) == index);
","updateDiscountDistribution (Lines 258-314),  | rebalanceUserDiscountPercent (Lines 333-356), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount balances for both sender and recipient during a transfer, burning a portion of their balances based on accrued debt from their actions. It also refreshes their discount rates after adjusting for the transfer amount and emits relevant events for tracking these transactions."
529d6a10e44c73ba00411bbbff1bc774,1045,rule,integrityOfMint_updateDiscountRate,283,322,updateDiscountDistribution,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));

	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
/***************************************************************
* Integrity of Mint
***************************************************************/
* @title proves that after calling mint, the user's discount rate is up to date
rule integrityOfMint_updateDiscountRate() {
	address user1;
	address user2;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	mint(e, user1, user2, amount, index);
	uint256 debtBalance = balanceOf(e, user2);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user2);
	uint256 discountRate = getUserDiscountRate(user2);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,Functionality: Adjust the discount rates and debt for both sender and recipient during a transfer of discount tokens by calculating their new balances and accrued debt based on their current discount percentages and updating their discount percentages accordingly.
5a0d8b2519b5fb0daee8ad4b681d1b8c,1101,rule,integrityOfBalanceOf_fullDiscount,651,660,updateDiscountDistribution,"rule integrityOfBalanceOf_fullDiscount() {
	address user;
	uint256 fullDiscountRate = 10000; //100%
	require(getUserDiscountRate(user) == fullDiscountRate);
	env e1;
	env e2;
	uint256 index1 = indexAtTimestamp(e1.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 index2 = indexAtTimestamp(e2.block.timestamp);
	assert(balanceOf(e1, user) == balanceOf(e2, user));
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution for both the sender and recipient by adjusting their debt based on their current balances and discount percentages, burning the calculated discount, and then refreshing their discount percentages according to the new balances and transactions within a lending protocol."
5dcbaec95503c5fa730a8cd2b4c3cac6,1066,rule,integrityOfBurn_updateDiscountRate,417,457,rebalanceUserDiscountPercent,"// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));

// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
//pass
use rule integrityMint_atoken
/***************************************************************
* Integrity of Burn
***************************************************************/
/**
* @title proves that after calling burn, the user's discount rate is up to date
**/
rule integrityOfBurn_updateDiscountRate() {
	address user;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	burn(e, user, amount, index);
	uint256 debtBalance = balanceOf(e, user);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user);
	uint256 discountRate = getUserDiscountRate(user);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the user's discount percent based on their current balance and debt in the system. It calculates the debt accrued by the user, burns the corresponding discount amount, and then updates the user's discount percent according to their new balance and the pool's index, emitting relevant events for tracking."
6708ab3b723a71d3083b49b993af40e5,1083,rule,integrityOfUpdateDiscountDistribution_discountRate,538,568,updateDiscountDistribution,"// rule integrityOfUpdateDiscountDistribution_discountRate() {
// 	address sender;
//     address recipient;
//     uint256 senderDiscountTokenBalanceBefore;
//     uint256 recipientDiscountTokenBalanceBefore;
//     uint256 amount;
// 	uint256 senderDiscountTokenBalanceAfter = senderDiscountTokenBalanceBefore - amount;
//     uint256 recipientDiscountTokenBalanceAfter = recipientDiscountTokenBalanceBefore + amount;
// 	env e0;
// 	env e;
// 	require(e.block.timestamp > e0.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	require(indexAtTimestamp(e.block.timestamp) >= indexAtTimestamp(e0.block.timestamp));
// 	require(indexAtTimestamp(e0.block.timestamp) == ray()); // reduces execution time
// 	require(getUserCurrentIndex(sender) == indexAtTimestamp(e0.block.timestamp));
// 	require(getUserCurrentIndex(recipient) == indexAtTimestamp(e0.block.timestamp));
// 	require(getBalanceOfDiscountToken(e0, sender) == senderDiscountTokenBalanceBefore);
// 	require(getBalanceOfDiscountToken(e0, recipient) == recipientDiscountTokenBalanceBefore);
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, sender), senderDiscountTokenBalanceBefore) == getUserDiscountRate(sender));
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, recipient), recipientDiscountTokenBalanceBefore) == getUserDiscountRate(recipient));
	
// 	require(getBalanceOfDiscountToken(e, sender) == senderDiscountTokenBalanceAfter);
// 	require(getBalanceOfDiscountToken(e, recipient) == recipientDiscountTokenBalanceAfter);
// 	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalanceBefore, recipientDiscountTokenBalanceBefore, amount);
// 	uint256 senderBalance = balanceOf(e, sender);
// 	uint256 recipientBalance = balanceOf(e, recipient);
// 	assert(discStrategy.calculateDiscountRate(senderBalance, senderDiscountTokenBalanceAfter) == getUserDiscountRate(sender));
// 	assert(discStrategy.calculateDiscountRate(recipientBalance, recipientDiscountTokenBalanceAfter) == getUserDiscountRate(recipient));
// }
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution when tokens are transferred between sender and recipient by accounting for their respective balances and discounts, burning the calculated discount amount, updating their discount percentages based on their new balances, and logging balance increases."
7b01ff5e9521886eaef35dfa5601467f,1071,rule,integrityOfBurn_fixedIndex,475,491,updateDiscountDistribution,"rule integrityOfBurn_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	burn(e, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore - scaledAmount);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution for both the sender and recipient by accruing debt based on their previous balances and discount percentages, burning the calculated discount, and refreshing their discount percentages based on their new true balances and the transaction amount."
83eb795939717fa27ff8e948adf7eac7,1086,rule,integrityOfUpdateDiscountDistribution_updateIndex,573,584,updateDiscountDistribution,"rule integrityOfUpdateDiscountDistribution_updateIndex() {
	address sender;
	address recipient;
	uint256 senderDiscountTokenBalance;
    uint256 recipientDiscountTokenBalance;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	assert(scaledBalanceOf(sender) > 0 => getUserCurrentIndex(sender) == index);
	assert(scaledBalanceOf(recipient) > 0 => getUserCurrentIndex(recipient) == index);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,Functionality: Update the discount distribution between two parties involved in a transaction. Calculate and adjust their respective debt based on previous balances and discount percentages. Update their discount percentages after taking into account the token transfer amount and burning the calculated discounted amount.
91c83a3e5ccf5302dee5148a9545aa5c,1104,rule,integrityOfBalanceOf_noDiscount,665,673,updateDiscountDistribution,"rule integrityOfBalanceOf_noDiscount() {
	address user;
	require(getUserDiscountRate(user) == 0);
	env e;
	uint256 scaledBalance = scaledBalanceOf(user);
	uint256 currentIndex = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 expectedBalance = rayMulCVL(scaledBalance, currentIndex);
	assert(balanceOf(e, user) == expectedBalance);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the discount percent and rebalance the distribution of discount tokens upon a transfer event between two addresses. This involves accruing debt, burning the scaled discount, refreshing the discount percentage for both the sender and recipient, and emitting corresponding events to reflect these changes."
92354492e9c7e4236ef303c872af5b9c,1056,rule,onlyMintForUserCanIncreaseUsersBalance,380,401,updateDiscountDistribution,"rule onlyMintForUserCanIncreaseUsersBalance() {
	address user1;
	address user2;
	address user3;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution for both sender and recipient during a transfer operation. Calculate and burn a scaled amount of sender and recipient's discounts, then refresh their discount percentages based on their new token balances post-transfer and the current debt index."
ba6091245295a0bbb3fcedc47372c0bf,1024,rule,discountCantExceed100Percent,162,183,updateDiscountDistribution,"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the user's discount rate based on their actions (such as transferring tokens), by calculating and updating the accrued debt and discount percentage for both the sender and recipient, while emitting events for balance increases and minting operations related to these updates."
bce393a0667d28567da556b9549bea03,1034 | 1035,rule,userAccumulatedDebtInterestWontDecrease,251,267,updateDiscountDistribution | decreaseBalanceFromInterest,"rule userAccumulatedDebtInterestWontDecrease(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 initAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	env e2 = envAtTimestamp(ts2);
	f(e2,args);
	uint256 finAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	assert(initAccumulatedInterest > finAccumulatedInterest => f.selector == decreaseBalanceFromInterest(address, uint256).selector);
","updateDiscountDistribution (Lines 258-314),  | decreaseBalanceFromInterest (Lines 327-330), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
 |   function decreaseBalanceFromInterest(address user, uint256 amount) external override onlyAToken {
    _ghoUserState[user].accumulatedDebtInterest = (_ghoUserState[user].accumulatedDebtInterest -
      amount).toUint128();
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution between a sender and recipient during a transaction, adjusting their balances and discount percentages based on the current index from the POOL normalized variable debt, and apply changes to their respective discount token and debt balances."
c82b94fca0e206d3036906a5e34248d9,1076,rule,burnZeroDoesntChangeBalance,496,512,updateDiscountDistribution,"use rule burnZeroDoesntChangeBalance

/**
* @title proves a concrete case of repaying the full debt that ends with a zero balance
**/
rule integrityOfBurn_fullRepay_concrete() {
	env e;
	address user;
	uint256 currentDebt = balanceOf(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == ray());
	require(index == 2*ray());
	require(scaledBalanceOf(user) == 4*ray());
	burn(e, user, currentDebt, index);
	uint256 scaled = scaledBalanceOf(user);
	assert(scaled == 0);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the discount distribution for both sender and recipient during a transaction by accruing debt based on their discount percent and scaled account balances, burning a proportionate amount of discount, and refreshing discount percentages post-transaction, factoring in balance changes."
caec741683fc6eed178cbcfe8cef0d97,1097,rule,integrityOfRebalanceUserDiscountPercent_userIsolation,634,642,rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	address targetUser;
	rebalanceUserDiscountPercent(e, targetUser);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => otherUser == targetUser);
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Calculate the new discount percentage for a user based on their previous balance and accrued debt, adjust their balance by burning the discounted amount, and then update their discount percentage by considering the balance after the adjustment and the user's holdings of a discount token."
db3d5547b479755a0c8b7b86956bcd39,1039,rule,userCantNullifyItsDebt,273,302,updateDiscountDistribution,"rule userCantNullifyItsDebt(method f) {
	address user;
	uint256 ts1;
	env e1 = envAtTimestamp(ts1);
	uint256 ts2;
	require(ts2 >= ts1);
	env e2 = envAtTimestamp(ts2);
	uint256 ts3;
	require(ts3 >= ts2);
	env e3 = envAtTimestamp(ts3);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));
	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Accrue and adjust debt for both sender and recipient involved in a transfer, based on their existing balances and a specified amount. It calculates new balances by applying discounts and index-based adjustments, followed by burning part of the discount token to reflect these changes."
de379461c5eb64b0c28840bbbb57e230,1088,rule,integrityOfUpdateDiscountDistribution_userIsolation,591,603,updateDiscountDistribution,"rule integrityOfUpdateDiscountDistribution_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	uint256 amount;
	uint256 senderDiscountTokenBalance;
	uint256 recipientDiscountTokenBalance;
	address sender;
	address recipient;
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => (otherUser == sender || otherUser == recipient));
}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the discount distribution for both a sender and recipient in a transaction by accruing debt based on their current balances and discount percentages, burning the calculated discount, and refreshing their discount percentages according to the new balances post-transaction."
e65710e6231a663d25e54b28026875ec,1092,rule,integrityOfRebalanceUserDiscountPercent_updateDiscountRate,612,617,rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_updateDiscountRate() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	assert(discStrategy.calculateDiscountRate(balanceOf(e, user), getBalanceOfDiscountToken(e, user)) == getUserDiscountRate(user));
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust the discount percent for a user by calculating the increase in debt from their previous balance and applying the current discount percentage. Burn the discounted tokens and update the user's discount rate based on their new balance, the global index, and their token holdings, emitting relevant transaction events."
ec9c93112beed3167d727d63b823b9bb,1050,rule,integrityOfMint_updateScaledBalance_fixedIndex,341,357,updateDiscountDistribution,"rule integrityOfMint_updateScaledBalance_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	mint(e, caller, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore + scaledAmount);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Adjust user balances and discount percentages in response to a transfer involving discount tokens. The method calculates the debt increase for both sender and recipient based on their current balances and discount percentages, then updates their respective discount percentages after burning the proportional amount of discount tokens."
db3d5547b479755a0c8b7b86956bcd39,1039,rule,userCantNullifyItsDebt,273,302,updateDiscountDistribution,"rule userCantNullifyItsDebt(method f) {
	address user;
	uint256 ts1;
	env e1 = envAtTimestamp(ts1);
	uint256 ts2;
	require(ts2 >= ts1);
	env e2 = envAtTimestamp(ts2);
	uint256 ts3;
	require(ts3 >= ts2);
	env e3 = envAtTimestamp(ts3);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));
	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update discount distribution for both sender and recipient by calculating and applying debt accrual based on their previous balances and updated discount token balances, adjusting their discount percentages accordingly, and recording these changes via minting and burning events."
de379461c5eb64b0c28840bbbb57e230,1088,rule,integrityOfUpdateDiscountDistribution_userIsolation,591,603,updateDiscountDistribution,"rule integrityOfUpdateDiscountDistribution_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	uint256 amount;
	uint256 senderDiscountTokenBalance;
	uint256 recipientDiscountTokenBalance;
	address sender;
	address recipient;
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => (otherUser == sender || otherUser == recipient));
}
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution between a sender and a recipient during a token transfer action within a lending pool, calculating their new debt balances based on previous balances and discount percentages, and adjust their discount percentages according to their new token balances."
e65710e6231a663d25e54b28026875ec,1092,rule,integrityOfRebalanceUserDiscountPercent_updateDiscountRate,612,617,rebalanceUserDiscountPercent,"rule integrityOfRebalanceUserDiscountPercent_updateDiscountRate() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	assert(discStrategy.calculateDiscountRate(balanceOf(e, user), getBalanceOfDiscountToken(e, user)) == getUserDiscountRate(user));
}
","rebalanceUserDiscountPercent (Lines 333-356), ","  function rebalanceUserDiscountPercent(address user) external override {
    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);
    uint256 previousScaledBalance = super.balanceOf(user);
    uint256 discountPercent = _ghoUserState[user].discountPercent;

    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(
      user,
      previousScaledBalance,
      discountPercent,
      index
    );

    _burn(user, discountScaled.toUint128());

    _refreshDiscountPercent(
      user,
      super.balanceOf(user).rayMul(index),
      _discountToken.balanceOf(user),
      discountPercent
    );

    emit Transfer(address(0), user, balanceIncrease);
    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Calculate and apply a user's debt rebalance based on their current balance and discount percent by accruing debt, burning a calculated amount of tokens, and updating the user's discount percent accordingly, while emitting events for key actions including transfers and mints."
ec9c93112beed3167d727d63b823b9bb,1050,rule,integrityOfMint_updateScaledBalance_fixedIndex,341,357,updateDiscountDistribution,"rule integrityOfMint_updateScaledBalance_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	mint(e, caller, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore + scaledAmount);
","updateDiscountDistribution (Lines 258-314), ","  function updateDiscountDistribution(
    address sender,
    address recipient,
    uint256 senderDiscountTokenBalance,
    uint256 recipientDiscountTokenBalance,
    uint256 amount
  ) external override onlyDiscountToken {
    uint256 senderPreviousScaledBalance = super.balanceOf(sender);
    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);

    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);

    uint256 balanceIncrease;
    uint256 discountScaled;

    if (senderPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        sender,
        senderPreviousScaledBalance,
        _ghoUserState[sender].discountPercent,
        index
      );

      _burn(sender, discountScaled.toUint128());

      _refreshDiscountPercent(
        sender,
        super.balanceOf(sender).rayMul(index),
        senderDiscountTokenBalance - amount,
        _ghoUserState[sender].discountPercent
      );

      emit Transfer(address(0), sender, balanceIncrease);
      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);
    }

    if (recipientPreviousScaledBalance > 0) {
      (balanceIncrease, discountScaled) = _accrueDebtOnAction(
        recipient,
        recipientPreviousScaledBalance,
        _ghoUserState[recipient].discountPercent,
        index
      );

      _burn(recipient, discountScaled.toUint128());

      _refreshDiscountPercent(
        recipient,
        super.balanceOf(recipient).rayMul(index),
        recipientDiscountTokenBalance + amount,
        _ghoUserState[recipient].discountPercent
      );

      emit Transfer(address(0), recipient, balanceIncrease);
      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);
    }
  }
",./gho-core/ghoVariableDebtToken.spec,gho-core,,Yes,,"Functionality: Update the discount distribution for both sender and recipient during a transfer event by accruing debt based on their respective balances and discount percentages, burning the accrued discount, and then refreshing their discount rates according to their new balances post-transfer."
189f573e83cb2b48e5cb2ae125c48e1e,988,rule,getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity,323,331,setFacilitatorBucketCapacity,"rule getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	assert getFacilitatorBucketCapacity(facilitator) == newCapacity;
}
","setFacilitatorBucketCapacity (Lines 111-121), ","  function setFacilitatorBucketCapacity(
    address facilitator,
    uint128 newCapacity
  ) external onlyRole(BUCKET_MANAGER) {
    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');

    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;
    _facilitators[facilitator].bucketCapacity = newCapacity;

    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);
  }
",./gho-core/ghoToken.spec,gho-core,,Yes,,"Functionality: Update the bucket capacity for a specified facilitator, provided the caller has the BUCKET_MANAGER role. It checks if the facilitator exists, changes their bucket capacity to a new value, and emits an event to record the update of the facilitator's bucket capacity."
2af8a8239d9757533c0b3fd8205166b5,1011,rule,address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address,523,531,removeFacilitator,"rule address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address(address facilitator){
rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
	require facilitator == 0;
	
","removeFacilitator (Lines 94-108), ","  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {
    require(
      bytes(_facilitators[facilitatorAddress].label).length > 0,
      'FACILITATOR_DOES_NOT_EXIST'
    );
    require(
      _facilitators[facilitatorAddress].bucketLevel == 0,
      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'
    );

    delete _facilitators[facilitatorAddress];
    _facilitatorsList.remove(facilitatorAddress);

    emit FacilitatorRemoved(facilitatorAddress);
  }
",./gho-core/ghoToken.spec,gho-core,,Yes,,"Functionality: Remove a facilitator from a system if they exist and their bucket level is zero, ensuring these conditions by checking the facilitator's label and bucket level. It deletes the facilitator's information and updates a facilitators list, then emits an event signaling the removal."
38790d06057378f6c391e5c3046dd295,985,rule,facilitator_in_list_after_setFacilitatorBucketCapacity,305,318,setFacilitatorBucketCapacity,"rule facilitator_in_list_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant addr_in_set_list_iff_in_map(facilitator);
invariant addr_in_set_list_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)
		requireInvariant addressSetInvariant();
		requireInvariant length_leq_max_uint160();
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
","setFacilitatorBucketCapacity (Lines 111-121), ","  function setFacilitatorBucketCapacity(
    address facilitator,
    uint128 newCapacity
  ) external onlyRole(BUCKET_MANAGER) {
    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');

    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;
    _facilitators[facilitator].bucketCapacity = newCapacity;

    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);
  }
",./gho-core/ghoToken.spec,gho-core,,Yes,,"Functionality: Update the bucket capacity for a specific facilitator, provided the function caller has the BUCKET_MANAGER role. It checks if the facilitator exists, updates their bucket capacity from the old to the new specified value, and triggers an event to log this update."
7862bd01a93f7c3d41d1c533f704923b,996,rule,address_not_in_list_after_removeFacilitator,372,379,removeFacilitator,"rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
","removeFacilitator (Lines 94-108), ","  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {
    require(
      bytes(_facilitators[facilitatorAddress].label).length > 0,
      'FACILITATOR_DOES_NOT_EXIST'
    );
    require(
      _facilitators[facilitatorAddress].bucketLevel == 0,
      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'
    );

    delete _facilitators[facilitatorAddress];
    _facilitatorsList.remove(facilitatorAddress);

    emit FacilitatorRemoved(facilitatorAddress);
  }
",./gho-core/ghoToken.spec,gho-core,,Yes,,"Functionality: Remove a facilitator from the system, given their address, if they exist and their bucket level is zero. The function checks for the facilitator's existence and their bucket level before removal, and then emits an event indicating the facilitator's removal."
88fa92046303ae3fec39f47242f20fee,989,rule,facilitator_in_list_after_addFacilitator,336,349,addFacilitator,"rule facilitator_in_list_after_addFacilitator(){

	env e;
	address facilitator;
	string label;
	uint128 capacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	
	addFacilitator(e,facilitator, label, capacity);
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
","addFacilitator (Lines 72-91), ","  function addFacilitator(
    address facilitatorAddress,
    string calldata facilitatorLabel,
    uint128 bucketCapacity
  ) external onlyRole(FACILITATOR_MANAGER) {
    Facilitator storage facilitator = _facilitators[facilitatorAddress];
    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');
    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');

    facilitator.label = facilitatorLabel;
    facilitator.bucketCapacity = bucketCapacity;

    _facilitatorsList.add(facilitatorAddress);

    emit FacilitatorAdded(
      facilitatorAddress,
      keccak256(abi.encodePacked(facilitatorLabel)),
      bucketCapacity
    );
  }
",./gho-core/ghoToken.spec,gho-core,,Yes,,"Functionality: Add a new facilitator with a specified address, label, and bucket capacity to a system, but only if the facilitator does not already exist and the label is valid. It emits an event with the facilitator's details upon successful addition."
046f05ee6551a1620728f9a265146e22,1117,rule,handleRepayment_after_transferUnderlyingTo,109,126,transferUnderlyingTo,"// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;

// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
","transferUnderlyingTo (Lines 156-158), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
",./gho-core/ghoAToken.spec,gho-core,,Yes,,"Functionality: Mint a specified amount of the underlying asset's GhoToken and transfer it to a targeted address. This action is exclusively callable by the pool, ensuring controlled and secure distribution of the tokens according to predefined rules or agreements within the system's architecture."
95cec3fe0428a84924062860aa08dbad,1118 | 1119,rule,level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment,133,148,transferUnderlyingTo | handleRepayment,"rule level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment()
{
	env e;
	calldataarg arg;
	uint256 amount;
	address target;
	address user;
    address onBehalfOf;

	uint256 levelBefore = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	transferUnderlyingTo(e, target, amount);
	handleRepayment(e, user, onBehalfOf, amount);
	uint256 levelAfter = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	assert levelBefore <= levelAfter;
}
","transferUnderlyingTo (Lines 156-158),  | handleRepayment (Lines 161-173), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
 |   function handleRepayment(
    address user,
    address onBehalfOf,
    uint256 amount
  ) external virtual override onlyPool {
    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);
    if (amount <= balanceFromInterest) {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);
    } else {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);
      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);
    }
  }
",./gho-core/ghoAToken.spec,gho-core,,Yes,,"Functionality: Enable the transfer of an underlying asset to a specific target by minting a designated amount to them. Manage the repayment process by reducing the debtor's interest balance when applicable, and burn the excess of the repayment over the interest balance, maintaining the debt and token supply integrity."
d1bfdd55444619c97b902ddfd3a1881e,1109 | 1110,invariant,userBalanceAlwaysZero,97,126,transferUnderlyingTo | handleRepayment,"invariant userBalanceAlwaysZero(address user)
	scaledBalanceOf(user) == 0

// /**
// * @title first handleRepayment(amount) after transferUnderlyingTo(amount) succeeds.
// * @dev assumption of sufficient balanceOf(msg.sender) is justified because BorrowLogic.executeRepay()
// * @dev executes: IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);
// * @dev before invocation of handleRepayment()
// * OBSOLETE - GhoToken has other rules to validate the behavior of the facilitator level maintenance
// */
// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;
// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
","transferUnderlyingTo (Lines 156-158),  | handleRepayment (Lines 161-173), ","  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IGhoToken(_underlyingAsset).mint(target, amount);
  }
 |   function handleRepayment(
    address user,
    address onBehalfOf,
    uint256 amount
  ) external virtual override onlyPool {
    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);
    if (amount <= balanceFromInterest) {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);
    } else {
      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);
      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);
    }
  }
",./gho-core/ghoAToken.spec,gho-core,,Yes,,"Functionality: Mint tokens to a specified target upon transfer, and manage repayments by decreasing the debt balance derived from interest. If repayment exceeds interest balance, adjust the interest debt accordingly and burn the excess tokens to account for the full repayment amount."
18b1fd04e5c050a349d5730e139ac42b,1129 | 1130,rule,feeSimulationEqualsActualFee,134,155,flashLoan | flashFee,"rule feeSimulationEqualsActualFee(address receiver, address token, uint256 amount, bytes data){
    env e;
    uint256 feeSimulationResult = flashFee(e, token, amount);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    
    flashLoanReqs(e);
    require atoken.getGhoTreasury() != currentContract;
    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, e.msg.sender, atoken);
    // Excluding call to distributeFeesToTreasury & calling another flashloan (which will generate another fee in recursion)
    require flashBorrower.action() != 1 && flashBorrower.action() != 0;
    // Because we calculate the actual fee by balance difference of the minter, we assume no extra money is being sent to the minter.
    require flashBorrower._transferTo() != currentContract;
    flashLoan(e, receiver, token, amount, data);

    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 actualFee = facilitatorBalance_ - _facilitatorBalance;
    assert feeSimulationResult == actualFee;
}
","flashLoan (Lines 68-90),  | flashFee (Lines 127-130), ","  function flashLoan(
    IERC3156FlashBorrower receiver,
    address token,
    uint256 amount,
    bytes calldata data
  ) external override returns (bool) {
    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');

    uint256 fee = ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);
    GHO_TOKEN.mint(address(receiver), amount);

    require(
      receiver.onFlashLoan(msg.sender, address(GHO_TOKEN), amount, fee, data) == CALLBACK_SUCCESS,
      'FlashMinter: Callback failed'
    );

    GHO_TOKEN.transferFrom(address(receiver), address(this), amount + fee);
    GHO_TOKEN.burn(amount);

    emit FlashMint(address(receiver), msg.sender, address(GHO_TOKEN), amount, fee);

    return true;
  }
 |   function flashFee(address token, uint256 amount) external view override returns (uint256) {
    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');
    return ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Enable a smart contract to borrow a specified amount of GHO tokens instantly with an optional fee unless the borrower is whitelisted. The borrower must repay the loan and fee within a single transaction, with failure to do so resulting in a transaction revert."
35173fbb4cd976f409e46c8e2e7a2093,1123,rule,integrityOfFeeSet,88,93,updateFee,"rule integrityOfFeeSet(uint256 new_fee){
    env e;
    updateFee(e, new_fee);
    uint256 fee_ = getFee(e);
    assert fee_ == new_fee;
}
","updateFee (Lines 100-105), ","  function updateFee(uint256 newFee) external override onlyPoolAdmin {
    require(newFee <= MAX_FEE, 'FlashMinter: Fee out of range');
    uint256 oldFee = _fee;
    _fee = newFee;
    emit FeeUpdated(oldFee, newFee);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Update the transaction fee to a new value, provided it does not exceed the defined maximum fee. This operation is only permitted for the pool administrator. Upon successful update, emit an event that logs the old and the new fee values."
9a3b325bd619dabdb4100dd82cd74ae2,1126,rule,integrityOfDistributeFeesToTreasury,114,129,distributeFeesToTreasury,"rule integrityOfDistributeFeesToTreasury(){
    env e;
    address treasury = getGhoTreasury(e);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    uint256 _treasuryBalance = gho.balanceOf(treasury);

    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, treasury, atoken);
    distributeFeesToTreasury(e);
    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 treasuryBalance_ = gho.balanceOf(treasury);
    assert treasury != currentContract => facilitatorBalance_ == 0;
    assert treasuryBalance_ - _treasuryBalance == _facilitatorBalance - facilitatorBalance_;
}
","distributeFeesToTreasury (Lines 176-180), ","  function distributeFeesToTreasury() external virtual override {
    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));
    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);
    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Transfer the entire balance of a specified underlying asset held by the contract to a designated treasury address. It then emits an event to log the details of the transfer, including the treasury address, the underlying asset, and the amount transferred."
eb7aa38b080a799792eb6feea03228f0,1120,rule,balanceOfFlashMinterGrows,57,58,distributeFeesToTreasury,"rule balanceOfFlashMinterGrows(method f, env e, calldataarg args) 
    filtered { f -> f.selector != distributeFeesToTreasury().selector }{
","distributeFeesToTreasury (Lines 176-180), ","  function distributeFeesToTreasury() external virtual override {
    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));
    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);
    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Transfer the entire balance of a specified ERC20 token held by the contract to a designated treasury address. Record this transfer event by emitting a `FeesDistributedToTreasury` event, documenting the treasury address, the token's address, and the amount transferred."
eec9e5a12b4a425d9d9d9eeac08ab0e7,1121,rule,integrityOfTreasurySet,78,83,updateGhoTreasury,"rule integrityOfTreasurySet(address token){
    env e;
    updateGhoTreasury(e, token);
    address treasury_ = getGhoTreasury(e);
    assert treasury_ == token;
}
","updateGhoTreasury (Lines 246-251), ","  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {
    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');
    address oldGhoTreasury = _ghoTreasury;
    _ghoTreasury = newGhoTreasury;
    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Change the GhoTreasury address to a new one, ensuring it's not the zero address. Maintain a record of the old address for auditing purposes. Only the Pool Admin can invoke this change, and an event is emitted to log the update of the treasury address."
faa2bba81f6a8aca859e0b6005f3ca27,1125,rule,availableLiquidityDoesntChange,98,107,maxFlashLoan,"rule availableLiquidityDoesntChange(method f, address token){
    env e; calldataarg args;
    uint256 _liquidity = maxFlashLoan(e, token);

    f(e, args);
    uint256 liquidity_ = maxFlashLoan(e, token);
    assert liquidity_ == _liquidity;
}
","maxFlashLoan (Lines 115-124), ","  function maxFlashLoan(address token) external view override returns (uint256) {
    if (token != address(GHO_TOKEN)) {
      return 0;
    } else {
      IGhoToken.Facilitator memory flashMinterFacilitator = GHO_TOKEN.getFacilitator(address(this));
      uint256 capacity = flashMinterFacilitator.bucketCapacity;
      uint256 level = flashMinterFacilitator.bucketLevel;
      return capacity > level ? capacity - level : 0;
    }
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Determine the maximum flash loan amount available for a specific token. If the token is not GHO, return zero. For GHO, calculate the available amount by subtracting the bucket level from its capacity, provided the capacity exceeds the level."
eb7aa38b080a799792eb6feea03228f0,1120,rule,balanceOfFlashMinterGrows,57,58,distributeFeesToTreasury,"rule balanceOfFlashMinterGrows(method f, env e, calldataarg args) 
    filtered { f -> f.selector != distributeFeesToTreasury().selector }{
","distributeFeesToTreasury (Lines 176-180), ","  function distributeFeesToTreasury() external virtual override {
    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));
    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);
    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Transfer the entire balance of a specific ERC20 token, denoted by `_underlyingAsset`, held by the contract to a designated treasury address (`_ghoTreasury`). Then, emit an event (`FeesDistributedToTreasury`) signaling the completion of this transfer, including the treasury address, the asset, and the amount transferred."
eec9e5a12b4a425d9d9d9eeac08ab0e7,1121,rule,integrityOfTreasurySet,78,83,updateGhoTreasury,"rule integrityOfTreasurySet(address token){
    env e;
    updateGhoTreasury(e, token);
    address treasury_ = getGhoTreasury(e);
    assert treasury_ == token;
}
","updateGhoTreasury (Lines 246-251), ","  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {
    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');
    address oldGhoTreasury = _ghoTreasury;
    _ghoTreasury = newGhoTreasury;
    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,Functionality: Update the GhoTreasury address if the incoming address is not the zero address. Verify the operation is initiated by the pool administrator. Store the old treasury address for record before updating it with the new one. Emit an event documenting the update from the old to new treasury address.
faa2bba81f6a8aca859e0b6005f3ca27,1125,rule,availableLiquidityDoesntChange,98,107,maxFlashLoan,"rule availableLiquidityDoesntChange(method f, address token){
    env e; calldataarg args;
    uint256 _liquidity = maxFlashLoan(e, token);

    f(e, args);
    uint256 liquidity_ = maxFlashLoan(e, token);
    assert liquidity_ == _liquidity;
}
","maxFlashLoan (Lines 115-124), ","  function maxFlashLoan(address token) external view override returns (uint256) {
    if (token != address(GHO_TOKEN)) {
      return 0;
    } else {
      IGhoToken.Facilitator memory flashMinterFacilitator = GHO_TOKEN.getFacilitator(address(this));
      uint256 capacity = flashMinterFacilitator.bucketCapacity;
      uint256 level = flashMinterFacilitator.bucketLevel;
      return capacity > level ? capacity - level : 0;
    }
  }
",./gho-core/flashMinter.spec,gho-core,,Yes,,"Functionality: Determine the maximum amount available for a flash loan of a specific token. If the token is not GHO_TOKEN, return 0. Otherwise, calculate the difference between the token's flash minter's bucket capacity and its current level, returning this available amount."
032167bdba6fbf63a8097a8c6db64d03,957 | 958,rule,banningIsReversible,88,102,ban | unban,"rule banningIsReversible(address agent, method f) {
    require owner() != 0;
    env e;
    ban(e, agent);

    // call some function for covering more cases
    require f.selector != unban(address).selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    unban@withrevert(e2, agent);
    assert !lastReverted, ""Unbanning should succeed"";
}
","ban (Lines 106-109),  | unban (Lines 114-117), ","    function ban(address agent) external isNotBanned(agent) onlyOwner {
        bannedAgents[agent] = 1;
        emit Banned(agent);
    }
 |     function unban(address agent) external isBanned(agent) onlyOwner {
        bannedAgents[agent] = 0;
        emit Unbanned(agent);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Implement a system to manage agent bans in a smart contract. Allow the contract owner to ban an agent, setting their status in the `bannedAgents` mapping to 1 and emitting a Banned event, or unban an agent by setting their status to 0 and emitting an Unbanned event."
0567294d237aab42e4368f373490459b,954,rule,unregisterHandlerIsPermanent2,72,78,unregister,"rule unregisterHandlerIsPermanent2(method f, address handler) {
rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
    require handlers(handler) == deprecated();
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a specific registration as deprecated if it exists and is not already marked as such, ensuring that the registration address is not the zero address and has been previously registered. Only the contract owner is allowed to perform this action."
33c932d0e1757f2a8595ccd730e08402,950,rule,changesCaller,38,44,unregisterCaller,"rule changesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != registerCaller(address,bytes32).selector && f.selector != unregisterCaller(address).selector) 
        => _regState == regState_, ""method unexpectedly changes caller info"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Invalidate a previously registered caller's address, ensuring it's neither a zero address nor already unregistered. This action, only executable by the contract owner, marks the caller's address as deprecated within the contract's state and emits an event indicating the caller's unregistration."
570cc6cdb48dec953ee13ed87d311009,955,rule,unregisterCallerIsPermanent2,80,86,unregisterCaller,"rule unregisterCallerIsPermanent2(method f, address caller) {
rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
    require callers(caller) == deprecated();
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a caller as unregistered if it is not the zero address, is currently registered, and not already marked as unregistered. This is enforced by setting the caller's status to a predefined 'DEPRECATED' value, and emitting a 'CallerUnregistered' event with the caller's address."
5760809d382e614b2e536ca6a6b7b0fe,951,rule,deprecatesCaller,46,52,unregisterCaller,"rule deprecatesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != unregisterCaller(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates caller"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a specified caller's registration as deprecated, provided it's not the zero address, already unregistered, or not registered. This action emits the `CallerUnregistered` event to signal the unregistration, ensuring only the contract owner can execute this change."
63d28478f6a10aa50f0e4991d9d70f48,949,rule,deprecatesHandler,30,36,unregister,"rule deprecatesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != unregister(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates handler"";
}
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a registered address as deprecated, ensuring it's not the zero address, already has a registration, and hasn't been previously unregistered. Validates the operation can only be performed by the contract owner."
e33f9ef3d3b7eb7cd645d9eb7b404f1b,960 | 961,rule,haltingIsReversible,104,119,halt | unhalt,"rule haltingIsReversible(method f) {
    require owner() != 0;
    env e;
    halt(e);

    // call some function for covering more cases
    require f.selector != unhalt().selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    assert e.msg.sender != 0, ""Cannot send transactions from 0 address"";
    unhalt@withrevert(e2);
    assert !lastReverted, ""Unhalting should succeed"";
}
","halt (Lines 139-142),  | unhalt (Lines 144-147), ","    function halt() external isNotHalted onlyOwner {
        fHalt = true;
        emit Halted();
    }
 |     function unhalt() external isHalted onlyOwner {
        fHalt = false;
        emit Unhalted();
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Implement controls to pause or resume specific functionalities within a smart contract. When the `halt` function is called by the contract owner, it sets a flag to true, effectively pausing operations. Conversely, `unhalt` resets this flag to false, resuming operations, with both actions emitting corresponding events."
f9840b401fe68d7a6413b07d8cbad65d,952,rule,unregisterHandlerIsPermanent,54,61,unregister,"rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a given registration address as deprecated in the adapters mapping, provided it is not the zero address, already has a registration, and is not already marked as deprecated. This action can only be performed by the contract owner."
fa776b5c4182a8ae091f55e1af54298c,947 | 948,rule,changesHandler,22,28,register | unregister,"rule changesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != register(address,bytes32).selector && f.selector != unregister(address).selector) 
        => _regState == regState_, ""method unexpectedly changes handler info"";
}
","register (Lines 28-32),  | unregister (Lines 38-43), ","    function register(address registration, bytes32 info) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] == bytes32(0), ""registered"");
        adapters[registration] = info;
    }
 |     function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Register an address with corresponding information if it hasn't been registered before and it's not the zero address. Unregister an already registered address by marking it as deprecated, ensuring it's not the zero address and has been previously registered."
fe8c987fb27105b67dce90aa69e6d968,953,rule,unregisterCallerIsPermanent,63,70,unregisterCaller,"rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Unregister a specified address from being a caller, ensuring it's not a zero address and currently registered but not already marked as deprecated. Then, mark the caller's registration as deprecated and emit an event indicating the caller has been unregistered."
e33f9ef3d3b7eb7cd645d9eb7b404f1b,960 | 961,rule,haltingIsReversible,104,119,halt | unhalt,"rule haltingIsReversible(method f) {
    require owner() != 0;
    env e;
    halt(e);

    // call some function for covering more cases
    require f.selector != unhalt().selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    assert e.msg.sender != 0, ""Cannot send transactions from 0 address"";
    unhalt@withrevert(e2);
    assert !lastReverted, ""Unhalting should succeed"";
}
","halt (Lines 139-142),  | unhalt (Lines 144-147), ","    function halt() external isNotHalted onlyOwner {
        fHalt = true;
        emit Halted();
    }
 |     function unhalt() external isHalted onlyOwner {
        fHalt = false;
        emit Unhalted();
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Implement control mechanisms to halt or unhalt specific operations in a contract. Only the contract owner can trigger these states. When halted, the contract flags itself as halted, emitting a Halted event, and similarly, emits an Unhalted event upon reactivation."
f9840b401fe68d7a6413b07d8cbad65d,952,rule,unregisterHandlerIsPermanent,54,61,unregister,"rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
","unregister (Lines 38-43), ","    function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a registered address as deprecated in a mapping if it is not the zero address, already registered, and not previously marked as deprecated. This is performed by setting its associated value in the `adapters` mapping to a predefined `DEPRECATED` value, ensuring it is only callable by the contract owner."
fa776b5c4182a8ae091f55e1af54298c,947 | 948,rule,changesHandler,22,28,register | unregister,"rule changesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != register(address,bytes32).selector && f.selector != unregister(address).selector) 
        => _regState == regState_, ""method unexpectedly changes handler info"";
}
","register (Lines 28-32),  | unregister (Lines 38-43), ","    function register(address registration, bytes32 info) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] == bytes32(0), ""registered"");
        adapters[registration] = info;
    }
 |     function unregister(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(adapters[registration] != bytes32(0), ""no registration"");
        require(adapters[registration] != DEPRECATED, ""unregistered"");
        adapters[registration] = DEPRECATED;
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Register an address with specific information if it hasn't been registered yet and is not zero. Unregister a previously registered address by marking it as deprecated, ensuring the address is neither zero, unregistered, nor already marked as deprecated."
fe8c987fb27105b67dce90aa69e6d968,953,rule,unregisterCallerIsPermanent,63,70,unregisterCaller,"rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
","unregisterCaller (Lines 94-100), ","    function unregisterCaller(address registration) external onlyOwner {
        require(registration != address(0), ""zero address"");
        require(callers[registration] != bytes32(0), ""no registration"");
        require(callers[registration] != DEPRECATED, ""unregistered"");
        callers[registration] = DEPRECATED;
        emit CallerUnregistered(registration);
    }
",./furucombo/specs/registry.spec,furucombo,,Yes,,"Functionality: Mark a caller as unregistered in a smart contract, ensuring it's not the zero address, already registered, and not previously unregistered. It then sets the caller's status to 'DEPRECATED' and emits a 'CallerUnregistered' event with the caller's address."
02c2786803dc8418e6fad9709e745c2f,931,rule,nonExecutableWithInitializedSender,461,473,registry.isValidCaller,"rule nonExecutableWithInitializedSender(method f) {
    require !isHandler();
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;

    arbitrary(f);
    assert ethBalance(currentContract) == 0;
}
    require !f.isView; // only non-view functions, that may modify the state, are interesting.
    require getSender() != 0; // sender is initialized
    env e;
    bool isGoodCaller = registry.isValidCaller(e, e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    assert (f.isFallback && !isGoodCaller) => lastReverted; // only valid callers should execute in fallback successfully (would violate since certora prover cannot distinguish between receive and fallback for now)
    assert (f.selector == execs(address[],bytes32[],bytes[]).selector && e.msg.sender != currentContract) => lastReverted; // `execs` is allowed to be called by proxy itself after initialized
    assert (!f.isFallback && f.selector != execs(address[],bytes32[],bytes[]).selector) => lastReverted; // all non-view functions other than above ones should revert if sender is already initialized
","isValidCaller (Lines 133-137), ","    function isValidCaller(
        address caller
    ) external view override returns (bool) {
        return callers[caller] != 0 && callers[caller] != DEPRECATED;
    }
",./furucombo/specs/proxy.spec,furucombo,,Yes,,"Functionality: Check if a caller address is valid by verifying that its corresponding value in the 'callers' mapping is neither zero nor marked as 'DEPRECATED'. Return true if the caller is valid, otherwise, return false. This ensures only authorized or non-deprecated callers can proceed."
3c7675cafe2f8abdcb3651dc5a393e8a,943,rule,onlyValidCaller,568,577,registry.isValidCaller,"// the rule is usually expected to fail, because handler functions do not check who calls them (it's usually the sender via the proxy delegatecall).
rule onlyValidCaller(method f) {
    env e;
    bool isGoodCaller = registry.isValidCaller(e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    bool succeeded = !lastReverted;

    assert !isGoodCaller => !succeeded, ""function can be called even if the sender is not an allowed caller"";
}
","isValidCaller (Lines 133-137), ","    function isValidCaller(
        address caller
    ) external view override returns (bool) {
        return callers[caller] != 0 && callers[caller] != DEPRECATED;
    }
",./furucombo/specs/proxy.spec,furucombo,,Yes,,"Functionality: Check whether the provided address (caller) is authorized by verifying if its associated value in the `callers` mapping is neither zero nor marked as deprecated (indicated by the `DEPRECATED` constant), and return a boolean indication of its validity."
466147d681a7443c369915dd2914ed64,915,rule,noOverwrite,370,381,postProcess,"rule noOverwrite(method f, uint slot) {
    require getStackLength() < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthBefore = getStackLength();

    arbitrary(f);
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
}
    uint oldValue = getSlot(slot);
    uint newValue = getSlot(slot);
    
    // slot 0 is stack length, postProcess() may nullify it and it's fine, and execs() can increase it
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;
    assert ethBalance(currentContract) == 0;
    assert oldValue != 0 => (newValue == oldValue 
            || slot == getStackLengthSlot()), ""Slot $slot changd during this execution"";
","postProcess (Lines 334-344), ","    function postProcess() external payable override {
        bytes4 sig = stack.getSig();
        // selector of openLockETHAndDraw(uint256,address,address,bytes32,uint256)
        // and openLockGemAndDraw(address,address,bytes32,uint256,uint256)
        if (sig == 0x5481e4a4 || sig == 0x73af24e7) {
            _transferCdp(uint256(stack.get()));
            uint256 amount = IERC20(DAI_TOKEN).balanceOf(address(this));
            if (amount > 0)
                IERC20(DAI_TOKEN).safeTransfer(_getSender(), amount);
        } else revert(""Invalid post process"");
    }
",./furucombo/specs/proxy.spec,furucombo,,Yes,,"Functionality: Check if the invoked function matches specific signatures related to financial operations. If so, transfer a collateralized debt position (CDP) and, if any DAI tokens are available, safely transfer these tokens to the transaction initiator's address. Otherwise, revert the transaction for invalid operations."
7957cf7a0c367b6d664077d0b8c77797,935,rule,transferredTokensMeanThatStackIsUpdated,476,491,summaryInstance.getEthAddress,"rule transferredTokensMeanThatStackIsUpdated(method f) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someToken.allowance(currentContract, summaryInstance) == 0; // to make sure we're starting clean as implied by approvedTokensAreTemporary
rule approvedTokensAreTemporary(method f, address someAllowed) {
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
    uint256 balanceBefore = someToken.balanceOf(currentContract);
    uint256 stackLengthBefore = getStackLength();
    require stackLengthBefore < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
    uint256 balanceAfter = someToken.balanceOf(currentContract);
    assert (balanceAfter > balanceBefore) => stackLengthAfter > stackLengthBefore, 
        ""must push an entry to postprocess stack if transferring funds into proxy which are not eth"";
","getEthAddress (Lines 30-39), ","    function getEthAddress(address handler) external returns (address) {
        // either the handler defines a ETH_ADDRESS function or it does not. If it does not then just return address(0)
        address eth = address(0);
        try WithEthAddress(handler).ETH_ADDRESS() returns (address x) {
            eth = x;
        } catch {
            eth = address(0);
        }
        return eth;
    }
",./furucombo/specs/proxy.spec,furucombo,,Yes,,"Functionality: Attempt to retrieve an Ethereum (ETH) address from a specified contract (`handler`). If the `handler` contract implements a function `ETH_ADDRESS` that returns an address, return this address. Otherwise, return the zero address (address(0)) to indicate failure or non-existence of such a function."
b6cc5e5592d5468e238c37b8cc5c5f5e,937,rule,approvedTokensAreTemporary,493,504,summaryInstance.getEthAddress,"rule approvedTokensAreTemporary(method f, address someAllowed) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
","getEthAddress (Lines 30-39), ","    function getEthAddress(address handler) external returns (address) {
        // either the handler defines a ETH_ADDRESS function or it does not. If it does not then just return address(0)
        address eth = address(0);
        try WithEthAddress(handler).ETH_ADDRESS() returns (address x) {
            eth = x;
        } catch {
            eth = address(0);
        }
        return eth;
    }
",./furucombo/specs/proxy.spec,furucombo,,Yes,,"Functionality: Attempt to retrieve an Ethereum address by calling the `ETH_ADDRESS` function on a provided handler. If the handler implements this function and it executes successfully, return the resulting Ethereum address. If the handler does not implement this function or its execution fails, return the zero address."
6150bfe8699e56ba558fa0c89564153e,901 | 902,rule,noThrow,6,19,getParams | getNumOfReferences,"rule noThrow(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		bytes32 x;
		require !isStatic(x);
		require getNumOfReferences(x) > 0;
		getParams@withrevert(e, x);
	} else {
		f@withrevert(e, arg);
	}
	assert !lastHasThrown;
}
","getParams (Lines 34-60),  | getNumOfReferences (Lines 14-23), ","    function getParams(
        bytes32 conf
    ) internal pure returns (uint256[] memory refs, uint256[] memory params) {
        require(!isStatic(conf), ""Static params"");
        uint256 n = REFS_LIMIT;
        while (conf & REFS_MASK == REFS_MASK && n > 0) {
            n--;
            conf = conf >> 8;
        }
        require(n > 0, ""No dynamic param"");
        refs = new uint256[](n);
        params = new uint256[](n);
        for (uint256 i = 0; i < n; i++) {
            refs[i] = uint256(conf & REFS_MASK);
            conf = conf >> 8;
        }
        uint256 locCount = 0;
        for (uint256 k = 0; k < PARAMS_SIZE_LIMIT; k++) {
            if (conf & PARAMS_MASK != 0) {
                require(locCount < n, ""Location count exceeds ref count"");
                params[locCount] = k * 32 + 4;
                locCount++;
            }
            conf = conf >> 1;
        }
        require(locCount == n, ""Location count less than ref count"");
    }
 | 	function getNumOfReferences(bytes32 conf) external returns (uint256) {
		// copied from getParams()
		uint256 n = 0;
        while (conf & REFS_MASK == REFS_MASK && n < REFS_LIMIT) {
            n++;
            conf = conf >> 8;
        }
        n = REFS_LIMIT - n;
		return n;
	}
",./furucombo/specs/libParam.spec,furucombo,,Yes,,"Functionality: Extract and return the number of dynamic references and parameters configurations from a given `bytes32` input, ensuring the input is not static and adheres to preset limits on references (`REFS_LIMIT`) and parameter size (`PARAMS_SIZE_LIMIT`)."
97095dcbe9edee1e85680df4e975f12e,903,rule,noRevert,21,31,getParams,"rule noRevert(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		require false;
	} else {
		f@withrevert(e, arg);
	}
	assert !lastReverted; // only fallback may revert
}","getParams (Lines 34-60), ","    function getParams(
        bytes32 conf
    ) internal pure returns (uint256[] memory refs, uint256[] memory params) {
        require(!isStatic(conf), ""Static params"");
        uint256 n = REFS_LIMIT;
        while (conf & REFS_MASK == REFS_MASK && n > 0) {
            n--;
            conf = conf >> 8;
        }
        require(n > 0, ""No dynamic param"");
        refs = new uint256[](n);
        params = new uint256[](n);
        for (uint256 i = 0; i < n; i++) {
            refs[i] = uint256(conf & REFS_MASK);
            conf = conf >> 8;
        }
        uint256 locCount = 0;
        for (uint256 k = 0; k < PARAMS_SIZE_LIMIT; k++) {
            if (conf & PARAMS_MASK != 0) {
                require(locCount < n, ""Location count exceeds ref count"");
                params[locCount] = k * 32 + 4;
                locCount++;
            }
            conf = conf >> 1;
        }
        require(locCount == n, ""Location count less than ref count"");
    }
",./furucombo/specs/libParam.spec,furucombo,,Yes,,"Functionality: Parse and extract two arrays of uint256 values, `refs` and `params`, from a provided `bytes32` configuration. It validates the dynamic nature of the configuration, determines the number of references, and maps parameter locations based on bit patterns within the configuration."
32d202a5d42940d3ddd3ea1a426af50b,905,rule,executeDelegatesOnlyToAllowedAddresses,59,67,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(FCOMPOUND_ACTIONS()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hscompound.spec,furucombo,,Yes,,"Functionality: The given code checks if the address provided as 'allowed' is the only address recorded in the 'delegated' array. It returns true only if the 'allowed' address matches all entries in the 'delegated' array, otherwise, it returns false."
102ab15f7889b3b711c724608fba9f17,945,rule,executeDelegatesOnlyToAllowedAddresses,59,67,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(getProxyActions()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hmaker.spec,furucombo,,Yes,,"Functionality: Check if a specified address (allowed) is the only address in a predefined list (delegated). It iterates through the list and returns false at the first instance of a different address, otherwise, it returns true, indicating all addresses in the list match the specified address."
0b96cb242633f7cfe4c1bfac5d1bcd84,963,rule,executeDelegatesOnlyToAllowedAddresses,65,73,summaryInstance.checkDelegated,"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(BACTIONS()), ""not all delegated are allowed"";
}
","checkDelegated (Lines 80-88), ","    function checkDelegated(address allowed) external returns (bool) {
        for (uint i = 0 ; i < delegated.length; i++) {
            if (delegated[i] != allowed) {
                return false;
            }
        }

        return true;
    }
",./furucombo/specs/hbalancer.spec,furucombo,,Yes,,"Functionality: Iterate through a list named `delegated` and check if every element in this list matches a specified address named `allowed`. Return `false` at the first occurrence of a mismatch. If no mismatches are found, return `true`."
0ec9a139fed5b159ecca1537d0d4c4bd,715,rule,withdraw,110,123,getPendingWithdrawalsIndex," * This rule verifies the Certora Prover is correctly modeling the behavior of GoldToken._transfer.
 */
rule withdraw(uint256 index) {
	env e;
	uint256 _balance = sinvoke ercBalanceOf(e.msg.sender);
	uint256 val = sinvoke getPendingWithdrawalsIndex(e.msg.sender, index);
	sinvoke withdraw(e, index);
	require (e.msg.sender != currentContract);
	uint256 balance_ = sinvoke ercBalanceOf(e.msg.sender);
	assert(
    _balance + val == balance_,
    ""Withdraw balance not updated""
  );
}
","getPendingWithdrawalsIndex (Lines 22-29), ","  function getPendingWithdrawalsIndex(address account, uint256 index) public returns (uint256) {
    require(getAccounts().isAccount(account), ""Unknown account"");
    require(
      index < balances[account].pendingWithdrawals.length,
      ""Index cannot exceed pending withdrawals length""
    );
    return balances[account].pendingWithdrawals[index].value;
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,Functionality: Retrieve the value of a pending withdrawal for a specified account based on the provided index. This requires verifying the existence of the account and ensuring the index is within the bounds of the account's pending withdrawals list.
35329bb83e3bac3b14314af37741a763,692 | 693 | 694 | 697,rule,totalNonVotingGEAccountNonVoting,27,41,incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | unlock | slash,"rule totalNonVotingGEAccountNonVoting(address a, method f) {
	require(sinvoke getNonvotingLockedGold()  >= sinvoke getAccountNonvotingLockedGold(a));
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector
  );
	env eF; 
    (f.selector != unlock(uint256).selector || eF.msg.sender == a) &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
	calldataarg arg;
	sinvoke f(eF,arg);
	assert(sinvoke getNonvotingLockedGold() >= sinvoke getAccountNonvotingLockedGold(a));
}
","incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | unlock (Lines 62-64),  | slash (Lines 74-84), ","  function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function unlock(uint256 value) external {
    accountTotalLockedGold[msg.sender] = accountTotalLockedGold[msg.sender].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,"Functionality: Manage account balances related to a blockchain-based governance system. Increase or decrease nonvoting account balances with specific amounts, reduce an account's total locked gold by a certain value, and apply penalties to account locked gold amounts due to infractions."
3b287718f21df196cbe7e912e1f53aff,700 | 701 | 702 | 704,rule,totalPreserved,46,75,getPendingWithdrawalsLength | incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | slash,"rule totalPreserved(address account, method f) {
	// We assume the sender is not the currentContract
	require(account != currentContract);
	uint256 _ercBalance = sinvoke ercBalanceOf(account); 
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(account);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(account);
	// We limit the amount of pending records due to loop handling 
	require sinvoke getPendingWithdrawalsLength(account) <= 1;
	env eF;
	require(eF.msg.sender == account);
	// These three function are exceptions to the rule (they are designed to affect total)
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	calldataarg arg;
	sinvoke f(eF,arg);
	uint length = sinvoke getPendingWithdrawalsLength(account);
	require(length <= 1);
	uint256 ercBalance_ = sinvoke ercBalanceOf(account);
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(account);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(account);
  assert(
    _ercBalance + _accountNonVoting + _accountTotalPendingWithdrawals ==
    ercBalance_ + accountNonVoting_ + accountTotalPendingWithdrawals_,
    ""Total of tokens not preserved""
}
","getPendingWithdrawalsLength (Lines 51-54),  | incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | slash (Lines 74-84), ","  function getPendingWithdrawalsLength(address account) external view returns (uint256) {
    uint256 length = balances[account].pendingWithdrawals.length;
    return length;
  }
 |   function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,"Functionality: Manage an account's balance and penalties within a system. Calculate the length of pending withdrawals for an account, adjust nonvoting account balances by adding or subtracting values, and reduce an account's total locked gold by a specified penalty amount."
ae66ba09f0bdeb24cc5f1772fb961b05,707 | 710 | 711 | 713,rule,noChangeByOther,80,107,getPendingWithdrawalsLength | incrementNonvotingAccountBalance | decrementNonvotingAccountBalance | slash,"rule noChangeByOther(address a, address b, method f) {
	require(a != b);
	// We assume the sender is not the currentContract
	require(
    a != currentContract &&
    (a == sinvoke getGoldTokenExt() => f.selector != withdraw(uint256).selector));
	uint256 _ercBalance = sinvoke ercBalanceOf(a);
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(a);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(a);
	// We limit the amount of pending records due to loop handling 
	uint length = sinvoke getPendingWithdrawalsLength(a);
	require(length <= 1);
	env eF;
	require(eF.msg.sender == b);
	calldataarg arg;
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	sinvoke f(eF,arg);
	uint256 ercBalance_ = sinvoke ercBalanceOf(a); 
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(a);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(a);
	assert(f.selector != withdraw(uint256).selector => _ercBalance == ercBalance_, ""Unexpected change to erc tokens"");
	assert(_accountTotalPendingWithdrawals == accountTotalPendingWithdrawals_, ""Unexpected change to total pending"");
	assert(_accountNonVoting == accountNonVoting_, ""Unexpected change to account nonvoting"");
}
","getPendingWithdrawalsLength (Lines 51-54),  | incrementNonvotingAccountBalance (Lines 27-29),  | decrementNonvotingAccountBalance (Lines 31-33),  | slash (Lines 74-84), ","  function getPendingWithdrawalsLength(address account) external view returns (uint256) {
    uint256 length = balances[account].pendingWithdrawals.length;
    return length;
  }
 |   function incrementNonvotingAccountBalance(address account, uint256 value) external {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].add(value);
  }
 |   function decrementNonvotingAccountBalance(address account, uint256 value) public {
    nonvotingAccountBalance[account] = nonvotingAccountBalance[account].sub(value);
  }
 |   function slash(
    address account,
    uint256 penalty,
    address,
    uint256,
    address[] calldata,
    address[] calldata,
    uint256[] calldata
  ) external {
    accountTotalLockedGold[account] = accountTotalLockedGold[account].sub(penalty);
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,"Functionality: Manage account balances by permitting the retrieval of the count of pending withdrawals for a given account, enabling the increment and decrement of a non-voting account balance, and allowing for the reduction of an account's total locked gold as a penalty."
e0e25c2eff6e77e4aa64ef1b150b6797,719 | 720,rule,noWithdrawBeforeUnlocking,128,150,pendingWithdrawalsNotFull | unlock,"rule noWithdrawBeforeUnlocking(address account, uint256 value, method f) {
	// We must make sure the length of pending withdrawals is not MAX_UINT, since then the `push` will make the length 0.
	// (this should have been checked by the solidity compiler)
	require(sinvoke pendingWithdrawalsNotFull(account), ""Pending withdrawals are full"");
	
	// Unlock a value and add it to pending withdrawals
	env _e;
	require(_e.msg.sender == account);
	sinvoke unlock(_e,value);

	// Try to run any function - adversary's goal is to succeed in unlocking before time
	env eF;
	require(eF.block.timestamp > _e.block.timestamp);
	calldataarg arg;
	sinvoke f(eF,arg);
	// We check if adversary succeeded
	uint256 totalPendingWithdrawals_ = sinvoke getTotalPendingWithdrawals(account);
	assert(
    eF.block.timestamp < _e.block.timestamp + sinvoke getunlockingPeriod() =>
    sinvoke getAccountNonvotingLockedGold(account) + totalPendingWithdrawals_ >= value,
    ""If we are before the unlock period passed, we cannot transfer the value outside the locked balance or pending balance""
  );
}
","pendingWithdrawalsNotFull (Lines 47-49),  | unlock (Lines 62-64), ","  function pendingWithdrawalsNotFull(address account) public view returns (bool) {
    return balances[account].pendingWithdrawals.length.add(2) >= 2; // we can add 2 more additional elements
  }
 |   function unlock(uint256 value) external {
    accountTotalLockedGold[msg.sender] = accountTotalLockedGold[msg.sender].sub(value);
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,"Functionality: Check if an account can add at least two more pending withdrawals, returning `true` if the sum of the current number of pending withdrawals and 2 is at least 2. Subtract a specified `value` from the sender's total locked gold balance in the contract."
e0e25c2eff6e77e4aa64ef1b150b6797,719 | 720,rule,noWithdrawBeforeUnlocking,128,150,pendingWithdrawalsNotFull | unlock,"rule noWithdrawBeforeUnlocking(address account, uint256 value, method f) {
	// We must make sure the length of pending withdrawals is not MAX_UINT, since then the `push` will make the length 0.
	// (this should have been checked by the solidity compiler)
	require(sinvoke pendingWithdrawalsNotFull(account), ""Pending withdrawals are full"");
	
	// Unlock a value and add it to pending withdrawals
	env _e;
	require(_e.msg.sender == account);
	sinvoke unlock(_e,value);

	// Try to run any function - adversary's goal is to succeed in unlocking before time
	env eF;
	require(eF.block.timestamp > _e.block.timestamp);
	calldataarg arg;
	sinvoke f(eF,arg);
	// We check if adversary succeeded
	uint256 totalPendingWithdrawals_ = sinvoke getTotalPendingWithdrawals(account);
	assert(
    eF.block.timestamp < _e.block.timestamp + sinvoke getunlockingPeriod() =>
    sinvoke getAccountNonvotingLockedGold(account) + totalPendingWithdrawals_ >= value,
    ""If we are before the unlock period passed, we cannot transfer the value outside the locked balance or pending balance""
  );
}
","pendingWithdrawalsNotFull (Lines 47-49),  | unlock (Lines 62-64), ","  function pendingWithdrawalsNotFull(address account) public view returns (bool) {
    return balances[account].pendingWithdrawals.length.add(2) >= 2; // we can add 2 more additional elements
  }
 |   function unlock(uint256 value) external {
    accountTotalLockedGold[msg.sender] = accountTotalLockedGold[msg.sender].sub(value);
  }
",./celo_governance/specs/lockedGold.spec,celo_governance,,Yes,,"Functionality: Determine if the account can add at least two more elements to its pending withdrawals, considering its current number of pending withdrawals. Additionally, reduce the total locked gold amount associated with the sender's account by a specified value."
2b7cc4ca0087210de350b81670679aae,899,rule,no_weight_changing_when_voting,44,61,isVoting,"rule no_weight_changing_when_voting(method f, address account) {
	env _e;
	uint256 _accountWeight = sinvoke _weight(_e,account);
	
	bool isAccountVoting = sinvoke isVoting(_e,account);
	env eF;
	calldataarg arg;
	invoke f(eF,arg);
	env e_;
	uint256 accountWeight_ = sinvoke _weight(e_,account);
	assert(
    isAccountVoting => _accountWeight == accountWeight_,
    ""Method changed weight of account if voting""
  );
}","isVoting (Lines 986-995), ","  function isVoting(address account) external view returns (bool) {
    Voter storage voter = voters[account];
    uint256 upvotedProposal = voter.upvote.proposalId;
    bool isVotingQueue = upvotedProposal != 0 &&
      isQueued(upvotedProposal) &&
      !isQueuedProposalExpired(upvotedProposal);
    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];
    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);
    return isVotingQueue || isVotingReferendum;
  }
",./celo_governance/specs/locked_gold_linked.spec,celo_governance,,Yes,,"Functionality: Determine if an account is currently voting by checking if they've upvoted a proposal that is queued (but not expired) or if their most recent referendum proposal is in the referendum stage, and return true if either condition is met."
bfa15d92e5a1b86e062356c758e9f662,898,rule,no_vote_delegation_when_voting,24,39,isVoting,"rule no_vote_delegation_when_voting {
	env _e;
	env eF;
	
	address account = eF.msg.sender;
	bool _isAccountVoting = sinvoke isVoting(_e,account);

	calldataarg arg;
	invoke delegateVoting(eF,arg);
	bool succeededDelegate = !lastReverted;
	assert(
    _isAccountVoting => !succeededDelegate,
    ""Account successfully delegated voting even though it is already a voter""
  );
} 
","isVoting (Lines 986-995), ","  function isVoting(address account) external view returns (bool) {
    Voter storage voter = voters[account];
    uint256 upvotedProposal = voter.upvote.proposalId;
    bool isVotingQueue = upvotedProposal != 0 &&
      isQueued(upvotedProposal) &&
      !isQueuedProposalExpired(upvotedProposal);
    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];
    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);
    return isVotingQueue || isVotingReferendum;
  }
",./celo_governance/specs/locked_gold_linked.spec,celo_governance,,Yes,,"Functionality: Determine if an account is currently voting by checking if the account has upvoted a proposal that is in the queue and not expired, or if it has voted on a proposal that is currently in the referendum stage."
835c513b44fd0be9723e8c5ac6e8c755,891 | 895,rule,no_double_vote_referendum_vote,4,55,propose | getVoteRecord,"rule no_double_vote_referendum_vote(address account, uint256 deqIndex) {
	/* A user that already has a vote record for a dequeued index, cannot make a transaction that will increase the weight of that choice */
	env eF; 
	env eFTime; // same time as eF;
	env e_;
	
	uint256 NONE_ENUM = getNoneVoteEnum();
	uint256 ABSTAIN = getAbstainVoteEnum();
	uint256 YES = getYesVoteEnum();
	uint256 NO = getNoVoteEnum();
	uint256 p; // a proposal - let's assume it already exists (required for propose() verification)
	uint256 recordValue;
	p, recordValue, _ = getVoteRecord(account,deqIndex);
	uint256 currentProposalCount = proposalCount();
	require currentProposalCount >= p;
	uint256 _yes; uint256 _no; uint256 _abstain;
	_yes,_no,_abstain = getVoteTotals(p);
	// if can't vote for NONE_ENUM, then necessarily if record vote is NONE_ENUM, all votes are zero currently
	require recordValue == NONE_ENUM => (_yes == 0 && _no == 0 && _abstain == 0);
	require accounts.voteSignerToAccount(eF.msg.sender) == account;
	uint256 someP; uint256 someIndex; uint8 someValue;
	uint256 pOfSomeIndex;
	pOfSomeIndex, _, _ = getVoteRecord(account,someIndex);
	require pOfSomeIndex == p => someIndex == deqIndex; // no duplicates in the dequeued array
	require someP == p => someIndex == deqIndex;
	vote(eF,someP,someIndex,someValue);
	uint256 yes_; uint256 no_; uint256 abstain_;
	yes_,no_,abstain_ = getVoteTotals(p);
	bool doesProposalExist_ = proposalExists(e_,p);
	// if p expires, then sum of votes is no longer relevant - happens in approve, vote, execute
	assert (recordValue != NONE_ENUM && doesProposalExist_) => (yes_ + no_ + abstain_) == (_yes + _no + _abstain), ""Total votes could not have changed if already voted"";
	assert recordValue == YES => yes_ <= _yes, ""Yes votes could not have increased if voted yes already"";
	assert recordValue == NO => no_ <= _no, ""No votes could not have increased if voted no already"";
	assert recordValue == ABSTAIN => abstain_ <= _abstain, ""Abstain votes could not have increased if voted abstain already"";
	assert recordValue == NONE_ENUM => (!doesProposalExist_ && yes_ == 0 && no_ == 0 && abstain_ == 0)// proposal no longer exists so everything is 0
									// or just one out of (yes,no,abstain) changed
									|| (yes_ == _yes && no_ == _no)
									|| (yes_ == _yes && abstain_ == _abstain)
									|| (no_ == _no && abstain_ == _abstain),
									""If previously did not vote, either this proposal was deleted, or only one kind of vote may change, and the other two are the same"";
}
","propose (Lines 467-485),  | getVoteRecord (Lines 1102-1116), ","  function propose(
    uint256[] calldata values,
    address[] calldata destinations,
    bytes calldata data,
    uint256[] calldata dataLengths,
    string calldata descriptionUrl
  ) external payable returns (uint256) {
    dequeueProposalsIfReady();
    require(msg.value >= minDeposit, ""Too small deposit"");

    proposalCount = proposalCount.add(1);
    Proposals.Proposal storage proposal = proposals[proposalCount];
    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);
    proposal.setDescriptionUrl(descriptionUrl);
    queue.push(proposalCount);
    // solhint-disable-next-line not-rely-on-time
    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);
    return proposalCount;
  }
 |   function getVoteRecord(address account, uint256 index)
    external
    view
    returns (uint256, uint256, uint256, uint256, uint256, uint256)
  {
    VoteRecord storage record = voters[account].referendumVotes[index];
    return (
      record.proposalId,
      uint256(record.deprecated_value),
      record.deprecated_weight,
      record.yesVotes,
      record.noVotes,
      record.abstainVotes
    );
  }
",./celo_governance/specs/governance_old_rules.spec,celo_governance,,Yes,,"Functionality: Create a proposal with specified values, destinations, and data, requiring a minimum deposit. It updates the global proposal count, stores the proposal, pushes it to a queue, and emits an event with pertinent details. Additionally, it allows fetching a voter's specific referendum vote record, including proposal ID and votes."
29e34d2da68f8eb527ac2d29a4ac129f,812 | 814 | 816,rule,no_double_upvote,80,97,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote proposals for consideration by locking their gold. This process includes validating user vote weight, checking proposal status, ensuring a single queued proposal upvote per user, updating the proposal queue with increased upvotes, and recording the user's upvote with their locked gold weight."
36053441f6f621827da74129aab292e2,807 | 809 | 811,rule,upvotesConsistency,62,62,getUpvotedProposal | upvote | getUpvoteRecord,"rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote governance proposals if they have locked a certain amount of gold, managing upvotes through a queue structure. It ensures a user cannot upvote more than one proposal in the queue simultaneously and handles the removal of expired proposals efficiently."
56617b3880c82c42b356f92974aab50a,828 | 831 | 833 | 835,rule,cant_unvote,143,161,getUpvotedProposal | upvote | getVoteRecord | getUpvoteRecord,"rule cant_unvote(uint256 deqIndex, uint8 voteValue) {	
    env eF;
	uint256 NONE_ENUM = getNoneVoteEnum();
	// get the voting delegate
	address voterDelegate = accounts.getVoteSigner(eF.msg.sender);
	
	// check if voted
    uint256 p;
	uint256 recordValue;
    uint256 weight;
	p, recordValue, weight = getVoteRecord(voterDelegate,deqIndex);
	bool result = vote(eF,p,deqIndex,voteValue);
	uint256 recordValue_;
    uint256 weight_;
	_, recordValue_, weight_ = getVoteRecord(voterDelegate,deqIndex);
	assert voteValue == NONE_ENUM => (!result && recordValue_ == recordValue && weight_ == weight), ""Cannot vote for none: function either returns false and did not update the vote, or it reverted""; // not voting none. reverting is fine and is encoded by the safe invoke
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getVoteRecord (Lines 1102-1116),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getVoteRecord(address account, uint256 index)
    external
    view
    returns (uint256, uint256, uint256, uint256, uint256, uint256)
  {
    VoteRecord storage record = voters[account].referendumVotes[index];
    return (
      record.proposalId,
      uint256(record.deprecated_value),
      record.deprecated_weight,
      record.yesVotes,
      record.noVotes,
      record.abstainVotes
    );
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Manage the process where users can upvote governance proposals by locking gold as a form of voting weight. It allows users to query their voting records, upvote active proposals in a queue (ensuring each can upvote only once and proposals aren't expired), and retrieve their upvote details."
57279cad5cd958e693560558b84af120,795 | 797 | 799,invariant,no_double_upvote,73,97,getUpvotedProposal | upvote | getUpvoteRecord,"    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote governance proposals by utilizing their locked gold, ensuring only one active upvote per queue. Automatically remove upvotes from expired proposals, and update the proposal queue with new upvote weights while emitting relevant events for tracking proposal support."
6a36db9550a0f783945aef5f05c1e0bd,801 | 803 | 806,invariant,referendumVoteIDIsLessThanOrEqCounter,211,215,getUpvotedProposal | upvote | getUpvoteRecord,"invariant referendumVoteIDIsLessThanOrEqCounter(address v, uint p) votedFor(v,p) => p <= proposalCount() {
    preserved vote(uint256 _, uint256 indx, uint8 vr) with (env e) {
        requireInvariant dequeuedIsWithinRange(indx); 
invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    }
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote governance proposals by locking gold as voting power, provided they haven't already upvoted a proposal in the queue. It enables querying of a user's upvoted proposal, managing the proposal queue, and ensuring each upvote action is valid and recorded accordingly."
844170c24f9033f884842c9ce6dc4f5a,880 | 883 | 885,rule,check_initializer,366,381,getUpvotedProposal | upvote | getUpvoteRecord,"rule check_initializer {
	env _e;
	env eF;
	env e_;
	
	bool _isInitialized = initialized(_e);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	calldataarg arg;
	initialize@withrevert(eF,arg);
	bool successInit = !lastReverted;
	bool isInitialized_ = initialized(e_);
	assert _isInitialized => !successInit, ""initialize() must revert if already initialized"";
	assert successInit => isInitialized_, ""When initialize() succeeds, must set initialization field to true"";
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Enable users to upvote governance proposals by leveraging their locked gold as voting weight. Prevent upvoting of multiple or expired proposals in the queue, manage user's current upvote, and allow querying of a user's upvoted proposal and its weight."
8b53a90047ebccc8bb4c45d839fdfb49,875 | 877 | 879,rule,only_initializer_changes_initialized_field,350,350,getUpvotedProposal | upvote | getUpvoteRecord,"rule only_initializer_changes_initialized_field(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Implement a voting system allowing users to upvote governance proposals by locking gold. Voters cannot upvote more than one active proposal in the queue. The system tracks each voter's upvote, including the proposal ID and weight of the vote, and ensures only proposals in the queue can be upvoted."
9228f7b8b1622d2108c894af4bd773de,870 | 872 | 874,rule,constitution_change,325,328,getUpvotedProposal | upvote | getUpvoteRecord,"rule constitution_change(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
        && f.selector != setConstitution(address,bytes4,uint256).selector
} {
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote governance proposals by locking gold, ensuring they can only upvote a proposal not already queued or expired. Users retrieve their current upvoted proposal's ID and weight, ensuring they cannot upvote more than one proposal in the queue simultaneously."
9bbba1adee0105bf12fa08893799ee7b,817 | 819 | 821,rule,proposal_count_monotonic_increasing,99,99,getUpvotedProposal | upvote | getUpvoteRecord,"rule proposal_count_monotonic_increasing(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users with locked gold to upvote a specific proposal in a queue, provided they are not already upvoting another proposal in the queue. Each user's upvote is weighted by their amount of locked gold, and this action updates the total upvotes for that proposal accordingly."
9fed64686c53b81b5adf2ab26146e30a,864 | 866 | 867 | 869,rule,can_add_to_queue,311,314,getUpvotedProposal | propose | upvote | getUpvoteRecord,"rule can_add_to_queue(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != propose(uint256[],address[],bytes,uint256[],string).selector
} {
","getUpvotedProposal (Lines 43-48),  | propose (Lines 467-485),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function propose(
    uint256[] calldata values,
    address[] calldata destinations,
    bytes calldata data,
    uint256[] calldata dataLengths,
    string calldata descriptionUrl
  ) external payable returns (uint256) {
    dequeueProposalsIfReady();
    require(msg.value >= minDeposit, ""Too small deposit"");

    proposalCount = proposalCount.add(1);
    Proposals.Proposal storage proposal = proposals[proposalCount];
    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);
    proposal.setDescriptionUrl(descriptionUrl);
    queue.push(proposalCount);
    // solhint-disable-next-line not-rely-on-time
    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);
    return proposalCount;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Implement a voting system where users can propose and upvote proposals by locking gold. Manage proposal queuing and expiration, ensuring a proposal is in queue for upvoting and preventing multiple active upvotes per user. Retrieve a user's active upvote and the associated weight."
c40c034df2d7060242259ba3fc9697d4,850 | 852 | 854,rule,approved_proposals_invariants,244,244,getUpvotedProposal | upvote | getUpvoteRecord,"rule approved_proposals_invariants(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow registered voters with locked gold to upvote proposals in a queued system, ensuring a voter can endorse only one active proposal at a time. Upvoted proposals gain weight proportional to the voter's locked gold, impacting their chance of passing or being acted upon."
d6c2378ee4d893eb1e3eb690a2660717,842 | 843 | 845 | 848 | 849,rule,approval_only_if_promoted_and_allowed,218,241,getUpvotedProposal | approve | upvote | getUpvoteRecord | isDequeuedProposalExpired,"rule approval_only_if_promoted_and_allowed(uint256 p, uint256 index) {
	// A proposal should never be able to be approved unless it was promoted from the queue
	env eF;
    env eGet;
    require eF.block.timestamp == eGet.block.timestamp;
    require eF.block.number == eGet.block.number;
	
	bool _isProposalApproved = isApproved(p);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	bool _isDequeued = getFromDequeued(index) == p;
	bool _isExpired = isDequeuedProposalExpired(eGet, p);
	address _approver = approver();
	require !_isProposalApproved; // we assume not approved yet
	require !_isExpired; // we also assume it did not expire
		
	approve(eF,p,index);
	// should check if dequeued right during approve
	bool isDequeued_ = getFromDequeued(index) == p;
	bool isProposalApproved_ = isApproved(p);
	assert isProposalApproved_ => _isDequeued || (!_isDequeued && isDequeued_), ""Cannot approve proposal $p unless $index points to it before approve or during it""; // index has p
	assert isProposalApproved_ => eF.msg.sender == _approver, ""Only approver ${_approver} can approve"";
","getUpvotedProposal (Lines 43-48),  | approve (Lines 614-634),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164),  | isDequeuedProposalExpired (Lines 1343-1346), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {
    dequeueProposalsIfReady();
    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(
      proposalId,
      index
    );
    if (!proposal.exists()) {
      return false;
    }

    require(!proposal.isApproved(), ""Proposal already approved"");
    require(
      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,
      ""Proposal not in correct stage""
    );
    proposal.approved = true;
    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.
    proposal.networkWeight = getLockedGold().getTotalLockedGold();
    emit ProposalApproved(proposalId);
    return true;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
 |   function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {
    Proposals.Proposal storage proposal = proposals[proposalId];
    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Manage proposal upvoting, approval, and expiration in a governance system. Enable users to upvote proposals by locking gold, allow approvers to officially approve proposals in their rightful stages, and check if a dequeued proposal has expired, ensuring the governance process is transparent and accountable."
e438d9fd1e89cf34c68ae2275f73ae7a,822 | 824 | 826,rule,no_referendum_votes_unless_approved,118,118,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_referendum_votes_unless_approved(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote governance proposals if they have locked gold, ensuring they cannot upvote more than one proposal in the queue at a time. It also enables fetching the upvote record for a specific account, detailing the proposal they've upvoted and the weight of their vote."
f4502f38f9ab63a1c3e3807bdfab9353,836 | 838 | 840,rule,no_double_vote_referendum_all_but_vote,164,164,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_double_vote_referendum_all_but_vote(method f, address account, uint256 deqIndex) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,Functionality: The provided code enables users to upvote proposals within a governance system after locking a certain amount of gold and ensures that only one queued proposal can be upvoted per user. It also allows retrieval of a user's current upvoted proposal and the weight of their vote.
fa2a422fee5dd1c3e6ef33248b1533df,790 | 792 | 794,invariant,dequeuedIsWithinRange,58,62,getUpvotedProposal | upvote | getUpvoteRecord,"invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Track and update upvotes for governance proposals. Allow users to upvote a proposal by locking gold, ensuring each user can only actively upvote one proposal in the queue. Additionally, manage upvote records, enabling retrieval of proposal IDs and weights associated with a user's upvote."
fe84951735c703be004207a0b3e78ab9,856 | 859 | 860 | 861 | 863,rule,modifying_stageDuration,291,297,getUpvotedProposal | setReferendumStageDuration | setExecutionStageDuration | upvote | getUpvoteRecord,"rule modifying_stageDuration(method f) filtered { f -> 
    !f.isView 
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != initialize(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256).selector
    && f.selector != setApprovalStageDuration(uint256).selector
    && f.selector != setExecutionStageDuration(uint256).selector
    && f.selector != setReferendumStageDuration(uint256).selector
} {
","getUpvotedProposal (Lines 43-48),  | setReferendumStageDuration (Lines 342-347),  | setExecutionStageDuration (Lines 353-358),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {
    require(referendumStageDuration != 0, ""Duration must be larger than 0"");
    require(referendumStageDuration != stageDurations.referendum, ""Duration unchanged"");
    stageDurations.referendum = referendumStageDuration;
    emit ReferendumStageDurationSet(referendumStageDuration);
  }
 |   function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {
    require(executionStageDuration != 0, ""Duration must be larger than 0"");
    require(executionStageDuration != stageDurations.execution, ""Duration unchanged"");
    stageDurations.execution = executionStageDuration;
    emit ExecutionStageDurationSet(executionStageDuration);
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Adjust referendum and execution stage durations, allow upvoting on governance proposals based on locked gold, ensure a single act of upvoting per queue, record upvote details, and retrieve an account's current upvote record, including the proposal ID and weight of the vote."
e438d9fd1e89cf34c68ae2275f73ae7a,822 | 824 | 826,rule,no_referendum_votes_unless_approved,118,118,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_referendum_votes_unless_approved(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Enable users to upvote governance proposals using their locked gold as voting power. It validates proposal eligibility, prevents users from supporting multiple active proposals, and updates the upvoted proposal's total upvotes accordingly while maintaining a record of each voter's current upvote."
f4502f38f9ab63a1c3e3807bdfab9353,836 | 838 | 840,rule,no_double_vote_referendum_all_but_vote,164,164,getUpvotedProposal | upvote | getUpvoteRecord,"rule no_double_vote_referendum_all_but_vote(method f, address account, uint256 deqIndex) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Manage upvotes for proposals within a governance framework, allowing users to upvote proposals in a queue by locking a certain amount of gold. It prevents upvoting multiple queued proposals simultaneously and ensures only active, non-expired proposals with sufficient locked gold can be upvoted, reflecting each vote's weight accurately."
fa2a422fee5dd1c3e6ef33248b1533df,790 | 792 | 794,invariant,dequeuedIsWithinRange,58,62,getUpvotedProposal | upvote | getUpvoteRecord,"invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","getUpvotedProposal (Lines 43-48),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Allow users to upvote proposals in a voting queue system by committing their locked gold as voting weight, ensuring each user can upvote on only one proposal in the queue at a time, and retrieve the proposal ID and voting weight for a given account's upvote record."
fe84951735c703be004207a0b3e78ab9,856 | 859 | 860 | 861 | 863,rule,modifying_stageDuration,291,297,getUpvotedProposal | setReferendumStageDuration | setExecutionStageDuration | upvote | getUpvoteRecord,"rule modifying_stageDuration(method f) filtered { f -> 
    !f.isView 
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != initialize(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256).selector
    && f.selector != setApprovalStageDuration(uint256).selector
    && f.selector != setExecutionStageDuration(uint256).selector
    && f.selector != setReferendumStageDuration(uint256).selector
} {
","getUpvotedProposal (Lines 43-48),  | setReferendumStageDuration (Lines 342-347),  | setExecutionStageDuration (Lines 353-358),  | upvote (Lines 530-558),  | getUpvoteRecord (Lines 1161-1164), ","  function getUpvotedProposal(address account) public view returns (uint256) {
    uint256 proposalId;
    uint256 weight;
    (proposalId, weight) = this.getUpvoteRecord(account);
    return proposalId;
  }
 |   function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {
    require(referendumStageDuration != 0, ""Duration must be larger than 0"");
    require(referendumStageDuration != stageDurations.referendum, ""Duration unchanged"");
    stageDurations.referendum = referendumStageDuration;
    emit ReferendumStageDurationSet(referendumStageDuration);
  }
 |   function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {
    require(executionStageDuration != 0, ""Duration must be larger than 0"");
    require(executionStageDuration != stageDurations.execution, ""Duration unchanged"");
    stageDurations.execution = executionStageDuration;
    emit ExecutionStageDurationSet(executionStageDuration);
  }
 |   function upvote(uint256 proposalId, uint256 lesser, uint256 greater)
    external
    nonReentrant
    returns (bool)
  {
    dequeueProposalsIfReady();
    // If acting on an expired proposal, expire the proposal and take no action.
    if (removeIfQueuedAndExpired(proposalId)) {
      return false;
    }

    address account = getAccounts().voteSignerToAccount(msg.sender);
    Voter storage voter = voters[account];
    removeIfQueuedAndExpired(voter.upvote.proposalId);

    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.
    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);
    require(weight > 0, ""cannot upvote without locking gold"");
    require(queue.contains(proposalId), ""cannot upvote a proposal not in the queue"");
    require(
      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),
      ""cannot upvote more than one queued proposal""
    );
    uint256 upvotes = queue.getValue(proposalId).add(weight);
    queue.update(proposalId, upvotes, lesser, greater);
    voter.upvote = UpvoteRecord(proposalId, weight);
    emit ProposalUpvoted(proposalId, account, weight);
    return true;
  }
 |   function getUpvoteRecord(address account) external view returns (uint256, uint256) {
    UpvoteRecord memory upvoteRecord = voters[account].upvote;
    return (upvoteRecord.proposalId, upvoteRecord.weight);
  }
",./celo_governance/specs/governance.spec,celo_governance,,Yes,,"Functionality: Set duration parameters for referendum and execution stages of a governance process, allowing only the owner to update these parameters under specific conditions. Enable users to upvote governance proposals by locking gold, ensuring only one queued proposal receives their support, and retrieve account-specific upvote records."
139286964f1450f902d49e41aa564621,787,rule,no_promoting_without_upvotes,55,74,dequeueProposalsIfReady,"rule no_promoting_without_upvotes(uint256 p, uint256 index) {
	// Can a proposal be promoted with 0 votes? 
	env _e;
	env eF;
	env e_;
	
	/* would actually want forall index. inrange(index) => dequeued[index] != p but here its suffice to 'pre-guess' the index of the proposal we dequeue */
	// a utility rule for figuring out which methods could dequeue and whether it's all due to dequeueProposalsIfReady calls.

	// require index to be valid and to be empty
	require index >= 0;
	uint256 queueLength = getDequeuedLength();
	require index <= queueLength || index == queueLength+1; // either an empty index or the next one we push
	// if it's an empty index in the range, then it's empty
	require index <= queueLength => getFromDequeued(index) == 0;
	callArbitrary(f);
	uint256 newValueInDequeued = getFromDequeued(index);
	assert newValueInDequeued == 0, ""Method caused a dequeue of proposal $newValueInDequeued to index $index"";	
}
rule promote_proposal(method f, uint256 p, uint256 index) filtered { f -> !f.isView } {
	require p > 0; // proposal 0 is not legal, and cannot happen (we check it)
	uint256 _upvotes = getUpvotes(p);
	dequeueProposalsIfReady(eF);
	assert getFromDequeued(index) == p => _upvotes > 0, ""Cannot dequeue (promote) proposal $p to index $index unless had some upvotes"";
}","dequeueProposalsIfReady (Lines 1222-1258), ","  function dequeueProposalsIfReady() public {
    // solhint-disable-next-line not-rely-on-time
    if (now >= lastDequeue.add(dequeueFrequency)) {
      uint256 numProposalsToDequeue = Math.min(concurrentProposals, queue.list.numElements);
      uint256[] memory dequeuedIds = queue.popN(numProposalsToDequeue);

      bool wasAnyProposalDequeued = false;
      for (uint256 i = 0; i < numProposalsToDequeue; i = i.add(1)) {
        uint256 proposalId = dequeuedIds[i];
        Proposals.Proposal storage proposal = proposals[proposalId];
        if (_isQueuedProposalExpired(proposal)) {
          emit ProposalExpired(proposalId);
          continue;
        }
        refundedDeposits[proposal.proposer] = refundedDeposits[proposal.proposer].add(
          proposal.deposit
        );
        // solhint-disable-next-line not-rely-on-time
        proposal.timestamp = now;
        if (emptyIndices.length != 0) {
          uint256 indexOfLastEmptyIndex = emptyIndices.length.sub(1);
          dequeued[emptyIndices[indexOfLastEmptyIndex]] = proposalId;
          delete emptyIndices[indexOfLastEmptyIndex];
          emptyIndices.length = indexOfLastEmptyIndex;
        } else {
          dequeued.push(proposalId);
        }
        // solhint-disable-next-line not-rely-on-time
        emit ProposalDequeued(proposalId, now);
        wasAnyProposalDequeued = true;
      }
      if (wasAnyProposalDequeued) {
        // solhint-disable-next-line not-rely-on-time
        lastDequeue = now;
      }
    }
  }
",./celo_governance/specs/goverance_with_dequeue.spec,celo_governance,,Yes,,"Functionality: Determine if enough time has passed since the last dequeue, then dequeue up to a specified number of proposals. For each dequeued proposal, refund the deposit to the proposer, update its timestamp, and store or remove its ID based on available spaces, emitting appropriate events."
128f7992885aeaf61914ff90925752e5,765,rule,cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy,290,294,authorizeSignerWithSignature,"rule cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
} {
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Use `authorizeSignerWithSignature` to authorize a signer for a specific role using EIP-712 signature, by internally calling `authorizeAddressWithRole` with the signer's details and marking the authorization process as both started and completed in the contract's state, then emit a `SignerAuthorized` event."
30c9824cebc813125783c38049e611c2,757,rule,address_can_authorize_two_addresses,125,149,authorizeSignerWithSignature,"rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Authorize a signer with a specific role using their signature. This is achieved by first authorizing the address with the desired role using the signature components (v, r, s), and then marking the authorization as started and completed for the signer in the contract's state."
45b72e5e6fd0c8a975a7ebba8ade9d6a,777 | 778,rule,gettersInAgreement,404,431,getLegacySigner | getDefaultSigner,"rule gettersInAgreement() {
	address account;
	require account != 0;
	bytes32 role;
	address indexedSigner = getIndexedSigner(account, role);
	address defaultSigner = getDefaultSigner(account, role);
	address legacySigner = getLegacySigner(account, role);
	address voteSigner = getVoteSigner(account);
	address validatorSigner = getValidatorSigner(account);
	address attestationSigner = getAttestationSigner(account);

	if (role == _getVoteRole()) {
		assert indexedSigner == legacySigner && indexedSigner == voteSigner, ""indexed signer agrees with legacy signer for vote role"";
	} else if (role == _getValidatorRole()) {
		assert indexedSigner == legacySigner && indexedSigner == validatorSigner, ""indexed signer agrees with legacy signer for validator role"";
	} else if (role == _getAttestationRole()) {
		assert indexedSigner == legacySigner && indexedSigner == attestationSigner, ""indexed signer agrees with legacy signer for attestation role"";
	} else {
		assert indexedSigner == defaultSigner, ""for any non legacy role indexed signer is default signer"";
	}
	assert indexedSigner != 0 && defaultSigner != 0 && legacySigner != 0 
		&& voteSigner != 0 && validatorSigner != 0 && attestationSigner != 0, ""signer is never address 0"";
	// original assertion is wrong
	//assert indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
	assert !isLegacyRole(role) && indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
}
","getLegacySigner (Lines 815-829),  | getDefaultSigner (Lines 837-840), ","  function getLegacySigner(address _account, bytes32 role) public view returns (address) {
    require(isLegacyRole(role), ""Role is not a legacy signer"");

    Account storage account = accounts[_account];
    address signer;
    if (role == ValidatorSigner) {
      signer = account.signers.validator;
    } else if (role == AttestationSigner) {
      signer = account.signers.attestation;
    } else if (role == VoteSigner) {
      signer = account.signers.vote;
    }

    return signer == address(0) ? _account : signer;
  }
 |   function getDefaultSigner(address account, bytes32 role) public view returns (address) {
    address defaultSigner = defaultSigners[account][role];
    return defaultSigner == address(0) ? account : defaultSigner;
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Determine the specific signer for a given account based on a role, either by returning a legacy signer from predefined roles (Validator, Attestation, Vote) if available, or a default signer. If neither is set, return the original account address as the signer."
7fdd0d548648197a95c1ceba571e0f0f,760 | 761,rule,createsAccount,181,185,setAccount | createAccount,"rule createsAccount(method f, address a) filtered { f ->
	!f.isView
		&& f.selector != createAccount().selector
		&& f.selector != setAccount(string,bytes,address,uint8,bytes32,bytes32).selector
} {
","setAccount (Lines 683-692),  | createAccount (Lines 198-207), ","  function setAccount(
    string calldata name,
    bytes calldata dataEncryptionKey,
    address walletAddress,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external onlyBeneficiaryAndNotRevoked {
    getAccounts().setAccount(name, dataEncryptionKey, walletAddress, v, r, s);
  }
 |   function createAccount() public returns (bool) {
    require(
      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),
      ""Account already exists or address is an authorized signer for another account""
    );
    Account storage account = accounts[msg.sender];
    account.exists = true;
    emit AccountCreated(msg.sender);
    return true;
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Allow only beneficiaries who have not been revoked to set account details, including name and encryption key, by invoking `setAccount` on another contract. Additionally, enable any user without an existing account or association as an authorized signer to create a new account."
a14efb5c31d183a49531a19fb24d01be,752 | 754,rule,address_can_authorize_two_addresses_legacy,96,120,authorizeSignerWithSignature | authorizeValidatorSigner,"rule address_can_authorize_two_addresses_legacy(address x, address d1, address d2)
rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
	authorizeValidatorSigner(e, d2, v2, r2, s2);  
	authorizeVoteSigner(e, d1, v1, r1, s1) at init;
","authorizeSignerWithSignature (Lines 407-417),  | authorizeValidatorSigner (Lines 461-470), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
 |   function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)
    external
    nonReentrant
  {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(!getValidators().isValidator(msg.sender), ""Cannot authorize validator signer"");
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Authorize a specific signer for a given role using a signature, then log this authorization. For validators, first, it reuses the signature-based authorization logic for a predefined validator role, then marks the signer as an indexed validator, ensuring the authorizing address isn't already a validator before emitting a relevant event."
a21117978d46dc8dc8c63bd0715b83ff,734 | 737,invariant,legacyRolesAreNotUsedInNewRoles,196,212,getOffchainStorageRoots | batchGetMetadataURL,"invariant legacyRolesAreNotUsedInNewRoles(address account, bytes32 role) 
	isLegacyRole(role) => _getDefaultSigner(account, role) == 0

/**
 * view functions in general should not revert.
 * Some exceptions and more refined revert-characteristics are provided.
 */
rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match
  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","getOffchainStorageRoots (Lines 299-324),  | batchGetMetadataURL (Lines 963-984), ","  function getOffchainStorageRoots(address account)
    external
    view
    returns (bytes memory, uint256[] memory)
  {
    require(isAccount(account), ""Unknown account"");
    uint256 numberRoots = offchainStorageRoots[account].length;
    uint256 totalLength = 0;
    for (uint256 i = 0; i < numberRoots; i++) {
      totalLength = totalLength.add(offchainStorageRoots[account][i].length);
    }

    bytes memory concatenated = new bytes(totalLength);
    uint256 lastIndex = 0;
    uint256[] memory lengths = new uint256[](numberRoots);
    for (uint256 i = 0; i < numberRoots; i++) {
      bytes storage root = offchainStorageRoots[account][i];
      lengths[i] = root.length;
      for (uint256 j = 0; j < lengths[i]; j++) {
        concatenated[lastIndex] = root[j];
        lastIndex++;
      }
    }

    return (concatenated, lengths);
  }
 |   function batchGetMetadataURL(address[] calldata accountsToQuery)
    external
    view
    returns (uint256[] memory, bytes memory)
  {
    uint256 totalSize = 0;
    uint256[] memory sizes = new uint256[](accountsToQuery.length);
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;
      totalSize = totalSize.add(sizes[i]);
    }

    bytes memory data = new bytes(totalSize);
    uint256 pointer = 0;
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {
        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];
        pointer = pointer.add(1);
      }
    }
    return (sizes, data);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Compile and return off-chain storage roots and metadata URLs for specified accounts. For each account, it concatenates off-chain storage roots and calculates their lengths, and similarly, compiles metadata URLs while tracking their sizes, efficiently aggregating and enabling batch queries of account-specific off-chain data."
ae2b1b890d73754684c90af39b339499,767 | 769 | 770 | 771,rule,cannotSetAuthorizedByWithoutSignatures,351,359,authorizeSignerWithSignature | authorizeValidatorSigner | authorizeValidatorSignerWithPublicKey | authorizeValidatorSignerWithKeys,"rule cannotSetAuthorizedByWithoutSignatures(method f) filtered { f -> 
	!f.isView 
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeAttestationSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSignerWithKeys(address,uint8,bytes32,bytes32,bytes,bytes,bytes).selector
		&& f.selector != authorizeValidatorSignerWithPublicKey(address,uint8,bytes32,bytes32,bytes).selector
		&& f.selector != authorizeVoteSigner(address,uint8,bytes32,bytes32).selector
} {
","authorizeSignerWithSignature (Lines 407-417),  | authorizeValidatorSigner (Lines 461-470),  | authorizeValidatorSignerWithPublicKey (Lines 481-496),  | authorizeValidatorSignerWithKeys (Lines 511-528), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
 |   function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)
    external
    nonReentrant
  {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(!getValidators().isValidator(msg.sender), ""Cannot authorize validator signer"");
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
 |   function authorizeValidatorSignerWithPublicKey(
    address signer,
    uint8 v,
    bytes32 r,
    bytes32 s,
    bytes calldata ecdsaPublicKey
  ) external nonReentrant {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(
      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),
      ""Failed to update ECDSA public key""
    );
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
 |   function authorizeValidatorSignerWithKeys(
    address signer,
    uint8 v,
    bytes32 r,
    bytes32 s,
    bytes calldata ecdsaPublicKey,
    bytes calldata blsPublicKey,
    bytes calldata blsPop
  ) external nonReentrant {
    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);
    setIndexedSigner(signer, ValidatorSigner);

    require(
      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),
      ""Failed to update validator keys""
    );
    emit ValidatorSignerAuthorized(msg.sender, signer);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Authorize validator signers by verifying signatures and optionally updating their ECDSA and BLS public keys. It first checks the signature, associates signers with specific roles, and then, based on the function called, updates either ECDSA or both ECDSA and BLS keys for validators."
c0e9b4ecf88680806e811df97fda19ef,749,invariant,accountToSignerAndInverseNewRoles,460,466,signerToAccount,"invariant accountToSignerAndInverseNewRoles(address a, address s, bytes32 r)	
	getIndexedSigner(a, r) == s => signerToAccount(s) == a 
{
		preserved {
			require a != s;
		}
}
","signerToAccount (Lines 791-799), ","  function signerToAccount(address signer) external view returns (address) {
    address authorizingAccount = authorizedBy[signer];
    if (authorizingAccount != address(0)) {
      return authorizingAccount;
    } else {
      require(isAccount(signer), ""Must first register address with Account.createAccount"");
      return signer;
    }
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Determine the account associated with a given signer. If the signer has been authorized by another account, return that authorizing account. Otherwise, ensure the signer has registered themselves as an account; if so, return the signer's address directly."
ea4ba5e30a4c062b8d537ef09b36af6b,766,rule,cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner,309,313,authorizeSignerWithSignature,"rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector	
} {
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Authorize a signer with a specific role by utilizing a digital signature (comprised of `v`, `r`, and `s` components) via the `authorizeAddressWithRole` function. It then marks the authorization as both started and completed within a mapping, and emits a `SignerAuthorized` event."
f0fd45ddb7814c4e7944892905b8c619,762 | 764,rule,viewFunctionsDoNotRevert,203,212,getOffchainStorageRoots | batchGetMetadataURL,"rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match

  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","getOffchainStorageRoots (Lines 299-324),  | batchGetMetadataURL (Lines 963-984), ","  function getOffchainStorageRoots(address account)
    external
    view
    returns (bytes memory, uint256[] memory)
  {
    require(isAccount(account), ""Unknown account"");
    uint256 numberRoots = offchainStorageRoots[account].length;
    uint256 totalLength = 0;
    for (uint256 i = 0; i < numberRoots; i++) {
      totalLength = totalLength.add(offchainStorageRoots[account][i].length);
    }

    bytes memory concatenated = new bytes(totalLength);
    uint256 lastIndex = 0;
    uint256[] memory lengths = new uint256[](numberRoots);
    for (uint256 i = 0; i < numberRoots; i++) {
      bytes storage root = offchainStorageRoots[account][i];
      lengths[i] = root.length;
      for (uint256 j = 0; j < lengths[i]; j++) {
        concatenated[lastIndex] = root[j];
        lastIndex++;
      }
    }

    return (concatenated, lengths);
  }
 |   function batchGetMetadataURL(address[] calldata accountsToQuery)
    external
    view
    returns (uint256[] memory, bytes memory)
  {
    uint256 totalSize = 0;
    uint256[] memory sizes = new uint256[](accountsToQuery.length);
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;
      totalSize = totalSize.add(sizes[i]);
    }

    bytes memory data = new bytes(totalSize);
    uint256 pointer = 0;
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {
        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];
        pointer = pointer.add(1);
      }
    }
    return (sizes, data);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,Functionality: Retrieve offchain storage roots and metadata URLs for specified accounts. The first function compiles and returns the concatenated offchain storage roots and their lengths for a given account. The second function aggregates and returns the sizes and concatenated metadata URLs for a batch of accounts.
ea4ba5e30a4c062b8d537ef09b36af6b,766,rule,cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner,309,313,authorizeSignerWithSignature,"rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector	
} {
","authorizeSignerWithSignature (Lines 407-417), ","  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)
    public
  {
    authorizeAddressWithRole(signer, role, v, r, s);
    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({
      started: true,
      completed: true
    });

    emit SignerAuthorized(msg.sender, signer, role);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Authorize a specified signer with a particular role after verifying the sender's signature, and mark the authorization process as both started and completed within the contract's storage. Then, emit an event to record the authorization of the signer for the specified role."
f0fd45ddb7814c4e7944892905b8c619,762 | 764,rule,viewFunctionsDoNotRevert,203,212,getOffchainStorageRoots | batchGetMetadataURL,"rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match

  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","getOffchainStorageRoots (Lines 299-324),  | batchGetMetadataURL (Lines 963-984), ","  function getOffchainStorageRoots(address account)
    external
    view
    returns (bytes memory, uint256[] memory)
  {
    require(isAccount(account), ""Unknown account"");
    uint256 numberRoots = offchainStorageRoots[account].length;
    uint256 totalLength = 0;
    for (uint256 i = 0; i < numberRoots; i++) {
      totalLength = totalLength.add(offchainStorageRoots[account][i].length);
    }

    bytes memory concatenated = new bytes(totalLength);
    uint256 lastIndex = 0;
    uint256[] memory lengths = new uint256[](numberRoots);
    for (uint256 i = 0; i < numberRoots; i++) {
      bytes storage root = offchainStorageRoots[account][i];
      lengths[i] = root.length;
      for (uint256 j = 0; j < lengths[i]; j++) {
        concatenated[lastIndex] = root[j];
        lastIndex++;
      }
    }

    return (concatenated, lengths);
  }
 |   function batchGetMetadataURL(address[] calldata accountsToQuery)
    external
    view
    returns (uint256[] memory, bytes memory)
  {
    uint256 totalSize = 0;
    uint256[] memory sizes = new uint256[](accountsToQuery.length);
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;
      totalSize = totalSize.add(sizes[i]);
    }

    bytes memory data = new bytes(totalSize);
    uint256 pointer = 0;
    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {
      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {
        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];
        pointer = pointer.add(1);
      }
    }
    return (sizes, data);
  }
",./celo_governance/specs/accounts.spec,celo_governance,,Yes,,"Functionality: Retrieve and concatenate offchain storage roots for a specified account and gather metadata URLs for a list of accounts, respectively. The first function combines roots into a single byte array with their lengths, while the second assembles URLs into a byte sequence, tracking each URL's size."
29b19cdda4094152b8f93f3c4753130e,628,rule,positiveSupply_imply_positiveAssets_other,159,167,initialize,"rule positiveSupply_imply_positiveAssets_other(method f) filtered {f ->
        f.selector != initialize(address,uint256,string,string,uint256).selector &&
        !harnessOnlyMethods(f) &&
        !f.isView &&
        !is_deposit_method(f) &&
        !is_mint_method(f) &&
        !is_withdraw_method(f) &&
        !is_redeem_method(f) 
        }
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/positiveSupply_imply_positiveAssets.spec,aave_vault,,Yes,,"Functionality: Initialize a contract with ownership, an ERC4626 vault, and ERC20 token settings using provided parameters. It ensures the owner and initial lock deposit are valid, sets the fee, approves unlimited token transfers to the AAVE_POOL, and handles an initial deposit transaction."
c54482f3f462be80b7a10a5bda2d44bf,637,rule,lastVaultBalance_LEQ_ATokenBalThis,63,68,initialize,"rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/lastVaultBal_LEQ_ATokenBalThis.spec,aave_vault,,Yes,,"Functionality: Initialize a contract by setting its ownership, initializing it with ERC4626 and ERC20 standards under specified names and symbols, enabling EIP712 functionalities, setting a fee, approving the maximum possible token amount to AAVE_POOL, and handling an initial deposit while ensuring the owner's address and the deposit are valid."
c79f6a9386ce1510d78fc0163111712a,636,invariant,inv_sumAllBalance_eq_totalSupply__underline,40,68,initialize,"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
    
// ******************************************************************************
// The main invariant of this file:
// _s.lastVaultBalance <= ATOKEN.balanceOf(theVault).
//
// Status: pass for all methods.
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","initialize (Lines 77-95), ","    function initialize(
        address owner,
        uint256 initialFee,
        string memory shareName,
        string memory shareSymbol,
        uint256 initialLockDeposit
    ) external initializer {
        require(owner != address(0), ""ZERO_ADDRESS_NOT_VALID"");
        require(initialLockDeposit != 0, ""ZERO_INITIAL_LOCK_DEPOSIT"");
        _transferOwnership(owner);
        __ERC4626_init(UNDERLYING);
        __ERC20_init(shareName, shareSymbol);
        __EIP712_init(shareName, ""1"");
        _setFee(initialFee);

        UNDERLYING.safeApprove(address(AAVE_POOL), type(uint256).max);

        _handleDeposit(initialLockDeposit, address(this), msg.sender, false);
    }
",./aave_vault/specs/lastVaultBal_LEQ_ATokenBalThis.spec,aave_vault,,Yes,,"Functionality: Initialize a contract by transferring ownership, initializing an ERC4626 token vault with an underlying asset, setting up an ERC20 token with custom name and symbol, initializing EIP712 for signed transactions, setting a fee, approving a maximum token amount to AAVE_POOL, and handling an initial deposit."
30e064abc6cb88cd2e83f83abbcc4556,635,rule,getCLMFees_LEQ_ATokenBAL_RW,201,207,withdrawFees,"rule getCLMFees_LEQ_ATokenBAL_RW(method f) filtered {f ->
        !harnessOnlyMethods(f) &&
        !f.isView &&
        (is_withdraw_method(f) || is_redeem_method(f) ||
         f.selector == withdrawFees(address,uint256).selector
        )
}
","withdrawFees (Lines 420-431), ","    function withdrawFees(address to, uint256 amount) public override onlyOwner {
        _accrueYield();
        require(amount <= _s.accumulatedFees, ""INSUFFICIENT_FEES""); // will underflow below anyway, error msg for clarity

        _s.accumulatedFees -= uint128(amount);

        ATOKEN.transfer(to, amount);

        _s.lastVaultBalance = uint128(ATOKEN.balanceOf(address(this)));

        emit FeesWithdrawn(to, amount, _s.lastVaultBalance, _s.accumulatedFees);
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,aave_vault,,Yes,,"Functionality: Deduct a specified amount of fees from the accumulated fees and transfer them to a given address. It updates the vault's last balance after performing these actions, and emits an event detailing the withdrawal, including recipient, amount withdrawn, last vault balance, and remaining accumulated fees."
393035f48fc830084fddfb8c4b026cc1,629 | 630 | 631,invariant,inv_sumAllBalance_eq_totalSupply__underline,56,148,depositATokensWithSig | mintWithATokensWithSig | getClaimableFees,"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
// ******************************************************************************
// The following invariant is proved in lastVaultBalance_OK.spec
invariant lastVaultBalance_OK()
    getLastVaultBalance() <= _AToken.balanceOf(currentContract)
    
// Proving the solvency rule:
//           getClaimableFees() <= ATOKEN.balanceOf(theVault).
// We do it by proving the stronger invariant:
//           max_possible_fees() <= _AToken.balanceOf(currentContract)
// 
// In this file we prove all method exept the following
// withraw*\redeem*\withdrawFees. (those methods are treated in fee_LEQ_ATokenBal-RW.spec
// Note: the reason for the seperation is that different methods require different summarizations.
//
// Status: pass for all methods that are checked in this file, but FAIL of the others.
//         See in fee_LEQ_ATokenBal-RW.spec
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
function getCLMFees_LEQ_ATokenBAL_1(method f) {
    env e;
    require e.msg.sender != currentContract;
    require getFee() <= SCALE();  // SCALE is 10^18
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require totalSupply() <= maxUint128();
    require Underlying.totalSupply() <= maxUint128();
    require _AToken.scaledTotalSupply() <= maxUint128();
    requireInvariant inv_sumAllBalance_eq_totalSupply__underline(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply__atoken(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply();
    requireInvariant lastVaultBalance_OK();
    uint256 ind = _SymbolicLendingPoolL1.getLiquidityIndex();
    uint256 s_bal = _AToken.scaledBalanceOf(currentContract);
    // The following require means: (s_bal - ass/ind)*ind == s_bal*ind - ass
    require (forall uint256 ass.
             rayMul_g(to_uint256(s_bal-rayDiv_g(ass,ind)),ind) == to_uint256(rayMul_g(s_bal,ind)-ass)
            );
    // The following require means: (x/ind+z)*ind == x+z*ind 
    require (forall uint256 x. forall uint256 ind. forall uint256 z.
             rayMul_g(to_uint256(rayDiv_g(x,ind)+z),ind) == to_uint256(x+rayMul_g(z,ind))
    require(max_possible_fees() <= _AToken.balanceOf(currentContract));
    if (f.selector == depositATokensWithSig(uint256,address,address,
                                            (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 assets; address receiver; address depositor;
        _ATokenVaultHarness.EIP712Signature sig;
        
        require depositor != currentContract;
        depositATokensWithSig(e,assets,receiver,depositor,sig);
    }
    else if (f.selector == mintWithATokensWithSig(uint256,address,address,
                                             (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 shares; address receiver; address depositor;
        mintWithATokensWithSig(e, shares, receiver, depositor, sig);
    else {
        calldataarg args;
        f(e,args);
    //    require Underlying.totalSupply() <= maxUint128();
    //require _AToken.scaledTotalSupply() <= maxUint128();
    assert(max_possible_fees() <= _AToken.balanceOf(currentContract));
}
","depositATokensWithSig (Lines 141-167),  | mintWithATokensWithSig (Lines 202-228),  | getClaimableFees (Lines 466-478), ","    function depositATokensWithSig(
        uint256 assets,
        address receiver,
        address depositor,
        EIP712Signature calldata sig
    ) public override returns (uint256) {
        unchecked {
            MetaTxHelpers._validateRecoveredAddress(
                MetaTxHelpers._calculateDigest(
                    keccak256(
                        abi.encode(
                            DEPOSIT_ATOKENS_WITH_SIG_TYPEHASH,
                            assets,
                            receiver,
                            depositor,
                            _sigNonces[depositor]++,
                            sig.deadline
                        )
                    ),
                    _domainSeparatorV4()
                ),
                depositor,
                sig
            );
        }
        return _handleDeposit(assets, receiver, depositor, true);
    }
 |     function mintWithATokensWithSig(
        uint256 shares,
        address receiver,
        address depositor,
        EIP712Signature calldata sig
    ) public override returns (uint256) {
        unchecked {
            MetaTxHelpers._validateRecoveredAddress(
                MetaTxHelpers._calculateDigest(
                    keccak256(
                        abi.encode(
                            MINT_WITH_ATOKENS_WITH_SIG_TYPEHASH,
                            shares,
                            receiver,
                            depositor,
                            _sigNonces[depositor]++,
                            sig.deadline
                        )
                    ),
                    _domainSeparatorV4()
                ),
                depositor,
                sig
            );
        }
        return _handleMint(shares, receiver, depositor, true);
    }
 |     function getClaimableFees() public view override returns (uint256) {
        uint256 newVaultBalance = ATOKEN.balanceOf(address(this));

        // Skip computation if there is no yield
        if (newVaultBalance <= _s.lastVaultBalance) {
            return _s.accumulatedFees;
        }

        uint256 newYield = newVaultBalance - _s.lastVaultBalance;
        uint256 newFees = newYield.mulDiv(_s.fee, SCALE, MathUpgradeable.Rounding.Down);

        return _s.accumulatedFees + newFees;
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,aave_vault,,Yes,,"Functionality: Implement two methods for depositing A tokens and minting shares with signatures for authentication, and another method to calculate claimable fees based on the yield generated, applying fees, and ensuring operations with nonces for security and avoiding replay attacks."
5b043ba29f63316fca2d8ddc2f1ed794,634,rule,getCLMFees_LEQ_ATokenBAL_DM_other,150,156,withdrawFees,"rule getCLMFees_LEQ_ATokenBAL_DM_other(method f) filtered {f ->
    !harnessOnlyMethods(f) &&
    !f.isView &&
    !is_withdraw_method(f) &&
    !is_redeem_method(f) &&
    f.selector != withdrawFees(address,uint256).selector
}
","withdrawFees (Lines 420-431), ","    function withdrawFees(address to, uint256 amount) public override onlyOwner {
        _accrueYield();
        require(amount <= _s.accumulatedFees, ""INSUFFICIENT_FEES""); // will underflow below anyway, error msg for clarity

        _s.accumulatedFees -= uint128(amount);

        ATOKEN.transfer(to, amount);

        _s.lastVaultBalance = uint128(ATOKEN.balanceOf(address(this)));

        emit FeesWithdrawn(to, amount, _s.lastVaultBalance, _s.accumulatedFees);
    }
",./aave_vault/specs/fees_LEQ_ATokenBal.spec,aave_vault,,Yes,,"Functionality: Accrue yield, then check if the specified withdrawal amount is less than or equal to the accumulated fees. Deduct the withdrawal amount from the accumulated fees and transfer it to the specified address. Update the vault balance and emit an event detailing the fees withdrawal transaction."
349bca8cb526de1d77091541cc2e8d49,654 | 658,rule,previewWithdraw_amount_check,172,195,previewWithdraw | _maxAssetsSuppliableToAave,"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewDeposit_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewDeposit(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewDeposit(e2, assets);
    assert (previewShares1 == previewShares2);
","previewWithdraw (Lines 393-396),  | _maxAssetsSuppliableToAave (Lines 571-600), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function _maxAssetsSuppliableToAave() internal view returns (uint256) {
        // returns 0 if reserve is not active, frozen, or paused
        // returns max uint256 value if supply cap is 0 (not capped)
        // returns supply cap - current amount supplied as max suppliable if there is a supply cap for this reserve

        AaveDataTypes.ReserveData memory reserveData = AAVE_POOL.getReserveData(address(UNDERLYING));

        uint256 reserveConfigMap = reserveData.configuration.data;
        uint256 supplyCap = (reserveConfigMap & ~AAVE_SUPPLY_CAP_MASK) >> AAVE_SUPPLY_CAP_BIT_POSITION;

        if (
            (reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) ||
            (reserveConfigMap & ~AAVE_FROZEN_MASK != 0) ||
            (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)
        ) {
            return 0;
        } else if (supplyCap == 0) {
            return type(uint256).max;
        } else {
            // Reserve's supply cap - current amount supplied
            // See similar logic in Aave v3 ValidationLogic library, in the validateSupply function
            // https://github.com/aave/aave-v3-core/blob/a00f28e3ad7c0e4a369d8e06e0ac9fd0acabcab7/contracts/protocol/libraries/logic/ValidationLogic.sol#L71-L78
            uint256 currentSupply = WadRayMath.rayMul(
                (ATOKEN.scaledTotalSupply() + uint256(reserveData.accruedToTreasury)),
                reserveData.liquidityIndex
            );
            uint256 supplyCapWithDecimals = supplyCap * 10 ** decimals();
            return supplyCapWithDecimals > currentSupply ? supplyCapWithDecimals - currentSupply : 0;
        }
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the maximum amount that can be withdrawn or supplied to Aave within certain conditions. It retrieves reserve data, evaluates the reserve's status (active, frozen, or paused), and computes based on the supply cap and current amount supplied."
35a5ebc4fb4b2dc3301c758b625a877c,643,rule,must_not_revert_unless_large_input__convertToAssets,114,124,previewWithdraw,"rule must_not_revert_unless_large_input__convertToAssets() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 shares;
    require (shares <= maxUint128());
    
    convertToAssets@withrevert(e, shares);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the maximum amount of shares withdrawable given a specific amount of assets, using the maximum withdrawable assets from Aave and converting this value to shares with rounding up, ensuring a return of zero if the maximum withdrawable is zero."
4879ee50b1caf11afce7225570d289b6,674,rule,previewWithdraw_amount_check,273,302,previewWithdraw,"// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the quantity of shares equivalent to a specified amount of assets that can be withdrawn, taking into account the maximum assets withdrawable from Aave. This calculation implements rounding up for the share conversion process."
5c655d719ae080c15b2a709647a14e2e,668 | 672,rule,previewWithdraw_amount_check,241,264,previewWithdraw | _maxAssetsSuppliableToAave,"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewMint_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewMint(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewMint(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
","previewWithdraw (Lines 393-396),  | _maxAssetsSuppliableToAave (Lines 571-600), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function _maxAssetsSuppliableToAave() internal view returns (uint256) {
        // returns 0 if reserve is not active, frozen, or paused
        // returns max uint256 value if supply cap is 0 (not capped)
        // returns supply cap - current amount supplied as max suppliable if there is a supply cap for this reserve

        AaveDataTypes.ReserveData memory reserveData = AAVE_POOL.getReserveData(address(UNDERLYING));

        uint256 reserveConfigMap = reserveData.configuration.data;
        uint256 supplyCap = (reserveConfigMap & ~AAVE_SUPPLY_CAP_MASK) >> AAVE_SUPPLY_CAP_BIT_POSITION;

        if (
            (reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) ||
            (reserveConfigMap & ~AAVE_FROZEN_MASK != 0) ||
            (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)
        ) {
            return 0;
        } else if (supplyCap == 0) {
            return type(uint256).max;
        } else {
            // Reserve's supply cap - current amount supplied
            // See similar logic in Aave v3 ValidationLogic library, in the validateSupply function
            // https://github.com/aave/aave-v3-core/blob/a00f28e3ad7c0e4a369d8e06e0ac9fd0acabcab7/contracts/protocol/libraries/logic/ValidationLogic.sol#L71-L78
            uint256 currentSupply = WadRayMath.rayMul(
                (ATOKEN.scaledTotalSupply() + uint256(reserveData.accruedToTreasury)),
                reserveData.liquidityIndex
            );
            uint256 supplyCapWithDecimals = supplyCap * 10 ** decimals();
            return supplyCapWithDecimals > currentSupply ? supplyCapWithDecimals - currentSupply : 0;
        }
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Determine the maximum number of assets that can be withdrawn from an Aave vault by converting the assets to shares, while accounting for Aave's reserve conditions such as being active, not frozen, or paused, and adhering to the supply cap if present."
8191ca744c3f84549e6fec22b86ad9b0,639,rule,must_not_revert_unless_large_input__convertToShares,94,104,previewWithdraw,"rule must_not_revert_unless_large_input__convertToShares() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 assets;
    require (assets <= maxUint128());
    
    convertToShares@withrevert(e, assets);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the maximum amount of shares that can be withdrawn from Aave, given a specified amount of assets. If the maximum withdrawable amount from Aave is non-zero, it compares this with the requested assets, takes the lesser value, and converts it to shares, rounding up the result."
8ed1f1ae4862c858247c91be7671c46d,663,rule,previewMint_amount_check,211,233,previewWithdraw,"rule previewMint_amount_check() {
    env e1;
    env e2;
    uint256 shares;
    address receiver;
    uint256 previewAssets;
    uint256 assets;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address owner;
    uint256 previewShares;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
        
    previewAssets = previewMint(e1,shares);
    require (shares <= convertToShares(e2,maxDeposit(receiver)) => convertToAssets(e2,shares) <= maxDeposit(receiver));
    assets = mint(e2, shares, receiver);
    assert previewAssets == assets || previewAssets == assets+1 || previewAssets+1 == assets, ""preview should be equal to actual - mint"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Determine the maximum number of shares that can be withdrawn given a specific amount of assets, accounting for the maximum assets withdrawable from Aave. If no assets can be withdrawn, return zero; otherwise, convert the minimum of the requested assets or the maximum withdrawable assets to shares, rounding up."
9f3f3b251f9be3f33c609ba44faaa108,678,rule,previewWithdraw_amount_check,310,333,previewWithdraw,"  The following rule checks that the value returned by the previewWithdraw depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewWithdraw_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewWithdraw(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewWithdraw(e2, assets);
    assert (previewShares1 == previewShares2);
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Determine the maximum amount of assets that can be withdrawn from an ERC4626-compatible Aave token vault, converting the lesser of the requested assets or the maximum withdrawable assets into their equivalent in shares, using upward rounding for precision."
b625a597ec38859d4d6517a24b574beb,687 | 688,rule,previewRedeem_has_NO_threshold,386,410,previewWithdraw | previewRedeem,"  The following rule checks that the value returned by the previewRedeem depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewRedeem_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewRedeem(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewRedeem(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
","previewWithdraw (Lines 393-396),  | previewRedeem (Lines 399-402), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
 |     function previewRedeem(uint256 shares) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToAssets(shares, MathUpgradeable.Rounding.Down).min(maxWithdrawable);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the amount of shares corresponding to a specified amount of assets for withdrawal by considering the maximum withdrawable amount from Aave, and determine the assets equivalent to a specific number of shares for redemption, factoring in Aave's maximum withdrawable limit."
b6fa1373095e549fac0067c5d3144d3c,683,rule,previewRedeem_amount_check,345,379,previewRedeem,"// rule to check the following for the previewRedeem function:
// 1. MUST return as CLOSE to and no more than the exact amount of assets that would be
//    withdrawn in a redeem call in the same transaction.
// I.e. redeem should return the same or more assets as previewRedeem if called in the
// same transaction.

// STATUS: pass
// The amount returned by previewRedeem is exactly equal to that returned by the redeem function.
rule previewRedeem_amount_check(env e1, env e2){
    uint256 shares;
    address receiver;
    address owner;
    uint256 previewAssets;
    uint256 assets;
    
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require (getFee() <= SCALE());  // SCALE is 10^18
    previewAssets = previewRedeem(e1, shares);
    require (shares <= convertToShares(e2,maxAssetsWithdrawableFromAave()) =>
                     convertToAssets(e2,shares) <= maxAssetsWithdrawableFromAave());
    assets = redeem(e2, shares, receiver, owner);
    assert previewAssets == assets 
        || previewAssets + 1 == assets
        //        || previewAssets + 2 == assets        
        ,""preview should the same as the actual assets received"";
}
","previewRedeem (Lines 399-402), ","    function previewRedeem(uint256 shares) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToAssets(shares, MathUpgradeable.Rounding.Down).min(maxWithdrawable);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Calculate the maximum amount of assets that can be redeemed from Aave with the given shares. If no assets can be withdrawn (maxWithdrawable == 0), return 0. Otherwise, convert the shares to assets considering down rounding and ensure it does not exceed the maximum withdrawable amount from Aave."
dd91771c89495f05befa5a3e85051667,649,rule,previewDeposit_amount_check,142,165,previewWithdraw,"rule previewDeposit_amount_check() {
    env e1;
    env e2;
    uint256 assets;
    address receiver;   
    uint256 previewShares;
    uint256 shares;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address receiver;
    address owner;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
    previewShares = previewDeposit(e1, assets);
    shares = deposit(e2, assets, receiver);
    assert previewShares == shares, ""preview shares should be equal to actual shares"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Determine the maximum shares that can be withdrawn based on the specified amount of assets or the maximum withdrawable assets from Aave, whichever is lower, by converting assets to shares, considering upwards rounding for accurate share representation."
dd91771c89495f05befa5a3e85051667,649,rule,previewDeposit_amount_check,142,165,previewWithdraw,"rule previewDeposit_amount_check() {
    env e1;
    env e2;
    uint256 assets;
    address receiver;   
    uint256 previewShares;
    uint256 shares;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address receiver;
    address owner;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
    previewShares = previewDeposit(e1, assets);
    shares = deposit(e2, assets, receiver);
    assert previewShares == shares, ""preview shares should be equal to actual shares"";
","previewWithdraw (Lines 393-396), ","    function previewWithdraw(uint256 assets) public view override(ERC4626Upgradeable, IATokenVault) returns (uint256) {
        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();
        return maxWithdrawable == 0 ? 0 : _convertToShares(maxWithdrawable.min(assets), MathUpgradeable.Rounding.Up);
    }
",./aave_vault/specs/erc4626.spec,aave_vault,,Yes,,"Functionality: Determine the maximum shares withdrawable from an asset pool by first identifying the maximum assets that can be withdrawn from Aave, then converting the lower of this maximum or the specified assets into shares, rounding up during conversion."
13cbf3ddc9932f6a669ae88c393a9252,621 | 622,rule,burnNoChangeToOther,213,225,balanceOf | burn,"rule burnNoChangeToOther(address user, uint256 amount, uint256 index, address other) {
  
	require other != user;
	
	env e;
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, amount, index);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust a user's balance and the total supply when burning tokens, taking into account accrued interest and average stable rates. It calculates balance increases, updates average rates, and either mints or burns the difference between actual and increased balances, emitting relevant events."
167a69be889b9a08f5691e704616a1e9,615 | 616,rule,integrityMint,182,199,mint | balanceOf,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	uint256 index = gRNVB();
	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e, delegatedUser, a, x, index);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);

	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
    assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
    // assert balanceAfter == balancebefore+x;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Facilitate minting of tokens on behalf of a user, adjust the average stable rate and the user's stable rate based on the newly minted amount, update the total supply, and emit relevant events. Additionally, compute an account's balance by considering compounded interest based on the user's stable rate and the time elapsed since the last update."
2686a2d05949073ce79d831e9c12b000,606,rule,integrityDelegationWithSig,111,116,delegationWithSig,"rule integrityDelegationWithSig(address delegator, address delegatee, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) {
    env e;
    uint256 oldNonce = nonces(e, delegator);
    delegationWithSig(e, delegator, delegatee, value, deadline, v, r, s);
    assert nonces(e, delegator) == oldNonce + 1 && borrowAllowance(e, delegator, delegatee) == value;
}
","delegationWithSig (Lines 43-68), ","  function delegationWithSig(
    address delegator,
    address delegatee,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external {
    require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[delegator];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(
          abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline)
        )
      )
    );
    require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[delegator] = currentValidNonce + 1;
    _approveDelegation(delegator, delegatee, value);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Verify a delegate's authority using EIP-712 typed data signature by checking if the delegation request is from the genuine delegator and within the valid deadline, then increment the delegator's nonce and approve the delegation of a specified value to the delegatee."
4622ab7641b781fb1314bb8cca221c4c,619 | 620,rule,burnZeroDoesntChangeBalance,202,208,balanceOf | burn,"rule burnZeroDoesntChangeBalance(address u, uint256 index) {
	env e;
	uint256 balanceBefore = balanceOf(u);
	invoke burn(e, u, 0, index);
	uint256 balanceAfter = balanceOf(u);
	assert balanceBefore == balanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: This code manages the balance adjustments and interest calculations for a decentralized finance (DeFi) protocol, facilitating the accurate accrual of interest on user balances, and dynamic supply adjustments through burning or minting tokens based on user interactions, ensuring equitable interest distribution and supply integrity."
53351ec08b433d2bbb6f664070cbd913,602 | 603 | 604,rule,inverseMintBurn,102,109,mint | balanceOf | burn,"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 index) {
	env e;
	uint256 balancebefore = balanceOf(a);
	mint(e, delegatedUser, a, amount, index);
	burn(e, a, amount, index);
	uint256 balanceAfter = balanceOf(a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Manage the minting and burning of tokens within a pool, adjusting user balances and rates, calculating balance increases due to accrued interest, and ensuring ledger consistency. It also dynamically updates total supply, user rates, and triggers events to log these operations."
5d71b4f35b768c528454239a3254d2c4,609 | 610,rule,integrityOfBurn,122,135,balanceOf | burn,"rule integrityOfBurn(address u, uint256 amount) {
	env e;
	uint256 index = gRNVB();
	uint256 balanceBeforeUser = balanceOf(u);
	uint256 totalSupplyBefore = totalSupply(e); 

	burn(e, u, amount, index);
	
	uint256 balanceAfterUser = balanceOf(u);
	uint256 totalSupplyAfter = totalSupply(e);
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust user balance and total supply upon burning tokens, accounting for accrued interest. It recalculates the average stable rate after token burn, distinguishes between total burn or partial, and emits events for minting or burning actions, updating user and supply parameters accordingly."
6f0a788c11d1de327d863a034e8efbe5,611 | 612,rule,additiveBurn,141,156,balanceOf | burn,"rule additiveBurn(address user1, address user2, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));
	require user1 != currentContract && user2 != currentContract;

    burn(e, user1, x, index);
	burn(e, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	burn(e, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust a user's balance and the total supply of a financial instrument by calculating interest accrued based on a stable rate, and either mint or burn tokens to reflect changes resulting from a transaction, while also updating average stable rates and timestamps accordingly."
7eb0e2b00764b010181008daff9b4e44,613 | 614,rule,additiveMint,162,176,mint | balanceOf,"rule additiveMint(address user1, address user2, address user3, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));

    mint(e, user3, user1, x, index);
	mint(e, user3, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	mint(e, user3, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: The provided code facilitates the process of minting new tokens on behalf of a user, adjusting borrow allowances, updating account balances with interest accruals, and recalculating the average stable rate based on newly minted amounts and existing balances, emitting relevant events in the process."
d3013503d662a8b808fa336b7b9f6f3a,623 | 624,rule,mintNoChangeToOther,230,247,mint | balanceOf,"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 index, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint256 userBalanceBefore = balanceOf(user);
	uint256 otherBalanceBefore = balanceOf(other);
	mint(e, user, onBehalfOf, amount, index);
  	uint256 userBalanceAfter = balanceOf(user);
	uint256 otherBalanceAfter = balanceOf(other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter ; 
	}
	assert otherBalanceBefore == otherBalanceAfter ;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/VariableDebtToken.spec,aave_v3,,Yes,,"Functionality: Update a user's balance and rates upon minting new tokens, considering the differences in borrowing allowances between users. It calculates the user's new balance with interest, adjusts the total supply, updates average and individual stable rates, and emits relevant events for transparency and tracking."
1a75d08adb77634e15df9b13ecd29a61,457 | 458 | 459 | 461 | 463,invariant,integrityOfisBorrowingOne,113,122,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Check user's assets status within a financial protocol, determining whether assets are being used as collateral, borrowed, or involved in any borrowing/collateral activities, through bitwise operations on a user configuration map based on the asset's reserve index."
34abe06e6ad3fdef0c1c59516bf3ec68,437 | 438 | 439 | 441 | 443,invariant,integrityOfisUsingAsCollateralOne,91,101,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine the user's interaction with reserves in a decentralized finance protocol by checking if assets are being used as collateral or if there is any borrowing activity. These functions facilitate querying whether specific reserves are utilized for borrowing, used as collateral, or if any such activities exist across all reserves."
3f5b2aa80e0c2eda650a4fc543aebf25,514,rule,integrityOfisBorrowingOne,107,111,isBorrowing,"// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
// }
","isBorrowing (Lines 87-95), ","  function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine if borrowing is active on a given reserve by checking a specific bit within a user's configuration map. This involves shifting and masking operations to inspect the correct bit corresponding to the reserve index, ensuring it matches a borrowing state."
4bd533864b70599a860629e3974e5edb,467 | 468 | 469 | 471 | 473,invariant,integrityOfisBorrowingAny,124,132,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()

// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Manage and query a user's borrowing and collateral status for specific reserves in a decentralized finance system. The functions check if a user is borrowing, using an asset as collateral, or performing either action for any reserve by manipulating bits in a stored data map."
568f1c053d910601ac7880d98abeb0b3,510,rule,integrityOfisUsingAsCollateralOne,85,89,isUsingAsCollateral,"// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// }
","isUsingAsCollateral (Lines 103-111), ","  function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,Functionality: Check if a specific reserve is being used as collateral by a user within a decentralized finance platform. This is done by shifting the user's configuration data to extract and evaluate a flag indicating collateral usage at the specified reserve index.
5b6710c4341e78f1615e26805e65fcc4,518 | 519 | 520 | 522 | 524,rule,integrityOfEmpty,128,132,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"// rule integrityOfEmpty(uint256 reserveIndex){
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine the borrowing and collateral usage status of a user within a financial protocol. The code checks if a user is using assets as collateral, borrowing, or engaging in any of these activities, leveraging bitwise operations to query the user's configuration stored as a compact data structure."
6cba815f971eb840c0cfa029125938b9,427 | 428 | 429 | 431 | 433,invariant,isUsingAsCollateralOrBorrowing,81,89,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine user interactions with reserves by verifying if they are using assets as collateral, borrowing, or engaging in either activity for any reserve. It manipulates bits within a user configuration map to check user status per reserve, utilizing bitwise operations for efficiency."
6fd5cce75786d7ead68351c53eb2f954,512 | 513,rule,integrityOfisUsingAsCollateralAny,97,101,isUsingAsCollateral | isUsingAsCollateralAny,"// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
// }
","isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135), ","  function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,Functionality: Determine if a user is utilizing a particular reserve as collateral and if they are using any reserve as collateral within a decentralized finance platform. This involves bit manipulation on a configuration map to efficiently check collateral status against a specific reserve or any reserves.
7798a3fdc9ae53e39a087a9e6cfaf586,492 | 493 | 494,rule,setBorrowingNoChangeToOther,27,44,setBorrowing | isBorrowing | isUsingAsCollateral,"rule setBorrowingNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool borrowing)
rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
","setBorrowing (Lines 27-41),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111), ","  function setBorrowing(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool borrowing
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << (reserveIndex << 1);
      if (borrowing) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: The given code manipulates and checks bits within an integer to track borrowing status and collateral usage of a user across various reserves. It enables setting and querying a user's borrowing status and if a reserve is used as collateral, using bitwise operations."
7d6535af59d06cae937ec367dae45f6e,497 | 498 | 499,rule,setCollateralNoChangeToOther,54,71,setUsingAsCollateral | isBorrowing | isUsingAsCollateral,"rule setCollateralNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool usingAsCollateral)
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	setUsingAsCollateral(reserveIndex, usingAsCollateral);
rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
","setUsingAsCollateral (Lines 49-63),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111), ","  function setUsingAsCollateral(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool usingAsCollateral
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << ((reserveIndex << 1) + 1);
      if (usingAsCollateral) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Manage and query a user's collateral usage and borrowing status for a specific financial reserve. It allows setting or revoking an asset as collateral, checking if an asset is being used as collateral, and verifying if a user is borrowing against a particular reserve."
b174800f92d62fa67f582c738e21f3a8,500 | 501 | 502 | 504 | 506,rule,IntegrityOfisUsingAsCollateralOrBorrowing,74,79,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"// rule IntegrityOfisUsingAsCollateralOrBorrowing(uint256 reserveIndex, bool borrowing, bool usingAsCollateral){
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// 	bool reserveBorrowing =  isBorrowing(reserveIndex);
// 	bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert ((reserveBorrowing || reserveCollateral) <=> borrowingOrCollateral);
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine if a user is using an asset as collateral, borrowing, or engaging in any such financial actions within a specific reserve, leveraging bit manipulation on a user's configuration map to efficiently query their lending platform activities."
b5b7950b2cb46d3bf99714a167fe18b5,447 | 448 | 449 | 451 | 453,invariant,integrityOfisUsingAsCollateralAny,103,111,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()

// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine whether a user is using assets as collateral, borrowing, or engaging in any of such activities for a specific reserve index within a decentralized finance platform, by manipulating bit masks and shifts on user configuration data stored compactly."
b8f3cd8c54fcd2be6a0f2d9758ce2daf,516 | 517,rule,integrityOfisBorrowingAny,118,122,isBorrowing | isBorrowingAny,"// rule integrityOfisBorrowingAny(uint256 reserveIndex){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
// }
","isBorrowing (Lines 87-95),  | isBorrowingAny (Lines 153-155), ","  function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine if a user is borrowing from a specific reserve or any reserve by inspecting bits in a user's configuration map. For a specific reserve, it shifts and masks the data to check a bit; for any borrowing, it applies a mask to see if any borrowing bit is set."
cb728ea63ff74380f5198b5dc966d384,495 | 496,rule,setUsingAsCollateral,47,51,setUsingAsCollateral | isUsingAsCollateral,"rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
{
	setUsingAsCollateral(reserveIndex, usingAsCollateral);
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
","setUsingAsCollateral (Lines 49-63),  | isUsingAsCollateral (Lines 103-111), ","  function setUsingAsCollateral(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool usingAsCollateral
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << ((reserveIndex << 1) + 1);
      if (usingAsCollateral) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Store or retrieve the status of an asset being used as collateral by a user within a DeFi platform. Update a bit within a compact data structure to indicate the collateral status, and efficiently check this status based on the asset's index."
de9b73e2d0acb6c986c9cda6f3cedfea,490 | 491,rule,setBorrowing,20,24,setBorrowing | isBorrowing,"rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
","setBorrowing (Lines 27-41),  | isBorrowing (Lines 87-95), ","  function setBorrowing(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool borrowing
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << (reserveIndex << 1);
      if (borrowing) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Enable or disable a user's borrowing status for a specific reserve index within a decentralized finance protocol. It verifies the reserve index's validity, modifies the user's configuration map to reflect the borrowing status, and checks if a user is currently borrowing from a specific reserve."
e99ec1e0380c9662c818d1564805722b,477 | 478 | 479 | 481 | 483,invariant,integrityOfEmpty,134,147,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: The provided code defines functions that determine if a user is using assets as collateral, borrowing, or doing either for a specific reserve index within a lending platform. It checks users' configurations against binary masks to reveal their engagement status with reserve assets."
de9b73e2d0acb6c986c9cda6f3cedfea,490 | 491,rule,setBorrowing,20,24,setBorrowing | isBorrowing,"rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
","setBorrowing (Lines 27-41),  | isBorrowing (Lines 87-95), ","  function setBorrowing(
    DataTypes.UserConfigurationMap storage self,
    uint256 reserveIndex,
    bool borrowing
  ) internal {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      uint256 bit = 1 << (reserveIndex << 1);
      if (borrowing) {
        self.data |= bit;
      } else {
        self.data &= ~bit;
      }
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Manage and check user borrowing status for specific reserves in a financial protocol. ""setBorrowing"" updates a user's borrowing status for a given reserve index, and ""isBorrowing"" checks if a user is currently borrowing from a specified reserve."
e99ec1e0380c9662c818d1564805722b,477 | 478 | 479 | 481 | 483,invariant,integrityOfEmpty,134,147,isUsingAsCollateralOrBorrowing | isBorrowing | isUsingAsCollateral | isUsingAsCollateralAny | isBorrowingAny,"invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","isUsingAsCollateralOrBorrowing (Lines 71-79),  | isBorrowing (Lines 87-95),  | isUsingAsCollateral (Lines 103-111),  | isUsingAsCollateralAny (Lines 131-135),  | isBorrowingAny (Lines 153-155), ","  function isUsingAsCollateralOrBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 3 != 0;
    }
  }
 |   function isBorrowing(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> (reserveIndex << 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateral(
    DataTypes.UserConfigurationMap memory self,
    uint256 reserveIndex
  ) internal pure returns (bool) {
    unchecked {
      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
    }
  }
 |   function isUsingAsCollateralAny(
    DataTypes.UserConfigurationMap memory self
  ) internal pure returns (bool) {
    return self.data & COLLATERAL_MASK != 0;
  }
 |   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
    return self.data & BORROWING_MASK != 0;
  }
",./aave_v3/specs/UserConfiguration.spec,aave_v3,,Yes,,"Functionality: Determine a user's interaction with a reserve in a DeFi protocol, specifically whether they are using a reserve as collateral, borrowing from it, doing either, or engaging in any such activities across all reserves, by analyzing bit patterns in a user configuration map."
21cf88eede76c8185d7fd5c5375f9b65,579 | 580,rule,integrityMint,153,163,mint | balanceOf,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e,a);
	mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Calculate and update the stable rate, average stable rate, and total supply when a user mints tokens, taking into account balance increases due to accrued interest. Additionally, adjust token balances for the minting user, considering the effects of compounding interest over time."
3c193d5534d23c852fd46919f5542e64,589 | 590,rule,additiveMint,242,258,mint | balanceOf,"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	mint(e, delegatedUser, a, x, index);
	mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	
	uint256 t = x + y;
	mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Calculate and update the account balances during mint operations, adjusting for interest rate changes and balance increases. It modifies user's stable rate based on new mints while maintaining the overall average stable rate and total supply. Additionally, it emits important transaction details for transparency."
510e4c7b63ea5358de0d810e6fcc4262,582,rule,integrityDelegationWithSig,176,181,delegationWithSig,"rule integrityDelegationWithSig(address delegator, address delegatee, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) {
    env e;
    uint256 oldNonce = nonces(e, delegator);
    delegationWithSig(e, delegator, delegatee, value, deadline, v, r, s);
    assert nonces(e, delegator) == oldNonce + 1 && borrowAllowance(e, delegator, delegatee) == value;
}
","delegationWithSig (Lines 43-68), ","  function delegationWithSig(
    address delegator,
    address delegatee,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external {
    require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[delegator];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(
          abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline)
        )
      )
    );
    require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[delegator] = currentValidNonce + 1;
    _approveDelegation(delegator, delegatee, value);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Verify a delegatee's authority via an EIP-712 signature from the delegator, ensuring the request is within deadline and authenticated through signature recovery. Increment the delegator's nonce and approve the delegation of a specified value to the delegatee, enforcing checks against zero address and invalid expiration."
6933eff4e13cc9ad6d72fa013dfbef2b,596 | 597,rule,mintNoChangeToOther,312,333,mint | balanceOf,"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 rate, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint128 userDataBefore = additionalData(user);
	uint128 otherDataBefore = additionalData(other);
	uint256 userBalanceBefore = balanceOf(e, user);
	uint256 otherBalanceBefore = balanceOf(e, other);
	mint(e, user, onBehalfOf, amount, rate);
  uint128 userDataAfter = additionalData(user);
	uint128 otherDataAfter = additionalData(other);
	uint256 userBalanceAfter = balanceOf(e, user);
	uint256 otherBalanceAfter = balanceOf(e, other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter && userDataBefore == userDataAfter; 
	}
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Update the state and balances when minting tokens for a user or on behalf of another. It adjusts allowances, calculates new and average stable rates, updates supply, and mints the new token amount with interest, emitting relevant events for transparency and tracking."
8aa368715d4def33d5d14e9a16af7032,577 | 578,rule,integrityBurn,138,147,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e, a);
	burn(e,a,x);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust user and total supply balances on a stablecoin contract, using time-dependent interest calculations for accurate accounting. Account for potential accumulation errors by adjusting the average stable rate as necessary, and handle burns or mints based on the comparison of user balance increases to requested burn amounts."
9834b93a34f460bef753f707bca5e47f,594 | 595,rule,burnNoChangeToOther,292,307,balanceOf | burn,"rule burnNoChangeToOther(address user, uint256 amount, address other) {
  
	require other != user;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(e, other);
	burn(e, user, amount);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(e, other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust a user's account balance by calculating compounded interest based on their stable rate and timestamp, and manage the burning of tokens. This involves updating total supply, user stable rates, and average stable rates, while handling cases where the total supply becomes fully repaid or overpaid."
b4f1b383da25135a485fc293d7d278aa,575,invariant,principalLessThanBalance,130,132,balanceOf,"invariant principalLessThanBalance(env e, address user)
    principalBalanceOf(e, user) <= balanceOf(e, user)
    filtered { f -> !disAllowedFunctions(f) }
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Retrieve the balance of a specific account adjusted for compounded interest. Initially, it fetches the base account balance and a pre-established interest rate. If the balance is non-zero, it computes the compounded interest over time using the interest rate and a timestamp, finally returning the interest-adjusted balance."
c8ae7e73dd80d7347106427554bcc45e,592 | 593,rule,burnZeroDoesntChangeBalance,281,287,balanceOf | burn,"rule burnZeroDoesntChangeBalance(address u) {
	env e;
	uint256 balanceBefore = balanceOf(e, u);
	burn(e, u, 0);
	uint256 balanceAfter = balanceOf(e, u);
	assert balanceBefore == balanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust the account balance and total supply in a smart contract based on accrued interest and stable rates. Upon a burn operation, calculate balance increases or decreases, update averages, and mint or burn tokens accordingly, also adjusting timestamp data for each user and the overall system."
cb81952394ea33aa5b1e095725df8d51,584 | 585,rule,additiveBurn,187,198,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	storage initialStorage = lastStorage;
	burn(e, a, x);
	burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust a user's balance and update the average stable rate and total supply in a decentralized finance protocol, handling balance increase due to interest, and minting or burning tokens accordingly while ensuring the last borrower repaying doesn't repay more than the available debt supply."
cd74f6164fe5b2edd58a2c20ba1ccdc0,586 | 587 | 588,rule,inverseMintBurn,201,208,mint | balanceOf | burn,"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 rate) {
	env e;
	uint256 balancebefore = balanceOf(e, a);
	mint(e, delegatedUser, a, amount, rate);
	burn(e, a, amount);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust users' balances and the system's total supply based on mint and burn actions. The code calculates new user and system-wide interest rates when tokens are minted or burned, updates ownership and timestamps, and emits events to log these actions."
e048152d004f950c8928015a4ddd0128,599 | 600,rule,canBurnAtZero,347,361,burn | _calculateBalanceIncrease,"By finding a violation, this rule checks that one can burn when there totalSupply is zero.
It is commented out since it should fail 
rule canBurnAtZero() {
	env e;
	address user;
	require totalSupply(e) == 0;
	uint256 userRate = additionalData(user);
	uint256 previousPrincipalBalance;
    uint256 newPrincipalBalance;
    uint256 diff;
	previousPrincipalBalance, newPrincipalBalance, diff =  _calculateBalanceIncrease(e,user);
	uint256 amount; 
	invoke burn(e,user,amount);
	assert amount>0 => lastReverted;
}
","burn (Lines 178-245),  | _calculateBalanceIncrease (Lines 254-270), ","  function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
 |   function _calculateBalanceIncrease(
    address user
  ) internal view returns (uint256, uint256, uint256) {
    uint256 previousPrincipalBalance = super.balanceOf(user);

    if (previousPrincipalBalance == 0) {
      return (0, 0, 0);
    }

    uint256 newPrincipalBalance = balanceOf(user);

    return (
      previousPrincipalBalance,
      newPrincipalBalance,
      newPrincipalBalance - previousPrincipalBalance
    );
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust the total supply and user balance upon burning debt tokens, accounting for potential discrepancies due to separate accrual mechanisms. It recalculates the average stable rate if necessary, handles the last repayment case, and emits appropriate events for burning or minting actions as needed."
e048152d004f950c8928015a4ddd0128,599 | 600,rule,canBurnAtZero,347,361,burn | _calculateBalanceIncrease,"By finding a violation, this rule checks that one can burn when there totalSupply is zero.
It is commented out since it should fail 
rule canBurnAtZero() {
	env e;
	address user;
	require totalSupply(e) == 0;
	uint256 userRate = additionalData(user);
	uint256 previousPrincipalBalance;
    uint256 newPrincipalBalance;
    uint256 diff;
	previousPrincipalBalance, newPrincipalBalance, diff =  _calculateBalanceIncrease(e,user);
	uint256 amount; 
	invoke burn(e,user,amount);
	assert amount>0 => lastReverted;
}
","burn (Lines 178-245),  | _calculateBalanceIncrease (Lines 254-270), ","  function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
 |   function _calculateBalanceIncrease(
    address user
  ) internal view returns (uint256, uint256, uint256) {
    uint256 previousPrincipalBalance = super.balanceOf(user);

    if (previousPrincipalBalance == 0) {
      return (0, 0, 0);
    }

    uint256 newPrincipalBalance = balanceOf(user);

    return (
      previousPrincipalBalance,
      newPrincipalBalance,
      newPrincipalBalance - previousPrincipalBalance
    );
  }
",./aave_v3/specs/StableDebtToken.spec,aave_v3,,Yes,,"Functionality: Adjust the total supply and average stable rate of a borrowing entity upon the burning of debt tokens, accounting for possible errors in debt supply calculation and making appropriate adjustments. It also updates user state, handles the transaction timestamp, and emits relevant events for tracking."
188b9e61449b74e385bce0db920a8a2f,555,rule,setSiloedBorrowingIntegrity,109,112,setSiloedBorrowing,"rule setSiloedBorrowingIntegrity(bool siloed) {
    setSiloedBorrowing(siloed);
    assert getSiloedBorrowing() == siloed;
}
","setSiloedBorrowing (Lines 268-284), ","  function setSiloedBorrowing(
    address asset,
    bool newSiloed
  ) external override onlyRiskOrPoolAdmins {
    if (newSiloed) {
      _checkNoBorrowers(asset);
    }
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);

    bool oldSiloed = currentConfig.getSiloedBorrowing();

    currentConfig.setSiloedBorrowing(newSiloed);

    _pool.setConfiguration(asset, currentConfig);

    emit SiloedBorrowingChanged(asset, oldSiloed, newSiloed);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Toggle the siloed borrowing status of a specific asset within a lending pool, ensuring no borrowers exist for that asset if enabling siloed borrowing, then updating the asset's configuration accordingly and emitting an event to reflect the change."
1b5d5c81c4f36f7d513ab83a0e779c11,562,rule,setBorrowCapIntegrity,133,136,setBorrowCap,"rule setBorrowCapIntegrity(uint256 borrowCap) {
    setBorrowCap(borrowCap);
    assert getBorrowCap() == borrowCap;
}
","setBorrowCap (Lines 287-296), ","  function setBorrowCap(
    address asset,
    uint256 newBorrowCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldBorrowCap = currentConfig.getBorrowCap();
    currentConfig.setBorrowCap(newBorrowCap);
    _pool.setConfiguration(asset, currentConfig);
    emit BorrowCapChanged(asset, oldBorrowCap, newBorrowCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Update the borrow cap for a specific asset in a lending pool. Retrieve the asset's current configuration, extract its old borrow cap, set a new borrow cap, update the asset's configuration in the pool, and emit an event documenting the change in borrow cap values."
1bf99931e9a4076cae997b43d8c98e58,570,rule,setUnbackedMintCapIntegrity,157,160,setUnbackedMintCap,"rule setUnbackedMintCapIntegrity(uint256 unbackedMintCap) {
    setUnbackedMintCap(unbackedMintCap);
    assert getUnbackedMintCap() == unbackedMintCap;
}
","setUnbackedMintCap (Lines 398-407), ","  function setUnbackedMintCap(
    address asset,
    uint256 newUnbackedMintCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldUnbackedMintCap = currentConfig.getUnbackedMintCap();
    currentConfig.setUnbackedMintCap(newUnbackedMintCap);
    _pool.setConfiguration(asset, currentConfig);
    emit UnbackedMintCapChanged(asset, oldUnbackedMintCap, newUnbackedMintCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Update the unbacked mint cap for a specific asset in a lending pool configuration, record the previous cap, apply the new cap within the pool configuration, and emit an event documenting the change from the old cap to the new cap."
27e34698fef9789101236824fbbf21e7,567,rule,setDebtCeilingIntegrity,145,148,setDebtCeiling,"rule setDebtCeilingIntegrity(uint256 ceiling) {
    setDebtCeiling(ceiling);
    assert getDebtCeiling() == ceiling;
}
","setDebtCeiling (Lines 247-265), ","  function setDebtCeiling(
    address asset,
    uint256 newDebtCeiling
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);

    uint256 oldDebtCeiling = currentConfig.getDebtCeiling();
    if (oldDebtCeiling == 0) {
      _checkNoSuppliers(asset);
    }
    currentConfig.setDebtCeiling(newDebtCeiling);
    _pool.setConfiguration(asset, currentConfig);

    if (newDebtCeiling == 0) {
      _pool.resetIsolationModeTotalDebt(asset);
    }

    emit DebtCeilingChanged(asset, oldDebtCeiling, newDebtCeiling);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: This function updates the debt ceiling for a specific asset in a lending pool. It retrieves the current configuration, checks for suppliers if the old debt ceiling is zero, updates the configuration with a new debt ceiling, resets isolation mode total debt if the new ceiling is zero, and emits a relevant event."
353a1369e69ed6d271f792a0ccad84bb,538,rule,setLtvIntegrity,61,64,setLtv,"rule setLtvIntegrity(uint256 ltv) {
    setLtv(ltv);
    assert getLtv() == ltv;
}
","setLtv (Lines 73-77), ","  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);

    self.data = (self.data & LTV_MASK) | ltv;
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,Functionality: Set the loan-to-value (LTV) ratio in the ReserveConfigurationMap while ensuring it does not exceed the maximum valid LTV. This is achieved by first masking out the old LTV value then setting the new LTV value within the preserved data structure.
593e289ed837ac2cdb73525c2ee423fd,573,rule,setEModeCategoryIntegrity,163,166,setEModeCategory,"rule setEModeCategoryIntegrity(uint256 category) {
    setEModeCategory(category);
    assert getEModeCategory() == category;
}
","setEModeCategory (Lines 324-375), ","  function setEModeCategory(
    uint8 categoryId,
    uint16 ltv,
    uint16 liquidationThreshold,
    uint16 liquidationBonus,
    address oracle,
    string calldata label
  ) external override onlyRiskOrPoolAdmins {
    require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
    require(liquidationThreshold != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);

    // validation of the parameters: the LTV can
    // only be lower or equal than the liquidation threshold
    // (otherwise a loan against the asset would cause instantaneous liquidation)
    require(ltv <= liquidationThreshold, Errors.INVALID_EMODE_CATEGORY_PARAMS);
    require(
      liquidationBonus > PercentageMath.PERCENTAGE_FACTOR,
      Errors.INVALID_EMODE_CATEGORY_PARAMS
    );

    // if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment
    // a loan is taken there is enough collateral available to cover the liquidation bonus
    require(
      uint256(liquidationThreshold).percentMul(liquidationBonus) <=
        PercentageMath.PERCENTAGE_FACTOR,
      Errors.INVALID_EMODE_CATEGORY_PARAMS
    );

    address[] memory reserves = _pool.getReservesList();
    for (uint256 i = 0; i < reserves.length; i++) {
      DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(reserves[i]);
      if (categoryId == currentConfig.getEModeCategory()) {
        require(ltv > currentConfig.getLtv(), Errors.INVALID_EMODE_CATEGORY_PARAMS);
        require(
          liquidationThreshold > currentConfig.getLiquidationThreshold(),
          Errors.INVALID_EMODE_CATEGORY_PARAMS
        );
      }
    }

    _pool.configureEModeCategory(
      categoryId,
      DataTypes.EModeCategory({
        ltv: ltv,
        liquidationThreshold: liquidationThreshold,
        liquidationBonus: liquidationBonus,
        priceSource: oracle,
        label: label
      })
    );
    emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Validate and set enhanced mode (EMode) category parameters for a financial pool, including loan-to-value (LTV), liquidation thresholds, bonuses, and oracle addresses. Enforce constraints on these parameters to ensure financial stability and solvency of the pool against instant liquidation risks."
60f622a4fd2e6d446364b36503f0cbf1,552,rule,setBorrowableInIsolationIntegrity,103,106,setBorrowableInIsolation,"rule setBorrowableInIsolationIntegrity(bool borrowable) {
    setBorrowableInIsolation(borrowable);
    assert getBorrowableInIsolation() == borrowable;
}
","setBorrowableInIsolation (Lines 215-223), ","  function setBorrowableInIsolation(
    address asset,
    bool borrowable
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    currentConfig.setBorrowableInIsolation(borrowable);
    _pool.setConfiguration(asset, currentConfig);
    emit BorrowableInIsolationChanged(asset, borrowable);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Modify an asset's configuration to allow or disallow borrowing it in isolation within a lending pool. This is achieved by fetching the asset's current configuration, updating the borrowable status, and then saving the updated configuration back to the pool."
c682985224aa29cd9c90e3bf25b8c0c3,564,rule,setSupplyCapIntegrity,139,142,setSupplyCap,"rule setSupplyCapIntegrity(uint256 supplyCap) {
    setSupplyCap(supplyCap);
    assert getSupplyCap() == supplyCap;
}
","setSupplyCap (Lines 299-308), ","  function setSupplyCap(
    address asset,
    uint256 newSupplyCap
  ) external override onlyRiskOrPoolAdmins {
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldSupplyCap = currentConfig.getSupplyCap();
    currentConfig.setSupplyCap(newSupplyCap);
    _pool.setConfiguration(asset, currentConfig);
    emit SupplyCapChanged(asset, oldSupplyCap, newSupplyCap);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Update the supply cap for a specific asset in a lending pool. Retrieve the asset's current configuration, record its old supply cap, set a new supply cap, update the pool configuration, and emit an event logging the change in supply cap."
c7f987fc748e630abc59db2134196077,560,rule,setReserveFactorIntegrity,127,130,setReserveFactor,"rule setReserveFactorIntegrity(uint256 reserveFactor) {
    setReserveFactor(reserveFactor);
    assert getReserveFactor() == reserveFactor;
}
","setReserveFactor (Lines 234-244), ","  function setReserveFactor(
    address asset,
    uint256 newReserveFactor
  ) external override onlyRiskOrPoolAdmins {
    require(newReserveFactor <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldReserveFactor = currentConfig.getReserveFactor();
    currentConfig.setReserveFactor(newReserveFactor);
    _pool.setConfiguration(asset, currentConfig);
    emit ReserveFactorChanged(asset, oldReserveFactor, newReserveFactor);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,Functionality: Set the reserve factor for a specified asset only if the action is performed by authorized roles and the new factor is within allowed limits. Update the asset's configuration in the lending pool to reflect the new reserve factor and emit a relevant event to log the change.
d006d522c332ba3ba477c7e5c892b16a,568,rule,setLiquidationProtocolFeeIntegrity,151,154,setLiquidationProtocolFee,"rule setLiquidationProtocolFeeIntegrity(uint256 liquidationProtocolFee) {
    setLiquidationProtocolFee(liquidationProtocolFee);
    assert getLiquidationProtocolFee() == liquidationProtocolFee;
}
","setLiquidationProtocolFee (Lines 311-321), ","  function setLiquidationProtocolFee(
    address asset,
    uint256 newFee
  ) external override onlyRiskOrPoolAdmins {
    require(newFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);
    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
    uint256 oldFee = currentConfig.getLiquidationProtocolFee();
    currentConfig.setLiquidationProtocolFee(newFee);
    _pool.setConfiguration(asset, currentConfig);
    emit LiquidationProtocolFeeChanged(asset, oldFee, newFee);
  }
",./aave_v3/specs/ReserveConfiguration.spec,aave_v3,,Yes,,"Functionality: Update the liquidation protocol fee for a specified asset to a new value, ensuring it does not exceed a predefined maximum percentage. The function validates the new fee, updates the configuration in the pool, and emits an event documenting the change."
6fa423ce5729d813dd3dde9bfde81194,535 | 536,rule,accruToTreasury,229,244,mintToTreasury | flashLoan,"// rule accruToTreasury()
// {
// 	env e;
// 	calldataarg args;
// 	calldataarg args2;
// 	calldataarg args3;
// 	storage init = lastStorage;
// 	mintToTreasury(e, args);
// 	flashLoan(e, args2);
// 	//mintToTreasury(e, args);
// 	uint256 withMintBefore = getReserveNormalizedIncome(e, args3);
// 	flashLoan(e, args2) at init;
// 	uint256 withoutMintBefore = getReserveNormalizedIncome(e, args3);
// 	assert withoutMintBefore == withMintBefore;
// }","mintToTreasury (Lines 444-446),  | flashLoan (Lines 386-421), ","  function mintToTreasury(address[] calldata assets) external virtual override {
    PoolLogic.executeMintToTreasury(_reserves, assets);
  }
 |   function flashLoan(
    address receiverAddress,
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata interestRateModes,
    address onBehalfOf,
    bytes calldata params,
    uint16 referralCode
  ) public virtual override {
    DataTypes.FlashloanParams memory flashParams = DataTypes.FlashloanParams({
      receiverAddress: receiverAddress,
      assets: assets,
      amounts: amounts,
      interestRateModes: interestRateModes,
      onBehalfOf: onBehalfOf,
      params: params,
      referralCode: referralCode,
      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,
      flashLoanPremiumTotal: _flashLoanPremiumTotal,
      maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,
      reservesCount: _reservesCount,
      addressesProvider: address(ADDRESSES_PROVIDER),
      userEModeCategory: _usersEModeCategory[onBehalfOf],
      isAuthorizedFlashBorrower: IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(
        msg.sender
      )
    });

    FlashLoanLogic.executeFlashLoan(
      _reserves,
      _reservesList,
      _eModeCategories,
      _usersConfig[onBehalfOf],
      flashParams
    );
  }
",./aave_v3/specs/pool.spec,aave_v3,,Yes,,"Functionality: Mint assets to the treasury based on input asset addresses and execute a flash loan transaction with specified parameters such as receiver address, assets, amounts, and interest rates. It constructs the parameters for the flash loan, including premium rates and borrower details, to facilitate the operation."
a17ca2e8fe7297047b2c0484f1988b46,532,rule,getReserveNormalizedVariableDebtCheck,197,209,supply,"rule getReserveNormalizedVariableDebtCheck()
{
	env e1;
	calldataarg args;
	calldataarg args2;
    address asset; uint256 amount; address onBehalfOf; uint16 referralCode;
    require asset != _aToken;
	uint256 oldIndex = getReserveNormalizedVariableDebt(e1, args);
    uint256 totalDebtBefore = getCurrScaledVariableDebt(asset);
	supply(e1, asset, amount, onBehalfOf, referralCode);
	uint256 newIndex = getReserveNormalizedVariableDebt(e1, args);
	assert totalDebtBefore != 0 => newIndex >= oldIndex;
}
","supply (Lines 143-160), ","  function supply(
    address asset,
    uint256 amount,
    address onBehalfOf,
    uint16 referralCode
  ) public virtual override {
    SupplyLogic.executeSupply(
      _reserves,
      _reservesList,
      _usersConfig[onBehalfOf],
      DataTypes.ExecuteSupplyParams({
        asset: asset,
        amount: amount,
        onBehalfOf: onBehalfOf,
        referralCode: referralCode
      })
    );
  }
",./aave_v3/specs/pool.spec,aave_v3,,Yes,,"Functionality: Execute a supply operation on behalf of a specified user by calling the SupplyLogic's `executeSupply` method with the specified asset, amount, beneficiary address, and referral code using the user's configuration and reserves data."
b4e82776f62a6eed7f2a204a2423decb,534,rule,withdrawCheck,213,225,withdraw,"// rule withdrawCheck()
// {
// 	env e;
// 	address to;
// 	address asset;
// 	uint256 part1;
// 	uint256 part2;
// 	storage init = lastStorage;
// 	withdraw(e, asset, part1, to);
// 	withdraw(e, asset, part2, to);
// 	withdraw@withrevert(e, asset, part1 + part2, to) at init;
// 	assert !lastReverted;
// }
","withdraw (Lines 196-216), ","  function withdraw(
    address asset,
    uint256 amount,
    address to
  ) public virtual override returns (uint256) {
    return
      SupplyLogic.executeWithdraw(
        _reserves,
        _reservesList,
        _eModeCategories,
        _usersConfig[msg.sender],
        DataTypes.ExecuteWithdrawParams({
          asset: asset,
          amount: amount,
          to: to,
          reservesCount: _reservesCount,
          oracle: ADDRESSES_PROVIDER.getPriceOracle(),
          userEModeCategory: _usersEModeCategory[msg.sender]
        })
      );
  }
",./aave_v3/specs/pool.spec,aave_v3,,Yes,,"Functionality: Execute a withdrawal operation by transferring the specified amount of a given asset to a target address. This is achieved by integrating various platform components such as reserves, price oracles, and user configurations to securely process and validate the withdrawal request."
0b98e96bc072889dd6362ca32821031f,418 | 419,rule,burnNoChangeToOther,271,287,balanceOf | burn,"rule burnNoChangeToOther(address user, address recieverOfUnderlying, uint256 amount, uint256 index, address other) 
{
  
	require other != user && other != recieverOfUnderlying;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, recieverOfUnderlying, amount, index);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Adjust user and total balances within a lending protocol by calculating compounded interest for account balances, and manage token supply through burn or mint operations based on the repayment or accrual of interest, ensuring accounting integrity through dynamic total supply and rate adjustments."
50ff229184cf4e472df89b28102a81ab,420 | 421,rule,mintNoChangeToOther,292,306,mint | balanceOf,"rule mintNoChangeToOther(address user, uint256 amount, uint256 index, address other)
{
	require other != user;

	env e;
	uint128 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	address caller; 
	mint(e, caller, user, amount, index);
	uint128 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Calculate and mint new tokens for a user or on behalf of another user, adjust borrow allowance if necessary, update balances, and stable rates including the average stable rate in the system. It also logs the transactions and updates the total supply and timestamps."
58a6a8906d2426b39b1127d638e4a6ed,425,rule,integrityBalanceOfTotalSupply,313,337,balanceOf,"// rule integrityBalanceOfTotalSupply(address a, address b, method f)
// {
// 	env e;
// 	require a!=b;
// 	uint256 balanceABefore = balanceOf(e,a);
// 	uint256 balanceBBefore = balanceOf(e,b);
// 	uint256 totalSupplyBefore = totalSupply(e);
	 
// 	calldataarg arg;
// 	sinvoke f(e, arg); 

// 	uint256 balanceAAfter = balanceOf(e,a);
// 	uint256 balanceBAfter = balanceOf(e,b);
// 	uint256 totalSupplyAfter = totalSupply(e);
// 	assert (balanceAAfter != balanceABefore && balanceBAfter != balanceBBefore) =>
// 	    ( (balanceAAfter - balanceABefore) + (balanceBAfter - balanceBBefore)  == totalSupplyAfter - totalSupplyBefore);
// 	require f.selector != transferFrom(address,address,uint256).selector &&
// 	        f.selector != transfer(address,uint256).selector &&
// 	        f.selector != transferOnLiquidation(address,address,uint256).selector;
// 	assert (balanceAAfter != balanceABefore &&  balanceBAfter == balanceBBefore ) =>
// 	    ( (balanceAAfter - balanceABefore)   == totalSupplyAfter - totalSupplyBefore);
		
// }
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Retrieve the balance of an account, adjusted for compounded interest based on a stable rate and the time since interest accrual began. If the account balance is zero, immediately return zero; otherwise, calculate and apply compounded interest to the account's balance."
5ef46523db01c063e88661dc1f6ac3eb,412,rule,additiveTransfer,178,201,balanceOf,"rule additiveTransfer(address from1, address from2, address to1, address to2, uint256 x, uint256 y)
{
	env e1;
	env e2;
    uint256 indexRay = gRNI();
	require (from1 != from2 && to1 != to2 && from1 != to2 && from2 != to1 && 
	        (from1 == to1 <=> from2 == to2) &&
			 balanceOf(from1) == balanceOf(from2) && balanceOf(to1) == balanceOf(to2));

	require e1.msg.sender == from1;
	require e2.msg.sender == from2;
	transfer(e1, to1, x);
	transfer(e1, to1, y);
	uint256 balanceFromScenario1 = balanceOf(from1);
	uint256 balanceToScenario1 = balanceOf(to1);
	transfer(e2, to2, x+y);
	
	uint256 balanceFromScenario2 = balanceOf(from2);
	uint256 balanceToScenario2 = balanceOf(to2);
	assert 	bounded_error_eq(balanceFromScenario1, balanceFromScenario2, 3)  &&
	 		bounded_error_eq(balanceToScenario1, balanceToScenario2, 3), ""transfer is not additive"";
}
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Calculate and return the adjusted balance of a given account by applying the compounded interest rate to the account's existing balance, incorporating a stable rate and time factor, with the calculation ceasing and returning zero if the account balance is initially zero."
ad8bad6fa1a1b0d635e435c9e7681c24,414 | 415,rule,integrityBurn,207,243,"balanceOf, _underlyingAsset.balanceOf | burn","rule integrityBurn(address user, address to, uint256 amount)
{
	env e;
	uint256 indexRay = gRNI();

	require user != currentContract;
	uint256 balanceBeforeUser = balanceOf(user);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingBeforeUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingBeforeSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyBefore = totalSupply(e); 
	burn(e, user, to, amount, indexRay);
	
	uint256 balanceAfterUser = balanceOf(user);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingAfterUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingAfterSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyAfter = totalSupply(e);
	if (user != to) {
		assert balanceAfterTo == balanceBeforeTo && // balanceOf To should not change
		bounded_error_eq(underlyingBeforeUser, underlyingAfterUser, 1), ""integrity break on user!=to"";
	}
	if (to != currentContract) {
		assert bounded_error_eq(underlyingAfterSystem, underlyingBeforeSystem - amount, 1) && // system transfer underlying_asset
		bounded_error_eq(underlyingAfterTo,  underlyingBeforeTo + amount, 1) , ""integrity break on to!=currentContract"";
	} else {
		assert underlyingAfterSystem == underlyingBeforeSystem, ""integrity break on to==currentContract"";
	} 
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Calculate the updated account balance by applying compounded interest based on a stable rate and timestamp; manage the burning of tokens from an account, adjusting total supply and user's stable rate accordingly, handling edge cases of total supply depletion, and emitting relevant events for minting or burning actions."
ba180b05fda6c7f8a377eb5a012621c7,416 | 417,rule,additiveBurn,249,266,balanceOf | burn,"rule additiveBurn(address user1, address user2, address to1, address to2, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require (user1 != user2 && to1 != to2 && user1 != to2 && user2 != to1 && 
	        (user1 == to1 <=> user2 == to2) &&
			 balanceOf(user1) == balanceOf(user2) && balanceOf(to1) == balanceOf(to2));
	require user1 != currentContract && user2 != currentContract;

	sinvoke burn(e, user1, to1, x, indexRay);
	sinvoke burn(e, user1, to1, y, indexRay);
	uint256 balanceUserScenario1 = balanceOf(user1);
	
	sinvoke burn(e, user2, to2, x+y, indexRay);
	uint256 balanceUserScenario2 = balanceOf(user2);
	assert 	bounded_error_eq(balanceUserScenario1, balanceUserScenario2, 3), ""burn is not additive"";
}
","balanceOf (Lines 101-112),  | burn (Lines 178-245), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(
    address from,
    uint256 amount
  ) external virtual override onlyPool returns (uint256, uint256) {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);

    uint256 previousSupply = totalSupply();
    uint256 nextAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _userState[from].additionalData;

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // might actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply - amount;
      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
      } else {
        nextAvgStableRate = _avgStableRate = (
          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
        ).toUint128();
      }
    }

    if (amount == currentBalance) {
      _userState[from].additionalData = 0;
      _timestamps[from] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[from] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease - amount;
      _mint(from, amountToMint, previousSupply);
      emit Transfer(address(0), from, amountToMint);
      emit Mint(
        from,
        from,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        nextAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount - balanceIncrease;
      _burn(from, amountToBurn, previousSupply);
      emit Transfer(from, address(0), amountToBurn);
      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
    }

    return (nextSupply, nextAvgStableRate);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Adjust the user's balance and the total supply based on stable interest rates when burning tokens from an account. This process recalculates the average stable rate and either mints or burns additional tokens to align with the accrued interest, emitting relevant events for tracking."
c84fc2b800ef2cefc6c60bf613636d00,410,rule,integrityTransfer,147,171,"balanceOf, _underlyingAsset.balanceOf","rule integrityTransfer(address from, address to, uint256 amount)
{
	env e;
	require e.msg.sender == from;
	address other; // for any address including from, to, currentContract the underlying asset balance should stay the same
	
	uint256 balanceBeforeFrom = balanceOf(from);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeOther =  _underlyingAsset.balanceOf(e, other);
	transfer(e, to, amount);
	uint256 balanceAfterFrom = balanceOf(from);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterOther =  _underlyingAsset.balanceOf(e, other);
	assert underlyingAfterOther == underlyingBeforeOther, ""unexpected change in underlying asserts"";
	if (from != to) {
		assert bounded_error_eq(balanceAfterFrom, balanceBeforeFrom - amount, 1) &&
	 		bounded_error_eq(balanceAfterTo, balanceBeforeTo + amount, 1), ""unexpected balance of from/to, when from!=to"";
	} else {
		assert balanceAfterFrom == balanceAfterTo , ""unexpected balance of from/to, when from==to"";
	}
}
","balanceOf (Lines 101-112), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Retrieve the balance of a specific account, adjusting it for compounded interest. First, it fetches the original account balance and the individual's stable rate. If the balance is non-zero, it computes the interest accrued since a timestamp and returns the updated balance."
d286347bed34bbf33e877c5571387424,400,rule,permitIntegrity,58,65,permit,"rule permitIntegrity(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) 
{
    env e;
    uint256 nonceBefore = nonces(owner);
    permit(e, owner, spender, value, deadline, v, r, s);
    assert allowance(owner, spender) == value;
    assert nonces(owner) == nonceBefore + 1;
}
","permit (Lines 170-193), ","  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external override {
    require(owner != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
    uint256 currentValidNonce = _nonces[owner];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))
      )
    );
    require(owner == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
    _nonces[owner] = currentValidNonce + 1;
    _approve(owner, spender, value);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Validate the signature for a permit to approve a spender by an owner within a deadline, using EIP-2612's permit method. It increases the nonce for the owner after authenticating the permit and approves the spender to spend a specified value of the owner's tokens."
efa0872e2bd5bc7b8586d20edeed3133,403 | 404,rule,integrityMint,101,119,mint | balanceOf,"rule integrityMint(address a, address b, uint256 x) 
{
	env e;
	uint256 indexRay = gRNI();

	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e,b,a,x,indexRay);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);
	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
	assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: The provided code defines a function for minting new tokens on behalf of a user, adjusting their balance based on an updated average stable rate and compounded interest, and emits events reflecting these changes. It also includes a method to calculate a user's current balance, factoring in accrued interest."
f51c7ba5d2946ebe18b96b976b8e7ef9,407 | 408,rule,additiveMint,125,140,mint | balanceOf,"rule additiveMint(address a, address b, address c, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require(balanceOf(a) == balanceOf(b) && a != b);
	uint256 balanceScenario0 = balanceOf(a);
	// storage initialStorage = lastStorage;
	mint(e,c,a,x,indexRay);
	mint(e,c,a,y,indexRay);
	uint256 balanceScenario1 = balanceOf(a);
	// mint(e,c, a, x+y ,indexRay) at initialStorage;
	mint(e, c, b, x+y ,indexRay);

	uint256 balanceScenario2 = balanceOf(b);
	assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""mint is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Calculate and update the stable rate, total supply, and user's balance upon minting new tokens. The code adjusts user borrow allowances, calculates interest growth, updates the average stable rate, mints the adjusted amount of tokens, and emits relevant events for tracking changes."
efa0872e2bd5bc7b8586d20edeed3133,403 | 404,rule,integrityMint,101,119,mint | balanceOf,"rule integrityMint(address a, address b, uint256 x) 
{
	env e;
	uint256 indexRay = gRNI();

	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e,b,a,x,indexRay);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);
	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
	assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Update an onBehalfOf user's balance by minting a specified amount with an adjusted rate, reflecting balance increases, and recalculating the average stable rate. The balanceOf function then returns the user's current balance, accounting for compounded interest based on their stable rate and the time elapsed since their last interaction."
f51c7ba5d2946ebe18b96b976b8e7ef9,407 | 408,rule,additiveMint,125,140,mint | balanceOf,"rule additiveMint(address a, address b, address c, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require(balanceOf(a) == balanceOf(b) && a != b);
	uint256 balanceScenario0 = balanceOf(a);
	// storage initialStorage = lastStorage;
	mint(e,c,a,x,indexRay);
	mint(e,c,a,y,indexRay);
	uint256 balanceScenario1 = balanceOf(a);
	// mint(e,c, a, x+y ,indexRay) at initialStorage;
	mint(e, c, b, x+y ,indexRay);

	uint256 balanceScenario2 = balanceOf(b);
	assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""mint is not additive"";
}
","mint (Lines 124-175),  | balanceOf (Lines 101-112), ","  function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external virtual override onlyPool returns (bool, uint256, uint256) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply + amount;

    vars.amountInRay = amount.wadToRay();

    vars.currentStableRate = _userState[onBehalfOf].additionalData;
    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());

    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = (
      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
    ).toUint128();

    uint256 amountToMint = amount + balanceIncrease;
    _mint(onBehalfOf, amountToMint, vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(
      user,
      onBehalfOf,
      amountToMint,
      currentBalance,
      balanceIncrease,
      vars.nextStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
  }
 |   function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _userState[account].additionalData;
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
      stableRate,
      _timestamps[account]
    );
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v3/specs/AToken.spec,aave_v3,,Yes,,"Functionality: Adjust an account's token supply and interest rate in a financial contract by minting tokens. This includes updating borrow allowances if the mint is on behalf of another user, recalculating the user's balance with interest, updating stable and average rates, and emitting relevant events."
35c9ff78c9a1ddd93a2de12d0010aaa3,374 | 376 | 377,rule,integirtyBalanceOfTotalSupplyOnBurn,46,60,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupplyOnBurn(address a)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke burn(e, a, x, index); 
	assert (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Implement interest accrual on user balances for a lending platform, adjusting account and total supplies dynamically with deposit (mint) and withdrawal (burn) operations. Calculate updated rates based on interactions, ensuring compliance with overflow limits and adjusting for balance changes accurately."
64277ceeda0193f62412a99e472fed0e,368,rule,balanceOfChange,6,20,balanceOf,"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a != b;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter);
}
","balanceOf (Lines 106-115), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Calculate and return the account balance adjusted for interest using a stable rate over a period of time. It involves compounding the interest based on a user's stable rate and the time elapsed since the rate was set, then applying this to the initial balance."
65111932145bbb0df029402de3cf10d4,393 | 394,rule,additiveBurn,143,156,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x, index);
	sinvoke burn(e, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Update user's stable rate and total supply upon burning tokens, adjusting the average stable rate accordingly. It compensates for potential over-repayment by adjusting average rates or supply to zero if needed, and handles interest accrual by minting or burning additional tokens based on the balance increase relative to the amount burnt."
76c29ccb27c5f54bbea876e7f43754b1,387 | 388,rule,additiveMint,108,121,balanceOf | mint,"rule additiveMint(address a, address delegatedUser, uint256 x, uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Calculate and adjust a user's balance based on compounded interest rates in a decentralized finance (DeFi) protocol. Additionally, manage the minting process including the allocation of new tokens to users and the recalculation of stable rates and total supply figures following a minting event."
76cef4ca824906ec6ca2097eee82e09d,384 | 385,rule,integrityMint,90,102,balanceOf | mint,"rule integrityMint(address u, address delegatedUser, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e,asset);
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 balanceDelegatedUBefore = balanceOf(e, delegatedUser);
	sinvoke mint(e, delegatedUser, u, x, index);
	
	uint256 balanceUAfter = balanceOf(e, u);
	uint256 balanceDelegatedUAfter = balanceOf(e, delegatedUser);
	assert balanceUAfter == balanceUBefore + x && (u != delegatedUser => (balanceDelegatedUAfter == balanceDelegatedUBefore));
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Calculate and adjust user and overall supply interest rates for a lending pool when minting new stable debt tokens. It updates user's balance, interest rate, and the average stable rate on behalf of or directly to a user, accounting for the lending pool's total supply changes."
cd108d038ced5169ddeb5afdc5ebdd1a,369 | 371 | 372,rule,integirtyBalanceOfTotalSupply,26,41,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Calculate a user's account balance by accounting for compounded interest using a stable rate and timestamp, mint new tokens while updating average rates and supplies in the protocol, and burn tokens adjusting for balance increases or decreases, with proper event emissions for tracking."
ea8444431540fefb99cfa34a20af034f,390 | 391,rule,integrityBurn,129,138,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke burn(e, a, x, index);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: The code handles the process of burning tokens for a user account, adjusting the user's and the overall system's stable rate based on the burnt amount, accounting for interest accruals, and ensuring consistent state through updates to supply and rate calculations. It emits relevant events for minting, burning, and transfers."
eda8d99348e80c0ae2bcda651695053e,379 | 381 | 382,rule,integirtyBalanceOfTotalSupplyOnMint,65,79,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupplyOnMint(address u, address delegatedUser)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke mint(e, delegatedUser, u, x, index); 
	uint256 balanceUAfter = balanceOf(e, u);
	assert (balanceUAfter != balanceUBefore  => (balanceUAfter - balanceUBefore  == totalSupplyAfter - totalSupplyBefore));
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Calculate a user's account balance by factoring in accrued interest using a stable rate, mint new tokens for a user considering the previous and new stable rates, and burn tokens from a user's account, adjusting the average stable rate and total supply accordingly."
fa40f6e5412f669823cb7f1f2cfe2380,396 | 397 | 398,rule,inverseMintBurn,164,174,balanceOf | mint | burn,"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address asset;
	address delegatedUser;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x, index);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Manage user balances and interest rates in a lending platform by allowing users to mint or burn their debt, adjusting average stable rates and individual account rates based on transactions. It calculates interest accumulation on balances and updates the total supply and average rates accordingly."
ea8444431540fefb99cfa34a20af034f,390 | 391,rule,integrityBurn,129,138,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke burn(e, a, x, index);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Update user balances and total supply when burning tokens, adjusting interest rates accordingly. Specifically, calculate user's increased balance due to interest, adjust total supply and average stable rates after burn, and correctly handle edge cases where the last borrower repays. Emit relevant events based on actions performed."
eda8d99348e80c0ae2bcda651695053e,379 | 381 | 382,rule,integirtyBalanceOfTotalSupplyOnMint,65,79,balanceOf | mint | burn,"rule integirtyBalanceOfTotalSupplyOnMint(address u, address delegatedUser)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke mint(e, delegatedUser, u, x, index); 
	uint256 balanceUAfter = balanceOf(e, u);
	assert (balanceUAfter != balanceUBefore  => (balanceUAfter - balanceUBefore  == totalSupplyAfter - totalSupplyBefore));
","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: The code allows for the minting and burning of a stable debt token within a lending pool, adjusting user balances and interest rates based on transactions. It calculates compounded interest, averages stable rates, and updates supply metrics while ensuring accuracy and consistency in the token's economics."
fa40f6e5412f669823cb7f1f2cfe2380,396 | 397 | 398,rule,inverseMintBurn,164,174,balanceOf | mint | burn,"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address asset;
	address delegatedUser;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x, index);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/VariableDebtToken.spec,aave_v2,,Yes,,"Functionality: Implement compound interest calculations for user account balances, allow minting of new tokens while adjusting average stable rates and user-specific rates, and support burning of tokens with update to average rates and supply. This ensures accurate tracking of debt balances and interest accrual in a lending pool system."
0ca81f9040073d2fec1a97d9de6c9e83,343 | 347 | 350,rule,integirtyBalanceOfTotalSupplyOnBurn,62,101,balanceOf | burn | if,"rule integirtyBalanceOfTotalSupplyOnBurn(address a, uint256 x)
rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	
	uint256 averageStableRateBefore = sinvoke getAverageStableRate(e);
	uint256 debtSupplyBefore = sinvoke rayWadMul(e, averageStableRateBefore, totalSupplyBefore);
	uint256 stableRateA = sinvoke getUserStableRate(e, a);
	uint256 repaidDebtA = sinvoke rayWadMul(e, stableRateA, x);
	sinvoke burn(e, a, x); 
	if(totalSupplyBefore > x) {
	    /* The amount being burned (x) is smaller than the total supply */
		if(repaidDebtA >= debtSupplyBefore) {
			/*
			The user debt being repaid is at least the debt supply.
			The total supply becomes 0.
			*/
			assert(totalSupplyAfter == 0);
		}
		else {
			assert(balanceAAfter != balanceABefore  =>
			(balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
	}
	else {
	/* The amount being burned (x) is at least the total supply.
	   The total supply becomes 0.
	*/
		assert (totalSupplyAfter == 0);
","balanceOf (Lines 106-115),  | burn (Lines 197-257),  | if (Lines 232-290), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
 |    * user calling the function if he wants to reduce/remove his own debt, or the address of any other
   * other borrower whose debt should be removed
   * @return The final amount repaid
   **/
  function repay(
    address asset,
    uint256 amount,
    uint256 rateMode,
    address onBehalfOf
  ) external override whenNotPaused returns (uint256) {
    DataTypes.ReserveData storage reserve = _reserves[asset];

    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);

    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);

    ValidationLogic.validateRepay(
      reserve,
      amount,
      interestRateMode,
      onBehalfOf,
      stableDebt,
      variableDebt
    );

    uint256 paybackAmount =
      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;

    if (amount < paybackAmount) {
      paybackAmount = amount;
    }

    reserve.updateState();

    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {
      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);
    } else {
      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(
        onBehalfOf,
        paybackAmount,
        reserve.variableBorrowIndex
      );
    }

    address aToken = reserve.aTokenAddress;
    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);

    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {
      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);
    }

    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);

    IAToken(aToken).handleRepayment(msg.sender, paybackAmount);

    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);

    return paybackAmount;
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Dynamically manage user debts within a lending protocol by calculating interest on debt balances, facilitating debt repayment or adjustment (burning or minting tokens as needed), and updating interest rates and user states in response to these changes, thus ensuring the system's balances and rates reflect all user interactions accurately."
204e75416bad1544302a9bf93bca9164,361 | 363,rule,additiveBurn,155,167,balanceOf | burn,"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x);
	sinvoke burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust a user's stable interest rate and corresponding debt balance upon token burn action in a lending scenario, preventing overflow by recalibrating the average rate and total supply as necessary, and ensuring the accrued interest aligns with the principal reduction, either minting or burning tokens accordingly."
4d593c910fdf96790b413f35eed43274,337,rule,balanceOfChange,21,36,balanceOf,"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a!=b;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter );
}
","balanceOf (Lines 106-115), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Retrieve the balance for a specified account considering compounded interest. Calculate the current balance by first obtaining the initial balance, then compute the compounded interest using a stable rate and the account's timestamp, and finally multiply the initial balance by the compounded interest."
58a9465ac2c96e9af7f73bcc2742b4fc,339 | 342,rule,integirtyBalanceOfTotalSupply,42,56,balanceOf | burn,"rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust a user's stable rate, total supply, and average stable rate when burning tokens. Calculate balance increases due to accrued interest, mint or burn the difference if the balance increase exceeds or is less than the amount burned, and update timestamps and rates accordingly."
60844a84c7080c8ea681e17fdee390b4,354 | 356,rule,additiveMint,126,142,balanceOf | mint,"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = sinvoke balanceOf(e, a);
	
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = sinvoke balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust a user's debt based on stable interest rates when minting tokens. The code calculates new user and average stable rates, updates balances and supply, issues new tokens considering accrued interest, and ensures rates do not overflow predefined limits."
84e795ba18832f76d8402f578e457060,358 | 360,rule,integrityBurn,144,153,balanceOf | burn,"rule integrityBurn(address a, uint256 x) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke burn(e,a,x);
	
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","balanceOf (Lines 106-115),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust a user's stable rate and total supply after burning a specified amount of tokens, taking into account the interest accrued over time. It calculates new average stable rates, updates user and total supply information, and mints or burns tokens based on the calculated balance increase or decrease."
8b3dce129e5798b11f02a26c40b6f6fb,364 | 366 | 367,rule,inverseMintBurn,174,184,balanceOf | mint | burn,"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x);
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}","balanceOf (Lines 106-115),  | mint (Lines 136-190),  | burn (Lines 197-257), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
 |   function burn(address user, uint256 amount) external override onlyLendingPool {
    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);

    uint256 previousSupply = totalSupply();
    uint256 newAvgStableRate = 0;
    uint256 nextSupply = 0;
    uint256 userStableRate = _usersStableRate[user];

    // Since the total supply and each single user debt accrue separately,
    // there might be accumulation errors so that the last borrower repaying
    // mght actually try to repay more than the available debt supply.
    // In this case we simply set the total supply and the avg stable rate to 0
    if (previousSupply <= amount) {
      _avgStableRate = 0;
      _totalSupply = 0;
    } else {
      nextSupply = _totalSupply = previousSupply.sub(amount);
      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());
      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());

      // For the same reason described above, when the last user is repaying it might
      // happen that user rate * user balance > avg rate * total supply. In that case,
      // we simply set the avg rate to 0
      if (secondTerm >= firstTerm) {
        newAvgStableRate = _avgStableRate = _totalSupply = 0;
      } else {
        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());
      }
    }

    if (amount == currentBalance) {
      _usersStableRate[user] = 0;
      _timestamps[user] = 0;
    } else {
      //solium-disable-next-line
      _timestamps[user] = uint40(block.timestamp);
    }
    //solium-disable-next-line
    _totalSupplyTimestamp = uint40(block.timestamp);

    if (balanceIncrease > amount) {
      uint256 amountToMint = balanceIncrease.sub(amount);
      _mint(user, amountToMint, previousSupply);
      emit Mint(
        user,
        user,
        amountToMint,
        currentBalance,
        balanceIncrease,
        userStableRate,
        newAvgStableRate,
        nextSupply
      );
    } else {
      uint256 amountToBurn = amount.sub(balanceIncrease);
      _burn(user, amountToBurn, previousSupply);
      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);
    }

    emit Transfer(user, address(0), amount);
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust user account balances and aggregate rates in a lending pool by minting new debt tokens with accrued interest to represent borrowed amounts or burning existing debt tokens to account for repayments, ensuring the total supply and average stable rates are correctly updated."
b36df21463e0bf49d73ba2ced5b29209,351 | 353,rule,integrityMint,106,116,balanceOf | mint,"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e,a);
	sinvoke mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = sinvoke balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
","balanceOf (Lines 106-115),  | mint (Lines 136-190), ","  function balanceOf(address account) public view virtual override returns (uint256) {
    uint256 accountBalance = super.balanceOf(account);
    uint256 stableRate = _usersStableRate[account];
    if (accountBalance == 0) {
      return 0;
    }
    uint256 cumulatedInterest =
      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);
    return accountBalance.rayMul(cumulatedInterest);
  }
 |   function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 rate
  ) external override onlyLendingPool returns (bool) {
    MintLocalVars memory vars;

    if (user != onBehalfOf) {
      _decreaseBorrowAllowance(onBehalfOf, user, amount);
    }

    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);

    vars.previousSupply = totalSupply();
    vars.currentAvgStableRate = _avgStableRate;
    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);

    vars.amountInRay = amount.wadToRay();

    vars.newStableRate = _usersStableRate[onBehalfOf]
      .rayMul(currentBalance.wadToRay())
      .add(vars.amountInRay.rayMul(rate))
      .rayDiv(currentBalance.add(amount).wadToRay());

    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);
    _usersStableRate[onBehalfOf] = vars.newStableRate;

    //solium-disable-next-line
    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);

    // Calculates the updated average stable rate
    vars.currentAvgStableRate = _avgStableRate = vars
      .currentAvgStableRate
      .rayMul(vars.previousSupply.wadToRay())
      .add(rate.rayMul(vars.amountInRay))
      .rayDiv(vars.nextSupply.wadToRay());

    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);

    emit Transfer(address(0), onBehalfOf, amount);

    emit Mint(
      user,
      onBehalfOf,
      amount,
      currentBalance,
      balanceIncrease,
      vars.newStableRate,
      vars.currentAvgStableRate,
      vars.nextSupply
    );

    return currentBalance == 0;
  }
",./aave_v2/specs/StableDebtToken.spec,aave_v2,,Yes,,"Functionality: Adjust the balance of an account by applying compounded interest using a stable rate and timestamp, and facilitate minting of tokens on behalf of a user with rate adjustment, updating the user's stable rate, total supply, and emitting relevant events for tracking changes."
0f2649fd976a6fd8dbf72e46bb229ed1,274 | 275,rule,getClaimableRewards_stable_after_atoken_transferFrom,560,575,_AToken.transferFrom | initialize,"rule getClaimableRewards_stable_after_atoken_transferFrom()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","transferFrom (Lines 99-121),  | initialize (Lines 68-87), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Transfer a specified amount of tokens from one account to another, ensuring the sender is authorized and has sufficient balance, adjusting allowances if they are not unlimited. Simultaneously, initialize a contract with token details, setting up an ERC20 token for use, and approve an unlimited amount of the underlying asset for the contract's pool, optionally refreshing reward tokens if an incentives controller is set."
244d2d86df57560bf0afb26c7e6c3cce,261,rule,totalClaimableRewards_stable,332,333,initialize,"rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a token by setting its underlying asset, name, symbol, and decimals. Approve the asset for unlimited transfers to a specific pool and, if an incentives controller is set, refresh the associated reward tokens. Emit an initialization event with the token details."
2950c202bcbdebfd8a2c94e9618e91e9,265,rule,getClaimableRewards_stable,453,458,initialize,"rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a contract with an AToken, setting its name, symbol, and decimals based on the AToken's metadata. It sets the underlying asset of the AToken, approves an infinite amount of this asset to a pool, and refreshes reward tokens if an incentives controller is set, emitting an initialization event."
2af1bc5d3f9a9da5b0aaa7f9e4339e77,247,invariant,inv_atoken_balanceOf_leq_totalSupply_redeem,162,164,redeem,"invariant inv_atoken_balanceOf_leq_totalSupply_redeem(address user)
invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
    filtered { f -> f.selector == redeem(uint256,address,address,bool).selector}
","redeem (Lines 469-478), ","  function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Verify that the number of shares to be redeemed does not exceed the maximum allowed for the owner, then execute a withdrawal process. This withdrawal transfers a specified amount of shares from the owner to a receiver, optionally converting them to an underlying asset, returning the amounts withdrawn and fees charged."
3d84e31cc38d2b2b5a0d53a31a34ec7a,290,rule,getClaimableRewardsBefore_leq_claimed_claimRewardsOnBehalf,657,673,claimRewardsOnBehalf,"rule getClaimableRewardsBefore_leq_claimed_claimRewardsOnBehalf(method f)
{   
    env e;
    address onBehalfOf;
    address receiver; 
    address my_reward;
    address[] rewards;
    //setup(e, onBehalfOf, receiver);   
    
    mathint balanceBefore = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint claimableRewardsBefore = getClaimableRewards(e, onBehalfOf, my_reward);
    claimRewardsOnBehalf(e, onBehalfOf, receiver, rewards);
    mathint balanceAfter = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint deltaBalance = balanceAfter - balanceBefore;
   
    assert deltaBalance <= claimableRewardsBefore;
}
","claimRewardsOnBehalf (Lines 280-291), ","  function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Validate that the caller is either the specified account (onBehalfOf) or is authorized by the INCENTIVES_CONTROLLER as the claimer for that account, then proceed to claim rewards on behalf of the specified account, directing the rewards to a designated receiver with specified reward tokens."
3f8558e6651d209c2dd9ce496276fc1c,251,rule,totalAssets_stable,281,284,claimRewardsOnBehalf,"rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
","claimRewardsOnBehalf (Lines 280-291), ","  function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Verify the sender's authority to claim rewards on another user's behalf by ensuring they are either the original claimant or an authorized claimer designated by the INCENTIVES_CONTROLLER. Upon successful validation, proceed to claim the specified rewards for the designated receiver."
6ee30d94d797130cd74c6f55bc82d1be,246,invariant,inv_atoken_balanceOf_leq_totalSupply,151,153,redeem,"invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
","redeem (Lines 469-478), ","  function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Validate that the amount of shares specified for redemption does not exceed the maximum allowed for the owner. If the validation passes, proceed to withdraw the specified amount of shares, transferring either the underlying asset or equivalent value to the receiver, based on the `toUnderlying` flag."
6f872af85baa8923798ee0d6cb35e3e1,278 | 279 | 280,rule,getClaimableRewards_stable_after_atoken_transferFrom_1,582,599,_AToken.transferFrom | initialize | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_atoken_transferFrom_1()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
rule getClaimableRewards_stable_after_atoken_transferFrom()
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
   // require isRegisteredRewardToken(reward); //todo: review the assumption
    setup(e, user);
","transferFrom (Lines 99-121),  | initialize (Lines 68-87),  | isRegisteredRewardToken (Lines 100-107), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Implement token transfer logic with allowance checks, initialize a token with metadata including approvals for underlying assets, and determine if a token is a registered reward. It handles the modification of balances, allowance verification, emitting events, and rewards token registration checks."
765d062f773b220222c98521c3ba7ee9,294 | 296,rule,getClaimableRewards_stable_after_metaWithdraw,708,720,initialize | metaWithdraw,"rule getClaimableRewards_stable_after_metaWithdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    metaWithdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | metaWithdraw (Lines 182-224), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a new token with specified name, symbol, and underlying asset, and set maximum approval for spending. Emit an event upon successful initialization. Verify a metaWithdraw operation using an owner's signature to safely execute withdrawals, ensuring expiration and nonce validation, and increment the owner's nonce to prevent replay attacks."
79babcb50168a081a1363c7e57440b31,298 | 301,rule,getClaimableRewards_stable_after_withdraw,722,734,initialize | withdraw,"rule getClaimableRewards_stable_after_withdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    withdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | withdraw (Lines 443-453), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a smart contract by setting up its internal state, including linking to an AToken, setting token name, symbol, and decimals, and configuring allowances and incentives. Additionally, provide a withdrawal function allowing assets to be pulled from the contract, subject to maximum withdrawal limits."
93f17742285f33b66c645050cfcebdfa,248 | 249 | 250,invariant,inv_atoken_balanceOf_2users_leq_totalSupply,172,204,metaWithdraw | withdraw | redeem,"invariant inv_atoken_balanceOf_2users_leq_totalSupply(address user1, address user2)
	(_AToken.balanceOf(user1) + _AToken.balanceOf(user2))<= _AToken.totalSupply()
    {
		preserved with (env e1){
            setup(e1, user1);
		    setup(e1, user2);
		}
        preserved redeem(uint256 shares, address receiver, address owner) with (env e2){
            require user1 != user2;
            require _AToken.balanceOf(currentContract) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        }
        preserved redeem(uint256 shares, address receiver, address owner, bool toUnderlying) with (env e3){
        	requireInvariant sumAllATokenScaledBalance_eq_totalSupply();
            require _AToken.balanceOf(e3.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        preserved withdraw(uint256 assets, address receiver,address owner) with (env e4){
            require _AToken.balanceOf(e4.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();

        preserved metaWithdraw(address owner, address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 deadline,_StaticATokenLM.SignatureParams sigParams)
        with (env e5){
            require _AToken.balanceOf(e5.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
	}
","metaWithdraw (Lines 182-224),  | withdraw (Lines 443-453),  | redeem (Lines 469-478), ","  function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
 |   function redeem(
    uint256 shares,
    address receiver,
    address owner,
    bool toUnderlying
  ) public virtual returns (uint256, uint256) {
    require(shares <= maxRedeem(owner), 'ERC4626: redeem more than max');

    return _withdraw(owner, receiver, shares, 0, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Implement token withdrawal mechanisms using signatures for authentication, allowing users to directly withdraw or redeem assets from their account based on predefined conditions, ensuring that operations meet the requirements regarding owner validity, deadline adherence, and withdrawal limits."
9465dd241cbab432d033f9887874c70d,254 | 255,rule,totalAssets_stable_after_collectAndUpdateRewards,297,307,collectAndUpdateRewards | claimRewardsOnBehalf,"rule totalAssets_stable_after_collectAndUpdateRewards()
rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
{
    env e;
    require _RewardsController.getRewardsByAsset(_AToken, 0) != _AToken;
    require _RewardsController.getUserAccruedReward(currentContract, _AToken, _AToken) ==0;
    address reward;
    mathint totalAssetBefore = totalAssets(e);
    collectAndUpdateRewards(e, reward); 
    mathint totalAssetAfter = totalAssets(e);
    assert totalAssetAfter == totalAssetBefore;
}
","collectAndUpdateRewards (Lines 262-277),  | claimRewardsOnBehalf (Lines 280-291), ","  function collectAndUpdateRewards(address reward) public returns (uint256) {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);

    return
      INCENTIVES_CONTROLLER.claimRewards(
        assets,
        type(uint256).max,
        address(this),
        reward
      );
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Claim rewards for a specified asset by invoking the `INCENTIVES_CONTROLLER`'s `claimRewards` method, which transfers the rewards to a designated address. Additionally, enable external entities to claim rewards on behalf of another account, given they are authorized as the account's claimer or are the account holder themselves."
9907f4c538f0fd18c2ec2390f590b29b,259 | 260,rule,reward_balance_stable_after_collectAndUpdateRewards,312,328,_AToken.transferFrom | collectAndUpdateRewards,"rule reward_balance_stable_after_collectAndUpdateRewards()
{
    env e;
    address reward;
    address sender;
    uint256 amount;

    storage initial = lastStorage;
    collectAndUpdateRewards(e, reward); 
    mathint reward_balance_before = _DummyERC20_rewardToken.balanceOf(currentContract);
    _AToken.transferFrom(e, sender, currentContract, amount) at initial;
    mathint reward_balance_after = _DummyERC20_rewardToken.balanceOf(currentContract);
    assert reward_balance_before == reward_balance_after;
}
","transferFrom (Lines 99-121),  | collectAndUpdateRewards (Lines 262-277), ","  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _beforeTokenTransfer(from, to, amount);
    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

    if (allowed != type(uint256).max)
      allowance[from][msg.sender] = allowed - amount;

    balanceOf[from] -= amount;

    // Cannot overflow because the sum of all user
    // balances can't exceed the max uint256 value.
    unchecked {
      balanceOf[to] += amount;
    }

    emit Transfer(from, to, amount);

    return true;
  }
 |   function collectAndUpdateRewards(address reward) public returns (uint256) {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);

    return
      INCENTIVES_CONTROLLER.claimRewards(
        assets,
        type(uint256).max,
        address(this),
        reward
      );
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Transfer a specified amount of tokens from one account to another if the sender is authorized, updating their balances accordingly, and emitting a Transfer event. Additionally, collect all possible rewards from a given reward address for the caller by claiming them through an incentives controller."
9da12aca901185910ac3e62fb248a5eb,270 | 271,rule,getClaimableRewards_stable_after_deposit,514,553,initialize | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_deposit()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    address user;
    address reward;
    
    uint256 assets;
    address recipient;
    uint16 referralCode;
    bool fromUnderlying = true;

    require user != 0;
    require getRewardTokensLength() == 1;
    require _RewardsController.getAvailableRewardsCount(_AToken)  > 0;
    require _RewardsController.getRewardsByAsset(_AToken, 0) == _DummyERC20_rewardToken;
    require currentContract != user;
    require _AToken != user;
    require _RewardsController !=  user;
    require _DummyERC20_aTokenUnderlying  != user;
    require _DummyERC20_rewardToken != user;
    require _SymbolicLendingPoolL1 != user;
    require _TransferStrategy != user;
    require _ScaledBalanceToken != user;
    //assume a single reward
    require reward == _DummyERC20_rewardToken;
    require getRewardToken(0) == _DummyERC20_rewardToken;
    //require isRegisteredRewardToken(reward); //todo: review the assumption
 
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    deposit(e, assets, recipient,referralCode,fromUnderlying);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | isRegisteredRewardToken (Lines 100-107), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a smart contract by setting its agnostic token details (name, symbol, decimals), approving unlimited transfers of its underlying asset to a given pool, and optionally refreshing reward tokens if a rewards controller is set. Additionally, determine if a reward token is registered with the contract."
ab1031d11c6e0a924cfa4651646516d4,292,rule,sanity_metaDeposit,693,699,metaDeposit,"rule sanity_metaDeposit    ()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaDeposit(e,args);
","metaDeposit (Lines 121-179), ","  function metaDeposit(
    address depositor,
    address recipient,
    uint256 value,
    uint16 referralCode,
    bool fromUnderlying,
    uint256 deadline,
    PermitParams calldata permit,
    SignatureParams calldata sigParams
  ) external returns (uint256) {
    require(depositor != address(0), StaticATokenErrors.INVALID_DEPOSITOR);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[depositor];

    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METADEPOSIT_TYPEHASH,
              depositor,
              recipient,
              value,
              referralCode,
              fromUnderlying,
              nonce,
              deadline,
              permit
            )
          )
        )
      );
      nonces[depositor] = nonce + 1;
      require(
        depositor == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    // assume if deadline 0 no permit was supplied
    if (permit.deadline != 0) {
      IERC20WithPermit(
        fromUnderlying ? address(_aTokenUnderlying) : address(_aToken)
      ).permit(
          depositor,
          address(this),
          permit.value,
          permit.deadline,
          permit.v,
          permit.r,
          permit.s
        );
    }
    return _deposit(depositor, recipient, value, referralCode, fromUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Verify the depositor's signature and, if an ERC20 token permit is provided, use it to approve a deposit on their behalf. It increments the depositor's nonce to prevent replay attacks, checks for deadline validity, and facilitates the deposit to a recipient with an optional referral code."
aee6dd6613f4b2497488f412dc63cc89,285 | 286 | 287,rule,getClaimableRewards_stable_after_refreshRewardTokens,638,653,initialize | refreshRewardTokens | isRegisteredRewardToken,"rule getClaimableRewards_stable_after_refreshRewardTokens()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{

    env e;
    address user;
    address reward;
    //require isRegisteredRewardToken(reward); //todo: review assumption
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    refreshRewardTokens(e);
    setup(e, user);    
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","initialize (Lines 68-87),  | refreshRewardTokens (Lines 90-97),  | isRegisteredRewardToken (Lines 100-107), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function refreshRewardTokens() public override {
    address[] memory rewards = INCENTIVES_CONTROLLER.getRewardsByAsset(
      address(_aToken)
    );
    for (uint256 i = 0; i < rewards.length; i++) {
      _registerRewardToken(rewards[i]);
    }
  }
 |   function isRegisteredRewardToken(address reward)
    public
    view
    override
    returns (bool)
  {
    return _startIndex[reward] != 0;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a new token by setting its name, symbol, decimals, and underlying asset, then approves an unlimited amount to a predefined pool, and optionally refreshes reward tokens if an incentives controller is set. It also provides methods to update and check registered reward tokens."
b3c244bdda23c1dbf83c2a347616e708,283,rule,getClaimableRewards_stable,601,607,initialize,"/// @title special case of rule getClaimableRewards_stable for initialize
//fail
//todo: consider removing this rule. no method is called before initialize()
/// @title getClaimableRewards() is stable after initialize()
/// @dev case splitting
rule getClaimableRewards_stable_after_initialize(method f)
    filtered { f -> !f.isView && !claimFunctions(f) }{
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a token contract by setting its underlying asset, name, symbol, and decimals. It approves an unlimited amount of the underlying asset for the specified pool and optionally refreshes rewards tokens if an incentives controller is set, emitting an initialization event."
ea7d4570d01619657844781819447258,263 | 264,rule,totalClaimableRewards_stable_after_initialized,410,448,initialize | getTotalClaimableRewards,"rule totalClaimableRewards_stable_after_initialized()
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
{
    env e;
    require e.msg.sender != currentContract;
    setup(e, 0);
    calldataarg args;
    address reward;

    require e.msg.sender != reward;
 
    require currentContract != e.msg.sender;
    require _AToken != e.msg.sender;
    require _RewardsController != e.msg.sender;
    require _DummyERC20_aTokenUnderlying  != e.msg.sender;
    require _DummyERC20_rewardToken != e.msg.sender;
    require _SymbolicLendingPoolL1 != e.msg.sender;
    require _TransferStrategy != e.msg.sender;
    require _ScaledBalanceToken != e.msg.sender;
    require currentContract != reward;
    require _AToken != reward;
    require _RewardsController !=  reward;
    require _DummyERC20_aTokenUnderlying  != reward;
    require _SymbolicLendingPoolL1 != reward;
    require _TransferStrategy != reward;
    require _ScaledBalanceToken != reward;
    address newAToken;
    string staticATokenName;
    string staticATokenSymbol;
    mathint totalClaimableRewardsBefore = getTotalClaimableRewards(e, reward);
    initialize(e, newAToken, staticATokenName, staticATokenSymbol);
    mathint totalClaimableRewardsAfter = getTotalClaimableRewards(e, reward);
    assert totalClaimableRewardsAfter == totalClaimableRewardsBefore;
}
","initialize (Lines 68-87),  | getTotalClaimableRewards (Lines 320-337), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a new AToken by setting its contract address, name, symbol, decimals, and underlying asset. Approve the maximum possible amount of the underlying asset for the pool. Optionally, refresh reward tokens if an incentives controller exists. Additionally, compute the total claimable rewards for a specified reward token by summing the rewards available directly and the fresh rewards from the controller for this contract."
eceb25c7b4d1c28f1b1637211e6bc892,262,rule,totalClaimableRewards_stable_SANITY,370,371,initialize,"rule totalClaimableRewards_stable_SANITY(method f)
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
    filtered { f -> f.selector == claimSingleRewardOnBehalf(address, address,address).selector   }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a contract by setting an ERC20 token's address, its static name, symbol, and decimals based on the provided token's metadata. Approve an unlimited allowance to a predefined pool from the token's underlying asset. Optionally refresh reward tokens and emit an initialization event."
ee6d8f5bd36e0405046f6e299fc7f330,293,rule,sanity_metaWithdraw,700,706,metaWithdraw,"rule sanity_metaWithdraw()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaWithdraw(e,args);
","metaWithdraw (Lines 182-224), ","  function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Verify the authenticity and timeliness of a meta-withdrawal request by checking the signature and deadline. Then, increment the user's nonce to prevent replay attacks, and execute the withdrawal from the owner's account to the recipient, handling both static and dynamic amounts, and optionally converting to the underlying asset."
f884b100c609512a7788b4fb61931545,267 | 269,rule,getClaimableRewards_stable_SANITY,483,486,initialize | claimRewardsOnBehalf,"rule getClaimableRewards_stable_SANITY(method f)
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
    filtered { f -> //claimFunctions(f)
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector   
","initialize (Lines 68-87),  | claimRewardsOnBehalf (Lines 280-291), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: The code initializes a new token by setting its name, symbol, decimals, and underlying asset, and approves the maximum amount of this asset to a designated pool. It also enables claiming rewards on behalf of another address, given specific conditions are met."
ea7d4570d01619657844781819447258,263 | 264,rule,totalClaimableRewards_stable_after_initialized,410,448,initialize | getTotalClaimableRewards,"rule totalClaimableRewards_stable_after_initialized()
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
{
    env e;
    require e.msg.sender != currentContract;
    setup(e, 0);
    calldataarg args;
    address reward;

    require e.msg.sender != reward;
 
    require currentContract != e.msg.sender;
    require _AToken != e.msg.sender;
    require _RewardsController != e.msg.sender;
    require _DummyERC20_aTokenUnderlying  != e.msg.sender;
    require _DummyERC20_rewardToken != e.msg.sender;
    require _SymbolicLendingPoolL1 != e.msg.sender;
    require _TransferStrategy != e.msg.sender;
    require _ScaledBalanceToken != e.msg.sender;
    require currentContract != reward;
    require _AToken != reward;
    require _RewardsController !=  reward;
    require _DummyERC20_aTokenUnderlying  != reward;
    require _SymbolicLendingPoolL1 != reward;
    require _TransferStrategy != reward;
    require _ScaledBalanceToken != reward;
    address newAToken;
    string staticATokenName;
    string staticATokenSymbol;
    mathint totalClaimableRewardsBefore = getTotalClaimableRewards(e, reward);
    initialize(e, newAToken, staticATokenName, staticATokenSymbol);
    mathint totalClaimableRewardsAfter = getTotalClaimableRewards(e, reward);
    assert totalClaimableRewardsAfter == totalClaimableRewardsBefore;
}
","initialize (Lines 68-87),  | getTotalClaimableRewards (Lines 320-337), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a contract with the given aToken details (address, name, symbol), approve the maximum token transfer amount to a defined pool, and if applicable, refresh available reward tokens. Additionally, compute and return the total claimable rewards for a specified reward address."
eceb25c7b4d1c28f1b1637211e6bc892,262,rule,totalClaimableRewards_stable_SANITY,370,371,initialize,"rule totalClaimableRewards_stable_SANITY(method f)
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
    filtered { f -> f.selector == claimSingleRewardOnBehalf(address, address,address).selector   }
","initialize (Lines 68-87), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a smart contract by setting its underlying asset token, name, symbol, decimals, approving the maximum token amount to a pool, optionally refreshing reward tokens if an incentives controller is set, and emitting an initialization event with provided parameters."
ee6d8f5bd36e0405046f6e299fc7f330,293,rule,sanity_metaWithdraw,700,706,metaWithdraw,"rule sanity_metaWithdraw()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaWithdraw(e,args);
","metaWithdraw (Lines 182-224), ","  function metaWithdraw(
    address owner,
    address recipient,
    uint256 staticAmount,
    uint256 dynamicAmount,
    bool toUnderlying,
    uint256 deadline,
    SignatureParams calldata sigParams
  ) external returns (uint256, uint256) {
    require(owner != address(0), StaticATokenErrors.INVALID_OWNER);
    //solium-disable-next-line
    require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);
    uint256 nonce = nonces[owner];
    // Unchecked because the only math done is incrementing
    // the owner's nonce which cannot realistically overflow.
    unchecked {
      bytes32 digest = keccak256(
        abi.encodePacked(
          '\x19\x01',
          DOMAIN_SEPARATOR(),
          keccak256(
            abi.encode(
              METAWITHDRAWAL_TYPEHASH,
              owner,
              recipient,
              staticAmount,
              dynamicAmount,
              toUnderlying,
              nonce,
              deadline
            )
          )
        )
      );
      nonces[owner] = nonce + 1;
      require(
        owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),
        StaticATokenErrors.INVALID_SIGNATURE
      );
    }
    return
      _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Verify a withdrawal request's authenticity and parameters, including the owner's identity and the request's timeliness, using EIP-712 typed signatures. Upon successful validation, increment the nonce and execute the withdrawal, transferring specified static and dynamic amounts to the intended recipient."
f884b100c609512a7788b4fb61931545,267 | 269,rule,getClaimableRewards_stable_SANITY,483,486,initialize | claimRewardsOnBehalf,"rule getClaimableRewards_stable_SANITY(method f)
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
    filtered { f -> //claimFunctions(f)
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector   
","initialize (Lines 68-87),  | claimRewardsOnBehalf (Lines 280-291), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
",./aave_static_token/StaticATokenLM.spec,aave_static_token,,Yes,,"Functionality: Initialize a smart contract by setting up its basic features, including its associated token, name, symbol, and decimals. It approves unlimited transfers for the underlying asset and refreshes reward tokens if an incentives controller is set. Additionally, it enables claiming rewards on behalf of another address, provided proper authorization is verified."
5c1eb3914f9849608311093a82e49318,318,rule,rewardsTotalDoesNotDeclineByDeposit,184,197,getTotalClaimableRewards,"rule rewardsTotalDoesNotDeclineByDeposit(uint256 assets) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	deposit(e, assets, e.msg.sender);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by deposit"";
}
","getTotalClaimableRewards (Lines 320-337), ","  function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/rewardPreserve.spec,aave_static_token,,Yes,,"Functionality: Compute the total claimable rewards for a specific address by summing the current balance of the rewards at that address and any fresh rewards accumulated from specified asset interactions through the incentives controller, returning zero if the reward address is not specified."
74b110f6138c21f9b68a8a13ccdbd513,315 | 316,rule,rewardsTotalDoesNotDeclineByWithdraw,167,181,getTotalClaimableRewards | withdraw,"rule rewardsTotalDoesNotDeclineByWithdraw() {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	calldataarg args;
	withdraw(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by withdraw"";
}
","getTotalClaimableRewards (Lines 320-337),  | withdraw (Lines 443-453), ","  function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
 |   function withdraw(
    uint256 assets,
    address receiver,
    address owner
  ) public virtual returns (uint256) {
    require(assets <= maxWithdraw(owner), 'ERC4626: withdraw more than max');

    (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, false);

    return shares;
  }
",./aave_static_token/rewardPreserve.spec,aave_static_token,,Yes,,"Functionality: Calculate and return the total claimable rewards for a given reward address, accounting for both the current balance of the reward token at the contract's address and any fresh rewards accumulated. Additionally, facilitate the withdrawal of assets by a user, enforcing a maximum withdrawal limit based on ownership, and return the corresponding shares withdrawn."
a7e8e6f427f8c6efc0c7051d5652af41,310 | 311 | 314,rule,rewardsTotalDeclinesOnlyByClaim,140,162,initialize | claimRewardsOnBehalf | getTotalClaimableRewards,"rule rewardsTotalDeclinesOnlyByClaim(method f) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	require f.selector != initialize(address, address, string, string).selector;
	uint256 preTotal = getTotalClaimableRewards(e);
	uint256 preRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	calldataarg args;
	f(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	uint256 postRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	require preRewards == postRewards;
	assert (postTotal < preTotal) => (
		(f.selector == claimRewardsOnBehalf(address, address).selector) ||
		(f.selector == claimRewards(address).selector) ||
		(f.selector == claimRewardsToSelf().selector)
	), ""Total rewards decline not due to claim"";
}
","initialize (Lines 68-87),  | claimRewardsOnBehalf (Lines 280-291),  | getTotalClaimableRewards (Lines 320-337), ","  function initialize(
    address newAToken,
    string calldata staticATokenName,
    string calldata staticATokenSymbol
  ) external initializer {
    _aToken = IERC20(newAToken);

    name = staticATokenName;
    symbol = staticATokenSymbol;
    decimals = IERC20Metadata(newAToken).decimals();

    _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();
    IERC20(_aTokenUnderlying).safeApprove(address(POOL), type(uint256).max);

    if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
      refreshRewardTokens();
    }

    emit Initialized(newAToken, staticATokenName, staticATokenSymbol);
  }
 |   function claimRewardsOnBehalf(
    address onBehalfOf,
    address receiver,
    address[] memory rewards
  ) external {
    require(
      msg.sender == onBehalfOf ||
        msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),
      StaticATokenErrors.INVALID_CLAIMER
    );
    _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);
  }
 |   function getTotalClaimableRewards(address reward)
    external
    view
    returns (uint256)
  {
    if (reward == address(0)) {
      return 0;
    }

    address[] memory assets = new address[](1);
    assets[0] = address(_aToken);
    uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(
      assets,
      address(this),
      reward
    );
    return IERC20(reward).balanceOf(address(this)) + freshRewards;
  }
",./aave_static_token/rewardPreserve.spec,aave_static_token,,Yes,,"Functionality: Initialize a smart contract by setting an aToken's parameters, approve infinite spending by a specific pool for the underlying asset, and handle rewards through claiming on behalf of an authorized user or calculating total claimable rewards for a specified reward token."
416fe8e50d23269d127c38d71950a3ca,234 | 235,rule,cross-layerRewardDistribution,102,165,initialize | BRIDGE_L2.deposit,"    // If any rule that count on the reward token balance, calls this method a `require RewardsVault != to` make sense to add
    //claimRewards(address[], uint256, address) returns (uint256) => DISPATCHER(true)
    getRewardsBalance(address[], address) returns (uint256) => DISPATCHER(true)

/***************************
 *     BridgeL2Harness     *
 ***************************/
    BRIDGE_L2.l2RewardsIndexSetter(uint256)
    BRIDGE_L2.deposit(address, uint256, address) 
    BRIDGE_L2.initiateWithdraw(address, uint256, address, address, bool)
    BRIDGE_L2.bridgeRewards(address, address, uint256)
    BRIDGE_L2.claimRewards(address, address)
    BRIDGE_L2.l2RewardsIndex() returns (uint256) envfree
    BRIDGE_L2.getStaticATokenAddress(address) returns (address) envfree
    BRIDGE_L2.address2uint256(address) returns (uint256) envfree
    l1ToL2MessageNonce() returns (uint256) => NONDET
/******************
 *     Tokens     *
 ******************/
    UNDERLYING_ASSET_ADDRESS() returns (address) => DISPATCHER(true)
    ATOKEN_A.UNDERLYING_ASSET_ADDRESS() returns (address) envfree
    ATOKEN_B.UNDERLYING_ASSET_ADDRESS() returns (address) envfree  
    claimRewards(address) returns (uint256) => DISPATCHER(true)
    getRewTokenAddress() returns (address) => rewardToken()
 *     Ray Math   *
 // See also notes at bottom of file (under ""Summarizations"")
 // Comment out the next two lines to remove the simplification,
 // and let the prover use the original library functions.
   // rayMul(uint256 a, uint256 b) returns (uint256) => rayMulConst(a, b)
   // rayDiv(uint256 a, uint256 b) returns (uint256) => rayDivConst(a, b)
}
////////////////////////////////////////////////////////////////////////////
//                       Definitions                                      //
// Definition of RAY unit
definition RAY() returns uint256 = 10^27;
definition MAX_ARRAY_LENGTH() returns uint256 = max_uint;
// Used for the Ray math summarization.
// Effectively sets the liquidity index in L1 to be a constant, given
// by the following value.
// Note: if the summarization is not used, i.e. they are commented out,
// this value has no use.
definition myConstRayValue() returns uint256 = (10*RAY())/2;
// The following definition shall be used later in some invariants,
// by filtering out the 'initialize' function.
definition excludeInitialize(method f) returns bool =
    f.selector != 
    initialize(uint256, address, address, address[], uint256[], uint256[]).selector; 
// A filter for parametric rules.
// The functions receiveRewards and withdraw should not be called by an external user
// Unless a message was already sent, which we mock through the additional functions that
// call the L2 interface.
// Using this filter via:
// filtered{f -> messageSentFilter(f)} will reduce running time, by skipping the analysis
","initialize (Lines 53-71),  | deposit (Lines 74-140), ","    function initialize(
        uint256 l2Bridge,
        address messagingContract,
        address incentivesController,
        address[] calldata l1Tokens,
        uint256[] calldata l2Tokens,
        uint256[] calldata ceilings
    ) external virtual onlyValidL2Address(l2Bridge) initializer {
        require(
            address(incentivesController) != address(0),
            Errors.B_INVALID_INCENTIVES_CONTROLLER_ADDRESS
        );
        _messagingContract = IStarknetMessaging(messagingContract);
        _l2Bridge = l2Bridge;
        _incentivesController = IAaveIncentivesController(incentivesController);
        _rewardToken = IERC20(_incentivesController.REWARD_TOKEN());

        _approveBridgeTokens(l1Tokens, l2Tokens, ceilings);
    }
 |     function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/setup.spec,aave_starknet_bridge,,Yes,,"Functionality: Initialize a bridge for token transfers between Layer 1 and Layer 2, setting contracts for messaging, incentives, and token parameters. It allows users to deposit tokensither directly or from an underlying assetpdating the state on L2 and tracking the deposit through events and reward indices."
2ec666caa49ec8d5382ab9e7a4c51a0e,233,rule,integrityOfDepositExpanded,72,147,deposit,"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceBefore - senderATokenBalanceAfter - amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,aave_starknet_bridge,,Yes,,"Functionality: Validate and process a deposit transaction by transferring either an aToken or its underlying asset from the user to the contract, updating the L2 state, and emitting a corresponding deposit event. The amount transferred must adhere to specified limits and requirements."
432ef9f3ac5b304e3d2889caca3ac4c9,231,invariant,alwaysUnSent,17,63,deposit,"use invariant alwaysUnSent // Imports the invariant alwaysUnSent
use invariant ATokenAssetPair // Imports the invariant ATokenAssetPair

////////////////////////////////////////////////////////////////////////////
//                       Rules                                            //
// A call to deposit and a subsequent call to withdraw with the same amount of 
// staticATokens received, should yield the same original balance for the user.
// For underlying tokens, the condition is modified by a bound, since staticToDynamic is not inversible with dyanmicToStatic.
rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset
    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,aave_starknet_bridge,,Yes,,"Functionality: Validate inputs and transfer either an aToken or its underlying asset from a sender to the contract, depositing the asset into a lending pool if it's the underlying asset. Then, calculate a static amount, update the L2 state with a message, and emit a Deposit event."
c4a147a06800d9ec64421eaf69d5f949,232,rule,depositWithdrawReversed,27,63,deposit,"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridgeConstIndex.spec,aave_starknet_bridge,,Yes,,"Functionality: Validate and process deposits either in aToken or its underlying asset into a lending pool, updating the L2 state and rewards index accordingly. The function checks for balance limits, asset approval, and positive amounts before transferring funds and emitting a Deposit event with relevant details."
5469a2ca6f387e7ad4f58768baa6ed6b,245,rule,integrityOfDepositExpanded,375,450,deposit,"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Validate and process a deposit, either of an aToken or its underlying asset, into a lending pool. It checks the deposit does not exceed the set ceiling, transfers the asset, updates L2 state, calculates a static amount for the deposit based on rewards, and emits a deposit event."
9190e21447ea5256050cbbbe7ccea5e0,244,rule,afterCancellationStartMustSucceed,291,314,startDepositCancellation,"rule afterCancellationStartMustSucceed(uint256 amount, address user) {
    env e1; env e2;
    address asset;
    address aToken;
    address static;
    setupTokens(asset, aToken, static);
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    uint256 dynamic = _staticToDynamicAmount_Wrapper(amount, asset, LENDINGPOOL_L1);
    require amount < 2^127;
    require tokenBalanceOf(e2, aToken, currentContract) >= dynamic;
    require tokenBalanceOf(e2, asset, currentContract) >= amount;
    require e1.block.timestamp > 0;
    require e2.block.timestamp > e1.block.timestamp;
    startDepositCancellation(e1, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit@withrevert(e2, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    bool cancelReverted = lastReverted;
    assert cancelReverted <=> !readyToCancel(e2, nonce);
}
","startDepositCancellation (Lines 465-494), ","    function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Initiate the cancellation of a deposit from Layer 1 to Layer 2 by creating a payload containing the sender, recipient, token addresses, amount, block number, and rewards index. This payload is then used to start a message cancellation through a messaging contract, emitting an event upon execution."
ae39b0814b54f7c493aacca03342581d,241 | 242 | 243,rule,cannotCancelDepositAndGainBothTokens,252,287,deposit | startDepositCancellation | cancelDeposit,"rule cannotCancelDepositAndGainBothTokens(address user, uint256 amount) {
    env e1; env e2; env e3;
    calldataarg args1;
    address asset;
    address aToken;
    address static;
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    uint16 code;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    setupTokens(asset, aToken, static);
    setupUser(user);
    require user == e1.msg.sender;
    require user == e2.msg.sender;
    require user == e3.msg.sender;
    
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance1 = tokenBalanceOf(e1, static, user);
    uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
    uint256 ATokenBalance2 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance2 = tokenBalanceOf(e1, static, user);
    startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance3 = tokenBalanceOf(e3, aToken, user);
    uint256 staticBalance3 = tokenBalanceOf(e3, static, user);
    // If static tokens were minted, no deposit cancellation should succeed.
        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 
        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
    assert staticBalance2 > staticBalance1 => ATokenBalance3 == ATokenBalance2;
","deposit (Lines 74-140),  | startDepositCancellation (Lines 465-494),  | cancelDeposit (Lines 497-554), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
 |     function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
 |     function cancelDeposit(
        address l1AToken,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1AToken].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.cancelL1ToL2Message(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );

        address underlyingAsset = address(
            _aTokenData[l1AToken].underlyingAsset
        );
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        uint256 dynamicAmount = _staticToDynamicAmount(
            amount,
            underlyingAsset,
            lendingPool
        );

        //transfer aTokens back to depositor
        IERC20(l1AToken).safeTransfer(msg.sender, dynamicAmount);

        //claim any accrued rewards for the depositor during the cancellation period
        uint256 currentRewardsIndex = _getCurrentRewardsIndex(l1AToken);
        uint256 rewardsAmount = _computeRewardsDiff(
            amount,
            rewardsIndex,
            currentRewardsIndex
        );

        if (rewardsAmount > 0) {
            _transferRewards(msg.sender, rewardsAmount);
            emit RewardsTransferred(_l2Bridge, msg.sender, rewardsAmount);
        }

        emit CancelledDeposit(
            l2Recipient,
            msg.sender,
            rewardsIndex,
            blockNumber,
            dynamicAmount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Allow token deposits from an L1 asset into an L2 scaling solution, including handling deposit cancellations and rewards management. The code enables transferring assets or their underlying equivalents to an L2 recipient, with mechanisms to start and finalize cancellations of pending deposits, while also calculating and transferring any accrued rewards based on dynamic changes in asset valuations."
b50baaae649904fc8c2aec1fda30bde8,237,rule,initializeIntegrity,191,206,initialize,"rule initializeIntegrity(address AToken, address asset)
{
    env e;
    calldataarg args;

    // Post-constructor conditions
    require getUnderlyingAssetHelper(AToken) == 0;
    require getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == 0;
    
    initialize(e, args);
    assert (asset !=0 && AToken !=0) => (
        getUnderlyingAssetHelper(AToken) == asset 
        <=>
        getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == AToken);
}
","initialize (Lines 53-71), ","    function initialize(
        uint256 l2Bridge,
        address messagingContract,
        address incentivesController,
        address[] calldata l1Tokens,
        uint256[] calldata l2Tokens,
        uint256[] calldata ceilings
    ) external virtual onlyValidL2Address(l2Bridge) initializer {
        require(
            address(incentivesController) != address(0),
            Errors.B_INVALID_INCENTIVES_CONTROLLER_ADDRESS
        );
        _messagingContract = IStarknetMessaging(messagingContract);
        _l2Bridge = l2Bridge;
        _incentivesController = IAaveIncentivesController(incentivesController);
        _rewardToken = IERC20(_incentivesController.REWARD_TOKEN());

        _approveBridgeTokens(l1Tokens, l2Tokens, ceilings);
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Initialize a bridging contract with Starknet messaging, setting specific tokens and their ceilings for transfer, alongside configuring an incentives controller. It ensures a non-zero incentives controller address, approves token transfers on the bridge, and associates a reward token from the incentives controller."
bc6bedc574d165310c9dbe483f1fd089,238 | 239 | 240,rule,cancelAfterDepositGivesBackExactAmount,209,249,deposit | startDepositCancellation | cancelDeposit,"rule cancelAfterDepositGivesBackExactAmount(uint256 amount) {
    
    env e1;
    env e2;
    env e3;
    address user = e1.msg.sender;
    address asset ;
    address aToken;
    address static ;
    address recipient;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;
    uint16 code;

    setupTokens(asset, aToken, static);
    requireValidUser(user);
    requireRayIndex(asset);
    require e1.msg.sender == e2.msg.sender;
    require e2.msg.sender == e3.msg.sender;
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp < e3.block.timestamp;
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 assetBalance1 = tokenBalanceOf(e1, asset, user);
        uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
        startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
        cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance2 = tokenBalanceOf(e3, aToken, user);
    uint256 assetBalance2 = tokenBalanceOf(e3, asset, user);
    if(fromUA){
        assert assetBalance1 == assetBalance2 + amount;
        assert ATokenBalance2 == ATokenBalance1 + amount;  
    }
    else {
        assert assetBalance1 == assetBalance2;
        assert ATokenBalance1 == ATokenBalance2;
}
","deposit (Lines 74-140),  | startDepositCancellation (Lines 465-494),  | cancelDeposit (Lines 497-554), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
 |     function startDepositCancellation(
        address l1Token,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1Token].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.startL1ToL2MessageCancellation(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );
        emit StartedDepositCancellation(
            l2Recipient,
            rewardsIndex,
            blockNumber,
            amount,
            nonce
        );
    }
 |     function cancelDeposit(
        address l1AToken,
        uint256 amount,
        uint256 l2Recipient,
        uint256 rewardsIndex,
        uint256 blockNumber,
        uint256 nonce
    ) external onlyValidL2Address(l2Recipient) {
        uint256[] memory payload = new uint256[](9);
        payload[0] = uint256(uint160(msg.sender));
        payload[1] = l2Recipient;
        payload[2] = _aTokenData[l1AToken].l2TokenAddress;
        (payload[3], payload[4]) = Cairo.toSplitUint(amount);
        (payload[5], payload[6]) = Cairo.toSplitUint(blockNumber);
        (payload[7], payload[8]) = Cairo.toSplitUint(rewardsIndex);

        _messagingContract.cancelL1ToL2Message(
            _l2Bridge,
            Cairo.DEPOSIT_HANDLER,
            payload,
            nonce
        );

        address underlyingAsset = address(
            _aTokenData[l1AToken].underlyingAsset
        );
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        uint256 dynamicAmount = _staticToDynamicAmount(
            amount,
            underlyingAsset,
            lendingPool
        );

        //transfer aTokens back to depositor
        IERC20(l1AToken).safeTransfer(msg.sender, dynamicAmount);

        //claim any accrued rewards for the depositor during the cancellation period
        uint256 currentRewardsIndex = _getCurrentRewardsIndex(l1AToken);
        uint256 rewardsAmount = _computeRewardsDiff(
            amount,
            rewardsIndex,
            currentRewardsIndex
        );

        if (rewardsAmount > 0) {
            _transferRewards(msg.sender, rewardsAmount);
            emit RewardsTransferred(_l2Bridge, msg.sender, rewardsAmount);
        }

        emit CancelledDeposit(
            l2Recipient,
            msg.sender,
            rewardsIndex,
            blockNumber,
            dynamicAmount,
            nonce
        );
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Facilitate deposit and cancellation of tokens for cross-chain transfers between Layer 1 and Layer 2, ensuring compliance with token ceilings, handling asset conversion, managing nonce for message tracking, and processing rewards for deposits and cancellations."
e1b05b2eeb80abf195c4651197e441d5,236,rule,depositWithdrawReversed,96,132,deposit,"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Transfer a specified amount of aTokens or underlying assets from a user to the contract, depositing the assets into a lending pool if from underlying assets, updating the Layer 2 (L2) state, and emitting a deposit event with relevant transaction details."
e1b05b2eeb80abf195c4651197e441d5,236,rule,depositWithdrawReversed,96,132,deposit,"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","deposit (Lines 74-140), ","    function deposit(
        address l1AToken,
        uint256 l2Recipient,
        uint256 amount,
        uint16 referralCode,
        bool fromUnderlyingAsset
    ) external override onlyValidL2Address(l2Recipient) returns (uint256) {
        require(
            IERC20(l1AToken).balanceOf(address(this)) + amount <=
                _aTokenData[l1AToken].ceiling,
            Errors.B_ABOVE_CEILING
        );
        IERC20 underlyingAsset = _aTokenData[l1AToken].underlyingAsset;
        ILendingPool lendingPool = _aTokenData[l1AToken].lendingPool;
        require(
            underlyingAsset != IERC20(address(0)),
            Errors.B_ATOKEN_NOT_APPROVED
        );
        require(amount > 0, Errors.B_INSUFFICIENT_AMOUNT);
        // deposit aToken or underlying asset

        if (fromUnderlyingAsset) {
            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);
            lendingPool.deposit(
                address(underlyingAsset),
                amount,
                address(this),
                referralCode
            );
        } else {
            IERC20(l1AToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        // update L2 state and emit deposit event

        uint256 rewardsIndex = _getCurrentRewardsIndex(l1AToken);

        uint256 staticAmount = _dynamicToStaticAmount(
            amount,
            address(underlyingAsset),
            lendingPool
        );
        uint256 l2MsgNonce = _messagingContract.l1ToL2MessageNonce();
        _sendDepositMessage(
            l1AToken,
            msg.sender,
            l2Recipient,
            staticAmount,
            block.number,
            rewardsIndex
        );
        emit Deposit(
            msg.sender,
            l1AToken,
            staticAmount,
            l2Recipient,
            block.number,
            rewardsIndex,
            l2MsgNonce
        );

        return staticAmount;
    }
",./aave_starknet_bridge/specs/bridge.spec,aave_starknet_bridge,,Yes,,"Functionality: Validate and process deposits of either aTokens or underlying assets to a lending pool, adjusting for asset ceilings and ensuring tokens are approved. It updates the L2 state, emits a deposit event, and returns the amount deposited in a static representation for L2 accounting."
34b04b9b51b850184861d2ebf0d20845,161 | 165,invariant,allSharesAreBacked,6,30,stakeWithPermit | returnFunds,"                  summarization is because the invariant does not claim anything about rewards.
    @Link: https://prover.certora.com/output/40577/370f63ee225743daba41087449111d8b/?anonymousKey=717499ff4fdcce2c8131025b4e00ade0e3a14200
*/
invariant allSharesAreBacked()
    previewRedeem(totalSupply()) <= stake_token.balanceOf(currentContract)
    {
        preserved stake(address to, uint256 amount) with (env e2)
        {
            require e2.msg.sender != currentContract;
        }
        preserved stakeWithPermit(address from, uint256 amount, uint256 deadline,
            uint8 v, bytes32 r, bytes32 s) with (env e3)
            require from != currentContract;
        preserved returnFunds(uint256 amount) with (env e4)
            require e4.msg.sender != currentContract;
        preserved initialize(address slashingAdmin, address cooldownPauseAdmin, address claimHelper,
                            uint256 maxSlashablePercentage, uint256 cooldownSeconds) with (env e5)
            require getExchangeRate() == INITIAL_EXCHANGE_RATE();
    }
","stakeWithPermit (Lines 103-121),  | returnFunds (Lines 299-308), ","  function stakeWithPermit(
    address from,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external override {
    IERC20WithPermit(address(STAKED_TOKEN)).permit(
      from,
      address(this),
      amount,
      deadline,
      v,
      r,
      s
    );
    _stake(from, from, amount);
  }
 |   function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/propertiesWithSummarizations.spec,aave_staked_token,,Yes,,"Functionality: Enable users to stake tokens with a permit, bypassing the need for a separate approval transaction, and return funds by transferring them back to the contract. It verifies minimum amount constraints, dynamically adjusts the exchange rate based on total supply, and logs the fund's return event."
559e8f53cbd85ad6dfcd5310cd05c816,178 | 179,invariant,cooldownAmountNotGreaterThanBalance,51,71,transfer | transferFrom,"invariant cooldownAmountNotGreaterThanBalance(address user)
    balanceOf(user) >= cooldownAmount(user)
    {
        preserved with (env e1)
        {
            requireInvariant cooldownDataCorrectness(user, e1);
            requireInvariant totalSupplyGreaterThanUserBalance(user);
invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
            requireInvariant cooldownDataCorrectness(user, e2);
            requireInvariant cooldownDataCorrectness(user, e3);
","transfer (Lines 53-61),  | transferFrom (Lines 81-90), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
 |   function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external override returns (bool) {
    b[sender] = sub(b[sender], amount);
    b[recipient] = add(b[recipient], amount);
    a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
    return true;
  }
",./aave_staked_token/certora/specs/invariants.spec,aave_staked_token,,Yes,,"Functionality: Implement token transfer mechanisms in a smart contract. The `transfer` function allows a sender to move tokens directly to a recipient, reducing the sender's balance and increasing the recipient's balance. The `transferFrom` function facilitates a transfer on behalf of the sender, adjusting both the sender's and the designated recipient's balances, and decrementing the allowance set for the caller."
c9fc17a95b00ed74332addb1fe6124b7,186 | 187,invariant,totalSupplyGreaterThanUserBalance,78,109,transfer | transferFrom,"invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
    {
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
        {
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
","transfer (Lines 53-61),  | transferFrom (Lines 81-90), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
 |   function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external override returns (bool) {
    b[sender] = sub(b[sender], amount);
    b[recipient] = add(b[recipient], amount);
    a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
    return true;
  }
",./aave_staked_token/certora/specs/invariants.spec,aave_staked_token,,Yes,,"Functionality: Allow users to transfer tokens directly between accounts with `transfer`, and enable a delegated transfer through `transferFrom`, decrementing the sender's balance, incrementing the recipient's, and updating the allowance the delegator has from the sender's account."
3edc675e26f6df969ebaab972be9d2c9,201,rule,integrityOfReturnFunds,184,200,returnFunds,"rule integrityOfReturnFunds(uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract);

    uint256 balanceStakeTokenSenderBefore = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenSenderBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    returnFunds(e, amount);
    uint256 balanceStakeTokenSenderAfter = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenVaultAfter > 0);
    assert balanceStakeTokenSenderAfter == balanceStakeTokenSenderBefore - amount;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore + amount;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Check if the requested `amount` meets a minimum threshold. Ensure the current shares are above a required minimum, and adjust the exchange rate based on the total assets after adding the `amount`. Transfer the specified `amount` of a token from the sender to the contract and log the transaction."
5990981935b4a7f4e51dab8559df3667,217,rule,returnFundsDecreaseExchangeRate,499,511,returnFunds,"rule returnFundsDecreaseExchangeRate(address receiver, uint256 amount) {
    env e;
    uint216 _ExchangeRate = getExchangeRate();

    // Currently, in the constructor, LOWER_BOUND = 10**decimals
    requireInvariant lowerBoundNotZero();
    returnFunds(e, amount);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ <= _ExchangeRate;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Verify that the requested amount and the total current shares are above a predefined minimum threshold. Update the exchange rate by adding the amount to the current assets before initiating the transfer from the sender to the contract. Finally, emit an event signaling the return of funds."
655103f9f0b4c260e5a6928b35ff315e,222 | 223,rule,slashAndReturnFundsOfZeroDoesntChangeExchangeRate,561,575,slash | returnFunds,"rule slashAndReturnFundsOfZeroDoesntChangeExchangeRate() {
    env e;
    address dest; uint256 amt = 0;
    uint216 _ER = getExchangeRate();
    storage initialStorage = lastStorage;

    slash(e, dest, amt);
    uint216 ER_AfterSlash = getExchangeRate();
    returnFunds(e, amt) at initialStorage;
    uint216 ER_AfterReturnFunds = getExchangeRate();
    assert(ER_AfterSlash == ER_AfterReturnFunds);
    assert(ER_AfterReturnFunds == _ER);
}
","slash (Lines 271-296),  | returnFunds (Lines 299-308), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
 |   function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Slash funds from a contract by transferring a specified amount to a designated address, ensuring this amount does not exceed a pre-defined maximum and retaining a minimal balance post-transfer. Additionally, enable the return of funds to the contract, augmenting its assets and adjusting the exchange rate accordingly."
982e55f477c725e3a79bd56f6210e61a,219,rule,exchangeRateNeverZero,526,543,returnFunds,"    @Notes: We used the following require to prove, that violation of this rule happened
            when totalSupply() == 0:
            require f.selector == returnFunds(uint256).selector => totalSupply() != 0;
            This has been solved by Lukas in this commit:
            https://github.com/Certora/aave-stk-slashing-mgmt/pull/1/commits/8336dc0747965a06c7dc39b4f89273c4ef7ed18a
    @Link: https://prover.certora.com/output/40577/3fdb151c46c84b1ab323b99c80890273/?anonymousKey=68e37ada870b7b91c68a5eadaf6030f3989002a6
*/
rule exchangeRateNeverZero(method f) {
    env e; calldataarg args;
    uint216 _ER = getExchangeRate();
    require _ER != 0;

    f(e, args);
    uint216 ER_ = getExchangeRate();
    assert ER_ != 0;
}
","returnFunds (Lines 299-308), ","  function returnFunds(uint256 amount) external override {
    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');
    uint256 currentShares = totalSupply();
    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');
    uint256 assets = previewRedeem(currentShares);
    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));

    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
    emit FundsReturned(amount);
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Validate the specified `amount` and the contract's total shares against a minimum threshold. Update the exchange rate considering the total assets including the new amount. Transfer the specified `amount` from the function caller to the contract, and emit an event signaling the funds return."
bf3346295073d544ab43da2516f00629,215,rule,slashingIncreaseExchangeRate,471,481,slash,"rule slashingIncreaseExchangeRate(address receiver, uint256 amount) {
    env e; calldataarg args;

    uint216 _ExchangeRate = getExchangeRate();
    slash(e, args);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ >= _ExchangeRate;
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Slash a specified amount from a staked balance, transferring it to a given destination, while ensuring not to exceed the maximum slashable percentage or drop below a specified balance minimum. It updates the exchange rate post-slash and marks the start of a post-slashing period."
ce084d104807d610c1c0b3e06a7d487c,204,rule,airdropNotMutualized,242,248,stake_token.transfer,"rule airdropNotMutualized(uint256 amount){
    env e;
    uint216 exchangeRateBefore = getExchangeRate();
    stake_token.transfer(e, currentContract, amount);
    uint216 exchangeRateAfter = getExchangeRate();
    assert exchangeRateBefore == exchangeRateAfter;
}
","transfer (Lines 53-61), ","  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    b[msg.sender] = sub(b[msg.sender], amount);
    b[recipient] = add(b[recipient], amount);
    return true;
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Subtract a specified `amount` of tokens from the balance of the sender and add the same `amount` to the recipient's balance, effectively transferring tokens between two accounts. Confirm the transfer by returning `true`. Ensure the implementation adheres to an external interface."
ce6177fbd7280f699f7c5375bc9340c8,194,rule,noSlashingMoreThanMax,98,112,slash,"rule noSlashingMoreThanMax(uint256 amount, address recipient){
    env e;
    uint vaultBalanceBefore = stake_token.balanceOf(currentContract);
    require(vaultBalanceBefore < AAVE_MAX_SUPPLY());
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());
    uint256 maxSlashable = vaultBalanceBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();

    require (amount > maxSlashable);
    require (recipient != currentContract);
    slash(e, recipient, amount);
    uint vaultBalanceAfter = stake_token.balanceOf(currentContract);
    assert vaultBalanceBefore - vaultBalanceAfter == maxSlashable;
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Verify conditions and slash a specified amount from a staked token pool, transferring it to a designated address. The slashing is limited by a maximum percentage, adjusts the exchange rate based on the new balance, and ensures the remaining balance stays above a minimum threshold."
f83d7edd31003566c52023d403cf1f07,197,rule,integrityOfSlashing,134,163,slash,"rule integrityOfSlashing(address to, uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract && to != currentContract);
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());

    require(totalSupply() > 0 && totalSupply() < AAVE_MAX_SUPPLY());
    uint256 total = totalSupply();
    uint256 balanceStakeTokenToBefore = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenToBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    slash(e, to, amount);
    uint256 balanceStakeTokenToAfter = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    uint256 maxSlashable = balanceStakeTokenVaultBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();
    uint256 amountToSlash;
    if (amount > maxSlashable) {
        amountToSlash = maxSlashable;
    } else {
        amountToSlash = amount;
    }
    assert balanceStakeTokenToAfter == balanceStakeTokenToBefore + amountToSlash;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore - amountToSlash;
    assert inPostSlashingPeriod();
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Slash a specified amount from a pool, transferring it to a designated address, without exceeding a maximum slashable percentage of the pool's balance. It updates the exchange rate post-slash and ensures the remaining balance stays above a minimum threshold, issuing an event upon completion."
f83d7edd31003566c52023d403cf1f07,197,rule,integrityOfSlashing,134,163,slash,"rule integrityOfSlashing(address to, uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract && to != currentContract);
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());

    require(totalSupply() > 0 && totalSupply() < AAVE_MAX_SUPPLY());
    uint256 total = totalSupply();
    uint256 balanceStakeTokenToBefore = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenToBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    slash(e, to, amount);
    uint256 balanceStakeTokenToAfter = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    uint256 maxSlashable = balanceStakeTokenVaultBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();
    uint256 amountToSlash;
    if (amount > maxSlashable) {
        amountToSlash = maxSlashable;
    } else {
        amountToSlash = amount;
    }
    assert balanceStakeTokenToAfter == balanceStakeTokenToBefore + amountToSlash;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore - amountToSlash;
    assert inPostSlashingPeriod();
}
","slash (Lines 271-296), ","  function slash(address destination, uint256 amount)
    external
    override
    onlySlashingAdmin
    returns (uint256)
  {
    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');
    require(amount > 0, 'ZERO_AMOUNT');
    uint256 currentShares = totalSupply();
    uint256 balance = previewRedeem(currentShares);

    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);

    if (amount > maxSlashable) {
      amount = maxSlashable;
    }
    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');

    inPostSlashingPeriod = true;
    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));

    STAKED_TOKEN.safeTransfer(destination, amount);

    emit Slashed(destination, amount);
    return amount;
  }
",./aave_staked_token/certora/specs/allProps.spec,aave_staked_token,,Yes,,"Functionality: Slash a specified amount of tokens from the total supply, ensuring it does not exceed a maximum permissible percentage or drop below a minimum balance. Adjust the exchange rate accordingly, transfer the slashed amount to a specified destination, and signal the operation's completion."
59f6b4127fa72f16d371ddaf860185f0,157,rule,LendIsBackedByAaveIncInitialize,42,61,"initialize, AAVE_ORIG.initialize","rule LendIsBackedByAaveIncInitialize(env e, method f){
invariant LendIsBackedByAave()
    ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract)
    {
        preserved with (env e){
            require e.msg.sender != LEND1;
            require e.msg.sender != AAVE1;
        }
    }
    require e.msg.sender != LEND1;
    require e.msg.sender != AAVE1;
    require ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
    
    if (f.selector == initialize(address, uint256, uint256, uint256).selector){
        address aaveMerkleDistributor; uint256 lendToMigratorAmount; uint256 lendToLendAmount; uint256 lendToAaveAmount;
        initialize(e, aaveMerkleDistributor, lendToMigratorAmount, lendToLendAmount, lendToAaveAmount);
        address lendToken = LEND1;
        address[] tokens; uint256[] amounts;
        env e2;
        AAVE_ORIG.initialize(e, tokens, amounts, aaveMerkleDistributor, lendToken, lendToAaveAmount);   
    else {
        calldataarg args;
        f(e, args);

    assert ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
}","initialize (Lines 1171-1181), ","  function initialize(address[] memory tokens, uint256[] memory amounts, address aaveMerkleDistributor, address lendToken, uint256 lendToAaveAmount) external initializer {
    // send tokens to distributor
    require(tokens.length == amounts.length, 'initialize(): amounts and tokens lengths inconsistent'); 
    for(uint i = 0; i < tokens.length; i++) {
      IERC20(tokens[i]).safeTransfer(aaveMerkleDistributor, amounts[i]);

      emit TokensRescued(tokens[i], aaveMerkleDistributor, amounts[i]);
    }

    IERC20(lendToken).safeTransfer(lendToken, lendToAaveAmount);
  }
",./aave_rescue_mission/specs/rescueLendMigrator.spec,aave_rescue_mission,,Yes,,"Functionality: Verify the consistency of token and amount arrays, then transfer specified tokens and amounts to the AaveMerkleDistributor. Emit an event for each transfer. Additionally, transfer a designated amount of a lendToken to itself, which is likely an error in the implementation."
1a45f8a5d1331c57ccb23e4ab81cf513,144 | 145,rule,integrityOfExecuteEmergencyAction,244,255,areAllReservesBacked | executeEmergencyAction,"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     aggregator.initFlags(rand);
//     require configurator.freezeWasCalled() == false;
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool freezeReserveWasCalled = configurator.freezeWasCalled();
//     assert !allReservesBacked => freezeReserveWasCalled;
//     assert allReservesBacked => !freezeReserveWasCalled;
// }
","areAllReservesBacked (Lines 87-97),  | executeEmergencyAction (Lines 70-92), ","  function areAllReservesBacked() external view returns (bool) {
    if (_assets.length == 0) {
      return true;
    }

    (bool areReservesBacked, ) = _proofOfReserveAggregator.areAllReservesBacked(
      _assets
    );

    return areReservesBacked;
  }
 |   function executeEmergencyAction() external override {
    (
      bool areReservesBacked,
      bool[] memory unbackedAssetsFlags
    ) = _proofOfReserveAggregator.areAllReservesBacked(_assets);

    if (!areReservesBacked) {
      _disableBorrowing();

      uint256 assetsLength = _assets.length;

      for (uint256 i = 0; i < assetsLength; ++i) {
        if (unbackedAssetsFlags[i]) {
          // freeze reserve
          _configurator.freezeReserve(_assets[i]);

          emit AssetIsNotBacked(_assets[i]);
        }
      }

      emit EmergencyActionExecuted();
    }
  }
",./aave_proof_of_reserve/specs/executorV3.spec,aave_proof_of_reserve,,Yes,,"Functionality: Verify if all reserves are backed by assets, returning a boolean value. In case of unbacked reserves, disable borrowing, freeze unbacked asset reserves, and emit relevant events to indicate assets that are not backed and that an emergency action has been executed."
1adad19c8ea189e760a3480b59dc3d24,142 | 143,rule,integrityOfExecuteEmergencyAction,235,246,areAllReservesBacked | executeEmergencyAction,"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     require _disableBorrowingCalled() == false;
//     aggregator.initFlags(rand);
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool disableBorrowingCalled = _disableBorrowingCalled();
//     assert !allReservesBacked => disableBorrowingCalled;
//     assert allReservesBacked => !disableBorrowingCalled;
// }
","areAllReservesBacked (Lines 87-97),  | executeEmergencyAction (Lines 70-92), ","  function areAllReservesBacked() external view returns (bool) {
    if (_assets.length == 0) {
      return true;
    }

    (bool areReservesBacked, ) = _proofOfReserveAggregator.areAllReservesBacked(
      _assets
    );

    return areReservesBacked;
  }
 |   function executeEmergencyAction() external override {
    (
      bool areReservesBacked,
      bool[] memory unbackedAssetsFlags
    ) = _proofOfReserveAggregator.areAllReservesBacked(_assets);

    if (!areReservesBacked) {
      _disableBorrowing();

      uint256 assetsLength = _assets.length;

      for (uint256 i = 0; i < assetsLength; ++i) {
        if (unbackedAssetsFlags[i]) {
          // freeze reserve
          _configurator.freezeReserve(_assets[i]);

          emit AssetIsNotBacked(_assets[i]);
        }
      }

      emit EmergencyActionExecuted();
    }
  }
",./aave_proof_of_reserve/specs/executorV2.spec,aave_proof_of_reserve,,Yes,,"Functionality: The provided code checks if all assets in a portfolio are backed by reserves through a proof of reserve aggregator. If any asset is unbacked, it disables borrowing, freezes the reserves of those specific unbacked assets, and emits events to indicate an emergency action and the assets not backed by reserves."
1f13d0617b40090d6b6dc2a0541c72d8,148 | 149,rule,PoRFeedChange,35,54,enableProofOfReserveFeed | enableProofOfReserveFeedWithBridgeWrapper,"rule PoRFeedChange(address asset, address PoRFeed, address wrapper){
    
    address feedBefore = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperBefore = getBridgeWrapperForAsset(asset);
    method f; env e;
    call_f_with_params(f, e, asset, PoRFeed, wrapper);

    address feedAfter = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperAfter = getBridgeWrapperForAsset(asset);
    assert f.selector == enableProofOfReserveFeed(address, address).selector => (feedAfter != 0 && feedAfter == PoRFeed);
    assert f.selector == enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector => 
                        (feedAfter != 0 && feedAfter == PoRFeed && bridgeWrapperAfter != 0 && bridgeWrapperAfter == wrapper);
    assert f.selector == disableProofOfReserveFeed(address).selector => feedAfter == 0 && bridgeWrapperAfter == 0;
    assert (f.selector != enableProofOfReserveFeed(address, address).selector && 
            f.selector != disableProofOfReserveFeed(address).selector &&
            f.selector != enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector) => 
                        feedBefore == feedAfter && bridgeWrapperBefore == bridgeWrapperAfter;
}
","enableProofOfReserveFeed (Lines 42-57),  | enableProofOfReserveFeedWithBridgeWrapper (Lines 60-79), ","  function enableProofOfReserveFeed(address asset, address proofOfReserveFeed)
    external
    onlyOwner
  {
    require(asset != address(0), 'INVALID_ASSET');
    require(proofOfReserveFeed != address(0), 'INVALID_PROOF_OF_RESERVE_FEED');
    require(_proofOfReserveList[asset] == address(0), 'FEED_ALREADY_ENABLED');

    _proofOfReserveList[asset] = proofOfReserveFeed;
    emit ProofOfReserveFeedStateChanged(
      asset,
      proofOfReserveFeed,
      address(0),
      true
    );
  }
 |   function enableProofOfReserveFeedWithBridgeWrapper(
    address asset,
    address proofOfReserveFeed,
    address bridgeWrapper
  ) external onlyOwner {
    require(asset != address(0), 'INVALID_ASSET');
    require(proofOfReserveFeed != address(0), 'INVALID_PROOF_OF_RESERVE_FEED');
    require(bridgeWrapper != address(0), 'INVALID_BRIDGE_WRAPPER');
    require(_proofOfReserveList[asset] == address(0), 'FEED_ALREADY_ENABLED');

    _proofOfReserveList[asset] = proofOfReserveFeed;
    _bridgeWrapperList[asset] = bridgeWrapper;

    emit ProofOfReserveFeedStateChanged(
      asset,
      proofOfReserveFeed,
      bridgeWrapper,
      true
    );
  }
",./aave_proof_of_reserve/specs/aggregator.spec,aave_proof_of_reserve,,Yes,,"Functionality: Enable or update the proof of reserve feed for a specified asset, optionally setting a bridge wrapper. Ensure the asset and feed addresses are valid and not already configured. Emit events to log changes in the state of proof of reserve feeds."
146389912a7f6292a03b4b8ba18cef46,32 | 33,rule,noIncarnations2,198,203,execute | getCurrentState,"rule noIncarnations2(uint256 actionsSetId)
{
	env e;
	execute(e, actionsSetId);
	assert getCurrentState(e, actionsSetId) != 0;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of queued actions at or after their scheduled execution time, provided they have not been canceled, already executed, or expired. The execution includes invoking specified functions on target addresses with given parameters and records the execution results, emitting an event upon completion."
1bad7daf2b739dbd96e5ed2a3c31f9d5,26 | 28,rule,executeCannotCancel,162,175,execute | getCurrentState,"rule executeCannotCancel()
{
	env e;
	calldataarg args;
	uint256 calledSet;
	uint256 canceledSet;

	require getCurrentState(e, canceledSet) != 2;
	require getGuardian() != _mock(e);
	
	execute(e, calledSet);
	assert getCurrentState(e, canceledSet) != 2;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a queued set of actions only if the current state is ""Queued"" and the predetermined execution time has passed. Iteratively execute each action within the set, supporting delegate calls if specified, and then emit an event upon successful execution with the relevant details."
219ed11f9069ce91f049ddef26842965,24 | 25,rule,queueCannotCancel,150,159,processMessageFromRoot | getCurrentState,"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Process a message received from a root contract by decoding and queuing various calls (targets, values, signatures, calldatas, and delegatecall flags) for execution, while ensuring the message sender is authorized. Also, determine the current state of an action set by checking if it's executed, canceled, expired, or queued."
25c1cb7eede8d1695a16c8fd79ca58f7,44 | 46,rule,queuedStateConsistency,264,272,processMessageFromRoot | getCurrentState,"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, id) == 0;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Decode and process a message received from a root contract, ensuring it originates from an authorized sender, then queue the decoded instructions (address-targeted actions, values, signatures, calldata, and delegation flags). Additionally, determine and return the current state of a specified action set based on its execution status, cancellation, expiration, or queuing."
27face4d5c5724191d8ed37da80b863d,74,rule,processMessageFromRootReachability,504,510,processMessageFromRoot,"rule processMessageFromRootReachability()
{
	env e; calldataarg args;

	processMessageFromRoot(e, args);
	assert false;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Authenticate messages from an authorized root sender, then decode and queue operations such as contract calls with specified parameters (targets, values, signatures, calldata, delegate call flags) received in a data package for further execution."
2cf9c49305d1f5840dd749a824582abd,56,rule,holdYourHorses,328,338,processMessageFromRoot,"rule holdYourHorses()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	
	uint256 delay = getDelay();
	processMessageFromRoot(e, args);
	execute@withrevert(e, actionsSetId);
	assert delay > 0 => lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Verify if the sender of a message from the root domain (e.g., a main blockchain) matches an authorized address, then decode the incoming message to extract execution details. Queue these decoded instructions (target contracts, signatures, call data, values, and delegation preferences) for execution."
36837de6d6f836fb6b03f06a841e1e83,49 | 50 | 53,rule,onlyCancelCanCancel,288,300,processMessageFromRoot | cancel | getCurrentState,"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","processMessageFromRoot (Lines 70-89),  | cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Decode multi-operation transactions from a root message, queue them for execution, allow their cancellation by a guardian if still queued, and provide the current state (Queued, Canceled, Executed, Expired) of an action set based on its properties and time conditions."
37ba3a47b63862d8cfbc1103ec6f4c36,54 | 55,rule,cancelExclusive,303,311,cancel | getCurrentState,"rule cancelExclusive(uint actionsSetId1, uint actionsSetId2)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId2);
		cancel(e, actionsSetId1);
	uint8 stateAfter = getCurrentState(e, actionsSetId2);

	assert actionsSetId1 != actionsSetId2 => stateBefore == stateAfter;
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel a queued actions set if it's in the ""Queued"" state, marking it as canceled, iterating over its elements to cancel each transaction, and emitting an event indicating the cancellation. It also defines getting the current state of an actions set based on its execution status and timing."
49cbf0bbe3ea148d0728ba8ed871b3a3,37,rule,executedForever,224,231,getCurrentState,"rule executedForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 1;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 1;
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of an actions set by its ID, checking if it's either canceled, executed, expired based on the grace period after its execution time, or still queued, and revert the transaction with an `InvalidActionsSetId` error if the ID does not exist."
4bd6efb816b95b42fd98e1ac04702afb,76,rule,cancelPriviliged,523,532,cancel,"rule cancelPriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	cancel(e1, args1);
	cancel@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","cancel (Lines 110-132), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel a queued actions set if it hasn't been executed, marking it as canceled. Iterate over the actions within the set, calling a separate function to cancel each transaction individually. Finally, emit an event indicating that the actions set has been canceled."
4e66823ad45575caac88bbc2b75ae2d6,5 | 12,invariant,minDelayLtMaxDelay,81,112,processMessageFromRoot | getCurrentState,"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate a message received from the root chain, ensuring it originates from an authorized sender, then decode the message to extract target addresses, values, signatures, caller data, and delegation preferences, queuing them for execution. Also, determine the current state of an action set by checking its execution status against predefined conditions, including expiration based on a grace period."
6d412d6f97f08b58a0ed8eba2121b198,34 | 36,rule,noIncarnations3,209,217,processMessageFromRoot | getCurrentState,"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate the sender of a root message, decode its data into targets, values, signatures, call datas, and delegation flags, and then queue these operations for execution. Additionally, determine the current state of an actions set based on its execution status, cancellation, expiration, or queued state."
75b0c8fe9bd3fe4e73227b8675251537,75,rule,queuePriviliged,512,521,processMessageFromRoot,"rule queuePriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	processMessageFromRoot(e1, args1);
	processMessageFromRoot@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate the sender of a root message and, upon successful validation, decode the message data into specified arrays of target addresses, values, signatures, calldata bytes, and delegatecall flags, then queue these decoded elements for further processing."
7ab48f4282d8995e3853581d1cfd757a,61,rule,executeFailsIfExpired,369,376,getCurrentState,"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specific actions set identified by `actionsSetId` within a smart contract. The function checks if the actions set is canceled, executed, expired based on a grace period after its execution time, or remains queued."
80be69ce13fbd406d8eaecb5f7af2cb0,59 | 60,rule,executedValidTransition2,357,366,execute | getCurrentState,"rule executedValidTransition2(uint256 actionsSetId)
{
	env e;
	uint actionsSetId2;
	uint8 state1 = getCurrentState(e, actionsSetId);
		execute(e, actionsSetId2);
	uint8 state2 = getCurrentState(e, actionsSetId);

	assert actionsSetId2 == actionsSetId <=> state1 == 0 && state2 == 1;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of actions that are queued and within the allowed execution time, updating their state to executed if they are not canceled, already executed, or expired. For each action in the set, execute the transaction and emit an event with the results."
80d890800992cfb32ecacbaa3ef05d9f,73,rule,actionDuplicate,493,501,processMessageFromRoot,"rule actionDuplicate()
{
	env e; 
	calldataarg args;

	processMessageFromRoot(e, args);
	processMessageFromRoot@withrevert(e, args);
	assert lastReverted;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Verify if the sender of a message is authorized, then decode the message data into five arrays detailing targets, values, function signatures, call data, and flags for delegate calls. After decoding, enqueue these transactions for execution, employing checks on the sender's authorization."
98a71abc41ec8fa047d5eb06a99d1556,67,rule,afterQueueHashQueued,457,470,processMessageFromRoot,"rule afterQueueHashQueued(bytes32 actionHash)
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();

	bool queueBefore = isActionQueued(e, actionHash);
		processMessageFromRoot(e, args);
	bool queuedAfter = isActionQueued(e, actionHash);
		
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1))
			<=> !queueBefore && queuedAfter;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate the origin of a root message and, if authorized, decode the message data to extract arrays of addresses, values, signatures, calldatas, and delegatecall flags. Then, queue these extracted parameters for further processing or execution."
a1e4a012a00628378b9f93ff4d57a76b,39 | 43,rule,expiredForever,242,260,processMessageFromRoot | getCurrentState,"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: The code defines a system for processing messages from a root contract, including executing a series of queued actions based on decoded data. It also includes a function to determine the current state of any queued action set, considering its execution, cancellation, expiration, or queued status."
abeceada21c252327457f30484b20279,70,rule,onlyQueuedAreExecuted,476,490,execute,"rule onlyQueuedAreExecuted(bytes32 actionHash, uint256 actionsSetId)
{
	env e2; env e;
	calldataarg args;

	require isActionQueued(e, actionHash);
	// This is true in general, guardian is not a contract (is EOA).
	require getGuardian() != _mock(e);
		execute(e2, actionsSetId);
	bool queuedAfter = isActionQueued(e2, actionHash);
	
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1)) 
			<=> !queuedAfter;
}
","execute (Lines 82-107), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute the actions in a queued actions set once the timelock has expired, ensuring each action is executed in sequence. It also records the execution by setting a flag, logs the execution event, and returns the data from each executed action."
bd8e968d62636c21f778bc20b9866c14,29 | 31,rule,noIncarnations1,177,193,processMessageFromRoot | getCurrentState,"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Decode a message received from a root contract, validate its origin, and queue various actions (targets, values, signatures, calldatas, withDelegatecalls) for execution. Additionally, provide the current state of an action set (Canceled, Executed, Expired, or Queued) based on its ID, execution time, and a grace period."
ca1e7fa28108be184815c7cb581cae09,47,rule,queuedChangedCounter,275,284,processMessageFromRoot,"rule queuedChangedCounter()
{
	env e;
	calldataarg args;
	uint256 count1 = getActionsSetCount();
		processMessageFromRoot(e, args);
	uint256 count2 = getActionsSetCount();

	assert count1 < max_uint => count2 == count1+1;
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate the sender of a message received from the root chain against an authorized address. Decode the received data into specified formats for targets, values, signatures, calldatas, and delegation options, and enqueue these decoded parameters for further processing or execution."
cddd9fdcb628cbcbb8d6e5e2b827c87c,38,rule,canceledForever,233,240,getCurrentState,"rule canceledForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 2;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of an actions set by its ID. If the actions set ID is invalid, it triggers an error. The function evaluates whether the actions set is canceled, executed, expired based on a grace period, or still queued, and returns the corresponding state."
f9e6ed390500679350d672a64af5070d,62 | 66,rule,sameExecutionTimesReverts,405,426,processMessageFromRoot | getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	processMessageFromRoot(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	processMessageFromRoot@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Decode and queue messages received from a root contract, ensuring they originate from an authorized sender, and manage the state of action sets based on their execution status, cancellation, expiration, or queued status by examining their properties and the current timestamp."
ff1cbe75de0f4d75fb1978174a455f4a,18,rule,queueDoesntModifyStateVariables,116,145,processMessageFromRoot,"rule queueDoesntModifyStateVariables()
{
	env e;
	calldataarg args;
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();

	// Call queue with one action in the set.
	processMessageFromRoot(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateIntact =  delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2;
	assert stateIntact,
		""_queue changed state variables unexpectedly"";
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Verify the message origin before decoding the passed `data` into specific parameters: targets, values, signatures, calldatas, and withDelegatecalls. Then, enqueue these parameters for further processing, ensuring that the operation originates from an authorized root sender."
f9e6ed390500679350d672a64af5070d,62 | 66,rule,sameExecutionTimesReverts,405,426,processMessageFromRoot | getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	processMessageFromRoot(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	processMessageFromRoot@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","processMessageFromRoot (Lines 70-89),  | getCurrentState (Lines 224-236), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate messages from a specified root sender, decode and queue transactions for execution. Monitor the state of action sets, determining whether they are executed, cancelled, expired, or queued based on conditions including time criteria and an actions set counter."
ff1cbe75de0f4d75fb1978174a455f4a,18,rule,queueDoesntModifyStateVariables,116,145,processMessageFromRoot,"rule queueDoesntModifyStateVariables()
{
	env e;
	calldataarg args;
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();

	// Call queue with one action in the set.
	processMessageFromRoot(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateIntact =  delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2;
	assert stateIntact,
		""_queue changed state variables unexpectedly"";
}
","processMessageFromRoot (Lines 70-89), ","  function processMessageFromRoot(
    uint256 stateId,
    address rootMessageSender,
    bytes calldata data
  ) external override onlyFxChild {
    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();

    address[] memory targets;
    uint256[] memory values;
    string[] memory signatures;
    bytes[] memory calldatas;
    bool[] memory withDelegatecalls;

    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(
      data,
      (address[], uint256[], string[], bytes[], bool[])
    );

    _queue(targets, values, signatures, calldatas, withDelegatecalls);
  }
",./aave_l2_bridge/specs/PolygonBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Validate the message origin and decode the received data into contract targets, transaction values, function signatures, call data, and delegate call flags. Then, queue these operations for execution, ensuring they originate from an authorized root sender on a bridge or messaging system."
0ee866cf04b0e092a596b6ba5fb20c1b,104 | 105,rule,noIncarnations2,199,204,execute | getCurrentState,"rule noIncarnations2(uint256 actionsSetId)
{
	env e;
	execute(e, actionsSetId);
	assert getCurrentState(e, actionsSetId) != 0;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of actions that have been previously queued and are now ready for execution, checking that they are in the correct state, not yet executed, and within the permitted time frame, then execute each action, and emit an event detailing the execution."
1a4a25f8935719ca1c8b9109f331782d,99 | 101,rule,executeCannotCancel,163,176,execute | getCurrentState,"rule executeCannotCancel()
{
	env e;
	calldataarg args;
	uint256 calledSet;
	uint256 canceledSet;

	require getCurrentState(e, canceledSet) != 2;
	require getGuardian() != _mock(e);
	
	execute(e, calledSet);
	assert getCurrentState(e, canceledSet) != 2;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of queued actions only if they are in a 'Queued' state and the timelock period has passed, then mark the set as executed. For each action, execute a transaction with the specified details and emit an event with the execution results."
5a182d74a19204819c5e218591314b26,125 | 126,rule,executedValidTransition2,354,363,execute | getCurrentState,"rule executedValidTransition2(uint256 actionsSetId)
{
	env e;
	uint actionsSetId2;
	uint8 state1 = getCurrentState(e, actionsSetId);
		execute(e, actionsSetId2);
	uint8 state2 = getCurrentState(e, actionsSetId);

	assert actionsSetId2 == actionsSetId <=> state1 == 0 && state2 == 1;
}
","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of actions queued in a smart contract if they are in a ""Queued"" state, not executed before their designated execution time, and not expired after a grace period. It performs the actions, marks them as executed, and emits an event with the execution results."
625e6c8a5ca9716245b958d3140c1c3c,103,rule,noIncarnations1,178,194,getCurrentState,"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specific actions set by evaluating whether it is canceled, executed, expired based on the current time and a grace period, or still queued to be executed, and return the corresponding state."
7044f007afd47a13ef204db9f85e9fa2,138 | 141,rule,gracePeriodChangedAffectsExecution,534,550,execute | getCurrentState,"rule gracePeriodChangedAffectsExecution(uint256 actionsSetId)
{
	env e; env e2;
	uint period;
	// Assume queued action set.
	require getCurrentState(e, actionsSetId) == 0;
	
	storage initialStorage = lastStorage;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	// Allow execution (assume does not revert)
	execute(e, actionsSetId);
	// Now check whether changing the grace period could lead to revert.
	updateGracePeriod(e, period) at initialStorage;
	uint8 stateAfterUpdate = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	assert lastReverted <=> stateAfterUpdate == 3;
}*/","execute (Lines 82-107),  | getCurrentState (Lines 224-236), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute a set of pre-queued actions at or after a specified execution time, if they have not been cancelled, executed, or expired. The function validates the state and execution time, performs each action, and emits an event with the execution results."
75a800eab04298ae5e3ba15ab42c6409,109,rule,canceledForever,230,237,getCurrentState,"rule canceledForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 2;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specified action set within a contract. The function evaluates whether the action set has been canceled, executed, expired based on a grace period, or is still queued, and returns the corresponding state."
8a2bf95e2ddc9ac12103b7e30b3ba5fa,87,invariant,minDelayLtMaxDelay,81,112,getCurrentState,"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine and return the current state of a specified actions set by checking if it's canceled, executed, expired (based on a grace period after a set execution time), or otherwise queued, ensuring the queried actions set's ID is valid before proceeding."
98a5fe0f238825a3098cf34b16bfde1a,108,rule,executedForever,221,228,getCurrentState,"rule executedForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 1;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 1;
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Determine the current state of an actions set by its ID, returning whether it is canceled, executed, expired based on the current time and a grace period, or queued if none of these conditions are met. The function reverts if an invalid actions set ID is provided."
98b4fce0123464476c95f751d5e64275,107,rule,noIncarnations3,210,218,getCurrentState,"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specified action set by evaluating its ID against cancellation, execution, expiry based on a grace period since its scheduled execution time, or queued status, and return the corresponding state from predefined options."
9d36dccfaae4489a0a898875315b9f8c,115,rule,queuedStateConsistency,261,269,getCurrentState,"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	queue2(e, args);
	assert getCurrentState(e, id) == 0;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specified action set by checking whether it is canceled, executed, expired based on a grace period after its execution time, or still queued. Return the corresponding state as one of Canceled, Executed, Expired, or Queued."
ca8a6a62a935ae02369374acf7ccd7b9,137,rule,cancelPriviliged,520,529,cancel,"rule cancelPriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	cancel(e1, args1);
	cancel@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
","cancel (Lines 110-132), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel a transaction action set if it is in a 'Queued' state by marking it as canceled, iterating over all its components (targets, values, signatures, calldatas, execution time, and delegate calls), and calling a method to cancel each transaction, finally emitting a cancellation event."
d12900bfb736b1070bd5e26630a9de40,121 | 122,rule,cancelExclusive,300,308,cancel | getCurrentState,"rule cancelExclusive(uint actionsSetId1, uint actionsSetId2)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId2);
		cancel(e, actionsSetId1);
	uint8 stateAfter = getCurrentState(e, actionsSetId2);

	assert actionsSetId1 != actionsSetId2 => stateBefore == stateAfter;
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel a set of actions, designated by `actionsSetId`, if they are currently in a 'Queued' state. It marks the actions set as canceled, iterates through each action to cancel the associated transaction, and emits an event indicating the cancellation of the actions set."
d39cb1049a1632b976bf2a73c9138e39,134,rule,onlyQueuedAreExecuted,473,487,execute,"rule onlyQueuedAreExecuted(bytes32 actionHash, uint256 actionsSetId)
{
	env e2; env e;
	calldataarg args;

	require isActionQueued(e, actionHash);
	// This is true in general, guardian is not a contract (is EOA).
	require getGuardian() != _mock(e);
		execute(e2, actionsSetId);
	bool queuedAfter = isActionQueued(e2, actionHash);
	
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1)) 
			<=> !queuedAfter;
}
","execute (Lines 82-107), ","  function execute(uint256 actionsSetId) external payable override {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();

    actionsSet.executed = true;
    uint256 actionCount = actionsSet.targets.length;

    bytes[] memory returnedData = new bytes[](actionCount);
    for (uint256 i = 0; i < actionCount; ) {
      returnedData[i] = _executeTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Execute queued actions in a set if they meet the conditions of not being executed before and having surpassed a timelock period. Transactions are executed based on their configuration in the set, and upon successful execution, an event with execution details is emitted."
d9b161d69bbfb8cc8ea860343753c78b,127,rule,executeFailsIfExpired,366,373,getCurrentState,"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of an actions set by its ID, checking if it's canceled, executed, expired based on a grace period after its execution time, or otherwise queued, and returning the corresponding state from predefined states in ActionsSetState."
dd1b2afe91af1df2889b8b063dcd3280,98,rule,queueCannotCancel,151,160,getCurrentState,"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of an actions set by its ID. Check if the actions set is canceled, executed, or expired based on the current block timestamp and a preset grace period. If none of these conditions are met, classify it as queued."
e1ac335f06161252dbb765388ee80abb,117 | 120,rule,onlyCancelCanCancel,285,297,cancel | getCurrentState,"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel a queued actions set by marking it as canceled and calling a function to cancel each individual transaction within it, based on the provided `actionsSetId`, if the state of the actions set is not queued, an error is thrown, and emits an event upon cancellation."
eff6819270a241845b4dca9d6cdf2d0c,113,rule,expiredForever,239,257,getCurrentState,"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a given actions set by assessing whether it has been canceled, executed, expired (based on a grace period after its execution time), or is still queued for execution, and return the corresponding state."
f24e7d78eab331ddf5b63feee8224e7e,131,rule,sameExecutionTimesReverts,402,423,getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	queue2(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	queue2@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of an actions set by its ID: returns ""Canceled"" if the set was canceled, ""Executed"" if already executed, ""Expired"" if the current time exceeds its execution time plus a grace period, and ""Queued"" otherwise."
d9b161d69bbfb8cc8ea860343753c78b,127,rule,executeFailsIfExpired,366,373,getCurrentState,"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specific action set by its ID. This involves checking whether the action set is canceled, executed, or has expired based on the current timestamp and a predefined grace period. Otherwise, it is considered queued for execution."
dd1b2afe91af1df2889b8b063dcd3280,98,rule,queueCannotCancel,151,160,getCurrentState,"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specified action set by checking if it's canceled, executed, expired based on a grace period after its execution time, or still queued. Return the corresponding state from the predefined options: Canceled, Executed, Expired, or Queued."
e1ac335f06161252dbb765388ee80abb,117 | 120,rule,onlyCancelCanCancel,285,297,cancel | getCurrentState,"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
","cancel (Lines 110-132),  | getCurrentState (Lines 224-236), ","  function cancel(uint256 actionsSetId) external override onlyGuardian {
    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();

    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    actionsSet.canceled = true;

    uint256 targetsLength = actionsSet.targets.length;
    for (uint256 i = 0; i < targetsLength; ) {
      _cancelTransaction(
        actionsSet.targets[i],
        actionsSet.values[i],
        actionsSet.signatures[i],
        actionsSet.calldatas[i],
        actionsSet.executionTime,
        actionsSet.withDelegatecalls[i]
      );
      unchecked {
        ++i;
      }
    }

    emit ActionsSetCanceled(actionsSetId);
  }
 |   function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Cancel queued action sets if they haven't already been executed or cancelled, marking the action set as cancelled, looping through all its transactions to systematically cancel each one, and emitting an event to log the cancellation of the action set identified by its unique ID."
eff6819270a241845b4dca9d6cdf2d0c,113,rule,expiredForever,239,257,getCurrentState,"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specific action set based on its ID. This involves checking if the action set is canceled, executed, or expired by comparing the current timestamp to its execution time plus a grace period, and returns the appropriate state accordingly."
f24e7d78eab331ddf5b63feee8224e7e,131,rule,sameExecutionTimesReverts,402,423,getCurrentState,"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	queue2(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	queue2@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","getCurrentState (Lines 224-236), ","  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {
    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();
    ActionsSet storage actionsSet = _actionsSets[actionsSetId];
    if (actionsSet.canceled) {
      return ActionsSetState.Canceled;
    } else if (actionsSet.executed) {
      return ActionsSetState.Executed;
    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {
      return ActionsSetState.Expired;
    } else {
      return ActionsSetState.Queued;
    }
  }
",./aave_l2_bridge/specs/Optimism_ArbitrumBridge.spec,aave_l2_bridge,,Yes,,"Functionality: Determine the current state of a specified action set by checking against its properties, such as cancellation, execution, and time constraints in relation to a grace period, and then return the appropriate state, whether it is Canceled, Executed, Expired, or Queued."
