RuleContent,Response,ClusterLabel
"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;

	uint256 strategyBalanceBefore = tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	
	env e;
	int256 amountAdded = exit(e, balance);
	uint256 strategyBalanceBAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	assert compareLTzero(amountAdded) => strategyBalanceBefore < balance , ""did not send all availaible tokens"";
}","This rule needs to verify that the correct amount of tokens are transferred from the current contract to the receiver instance after an exit function is called, while ensuring that the strategy balance before the exit is less than the balance after the transfer.",3
"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	
	require strategyBalanceBefore == tokenInstance.balanceOf(currentContract);
	uint256 balanceBefore = tokenInstance.balanceOf(receiverInstance);
	env e;
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 strategyBalanceAfter = tokenInstance.balanceOf(currentContract);
	uint256 balanceAfter = tokenInstance.balanceOf(receiverInstance);
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","This rule needs to be verified to ensure that the balance and strategy balance are properly adjusted after a harvest operation, taking into account profit or loss scenarios.",0
"rule toBaseIsMonotone {
    bool roundUp;
    uint x;
    uint y;
    require x < y;
    uint xToBase = toBase(x, roundUp);
    uint yToBase = toBase(y, roundUp);
    assert xToBase <= yToBase; 
}
",This rule needs to be verified to ensure that converting a smaller input value to a specified base results in a value that is less than or equal to the conversion of a larger input value to the same base.,2
"    Contributes to proof of rule named ""Identity"" in GDoc.
 */ 
rule toElasticAndToBaseAreInverse1down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 1; 
    assert only_slightly_larger_than(amount, amountToElasticToBase, error_margin1);
}
",This rule needs to be verified to ensure that the conversion functions between two values are inverses of each other with a small margin of error.,0
"rule toElasticAndToBaseAreInverse1up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 error_margin1 = base1 / elastic1 + 2; // ""base1/elastic1 + 1"":to
    assert only_slightly_smaller_than(amount, amountToElasticToBase, error_margin1);
}
","This rule verifies that the conversion functions `toElastic` and `toBase` are inverses of each other, ensuring that there is no loss of precision in the conversion process.",2
"rule toElasticAndToBaseAreInverse0BaseEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  ||  amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}","This rule verifies that converting an amount from base to elastic and back to base, as well as converting an amount from elastic to base and back to elastic, results in the original amount when the base value is 0, considering the specified rounding behavior.",2
"rule toElasticAndToBaseAreInverse0ElasticEdgeCase {
    bool roundUp;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require elastic1 == 0;
    uint256 amount;
    uint256 amountToElastic = toElastic(amount, roundUp);
    uint256 amountToElasticToBase = toBase(amountToElastic, roundUp);
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    assert amountToElasticToBase == amount  || amountToElasticToBase == 0;
    assert amountToBaseToElastic == amount || amountToBaseToElastic == 0;
}
","This rule verifies that converting an amount from elastic units to base units and then back to elastic units results in the original amount, when the initial elastic amount is zero.",2
"rule toElasticAndToBaseAreInverse2up {
    bool roundUp = true;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 2; 
    assert only_slightly_smaller_than(amount, amountToBaseToElastic, error_margin2);
}
","This rule verifies that the functions to convert between base and elastic values are inverses of each other, within a small error margin, when rounding up.",2
"    Contributes to proof of rule named ""Identity"" in GDoc.
 */
rule toElasticAndToBaseAreInverse2down {
    bool roundUp = false;
    uint128 base1 = getBase();
    uint128 elastic1 = getElastic();

    require base1 != 0 && elastic1 != 0;
    uint256 amount;
    uint256 amountToBase = toBase(amount, roundUp);
    uint256 amountToBaseToElastic = toElastic(amountToBase, roundUp);
    uint256 error_margin2 = elastic1 / base1 + 1; 
    assert only_slightly_larger_than(amount, amountToBaseToElastic, error_margin2);
}
",This rule needs to be verified to ensure that the conversion functions for a specific ratio of base and elastic tokens are inverses of each other within a certain error margin.,0
"rule ifExitedIsTrueThenMethodsRevertExceptOwner() {
	env e;

	require exited() == true;
	method f;
	calldataarg args;
	require !f.isView && f.selector != claimOwnership().selector;
	require e.msg.sender != owner();
	f@withrevert(e, args);
	
	assert(lastReverted, ""Methods didn't revert"");
}
","This rule verifies that when a specific condition is met, certain methods should revert unless they are being called by the owner.",2
"rule integrityHarvest(uint256 balance, uint256 strategyBalanceBefore) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance, receiverInstance);
		
	int256 amountAdded = harvest(e, balance,_);

	require amountAdded < MIN_INT();
	uint256 balanceAfter = tokenBalanceOf(tokenInstance, receiverInstance);
	
	if (compareGTzero(amountAdded)) {
		// strategy made profit 
		assert checkAplusBeqC(balanceBefore, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
	} else {
		// strategy made loss
		assert balanceBefore == balanceAfter, ""balance should not change if profit is negative"";
	}
}
","This rule verifies that the balance transfer to the receiver instance is accurate after harvesting, ensuring integrity in the strategy's profit or loss calculation.",5
"rule integrityExit(uint256 balance) {
	require receiver() == receiverInstance;
	env e;
	uint256 balanceBefore = tokenBalanceOf(tokenInstance,receiverInstance);
		
	int256 amountAdded = exit(e, balance);
	
	uint256 balanceAfter = tokenBalanceOf(tokenInstance,receiverInstance);

	mathint t = balanceBefore + balance;
	require t <= MAX_UNSIGNED_INT();
	uint256 expectedBalance = balanceBefore + balance;
	assert checkAplusBeqC(expectedBalance, amountAdded, balanceAfter), ""wrong balance transfered to receiver"";
}","This rule verifies that the correct amount is transferred to the designated receiver upon exiting, ensuring the integrity of the balance transfer process.",5
"invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
	
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)

// Rules
/**
 * solvency:
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	require straToken == strategy(token);
	//proven in zeroStrategy
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
","This rule needs to verify that the solvency of the system is maintained with respect to the token balances and strategies associated with the BentoBox. Additionally, it needs to ensure the integrity of total token shares in the system.",0
"rule validDecreaseToBalanceOf(address token, address a,
							  address from, address to,
 							  address other, method f) {

	uint256 amount;
	uint256 share;
 	require  from == harnessFrom();
	uint256 vBefore = balanceOf(token, a);
	callFunctionWithParams(token, from, to, amount, share, f);
	uint256 vAfter = balanceOf(token, a);
	assert (vBefore > vAfter => ( from == a && (
	 		f.selector == transfer(address, address, address, uint256).selector ||
			f.selector == withdraw(address, address, address, uint256, uint256).selector ||
			f.selector == transferMultiple(address, address, address[], uint256[]).selector)));
}
",This rule needs to verify that the token balance of a specific address decreases after a certain method is called with specific parameters from a specific address.,1
"rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	//link the strategy to the current token
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;
	require harnessBorrower() == borrower;
	require harnessToken() == token;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
",This rule needs to be verified to ensure that the solvency of the system is maintained by checking the balance and integrity of total assets for a specific token within the BentoBox and its associated strategy.,5
"rule preserveTotalAssetsOfUser(address token, address from, address to,
					    	   address user, uint256 amount, uint256 share,
							   method f) {
	env e;

	// verifying a simplified version
	require totalTokenAmount(token) == totalTokenShare(token);
	uint256 _userShares = balanceOf(token, user);
	// roundUp = true or false shouldn't matter as long as they are consistent
	mathint _userAssets = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true); 
	require user != currentContract &&  user == from && user == harnessFrom() && user == to;
	//for transfermultiple we assume that all transfer are to the same user
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint userAssets_ = tokenBalanceOfUser(token, user) + toAmount(token, balanceOf(token, user), true);
	uint256 userShares_ = balanceOf(token, user);
	
	// transferMultiple transfer from user to some arbitrary other user so we expect assets to be preserved
	require  f.selector != transferMultiple(address,address,address[],uint256[]).selector; 
	// flash loan can reduce asset of user due to fee, and strategy can also reduce user assets due to negative profit
	if (f.selector != 0xf1676d37 && // hascode of flashLoan 
		f.selector != setStrategy(address,address).selector &&
		f.selector != harvest(address,bool,uint256).selector)
	{
		assert (_userAssets <= userAssets_,
			""total user assets not preserved"");
	}
	else  {
		// however on those functions, a user's share should not change
		assert (_userShares == userShares_,
}
","This rule needs to verify that the total assets and shares of a user remain preserved during token transfers and specific function calls, except for flash loans and certain financial strategies which may affect the user's assets.",5
"rule totalAssetsAfterFlashLoan(address token) {
	//link the strategy to the current token
	require harnessBorrower() == borrower;
	require harnessToken() == token;
	//assume solvency safe assumption as we know that solvency is kept before and after flash loan
rule solvency(address token, address from, address to,
								  uint256 amount, uint256 share, method f,
								  uint256 _strategy,
								  uint256 strategy_,
								  address straToken,
								  uint256 _systemBalance,
								  uint256 systemBalance_,
								  uint256 _strategyBalance,
								  uint256 strategyBalance_  ) {
	require strategyInstance.token() == token;
	// link the strategy owner to the bentobox
	require strategyInstance.owner() == currentContract;

	mathint _actual = tokenBalanceOf(token); //casting form uint256
	require _systemBalance == tokenBalanceOfUser(token, currentContract);
	mathint _asElastic = totalTokenAmount(token); //casting from uint128
	require _actual == _asElastic;
	require _strategy == getStrategyTokenBalance(token);
	
	require straToken == strategy(token);
	//proven in zeroStrategy
invariant zeroStrategy(address token)
	strategy(token) == 0 => getStrategyTokenBalance(token) == 0
invariant integrityOfTotalShare(address token) 
 	totalTokenShare(token) == shareSum(token)
// Rules
/**
 * solvency:
	require straToken == 0 => _strategy == 0;
	require _strategyBalance == tokenBalanceOfUser(token, straToken);
	env e;
	calldataarg args;
	callFunctionWithParams(token, from, to, amount, share, f);
	mathint actual_ = tokenBalanceOf(token); //casting form uint256
	require systemBalance_ == tokenBalanceOfUser(token, currentContract);
	mathint asElastic_ = totalTokenAmount(token); //casting from uint128
	require strategy_ == getStrategyTokenBalance(token);
	assert actual_ >= asElastic_, ""system solvency is broken"";
}
 * internal representation of total assets:
 * _tokenBalanceOf(token) >= totals[token].elastics
 * checking if the the total assets within the BentoBox and outside
 * the BentoBox are preserved
 */
	require tokenBalanceOf(token) == totalTokenAmount(token);
	uint256 _systemBalance = tokenBalanceOfUser(token, currentContract);
	flashLoan(e, args);
	uint256 systemBalance_ = tokenBalanceOfUser(token, currentContract);
	assert  systemBalance_ >= _systemBalance, ""system lost assets due to flahs loan"";
","This rule/invariant needs to be verified to ensure that the total assets before and after a flash loan within the BentoBox are preserved, and the system does not lose assets due to the flash loan.",0
"rule staking_non_trivial_rJoe() {
    // requireInvariant totalJoeStaked_sums_user_balance();
// invariant totalJoeStaked_sums_user_balance() // passes
//     totalJoeStaked() == sum_user_balance()
// { preserved {
//     requireInvariant user_balances_less_than_totalJoeStaked();
invariant user_balances_less_than_totalJoeStaked() // passes
    forall address a. forall address b. (a != b) => to_uint256(totalJoeStaked()) >= userJoeStaked(a) + userJoeStaked(b)
{ preserved with (env e) {
    require e.msg.sender != currentContract;
}}
// }}
    requireInvariant is_initialized();
invariant is_initialized()
    initialized()
{ preserved {
    requireInvariant not_initializing();
invariant not_initializing()
    !initializing()

////////////////////////////////////////////////////////////////////////////
//                       Invariants                                       //
// // rJoe.totalSupply is sum of rJoe balances
// invariant User_RJ_balance_sums_supply()
//     false
//joe.balanceOf(RJStaking)  閳 鍗 userInfo[user].amount
// invariant staking_joe_bal_sums_user_balance(env e) // passes
//    joe.balanceOf(e, currentContract) >= sum_user_balance()
// { preserved with (env otherE) {
//     require otherE.msg.sender != currentContract;
// } }
    require PRECISION() > 0;
    require rJoePerSec() > 0 && rJoePerSec() < 1000000; // realistic range to help the tool run this rule faster
    uint256 amount;
    require amount > 0;
    env e0; env e1;
    require e0.msg.sender == e1.msg.sender;
    deposit(e0, amount);
    require e1.block.timestamp > lastRewardTimestamp();
    require userRewardDebt(e0.msg.sender) < max_uint256;
    uint dt = e1.block.timestamp - lastRewardTimestamp(); // store this as a variable for more readable cex
    uint256 rewards = pendingRJoe(e1, e0.msg.sender);
    assert exists uint256 t. (t == dt) => rewards > 0,  ""trivial rJoe"";
    // doing the min interval calculations would likely be a better rule but causes timeouts, left for future consideration
    // uint256 min_interval = totalJoeStaked() / rJoePerSec();
    // require min_interval < (max_uint256 / 10) && min_interval > 0; // divide by 10 to reduce the scope of the problem
    // assert dt > min_interval => rJoe != 0, ""trivial rJoe"";
}
rule staking_trivial_on_zero_time() { // passes
    env e0;
    env e1; 
    uint delta_t = e1.block.timestamp - e0.block.timestamp; // store this as a variable for more readable cex
    require delta_t == 0; 
    uint256 rJoe = pendingRJoe(e1, e0.msg.sender);
    assert rJoe == 0, ""RJOE gained with no stake time"";
",This rule needs to verify that the rewards earned in a staking contract are non-trivial and are proportional to the stake time of the user.,3
"// // I'd like to do an invariant that shows this is always increasing, but I can't see a good way to do so
// this rule has been kind of a pain and doesn't add much to coverage past what non_trivial_rJoe and duration correlates return already provide
// rule updatePool_increases_accRJoePerShare() {
//     require PRECISION > 0;
//     env e;
//     require e.block.timestamp > lastRewardTimestamp();
//     require joe.balanceOf(e, currentContract) > 0; // will not increase if supply is 0
//     uint256 pre = accRJoePerShare();
//     updatePool(e);
//     uint256 post = accRJoePerShare();
//     assert post > pre, ""acc not increasing"";
// }
",This rule needs to be verified to ensure that the accumulated reward per share always increases after the pool is updated.,0
"rule pending_reward_decreased_only_user(method f) filtered { f -> (f.selector != 0xeb990c59 && f.selector != emergencyWithdraw().selector)
} { 
",This rule needs to verify that the pending rewards can only be decreased by the user and not by emergency withdrawal functions.,3
"rule additivity_withdraw() {
    storage init = lastStorage;
    env e; 
    uint256 x;
    uint256 y;
    // require x > 0 && y > 0;
    // require userJoeStakede.msg.sender) > x + y;
    withdraw(e, x);
    withdraw(e, y);

    uint256 bal_sep = userJoeStaked(e.msg.sender);
    withdraw(e, x+y) at init;
    uint256 bal_sum = userJoeStaked(e.msg.sender);
    
    assert bal_sep == bal_sum, ""additivity failed"";
}
",This rule verifies that the total amount withdrawn by a user is equal to the sum of the amounts withdrawn individually.,5
"rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){
    address user;
    require user != currentContract;
    require user == e.msg.sender;
    require user == issuer();
    require token() == SymbERC20A || token() == SymbERC20B;

    bool hasWPairBefore = userHasWithdrawnPair(user);
    uint256 userPairBalanceBefore = getPairBalance(user);
    helperFunctionsForWithdrawLiquidity(f, e);
    
    bool hasWPairAfter = userHasWithdrawnPair(user);
    uint256 userPairBalanceAfter = getPairBalance(user);
    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, ""hasWithdrawnPair was changed by wrong method"";
}
",This rule verifies that the pair balance of a user only changes if they have actually withdrawn liquidity and that the `hasWithdrawnPair` flag is updated correctly.,5
"rule tr_pairOnlyChange(method f, env e){     

    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore != pairAfter <=> f.selector == createPair().selector, ""pair was changed by wrong method"";
}
",This rule ensures that a specific method can only result in a change to the pair contract if its selector matches the selector of the method that creates pairs.,2
"rule tr_incentivesForUsersChanges(method f){     
    uint256 incentivesBefore = tokenIncentivesForUsers();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentivesForUsers();
    assert incentivesBefore != incentivesAfter 
                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector
                || f.selector == createPair().selector, ""tokenIncentivesForUsers was changed by wrong method"";
}
",This rule verifies that changes in token incentives for users are only made by specific methods.,3
"rule tr_incentiveIssuerRefundChanges(method f){     
    uint256 incentivesBefore = tokenIncentiveIssuerRefund();

    env e;
    calldataarg args;
    f(e, args);
    uint256 incentivesAfter = tokenIncentiveIssuerRefund();
    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, ""tokenIncentiveIssuerRefund was changed by wrong method"";
}
",This rule verifies that the token incentive issuer refund amount is not changed by any method other than creating a new pair.,3
"rule cl_userAllocUnchanging(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 userAllocationBefore = getUserAllocation(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 userAllocationAfter = getUserAllocation(user);
    assert userAllocationBefore == userAllocationAfter, ""userAllocation was changed"";
}
",This rule needs to be verified to ensure that a user's allocation remains unchanged after a specific method is called in Phase Three of the contract.,5
"rule cl_userBalanceFixed(method f, env e, address user) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 balanceBefore = getUserBalance(user);
    require closed();
    calldataarg args;
    f(e, args);
    uint256 balanceAfter = getUserBalance(user);
    assert balanceBefore == balanceAfter, ""userBalance was changed"";
}
","This rule verifies that a specified user's balance remains fixed after a specific method is called in a certain phase, under the assumption that the system is safe and closed.",5
"invariant cl_avaxReservCheck()
    closed() => avaxReserve() == 0
    { 
        preserved with (env e2) { 
            require currentPhase(e2) == PhaseThree();
            safeAssumptions(e2); 
        } 
    }
",This rule needs to be verified to ensure that the AVAX reserve is equal to zero when the system is in Phase Three and certain safe assumptions are met.,0
"rule transition_balThisZero(address user, method f, env e) {
    safeAssumptions(e);
    require currentPhase(e) == PhaseThree();

    uint256 wavaxBalanceBefore = getWAVAXbalanceOfThis();
    uint256 wavaxPairBalanceBefore = getWAVAXbalanceOfPair();
    uint256 avaxAllocBefore = avaxAllocated();
    require open();
    calldataarg args;
    createPair(e);
    require closed();
    uint256 wavaxBalanceAfter = getWAVAXbalanceOfThis();
    assert wavaxBalanceBefore == wavaxBalanceAfter, ""wavax balance of LE contract was changed"";
    assert getWAVAXbalanceOfPair() - wavaxPairBalanceBefore == avaxAllocated(), ""correlation is wrong"";
}
",This rule verifies that the total balance of a token before and after a specific action remains the same and that the allocation of a certain asset is calculated correctly.,5
"rule hl_noDepositFrontRun(method f, env e, env e2){
    require open();
    require e.msg.sender != e2.msg.sender;

    calldataarg args;
    storage initialStorage = lastStorage;
    uint256 userBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);
    f(e2, args) at initialStorage;
    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);
    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, ""frontrun on Deposit"";
}
",This rule verifies that no front-running behavior occured during a deposit transaction by checking the user's balance before and after the transaction in two different environments.,3
"rule hl_whatShouldRevert(method f, env e){
    require stopped();

    calldataarg args;
    f@withrevert(e, args);
    assert((f.selector == depositAVAX().selector
                || f.selector == withdrawAVAX(uint256).selector
                || f.selector == createPair().selector
                || f.selector == withdrawLiquidity().selector)
                => lastReverted, 
                ""function was not reverted"");
}
",This rule verifies that specific functions should revert under certain conditions to ensure the correct operation of the system.,3
"rule cl_unchangingPair(method f, env e){
    require pair() != 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    address pairBefore = pair();
    calldataarg args;
    f(e, args);
    address pairAfter = pair();
    assert pairBefore == pairAfter, ""pair was changed in close stage"";
}
",This rule verifies that a pair's correlation is maintained consistently between different pairs and that certain conditions remain true throughout the execution of the smart contract code.,3
"rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){
    require initialized();          // initialize()

    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();
    require tokenIncentivesBalanceBefore > 0;
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();
    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, ""tokenIncentivesBalance is 0 unintentionally"";
}
",This rule verifies that the token incentives balance can be zero under certain circumstances specified in the function arguments.,1
"rule op_token_res_fixed(method f, env e) {

    require pair() == 0;
    requireInvariant pairAndGetPairCorrelation(e);
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    require initialized();
    require !stopped();
    uint256 tokenReserveBefore = tokenReserve();
    calldataarg args;
    f(e, args);
    uint256 tokenReserveAfter = tokenReserve();
    assert tokenReserveBefore == tokenReserveAfter, ""tokenReserve was changed"";
}
","This rule verifies that the correlation between pairs in the factory contract remains consistent before and after a specific method is called, ensuring that the token reserves are not altered during the execution of the method.",3
"invariant cl_token_bal_eq_res_token()
    false

// STATUS - in progress
// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459
// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632
// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`
invariant clIncentivesCorrelation()
    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())
    {
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","This invariant verifies that the correlation between token incentives balance and token incentives for users is maintained, as well as the correlation between pairs created in the factory contract.",3
"invariant al_balance_less_than_allocation(address user)
    getUserBalance(user) <= getUserAllocation(user) 

// STATUS - verified
// - getUI[user].allocation <= maxAllocation
invariant al_userAllocation_less_than_maxAllocation(address user)
    getUserAllocation(user) <= maxAllocation()
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()
// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
","This rule/invariant needs to be verified to ensure that a user's balance is always less than or equal to their allocated amount, and that a user's allocation is always less than or equal to the maximum allowed allocation.",5
"rule op_tokenIncentivesForUsersUnchange(method f, env e){
    require pair() == 0;                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);   // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    requireInvariant isInitialized();       // initialize()
    uint256 tokenIncentivesForUsersBefore = tokenIncentivesForUsers();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentivesForUsersAfter = tokenIncentivesForUsers();
    assert tokenIncentivesForUsersBefore == tokenIncentivesForUsersAfter, ""tokenRestokenIncentivesForUserserve was changed"";
}
",This rule needs to be verified to ensure that the token incentives for users remain unchanged after certain function calls or contract interactions.,5
"rule hl_depositAdditivity(env e, env e2){
    require e.msg.value > 0;
    require e.msg.value == 2 * e2.msg.value;
    require e.msg.sender != e2.msg.sender;

    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);
    depositAVAX(e);
    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);
    
    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);
    require userOneBalanceBefore == userTwoBalanceBefore;
    depositAVAX(e2);
    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);
    assert userOneBalanceAfter == userTwoBalanceAfter, ""deposit is not additive"";
}
","This rule needs to verify that when two different users deposit AVAX, the increase in their respective balances is proportional to the amount deposited, and their balances remain equal after depositing.",5
"rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){
    require pair() == 0;                                    // createPair()
    requireInvariant pairAndGetPairCorrelation(e);          // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()
invariant opPairAndTotalSupplyCorrelation()
    pair() == 0 => getPairTotalSupply() == 0
        preserved with (env e2){
            requireInvariant pairAndGetPairCorrelation(e2);
            requireInvariant factoryGetPairCorrelationCurrentVals(e2);
    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();
    calldataarg args;
    f(e, args);
    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();
    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, ""tokenIncentiveIssuerRefund was changed"";
}
",This rule needs to verify that the token incentive issuer refund remains unchanged after a certain operation is performed.,5
"invariant cl_nonzero_user_pair_bal(address user, env e)
    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)
    {
        preserved with (env e2){
            requireInvariant cl_not_stopped();                  // emergencyWithdraw()
            require currentPhase(e2) == PhaseThree();           // withdrawAVAX(uint256)
            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
","This invariant needs to be verified to ensure that the correlation between pairs returned by the factory function remains consistent and accurate, regardless of the token addresses provided as parameters.",2
"rule cl_pairAndTokenBalancesNonIncreasing(method f, env e){
    require pair() != 0;                                // createPair()
    requireInvariant pairAndGetPairCorrelation(e);      // createPair()
invariant pairAndGetPairCorrelation(env e)
    pair() == Factory.getPair(e, WAVAX(), token())
    {
        preserved{
            requireInvariant isInitialized();
invariant isInitialized()
    initialized()

// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446
// - stopped == false
invariant initNotStopped()
    initialized() => !stopped()
            requireInvariant notStoppedIfNonInitialized();
        }
    }
            requireInvariant factoryGetPairCorrelationCurrentVals(e);
invariant factoryGetPairCorrelationCurrentVals(env e)
    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())
        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,
                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){
            requireInvariant factoryGetPairCorrelationNewVals(e, _token);
invariant factoryGetPairCorrelationNewVals(env e, address token)
    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)
            require token == _token;
    requireInvariant isInitialized();                   // initialize()
    require currentPhase(e) == PhaseThree();            // depositAVAX() 
    uint256 tokenBalanceBefore = getTokenBalanceOfThis();
    uint256 pairBalanceBefore = getPairBalanceOfThis();
    calldataarg args;
    f(e, args);
    uint256 tokenBalanceAfter = getTokenBalanceOfThis();
    uint256 pairBalanceAfter = getPairBalanceOfThis();
    assert tokenBalanceBefore >= tokenBalanceAfter, ""token balance was increased"";
    assert pairBalanceBefore >= pairBalanceAfter, ""pair balance was increased"";
}
","This rule ensures that after certain operations are performed, the token balance and pair balance should not increase to maintain consistency and prevent unexpected behavior.",5
"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","This rule needs to be verified in order to ensure that three users cannot front-run each other when splitting a specific asset, with the user IDs being the same for all three users.",3
"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","This rule verifies that two different users cannot front-run a split transaction with a third user as the receiver, ensuring fair and secure distribution of assets.",3
"// the rule below still fails, probably because some of the split receivers can overflow too
rule revertCharacteristicsOfSplit() {
    env e; uint256 userA_Id; uint256 assetId;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;

    // allowing only valid splitReceivers because revert is not allowed
    bytes32 receiversHash = hashSplits(e, true);
    assertSplitsValid(e, true, receiversHash);
    setSplits(e, userA_Id, true);
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    require userA_splittableBefore + userA_collectableBefore < 2^128;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    //require userA_splittableAfter + userA_collectableAfter < 2^128;
    userA_collectableAmt, userA_splitAmt = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
",This rule needs to verify that the characteristics of splitting an asset between users are correctly reverted when there is an overflow risk in the split amounts.,5
"rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    // prevents overflow of the splittable of the receiver userC:
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","This rule ensures that front-running cannot occur during splitting assets between users, by verifying the integrity of the splitting process and preventing potential overflows or unexpected behavior.",5
"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
}
","This rule/invariant needs to be verified to ensure that two users cannot front run and split their assets with the same third user, thus preventing unfair advantage or manipulation in asset splitting transactions.",5
"rule sameReturnOfSplitAndSplitResults() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    require userA_Id != userB_Id;   require userA_Id != userC_Id;   require userB_Id != userC_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require length == 2;
    require index1 != index2;
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 > 0;
    require weight2 > 0;
    require weight1 + weight2 <= 1000000;  // safe assumptions
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we force the receivers to be only two, therefore totalWeight = weight1 + weight2
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // calling splitResults() upon userA with amount = userA.splittable
    uint128 userA_splitAmt_splitResults; uint128 userA_collectableAmt_splitResults;
    userA_collectableAmt_splitResults, userA_splitAmt_splitResults = splitResults(e, userA_Id, true, userA_splittableBefore);
    
    // calling split() on userA
    uint128 userA_collectableAmt_split; uint128 userA_splitAmt_split;
    userA_collectableAmt_split, userA_splitAmt_split = split(e, userA_Id, assetId, true);
    assert userA_collectableAmt_split == userA_collectableAmt_splitResults;
    assert userA_splitAmt_split == userA_splitAmt_splitResults;
","This rule verifies that the amount of money remains the same before and after a split operation, ensuring that no money is lost or created during the split process.",5
"rule correctnessOfHashSplits() {
    env e; uint256 index; uint256 length1; uint256 length2;  
    uint256 userId1; uint32 weight1; uint256 userId2; uint32 weight2;
    bytes32 receiversHash1; bytes32 receiversHash2;

    length1 = getCurrSplitsReceiverLocaLength(e, true);
    length2 = getCurrSplitsReceiverLocaLength(e, false);
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index);
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, false, index);
    receiversHash1 = hashSplits(e, true);
    receiversHash2 = hashSplits(e, false);
    assert (receiversHash1 == receiversHash2) => ((length1 == length2) && (userId1 == userId2) && (weight1 == weight2));
}
","This rule verifies that the hash of receiver splits for two separate entities should be the same if the lengths of the splits, user IDs, and weights are also the same for both entities.",2
"rule correctnessOfGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint128 splittableBefore; uint128 splittableAfter;

    splittableBefore = splittable(e, receiver, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, receiver, assetId);
    assert splittableAfter == splittableBefore + amt;
}
",This rule verifies that the amount of a specified asset received by the receiver increases correctly after a transfer operation between two users.,5
"rule assetsDoNotInterfereEachOther() {
    env e; uint256 assetId1; uint256 assetId2; uint256 userA_Id; uint256 userB_Id;

    // make sure the users/assets are not the same
    require userA_Id != userB_Id;
    require assetId1 != assetId2;
    // recording the state before split()
    uint128 userA_splittableAssetId1_Before = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_Before = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_Before = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_Before = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_Before = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_Before = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_Before = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_Before = collectable(e, userB_Id, assetId2);
    // calling the split() for userA over assertId1
    uint128 userA_collectableAmtAssetId1; uint128 userA_splitAmtAssetId1;
    userA_collectableAmtAssetId1, userA_splitAmtAssetId1 = split(e, userA_Id, assetId1, true);
    // recording the state after split()
    uint128 userA_splittableAssetId1_After = splittable(e, userA_Id, assetId1);
    uint128 userA_collectableAssetId1_After = collectable(e, userA_Id, assetId1);
    uint128 userA_splittableAssetId2_After = splittable(e, userA_Id, assetId2);
    uint128 userA_collectableAssetId2_After = collectable(e, userA_Id, assetId2);
    uint128 userB_splittableAssetId1_After = splittable(e, userB_Id, assetId1);
    uint128 userB_collectableAssetId1_After = collectable(e, userB_Id, assetId1);
    uint128 userB_splittableAssetId2_After = splittable(e, userB_Id, assetId2);
    uint128 userB_collectableAssetId2_After = collectable(e, userB_Id, assetId2);
    // the expectation:
    // splittable and collectable for any user's assetId2 stays the same
    assert userA_splittableAssetId2_After == userA_splittableAssetId2_Before;
    assert userA_collectableAssetId2_After == userA_collectableAssetId2_Before;
    assert userB_splittableAssetId2_After == userB_splittableAssetId2_Before;
    assert userB_collectableAssetId2_After == userB_collectableAssetId2_Before;
    // the collectable of userB's assetId1 should not be affected by the split
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_collectableAssetId1_After == userB_collectableAssetId1_Before;
    // the splittable of userB's assetId1 should not decrease
    assert userB_splittableAssetId1_After >= userB_splittableAssetId1_Before;
",This rule/invariant needs to verify that assets do not interfere with each other and that money is not lost or created during a split function.,5
"rule correctnessOfSplitResults() {
rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
    env e; uint256 userId; uint128 amount; uint128 collectableAmt; uint128 splitAmt;
    collectableAmt, splitAmt = splitResults(e, userId, true, amount);
    assert amount == collectableAmt + splitAmt;
","This rule ensures that after splitting an asset, the total amount available to be split and collected does not increase, and the sum of splittable and collectable amounts does not decrease.",3
"/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
",This rule/invariant needs to be verified to ensure that the total amount of money in the system remains constant before and after a split operation between two users.,5
"rule equalSplitWeightsResultEqualSplittableIncrease() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;

    // all the 3 users are different
    require userA_Id != userB_Id; require userA_Id != userC_Id; require userB_Id != userC_Id;
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1; uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    uint256 length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 2;            // only two split receivers
    require index1 != index2;       // different indexes sample different splitReceivers
    require userId1 == userB_Id;
    require userId2 == userC_Id;
    require weight1 == weight2;
    require weight1 <= 500000;      // safe assumption since MAX _TOTAL_SPLITS_WEIGHT == 1000000
    require weight1 > 0;            // safe assumption
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId); 
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    require userA_splittableBefore > 0; // there is a splittable amount to be split
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    // the splittable balances of userB and userC will increase by the same amount
    // in case of rounding - diffrence between amounts can be 1
    uint128 userB_splittableChange = userB_splittableAfter - userB_splittableBefore;
    uint128 userC_splittableChange = userC_splittableAfter - userC_splittableBefore;
    assert ((userC_splittableChange == userB_splittableChange) || 
            (userB_splittableChange == userC_splittableChange + 1) || 
            (userC_splittableChange == userB_splittableChange + 1));    
","This rule verifies that when a user splits their assets with two other users, the splittable balances of the recipients increase equally, or with a difference of 1 in case of rounding.",5
"/// Note: this rule fails!
/// In cases when userB weight is small, the calculation for the split
/// will be rounded down to zero, therefore the receiver will get nothing!
///
/// Possible abuse vector:
/// split is called every time when the splittable balance of userA is so low, 
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
/// so that rounding error will cause the splitReceiver userB to get zero
/// as a result userA will get all the splittable to himself
/// Severity: low
/// The one who will benefit the abuse is the splitter,
/// but he is also the one that in advance decided who
/// are going to be his splitReceivers
rule splitReceiverShouldGetMoneyUponSplit() {
    env e; uint256 assetId; uint256 userA_Id; uint256 userB_Id;
    require userA_Id != userB_Id;
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userB_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;         // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    require userA_splittableBefore > 0;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    // the expectation: the splittable balance of userB should increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userB_splittableAfter > userB_splittableBefore;
","This rule needs to verify that upon calling the split function, the receiver should receive a non-zero amount of money and not lose out due to rounding errors.",3
"rule correctnessOfSplit() {
    env e; uint256 userId; uint256 assetId; uint128 collectableAmt; uint128 splitAmt;

    uint128 splittableBefore;   uint128 collectableBefore;
    uint128 splittableAfter;    uint128 collectableAfter;
    
    splittableBefore = splittable(e, userId, assetId);
    collectableBefore = collectable(e, userId, assetId);
    collectableAmt, splitAmt = split(e, userId, assetId, true);
    splittableAfter = splittable(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert splittableBefore >= splittableAfter;
    assert collectableBefore + collectableAmt == collectableAfter;
    assert splittableBefore + collectableBefore >= splittableAfter + collectableAfter;
}
","This rule verifies that after splitting a certain amount of assets, the total amount of splittable assets decreases, the collectable amount increases by the specified split amount, and the total amount of splittable and collectable assets remains unchanged.",0
"rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;

    // setting up the currReceivers[] of userA
/// are invariant of the split
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
",This rule/invariant needs to be verified to ensure that no money is lost or created during the split operation between userA and userB.,5
"rule integrityOfSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id; uint256 userC_Id; uint256 userD_Id;
    
    require userA_Id != userB_Id;   require userA_Id != userD_Id;
    require userA_Id != userC_Id;   require userB_Id != userD_Id;
    require userB_Id != userC_Id;   require userC_Id != userD_Id;

    // obtaining splittable/collectable states before calling split()
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    require userA_splittableBefore > 0;
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    uint128 userD_splittableBefore = splittable(e, userD_Id, assetId);
    uint128 userD_collectableBefore = collectable(e, userD_Id, assetId);
    // setting up the currReceivers[] of userA
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    uint256 userA_Id; uint256 userB_Id;
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    uint256 index1; uint256 userId1; uint32 weight1;
    uint256 index2; uint256 userId2; uint32 weight2;
    userId2, weight2 = getCurrSplitsReceiverLocalArr(e, true, index2);
    require index1 != index2;     // different indexes sample different splitReceivers
    require userId1 == userB_Id;  // userB is on the list of splitReceivers of userA
    require userId2 != userC_Id;  // the second splitReceiver is not userC
    require userId2 != userA_Id;  // the second splitReceiver is not the splitter itself
    require userId2 == userD_Id;  // since we run with loop_iter 2, there are max 2 receivers
    // obtaining splittable/collectable states after calling split()
    uint128 userC_splittableAfter = splittable(e, userC_Id, assetId);
    uint128 userC_collectableAfter = collectable(e, userC_Id, assetId);
    uint128 userD_splittableAfter = splittable(e, userD_Id, assetId);
    uint128 userD_collectableAfter = collectable(e, userD_Id, assetId);
    // UserA's splittable should NOT increase
/// @notice The sanity rule should always fail.
rule sanity {
    method f; env e; calldataarg args;
    f(e, args);
    assert false, 
        ""This rule should always fail"";
    assert userA_splittableAfter <= userA_splittableBefore;
    assert userA_splittableAfter == 0; // it should be zero
    // UserB is on the list of UserA's splitters, therefore ""userB's splittable should NOT decrease""
    assert userB_splittableAfter >= userB_splittableBefore;
    // UserC is NOT on the list of UserA's splitters, therefore ""userC's splittable should NOT change""
    assert userC_splittableAfter == userC_splittableBefore;
    // UserA's collectable should NOT decrease, UserB and UserC's collectable should NOT change
    assert userA_collectableAfter >= userA_collectableBefore;
    assert userB_collectableAfter == userB_collectableBefore;
    assert userC_collectableAfter == userC_collectableBefore;
    // The increase of the splittable of the receivers userB and userD should be equal the splittable of userA
    assert (userB_splittableAfter - userB_splittableBefore) +
           (userD_splittableAfter - userD_splittableBefore) +
           (userA_collectableAfter - userA_collectableBefore) == userA_splittableBefore;
","This rule needs to verify that the amount of funds available for splitting and collecting remains the same before and after a split operation, with specific conditions for each user involved in the split.",5
"rule cannotFrontRunSplitDifferentUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require userA_Id != userB_Id;
    require userA_Id != userC_Id;
    require userB_Id != userC_Id;
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    //require userA_collectableBefore + userA_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    //require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    //require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
",This rule needs to be verified to ensure that funds are not lost or created during a split operation involving multiple users.,5
"rule cannotFrontRunSplitTwoSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id != userB_Id) && 
             ((userC_Id == userA_Id) || (userC_Id == userB_Id)) );
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
","This rule verifies that funds are not lost or created during a split operation involving two users, ensuring that the total amount of money remains the same before and after the split.",5
"rule splittableOfNonReceiverNotAffectedByGive() {
    env e; uint256 userId; uint256 receiver; uint256 assetId; uint128 amt;
    uint256 otherUser; uint128 splittableBefore; uint128 splittableAfter;

    require otherUser != receiver;
    splittableBefore = splittable(e, otherUser, assetId);
    give(e, userId, receiver, assetId, amt);
    splittableAfter = splittable(e, otherUser, assetId);
    assert splittableAfter == splittableBefore;
}
",This rule verifies that transferring an asset from one user to another does not affect the splittable balance of a third user who is not involved in the transaction.,5
"rule integrityOfCollect() {
    env e; uint256 userId; uint256 assetId;
    uint128 collectedAmt; uint128 collectableAfter;

    collectedAmt = collect(e, userId, assetId);
    collectableAfter = collectable(e, userId, assetId);
    assert collectableAfter == 0;
}
","This rule verifies that after an amount is collected from a specified user and asset, the collectable amount for that user and asset becomes zero.",3
"rule cannotFrontRunSplitThreeSameUsers() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);

    require ( (userA_Id == userB_Id) && (userB_Id == userC_Id) );
    // prevents overflow in the edge cases of (userA == userB == userC):
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
}
    require userA_collectableBefore + userA_splittableBefore < 2^128;    
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
",This rule needs to verify that splitting assets among three users does not result in front-running or loss of assets during the split process.,3
"        ""This rule should always fail"";
}
*/

/// @notice front running split() does not affect receiver
/// userA has a single splitReceiver userC
/// userB also has the same single splitReceiver UserC
/// we want to verify split() can be called on userA successfully
/// even if someone front runs it and calls splits() first on userB
/// no assumptions about userA, userB, userC
rule cannotFrontRunSplitGeneralCase() {
    env e; env e2; uint256 assetId; uint256 userA_Id; uint256 userB_Id; uint256 userC_Id;
    uint128 userA_collectableAmt; uint128 userA_splitAmt;
    uint128 userA_collectableAmt2; uint128 userA_splitAmt2;
    uint128 userB_collectableAmt; uint128 userB_splitAmt;
    uint128 userA_splittableBefore = splittable(e, userA_Id, assetId);
    uint128 userB_splittableBefore = splittable(e, userB_Id, assetId);
    uint128 userC_splittableBefore = splittable(e, userC_Id, assetId);
    uint128 userA_collectableBefore = collectable(e, userA_Id, assetId);
    uint128 userB_collectableBefore = collectable(e, userB_Id, assetId);
    uint128 userC_collectableBefore = collectable(e, userC_Id, assetId);
    // prevents overflow of the splittable of the receiver userC:
/// are invariant of the split
rule moneyNotLostOrCreatedDuringSplit() {
    env e; uint256 assetId;
    uint256 userA_Id; uint256 userB_Id;
    // setting up the currReceivers[] of userA
    uint256 length; uint256 index1; uint256 userId1; uint32 weight1;
    userId1, weight1 = getCurrSplitsReceiverLocalArr(e, true, index1);
    length = getCurrSplitsReceiverLocaLength(e, true);
    require length == 1;            // only one splitsReceiver
    require userId1 == userB_Id;    // making sure it is userB (not limiting it to be userA)
    require weight1 <= 1000000;     // safe assumptions since the function _assertSplitsValid()
                                    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
                                    // we required that there is only one receiver, therefore totalWeight = weight1
                                    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // recording the state before split()
    // calling the split() on userA
    uint128 userA_collectableAmt;   uint128 userA_splitAmt;
    userA_collectableAmt, userA_splitAmt = split(e, userA_Id, assetId, true);
    // recording the state after split()
    uint128 userA_splittableAfter = splittable(e, userA_Id, assetId);
    uint128 userA_collectableAfter = collectable(e, userA_Id, assetId);
    uint128 userB_splittableAfter = splittable(e, userB_Id, assetId);
    uint128 userB_collectableAfter = collectable(e, userB_Id, assetId);
    // the expectation:
    uint128 moneyBefore = userA_splittableBefore + userA_collectableBefore + userB_splittableBefore + userB_collectableBefore;
    uint128 moneyAfter = userA_splittableAfter + userA_collectableAfter + userB_splittableAfter + userB_collectableAfter;
    assert moneyBefore == moneyAfter;
    require userA_splittableBefore + userB_splittableBefore + userC_splittableBefore < 2^128;
    // prevents overflow of the collectable of the splitters userA and userB:
    require userA_collectableBefore + userA_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore < 2^128;
    // prevents overflow in the edge cases of (userC == userA) or (userC == userB):
    require userA_collectableBefore + userA_splittableBefore + userB_splittableBefore < 2^128;
    require userB_collectableBefore + userB_splittableBefore + userA_splittableBefore < 2^128;
    
    // setting up the currReceivers[] of userA and userB to be the same - singe receiver userC
    uint256 length1 = getCurrSplitsReceiverLocaLength(e, true);
    require length1 == 1;  // only one receiver
    uint256 index1; uint256 userId1; uint32 weight1;
    require userId1 == userC_Id;
    require weight1 <= 1000000;  // safe assumption
    require weight1 > 0;  // safe assumption
    // safe assumptions since the function _assertSplitsValid()
    // verified that totalWeight <= _TOTAL_SPLITS_WEIGHT upon _setSplits()
    // we required that there is only one receiver, therefore totalWeight = weight1
    // _TOTAL_SPLITS_WEIGHT == 1000000, hence the assumption above is safe
    // also _assertSplitsValid() verified that weight != 0
    storage initStorage = lastStorage;
    uint128 userC_splittableAfterSplitA = splittable(e, userC_Id, assetId);
    userB_collectableAmt, userB_splitAmt = split(e, userB_Id, assetId, true) at initStorage;
    uint128 userC_splittableAfterSplitB = splittable(e, userC_Id, assetId);
    userA_collectableAmt2, userA_splitAmt2 = split@withrevert(e, userA_Id, assetId, true);
    assert !lastReverted;
",This rule verifies that the total amount of money is not lost or created during the split operation and ensures that there is no overflow in the amounts handled by the users involved.,5
"rule whoChangedUserState(method f) {
    env e;
    calldataarg args;
    
    address userA;
    address userB;

    bool isUserBefore;
    bool isUserAfter;
    isUserBefore = getIsUser(e, userB);
    f(e,args);
    // addUser(userA);
    // removeUser(userA);
    // require userA != userB;
    isUserAfter = getIsUser(e, userB);
    assert isUserBefore == isUserAfter;
}
",This rule verifies that a specific method does not change the state of a particular user.,2
"rule totalMoneyIsConstant(method f) {
    env e; // env eB; env eF;
    calldataarg args;

    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 balanceOfUserBefore;    uint256 balanceOfUserAfter;
    uint256 balanceOfReserveBefore; uint256 balanceOfReserveAfter;
    uint256 depositedBefore;        uint256 depositedAfter;
    balanceOfUserBefore = dummyERC20Token.balanceOf(user);
    balanceOfReserveBefore = dummyERC20Token.balanceOf(reserveH);
    depositedBefore = getDeposited(dummyERC20Token);
    require depositedBefore == balanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(dummyERC20Token) == 0;
    deposit(e, dummyERC20Token, user, amtDeposited);
    //f(e,args);
    withdraw(e, dummyERC20Token, user, amtWithdrawn);
    require amtDeposited == amtWithdrawn;
    balanceOfUserAfter = dummyERC20Token.balanceOf(user);
    balanceOfReserveAfter = dummyERC20Token.balanceOf(reserveH);
    depositedAfter = getDeposited(dummyERC20Token);
    assert balanceOfUserBefore == balanceOfUserAfter;
    //assert balanceOfUserBefore + balanceOfReserveBefore == balanceOfUserAfter + balanceOfReserveAfter;
    //assert depositedAfter == depositedBefore + amtDeposited - amtWithdrawn;
}
",This rule verifies that the total amount of a particular token remains constant within a system after a series of deposits and withdrawals by a user.,5
"// rule ideas for verification of the functions in Reserve.sol
// ///////////////////////////////////////////////////////////////

using DummyERC20Impl as dummyERC20Token
using DummyERC20A as tokenA
using DummyERC20B as tokenB
using ReserveHarness as reserveH
methods{
    ////////////////////////////////////////
	// ERC20 methods
	transferFrom(address, address, uint256) => DISPATCHER(true)
	transfer(address, uint256) => DISPATCHER(true)
	//
    tokenA.balanceOf(address) envfree
	tokenB.balanceOf(address) envfree
	dummyERC20Token.balanceOf(address) envfree
    tokenA.totalSupply() envfree
	tokenB.totalSupply() envfree
	dummyERC20Token.totalSupply() envfree
    transfer() => DISPATCHER(true)
    // Call resolutions for IReservePlugin
    afterStart(address, uint256) => NONDET //HAVOC_ALL
    afterDeposition(address, uint256) => NONDET //HAVOC_ALL
    beforeWithdrawal(address, uint256) => NONDET //HAVOC_ALL
    beforeEnd(address, uint256) => NONDET //HAVOC_ALL
    reserveH.getDeposited(address) envfree
    reserveH.getPlugins(address) envfree
}
","This rule verifies that the ERC20 transfer functions behave as expected, that token balances and total supplies are correctly retrieved, and that IReservePlugin functions are properly called during specific stages of the Reserve contract.",5
"rule tokensNonInterference() {
    env e;
    calldataarg args;

    bool depositOrWithdraw;
    address user;
    uint256 amtDeposited;
    uint256 amtWithdrawn;
    uint256 tokenABalanceOfUserBefore;    uint256 tokenABalanceOfUserAfter;
    uint256 tokenBBalanceOfUserBefore;    uint256 tokenBBalanceOfUserAfter;
    uint256 tokenABalanceOfReserveBefore; uint256 tokenABalanceOfReserveAfter;
    uint256 tokenBBalanceOfReserveBefore; uint256 tokenBBalanceOfReserveAfter;
    uint256 tokenADepositedBefore;        uint256 tokenADepositedAfter;
    uint256 tokenBDepositedBefore;        uint256 tokenBDepositedAfter;
    tokenABalanceOfUserBefore = tokenA.balanceOf(user);
    tokenBBalanceOfUserBefore = tokenB.balanceOf(user);
    tokenABalanceOfReserveBefore = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveBefore = tokenB.balanceOf(reserveH);
    tokenADepositedBefore = getDeposited(tokenA);
    tokenBDepositedBefore = getDeposited(tokenB);
    require tokenADepositedBefore == tokenABalanceOfReserveBefore;
    require tokenBDepositedBefore == tokenBBalanceOfReserveBefore;
    //require e.msg.sender != 0;
    require reserveH.getPlugins(tokenA) == 0;
    require reserveH.getPlugins(tokenB) == 0;
    //deposit(e, tokenA, user, amtDeposited);
    //f(e,args);
    //withdraw(e, tokenA, user, amtWithdrawn);
    if (depositOrWithdraw) {
        deposit(e, tokenA, user, amtDeposited);
    } else {
        withdraw(e, tokenA, user, amtWithdrawn);
    }
    require amtDeposited == amtWithdrawn;
    tokenABalanceOfUserAfter = tokenA.balanceOf(user);
    tokenBBalanceOfUserAfter = tokenB.balanceOf(user);
    tokenABalanceOfReserveAfter = tokenA.balanceOf(reserveH);
    tokenBBalanceOfReserveAfter = tokenB.balanceOf(reserveH);
    tokenADepositedAfter = getDeposited(tokenA);
    tokenBDepositedAfter = getDeposited(tokenB);
    assert tokenBBalanceOfUserBefore == tokenBBalanceOfUserAfter;
    assert tokenBBalanceOfReserveBefore == tokenBBalanceOfReserveAfter;
    assert tokenBDepositedBefore == tokenBDepositedAfter;
}
",This rule needs to be verified to ensure that token deposits and withdrawals by users do not interfere with token balances and reserves.,5
"rule unrelatedUserBalanceNotChangingParametric(
        method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
    env e; env eB; env eF;
    calldataarg args;

    // step 1 - balance before of receiverId
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
    uint256 userId1; uint256 config1;
    uint256 userId2; uint256 config2;
    uint256 userId3; uint256 config3;
    userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
    DH.DripsReceiver argsReceiver1;
    require argsReceiver1.userId == userId1;
    require argsReceiver1.config == config1;
    DH.DripsReceiver argsReceiver2;
    require argsReceiver2.userId == userId2;
    require argsReceiver2.config == config2;
    DH.DripsReceiver argsReceiver3;
    require argsReceiver3.userId == userId3;
    require argsReceiver3.config == config3;
    require argsReceiver1.userId != receiverId;
    require argsReceiver2.userId != receiverId;
    require argsReceiver3.userId != receiverId;
    f(e, args);
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
    //assert false;
}
",This rule verifies that the balance of a user remains unchanged after a function is called with unrelated user parameters.,5
"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
",This rule verifies that the balance of a specific user remains unchanged after a specific function is called.,5
"rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
    env e; env eB; env eF;
    calldataarg args;

    // uint8 i;
    // userId1 and userId2 - receivers Id
    uint256 assetId; uint256 userId1; uint256 userId2;
    require userId != userId1; // != userId2;
    require userId1 < userId2; // sorted
    require userId != userId2;
    // step 1 - balance before of user2
    bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
    dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
     balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
    // assert false; // false 0
    // step 2 - setup user1 changes and then call _updateReceiverStates()
    /*  //setting values to config by create:
        uint192 _amtPerSec;
        uint32 _start;
        uint32 _duration;
    require _amtPerSec != 0;
    */
    DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
    DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
    DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
   // DH.DripsConfig configNew2;
    require configOld1 != configNew1;
    // require configOld2 == configNew2;
    DH.DripsReceiver receiverOld1;
    require receiverOld1.userId == userId1;
    require receiverOld1.config == configOld1;
    DH.DripsReceiver receiverOld2;
    require receiverOld2.userId == userId2;
    require receiverOld2.config == configOld2;
    DH.DripsReceiver receiverNew1;
    require receiverNew1.userId == userId1;
    require receiverNew1.config == configNew1;
    // DripsReceiver[] memory currReceivers;
    // DripsReceiver[] memory newReceivers;
    // currReceivers[i].userId = userId1;
    // currReceivers[i].config = configCurr;
    // require sorted
    // require no duplicate
    // require amtPerSec != 0
    // require(i < _MAX_DRIPS_RECEIVERS,"""");
    // require currReceivers == newReceivers;
    // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
    // DripsState storage state = _dripsStorage().states[assetId][userId];
    // uint32 lastUpdate = state.updateTime;
    // uint32 currMaxEnd = state.maxEnd;
    // uint32 newMaxEnd = sizeof(uint32);
    // assert false;  // false 1
     //assert configOld2 != configNew2;  //returned 0
    _helperUpdateReceiverStates( e,
            receiverOld1,
            receiverOld2,
            receiverNew1,
            assetId,
            userId
        );
    //assert false;  // false 2
    // step 3 - balance after of user2
    bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
    dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
     balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
    // check that balance of user2 was not modified
    assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
    assert false;
}
","This rule ensures that when updating the time for a single user, it does not inadvertently change the balance of another user in the system.",3
"// rule ifTheOnlyOneDripperStopsReceivableDripsCanNotIncrease()
// {
//     // make sure there is only one sender and one receiver
//     // make sure the sender is dripping to the receiver
//     // calculate the _receivableDrips(receiver) before dripping stops
//     // stop the dripping
//     // calculate the _receivableDrips(receiver) after dripping stops
//     // after == before
// }
","This rule needs to verify that if the only dripper stops dripping, the receivable drips for the receiver cannot increase.",3
"rule whoChangedBalanceOfUserId(method f, uint256 userId) {
    env eB;
    env eF;

    require requireValidSlots();
    calldataarg args;
    uint256 assetId;
    bytes32 dripsHashBefore;
    bytes32 dripsHistoryHashBefore;
    uint32 updateTimeBefore;
    uint128 balanceBefore;
    uint32 maxEndBefore;
    dripsHashBefore,
     dripsHistoryHashBefore,
     updateTimeBefore,
     balanceBefore,
     maxEndBefore = _dripsState(eB, userId, assetId);
    f(eF,args);  // call any function
    bytes32 dripsHashAfter;
    bytes32 dripsHistoryHashAfter;
    uint32 updateTimeAfter;
    uint128 balanceAfter;
    uint32 maxEndAfter;
    dripsHashAfter,
     dripsHistoryHashAfter,
     updateTimeAfter,
     balanceAfter,
     maxEndAfter = _dripsState(eF, userId, assetId);
    assert balanceBefore == balanceAfter, ""balanceOfUser changed"";
}
",This rule verifies that the balance of a specific user remains unchanged after calling a given method.,5
"// rule unrelatedUserBalanceNotChangingParametric(
//         method f, uint256 senderId, uint256 receiverId, uint256 assetId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // step 1 - balance before of receiverId
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, receiverId, assetId);
    
//     uint256 userId1; uint256 config1;
//     uint256 userId2; uint256 config2;
//     uint256 userId3; uint256 config3;
//     userId1, config1, userId2, config2, userId3, config3 = unpackArgs(e, args);
//     DH.DripsReceiver argsReceiver1;
//     require argsReceiver1.userId == userId1;
//     require argsReceiver1.config == config1;
//     DH.DripsReceiver argsReceiver2;
//     require argsReceiver2.userId == userId2;
//     require argsReceiver2.config == config2;
//     DH.DripsReceiver argsReceiver3;
//     require argsReceiver3.userId == userId3;
//     require argsReceiver3.config == config3;
//     require argsReceiver1.userId != receiverId;
//     require argsReceiver2.userId != receiverId;
//     require argsReceiver3.userId != receiverId;
//     f(e, args);
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, receiverId, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOf receiverId changed"";
//     //assert false;
// }
",This rule is verifying that the balance of a user (receiverId) does not change after a function is called with specified parameters.,5
"rule cyclesAdditivity{
    env e1;
    env e2;
    address erc20;
    uint32 maxCycles;
    uint256 userId;
    uint256 assetId;
    uint32 from1;
    uint32 to1;
    uint32 from2;
    uint32 to2;

    require to_mathint(maxCycles) == 2^32-1;
    //require e2.block.timestamp > e1.block.timestamp;
    storage init = lastStorage;
    from1, to1 = _receivableDripsCyclesRange(e1, userId, assetId);
    from2, to2 = _receivableDripsCyclesRange(e2, userId, assetId);
    //require to1-from1 == 2;
    //require to2-from2 == 3;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < 4294967295;
    uint128 receivableAmt1; uint32 receivableCycles1;
    receivableAmt1, receivableCycles1 = _receivableDrips(e1, userId, assetId, maxCycles);
        _receiveDrips(e1, userId, assetId, maxCycles);
    uint128 receivableAmt2; uint32 receivableCycles2;
    receivableAmt2, receivableCycles2 = _receivableDrips(e2, userId, assetId, maxCycles);
    uint128 receivableAmt12; uint32 receivableCycles12;
    receivableAmt12, receivableCycles12 = _receivableDrips(e2, userId, assetId, maxCycles) at init;
    assert receivableAmt12 == receivableAmt1 + receivableAmt2;
    //assert false;
}
",This rule verifies the additivity of receivable amounts and cycles for two consecutive receivable drips cycles of a user for a specific asset.,3
"// rule singleUserTimeUpdateNotChangingOtherUserBalance(method f, uint256 userId) {
//     env e; env eB; env eF;
//     calldataarg args;

//     // uint8 i;
//     // userId1 and userId2 - receivers Id
//     uint256 assetId; uint256 userId1; uint256 userId2;
//     require userId != userId1; // != userId2;
//     require userId1 < userId2; // sorted
//     require userId != userId2;
//     // step 1 - balance before of user2
//     bytes32 dripsHashBefore; bytes32 dripsHistoryHashBefore;
//     uint32 updateTimeBefore; uint128 balanceBefore; uint32 maxEndBefore;
//     dripsHashBefore, dripsHistoryHashBefore, updateTimeBefore,
//      balanceBefore, maxEndBefore = _dripsState(eB, userId2, assetId);
    
//     // assert false; // false 0
//     // step 2 - setup user1 changes and then call _updateReceiverStates()
//     /*  //setting values to config by create:
//         uint192 _amtPerSec;
//         uint32 _start;
//         uint32 _duration;
//     require _amtPerSec != 0;
//     */
//     DH.DripsConfig configOld1;// = create(_amtPerSec, _start, _duration);
//     DH.DripsConfig configOld2;// = DH.create(_amtPerSec+1, _start+1, _duration+1);
//     DH.DripsConfig configNew1;// = DH.create(_amtPerSec+2, _start+2, _duration+2);
//    // DH.DripsConfig configNew2;
//     require configOld1 != configNew1;
//     // require configOld2 == configNew2;
//     DH.DripsReceiver receiverOld1;
//     require receiverOld1.userId == userId1;
//     require receiverOld1.config == configOld1;
//     DH.DripsReceiver receiverOld2;
//     require receiverOld2.userId == userId2;
//     require receiverOld2.config == configOld2;
//     DH.DripsReceiver receiverNew1;
//     require receiverNew1.userId == userId1;
//     require receiverNew1.config == configNew1;
//     // DripsReceiver[] memory currReceivers;
//     // DripsReceiver[] memory newReceivers;
//     // currReceivers[i].userId = userId1;
//     // currReceivers[i].config = configCurr;
//     // require sorted
//     // require no duplicate
//     // require amtPerSec != 0
//     // require(i < _MAX_DRIPS_RECEIVERS,"""");
//     // require currReceivers == newReceivers;
//     // newReceivers[i].config = configNew; // the only change in newReceivers is configNew of userId2
//     // DripsState storage state = _dripsStorage().states[assetId][userId];
//     // uint32 lastUpdate = state.updateTime;
//     // uint32 currMaxEnd = state.maxEnd;
//     // uint32 newMaxEnd = sizeof(uint32);
//     // assert false;  // false 1
//      //assert configOld2 != configNew2;  //returned 0
//     _helperUpdateReceiverStates( e,
//             receiverOld1,
//             receiverOld2,
//             receiverNew1,
//             assetId,
//             userId
//         );
//     //assert false;  // false 2
//     // step 3 - balance after of user2
//     bytes32 dripsHashAfter; bytes32 dripsHistoryHashAfter;
//     uint32 updateTimeAfter; uint128 balanceAfter; uint32 maxEndAfter;
//     dripsHashAfter, dripsHistoryHashAfter, updateTimeAfter, 
//      balanceAfter, maxEndAfter = _dripsState(eF, userId2, assetId);
//     // check that balance of user2 was not modified
//     assert balanceBefore == balanceAfter, ""balanceOfUser2 changed"";
//     assert false;
// }
",This rule needs to verify that updating the time for a single user does not change the balance of another user in the system.,3
"// rule startDrippingToUserCannotDecreaseReceivableAmt()
// {
//     // make sure that the dripper was not sending to the user:
//     // require currReceivers.length == 0;

//     // check the receivable balance of the user before:
//     // (uint128 receivedAmtBefore, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // start sending to the user
//     // check the receivable balance of the user after:
//     // (uint128 receivedAmtAfter, ) = Drips._receivableDrips(userId, assetId, type(uint32).max);
//     // assert receivedAmtAfter > receivedAmtBefore
// }
",This rule/invariant needs to verify that the receivable balance of a user cannot decrease when starting to send drips to them.,3
"rule integrityOfPast(method f)
{
    require requireValidSlots();

    env e0;                 address erc20;
    calldataarg args;       uint256 dripperId;      uint256 receiverId;
    require erc20 == 0x100;
    require dripperId == 1;
    require receiverId == 2;
    // setup one dripper and one receiver with start dripping timestamp of now
    uint192 amtPerSec;      uint32 start;           uint32 duration;
    require amtPerSec == 1;
    require start == 5;
    require duration == 100;
    DH.DripsConfig configBefore = _helperCreateConfig(amtPerSec, start, duration);
    require e0.block.timestamp == start;
    int128 balanceDelta;
    DH.DripsReceiver currReceiverBefore;
    require currReceiverBefore.userId == 0; // this will force passing empty currReceivers
    DH.DripsReceiver newReceiverBefore;
    require newReceiverBefore.userId == receiverId;
    require receiverId != 0;
    require newReceiverBefore.config == configBefore;
    //_helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    //helperSetDrips01(e0, dripperId, erc20, currReceiverBefore, balanceDelta, newReceiverBefore);
    // let at least one cycle pass
    uint32 cycleSecs = getCycleSecs();
    require cycleSecs == 2;
    env e1;
    require e1.block.timestamp > e0.block.timestamp + cycleSecs;
    // calculate the ReceivableDripsBefore of the receiver
    // collectableAll() can be used if the user has also set splits
    uint128 ReceivableDripsBefore; uint32 receivableCyclesBefore;
    // type(uint32).max = 2^32 - 1 = 4294967295
    ReceivableDripsBefore, receivableCyclesBefore = receivableDrips(e1, receiverId, erc20, 4294967295);
    // change the dripper configuration to start dripping to the receiver in the future
    // i.e. try to alter the past, as if the past dripping did not occur
    // use the same amtPerSec and duration, only change the start time to the future
    uint32 newStart;
    require newStart > e1.block.timestamp + 10 * cycleSecs;
    DH.DripsConfig configAfter = _helperCreateConfig(amtPerSec, newStart, duration);
    DH.DripsReceiver newReceiverAfter;
    require newReceiverAfter.userId == receiverId;
    require newReceiverAfter.config == configAfter;
    //_helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    //setDrips(e1, dripperId, erc20, _helperArrOfStruct(e1, newReceiverBefore), balanceDelta, _helperArrOfStruct(e1, newReceiverAfter));
    //helperSetDrips11(e1, dripperId, erc20, newReceiverBefore, balanceDelta, newReceiverAfter);
    // calculate again the ReceivableDripsAfter of the receiver
    // at a time before the newStart begins
    env e2;
    require e2.block.timestamp > e1.block.timestamp;
    require e2.block.timestamp < newStart;
    uint128 ReceivableDripsAfter; uint32 receivableCyclesAfter;
    ReceivableDripsAfter, receivableCyclesAfter = receivableDrips(e2, receiverId, erc20, 4294967295);
    // validate that the past dripping stays, i.e. what was already dripped is still receivable
    assert ReceivableDripsBefore == ReceivableDripsAfter;
    assert false; // sanity
rule sanity(method f){
    //uint32 cycleSecs = getCycleSecs();
    //require cycleSecs == 2;
    //setupState();
    env e;
    calldataarg args;
    f(e,args);
    assert false;
}
","This rule verifies the integrity of past dripping transactions, ensuring that the amount dripped to a receiver in the past remains consistent even if the dripper's configuration is altered for future drippings.",3
"    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
","This rule/invariant needs to be verified in order to ensure that the total supply of tokens is only greater than 0 if there is liquidity in the pool, and vice versa.",5
"///// rule empty_pool_zero_totalSupply()
////  verifies that pool is empty IFF totalSupply == 0
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  collectProtocolFees() - it breakes the rule
rule empty_pool_zero_totalSupply(method f, address to)
filtered { f -> excludeCallback(f) }{
",This rule verifies that the pool should be empty if the total supply of tokens in the pool is equal to zero.,0
"///// rule totalSupply_vs_positionAmounts()
////  verifies that totalSupply before applying f() greater than totalSupply after implies posistion 
////  liquidity before is greater than position liquidity after minus last compound liquidity
rule totalSupply_vs_positionAmounts(method f){
   env e;

   uint256 totalSupplyBefore = totalSupply();
   uint256 posLiquidityBefore = position_Liquidity();
    require governance() != currentContract;
    require governance() != pool;
   require lastCompoundLiquidity(e) == 0;
   calldataarg args;
	f(e,args);
   uint256 totalSupplyAfter = totalSupply();
   uint256 posLiquidityAfter = position_Liquidity();   
   uint256 compoundAfter = lastCompoundLiquidity(e);
    assert totalSupplyAfter < totalSupplyBefore =>
            posLiquidityAfter - compoundAfter < posLiquidityBefore;
}
","This rule verifies that when the total supply decreases after a function is called, the position liquidity also decreases by at least the amount of the last compound liquidity.",3
"    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    } 
    }
","This rule verifies that when the total supply of assets in a pool is zero, there are no owed assets left in the pool, and vice versa. It also ensures that the liquidity of the pool is zero only when the total supply is zero.",0
"///// rule zeroCharacteristicOfWithdraw()
////  verifies that if withraw returns amount0 == 0 and amount1 == 0 then necessarily shares == 0
rule zeroCharacteristicOfWithdraw(uint256 shares, address to){
    env e;
    uint256 amount0;
    uint256 amount1;

    require governance() != currentContract;
    require governance() != pool;
    require to != currentContract && to != pool && to != governance();
    require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
    amount0,amount1 =  withdraw(e,shares, to);
    assert (amount0 == 0 && amount1 == 0 => shares == 0);
}
","This rule verifies that when withdrawing with amount0 and amount1 equal to zero, the shares must also be zero.",3
"    ///// invariant empty_pool_state_reverse()
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
    ////  verifies that pool liquidity == 0 IFF pool balance - pool owed == 0
    ////  following function are excluded:
    invariant empty_pool_state_reverse()
    pool.liquidity() == 0 <=> (pool.balance0() - pool.owed0() == 0 && pool.balance1() - pool.owed1() == 0)
",This rule needs to be verified by ensuring that the liquidity of the pool is equal to zero if and only if either the total supply is equal to zero or the balance of the pool minus the amount owed by the pool is equal to zero for both tokens.,0
"    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
    filtered { f -> excludeCallback(f) }
",This rule verifies that the total liquidity in the pool is equal to the difference between the balance of one asset in the pool and the amount owed for that asset.,0
"// rule withdraw_amount(address to){
//     env e;

//     require governance() != currentContract;
//     require governance() != pool;
//     require (to!=governance() && to != pool && to != currentContract);
//     require e.msg.sender != pool && e.msg.sender != currentContract && e.msg.sender != governance();
//     require token0.balanceOf(currentContract) == 0 &&
//             token1.balanceOf(currentContract) == 0;
//             requireInvariant empty_pool_state();
    ///// invariant empty_pool_state()
    ////  verifies that pool liquidity == 0 IFF totalSupply == 0
    ////  collectProtocolFees() - it breakes the rule
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant empty_pool_state()
    pool.liquidity() == 0 <=> totalSupply() == 0
    filtered { f -> excludeCallback(f) }
//             requireInvariant zero_totalSupply_zero_owed();
    ///// invariant zero_totalSupply_zero_owed()
    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool
    invariant zero_totalSupply_zero_owed()
    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ 
    preserved {
        requireInvariant empty_pool_state();
    } 
    }
//             requireInvariant pool_balance_vs_owed();
    ///// invariant pool_balance_vs_owed()
    ////  verifies that pool balance greater equal to pool owed
    invariant pool_balance_vs_owed()
    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()
//             requireInvariant total_vs_protocol_Fees();
    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
//             requireInvariant liquidity_GE_poolBalance0();
    ///// invariant liquidity_GE_poolBalance0()
    ////  verifies that pool liquidity == pool balance - pool owed
    ////  collectProtocolFees() - breaks the rule
    invariant liquidity_GE_poolBalance0()
    pool.liquidity() == pool.balance0() - pool.owed0()
//             requireInvariant balance_contract_GE_protocolFees();
    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
//     uint256 shares;
//     uint256 amount0;
//     uint256 amount1;
//     uint256 totalsupply = totalSupply();
//     uint256 pool_balance0 = pool.balance0();
//     uint256 pool_owed0 = pool.owed0();
//             amount0,amount1 =  withdraw(e,shares, to);
    
//     // uint256 amount0_calc = (pool_balance0 - pool_owed0) * shares / totalsupply;
//     mathint amount0_calc = pool_balance0 * shares / totalsupply;
//     require amount0_calc >= 1;
//     assert  amount0 <= amount0_calc;
// }
","This rule/invariant needs to be verified in order to ensure that withdrawals from the pool are conducted correctly and in compliance with the specified conditions, such as maintaining the pool balance, total fees, and owed assets.",5
"    ///// invariant balance_contract_GE_protocolFees()
    ////  verifies that balance of the conttract is greater than protocol fees
    ////  uniswapV3SwapCallback() - meaningles outside of the swap context
    ////  uniswapV3MintCallback() - meaningles outside of the mint context
    invariant balance_contract_GE_protocolFees()
    token0.balanceOf(currentContract) >= protocolFees0()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","This rule verifies that the balance of the contract is always greater than the protocol fees required for certain operations, excluding specific callback functions from the check.",3
"    ///// invariant balance_vs_protocol_Liquidity()
    ////  verifies that if total supply is zero than all the assets of the system is the owned to governance 
    ////  uniswapV3SwapCallback() - meaningless outside of the swap context
    ////  uniswapV3MintCallback() - meaningless outside of the mint context
    invariant balance_vs_protocol_Liquidity()
    (totalSupply() == 0) => token0.balanceOf(currentContract) == protocolFees0() //&&
                            //token1.balanceOf(currentContract) == protocolFees1()
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }
","This rule verifies that if the total supply is zero, then all the assets of the system are owned by governance. It excludes certain functions related to minting and swapping outside of their intended contexts.",3
"///// rule more_shares_more_amounts_to_withdraw()
////  verifies that with larger number of shares one will withdraw a larger amount of assets
////  this rule passes only when the following line added to burnLiquidityShares():
////  require (share == liquidity * totalSupply/uint256(liquidityInPool));
// rule more_shares_more_amounts_to_withdraw( address to){
// env e;
//     uint256 sharesX;
//     uint256 sharesY;
//     uint256 amount0X;
//     uint256 amount1X;
//     uint256 amount0Y;
//     uint256 amount1Y;

//     require governance() != currentContract;
//     require governance() != pool;
//     require to != currentContract && to != pool && to != governance();
//     require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
//     require sharesX > sharesY;
//     storage init = lastStorage;
    
//     amount0X,amount1X =  withdraw(e,sharesX, to);
//     amount0Y,amount1Y =  withdraw(e,sharesY, to) at init;
//     assert amount0X >= amount0Y && amount1X >= amount1Y;
// }
",This rule verifies that withdrawing a larger number of shares will result in withdrawing a larger amount of assets from the contract.,3
"///// rule protocolFees_state()
////  verifies that balance of governance before applying f() + the change in protocolFees is greater or equal balance of governance after applying f()
////  uniswapV3SwapCallback() - meaningless outside of the swap context
////  uniswapV3MintCallback() - meaningless outside of the mint context
////  acceptGovernance()      - breaks the rule when governance changes
rule protocolFees_state(env e, method f, uint256 shares, address to)
    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector && f.selector != acceptGovernance().selector }
",This rule verifies that the change in protocol fees does not result in a decrease in the balance of governance after applying a function.,3
"/* rule zeroBalancesAfterRebalance(){
    env e;
    rebalance(e);
    assert (token0.balanceOf(e, currentContract)==0 && 
                             token1.balanceOf(e, currentContract)==0);
} */
","This rule/invariant verifies that after a rebalance operation, the token balances of the contract are zero.",5
"    ///// invariant total_vs_protocol_Fees()
    ////  verifies that total fees greater than protocol fees
    invariant total_vs_protocol_Fees()
    totalFees0() > protocolFees0() ||
    totalFees0() == 0 &&  protocolFees0() == 0
    {
        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){
             require to != currentContract && to != pool && to != governance();
             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();
         } 
    }
",This rule ensures that the total fees generated are always greater than or equal to the protocol fees in the system to maintain a proper fee structure and prevent any discrepancies in fee collection.,3
"rule checkBurnExactLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity
    ){
        env e;
        require to == e.msg.sender;
        uint256 amount0;
        uint256 amount1;
        amount0, amount1 = callBurnExactLiquidity(e,
            tickLower,
            tickUpper,
            liquidity,
            e.msg.sender);
        assert liquidity == 0 => amount0 == 0 && amount1 == 0;
        assert liquidity > 0 => amount0 > 0 || amount1 > 0;// && (amount0 <= liquidity || amount1 <= liquidity);
}
",This rule verifies that the correct amount of tokens are burned when removing a specific liquidity amount within the given tick range.,1
"rule checkBurnAllLiquidity(int24 tickLower,
                        int24 tickUpper){
    callBurnAllLiquidity(tickLower, tickUpper);
    // uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);
    // assert(liquidity ==0);
}","This rule/invariant needs to verify that all liquidity within a given range has been burned, resulting in a liquidity value of 0.",0
"rule checkBurnLiquidityShare(
        int24 tickLower,
        int24 tickUpper,
        uint256 share,
        address to){
    env e;
    require (share > 0 && share <= totalSupply());
    uint256 totalSupplyBefore = totalSupply();
    uint256 amount0;
    uint256 amount1;
    amount0, amount1 = callBurnLiquidityShare(e, tickLower, tickUpper, share, 
                       e.msg.sender);
    assert(totalSupply() == totalSupplyBefore);
    assert(!lastReverted);
    
}
","This rule/invariant needs to be verified that the amount of liquidity burned should be within the total supply of liquidity tokens and the total supply remains unchanged after the burn operation. Additionally, it needs to be verified that the function call to burn liquidity share does not revert.",1
"rule integrityOfMulDivNoOverflow(uint256 a,
rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
    require(denominator > 0x0 && a*b <= max_uint256);
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    /*
    assert ((denominator > 0 &&
    (denominator < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) => (result == truncated/denominator));
    */
    assert (result == a*b/denominator);
",This rule needs to be verified to ensure that the result of a multiplication and division operation does not overflow and remains within the specified bounds.,0
"rule integrityOfMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    /* require(denominator > 0 && a*(b/denominator) >= 0 && b*(a/denominator) >= 0 &&
            a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
            b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); */
    env e;

    uint256 mul = a * b;
    /* uint256 remainder = mul % denominator; 
    uint256 truncated = (a * b) - remainder; */
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator || a==0 || b==0);
}
","This rule verifies the integrity of the multiplication and division operations involving three uint256 variables, ensuring that the result is correct within specified bounds.",3
"rule integrityOfSafeMulDiv(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0 && 
            mul(a , div(b , denominator)) <= max_uint256 &&
            mul(b , div(a , denominator)) <= max_uint256);
    env e;

    uint256 mul = a * b;
    uint256 remainder = mul % denominator;
    uint256 truncated = (a * b) - remainder;
    uint256 result = callMulDiv(e , a,
             b,
             denominator);
    
    assert (result == a*b/denominator);
}
",This rule verifies the integrity of safe multiplication and division operations by checking that the result is within the limits of the maximum uint256 value and comparing it with the result obtained using bitwise operations.,3
"rule checkMulDivRoundingUp(uint256 a,
             uint256 b,
             uint256 denominator){
    require(denominator > 0x0 && 
             a*(b/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &&
             b*(a/denominator) <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    env e;
    uint256 result = callMulDivRoundingUp(e , a,
             b,
             denominator);
     assert ((a *b % denominator == 0) && result == (a*b)/denominator ||
              (a *b % denominator> 0) && result == (a*b)/denominator + 1);
}
",This rule needs to verify that the result of multiplying two integers is correctly rounded up when divided by a given denominator.,2
"rule burnDoesNotIncreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, amount);
	uint after = balanceOf(burned);
	assert before >= after;
","This rule verifies that burning tokens does not increase the balance of the address that initiated the burn, ensuring the integrity of the total token supply and the rebasing mechanism.",1
"rule mintDoesNotDecreaseBalance(address burned, uint256 amount){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	mint(e, burned, amount);
	uint after = balanceOf(burned);
	assert after >= before;
",This rule/invariant verifies that minting does not decrease the balance of an address and that the total supply remains intact when a minting operation is performed. It also ensures that the rebasing credits per token remain greater than zero to prevent issues with rebasing/non-rebasing accounting.,1
"rule changesRebaseState(method f) {
	address who;
	
	uint8 _rebaseState = rebaseState(who);
	executeAFunction(f);
	uint8 rebaseState_ = rebaseState(who);
	assert _rebaseState == rebaseState_ 
			|| f.selector == rebaseOptIn().selector 
			|| f.selector == rebaseOptOut().selector;
}
","This rule verifies that a certain function does not change the rebase state of a specific address, except for the cases of opting in or opting out of rebasing.",3
"rule reverseOptInThenOut(address u) {
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0(); // had typo, TODO rerun
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	env eF;
	require eF.msg.sender == u;
	uint256 _nonRebasingSupply = nonRebasingSupply();
	uint256 _rebasingCredits = rebasingCredits();
	uint256 _balance = balanceOf(u);
	uint256 _nonRebasingCreditsPerToken = nonRebasingCreditsPerToken(u);
	// assume currently not opt-in // TODO: Strengthen - should be explicity it's opt-out or require that it is not rebasing at the moment it's run
	require rebaseState(u) != OPT_IN();
	sinvoke rebaseOptIn(eF);
	sinvoke rebaseOptOut(eF);
	uint256 nonRebasingSupply_ = nonRebasingSupply();
	assert _nonRebasingSupply == nonRebasingSupply_, ""non rebasing supply must be preserved when opting-in and immediately opting-out"";
	uint256 rebasingCredits_ = rebasingCredits();
	assert _rebasingCredits == rebasingCredits_, ""rebasing credits must be preserved when opting-in and immediately opting-out"";
	uint256 balance_ = balanceOf(u);
	assert _balance == balance_, ""balance of user must be preserved if user opts-in and immediately opts-out"";
",This rule/invariant needs to be verified to ensure that the total supply of tokens remains intact when a user opts-in and immediately opts-out of rebasing.,5
"rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","This rule verifies that the total supply of tokens in the system is maintained accurately and consistently, considering both rebasing and non-rebasing credits. It also ensures that the calculation of rebasing credits per token always results in a value greater than zero to prevent accounting errors.",1
"rule transferCheckPreconditions(env e, address to, uint256 value)
{
	require to != 0;
	require value != 0;
	
	address from = e.msg.sender;
	bool precondition = balanceOf(from) >= value;

	bool result = transfer@withrevert(e, to, value);
	bool transferReverted = lastReverted; // loading transferReverted
	// The transfer function must meet the precondition, or to revert.
	assert !precondition => (transferReverted || !result), ""If transfer() precondition does not hold, must either revert or return 0"";
}
",This rule checks that a specific precondition is met before a transfer operation is executed and ensures that the transfer operation either successfully completes or reverts if the precondition is not satisfied.,3
"rule additiveMint(address minter, uint256 x, uint256 y) {
	env e;
    storage init = lastStorage;	

    mint(e, minter, x);
    mint(e, minter, y);
    uint b1 = balanceOf(minter);
    
    require x+y <= MAX_UINT256();
    uint sumXY = x+y;
    mint(e, minter, sumXY) at init;
    uint b2 = balanceOf(minter);
    assert b1 == b2, ""mint is not additive in balance of burned"";
}
",This rule needs to be verified to ensure that minting two tokens separately and then minting the sum of those tokens does not result in a change in the balance of the account.,1
"invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
",These rules verify the integrity of the total supply in the token contract and ensure that the rebasing credits per token are always greater than zero. They also sync the opting in and out states with the non-rebasing credits per token.,3
"invariant totalSupplyIsBelowMaxSupply() 
	totalSupply() <= Certora_maxSupply()

rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
","This rule/invariant needs to be verified to ensure that the total supply of tokens is maintained correctly and does not exceed the maximum supply allowed. Additionally, it ensures that the rebasing credits per token remain above zero, which is essential for proper accounting within the contract.",5
"rule isRebasingPredicateSynchronized(address a) {
	requireInvariant optingInAndOutSyncdWithNonRebasingState;
invariant optingInAndOutSyncdWithNonRebasingState(address a) 
	(rebaseState(a) == OPT_IN() => nonRebasingCreditsPerToken(a) == 0) &&
	(rebaseState(a) == OPT_OUT() => nonRebasingCreditsPerToken(a) > 0) // otherwise - no need to check

	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}
// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint256 _previousNonRebasingCreditsPerToken = nonRebasingCreditsPerToken(a);
	bool becomesNonRebasing = Certora_isNonRebasingAccount(a);
	// the only thing we can say for sure here is that if it was non rebasing, then it remains non rebasing
	if (_previousNonRebasingCreditsPerToken > 0) {
		assert becomesNonRebasing;
	} // can't say anything else because a contract will be migrated.
	// after we call _isNonRebasingAccount, and it returns true, it must be the case that nonRebasingCreditsPerToken is positive.
	if (becomesNonRebasing) {
		assert nonRebasingCreditsPerToken(a) > 0;
	} else {
		assert nonRebasingCreditsPerToken(a) == 0;
	}
","This rule verifies the integrity of the total token supply by ensuring that it is always greater than or equal to the sum of rebasing and non-rebasing credits per token, taking into account any changes in the non-rebasing status of accounts.",1
"	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
",This rule ensures that the total supply of tokens remains consistent and does not revert during the execution of certain functions by checking that it is always greater than or equal to a calculated value based on rebasing and non-rebasing credits per token. It also ensures that the rebasing credits per token is always greater than zero.,3
"rule neverRevert_BalanceOf {
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
",This rule/invariant needs to verify that the total supply of tokens remains consistent and does not decrease below a certain threshold relative to the rebasing and non-rebasing credit supply in the contract. This ensures that the integrity of the total token supply is maintained throughout contract operations.,5
"rule zeroMintDoesNotIncreaseBalance(address user) {
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(user);
	mint(e, user, 0);
	uint after = balanceOf(user);
	assert after == before;
",This rule ensures that the total supply of tokens remains consistent and does not decrease when minting tokens with a value of zero.,1
"rule zeroBurnDoesNotDecreaseBalance(address burned){
	env e;
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0();
	// probably must assume invariant rebasingCreditsPerTokenMustBeGreaterThan0
	address who;
	invoke balanceOf(who);
	assert !lastReverted;
}

// Requireing rebasingCreditsPerToken to be greater than zero is important
// since much of the rebasing/nonRebasing accounting will fail if it is zero.
//
// Once the contract is initialized, the rebasingCreditsPerToken should never
// again be zero, since a positive value is set in the initializer and there is a
// require statement guarding against it going back down to zero in the only
// function that updates it.
invariant rebasingCreditsPerTokenMustBeGreaterThan0() 
	rebasingCreditsPerToken() > 0
	
// a condition for changeSupply() not to revert:
// TODO: Check in init_state. probably wrong in constructor/initialization?
rule totalSupplyIntegrity(method f) {
	require totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	requireInvariant rebasingCreditsPerTokenMustBeGreaterThan0;
	// need to require that nonRebasingCreditsPerToken is < 1e18?
    executeAFunction(f);
    assert totalSupply() >= (rebasingCredits()*ONE()) / rebasingCreditsPerToken() + nonRebasingSupply();
	uint before = balanceOf(burned);
	burn(e, burned, 0);
	uint after = balanceOf(burned);
	assert before == after;
",This rule/invariant needs to be verified to ensure that the total token supply remains intact and that burning tokens does not decrease the balance of a specific address.,1
"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= T || T2 == NR;
}
","This rule needs to be verified to ensure that the calculation of the change in supply based on the total supply, new supply, and reserve currency is within the specified constraints and does not exceed the maximum supply limit.",0
"rule mathOfChangeSupply(uint T, uint NR, uint RC) {
	require T <= MAX_SUPPLY();
	require T > 0 && NR > 0 && T > NR;
	require RC > 0; // is this reasonable?
	
	mathint RCPT = divPrecisely(RC, (T - NR));
	require RCPT <= MAX_UINT256();
	mathint T2 = divPrecisely(RC, RCPT) + NR;
	assert T2 <= MAX_SUPPLY();
}
",This rule needs to be verified to ensure that the change in supply calculated based on the input values is within the valid range and complies with the specified conditions.,0
"rule onlyValidOtoken(address owner, uint256 vaultId, uint256 index, address otoken, method f) {
    links();
    require shortOtoken.underlyingAsset() == underlying;
    require longOtoken.underlyingAsset() == underlying;
    require shortOtoken.strikeAsset() == strike;
    require longOtoken.strikeAsset() == strike;
    require shortOtoken.collateralAsset() == collateralToken;
    require longOtoken.collateralAsset() == collateralToken;
    require smallVault(owner, vaultId, 1);
    require (otoken == shortOtoken || otoken == longOtoken );
    require ( getVaultShortOtoken(owner, vaultId, index) == otoken || getVaultLongOtoken(owner, vaultId, index) == otoken) 
            => whitelist.isWhitelistedOtoken(otoken);
    uint256 before = pool.getStoredBalance(otoken);
    uint256 totalSupplyBefore = assetTotalSupply(otoken);
    require !whitelist.isWhitelistedCollateral(otoken);
    callFunctionWithParameters(f, owner, vaultId, index);
    uint256 after = pool.getStoredBalance(otoken);
    uint256 totalSupplyAfter = assetTotalSupply(otoken);
    assert ( before != after || totalSupplyBefore != totalSupplyAfter) => whitelist.isWhitelistedOtoken(otoken);
}
","This rule needs to verify that the ownership, vault details, otoken properties, and whitelist status are valid before executing a specified method. It also ensures that the otoken's balance and total supply are updated accordingly after the method is called.",3
"rule cantSettleUnexpiredVault(address owner, uint256 vaultId)
{
    links();
    env e;
    require !isVaultExpired(e, owner, vaultId);
    require smallVault(owner, vaultId, 1);
    address whoever;
    sinvoke settleVault(e, owner, vaultId, whoever);
    assert false; // will pass because cannot sinvoke settleVault when dealing with a non-expired vault
}
",This rule needs to be verified to ensure that unexpired vaults cannot be settled before their expiry date.,0
"// rule validBalanceTotalCollateralPostExpiry(address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
    // env e;
    // require oToken == shortOtoken;
    // require collateral == collateralToken;
    // require isValidVault(owner, vaultId); 
    // require getVaultShortOtoken(owner, vaultId, index) == oToken;
    // require getVaultCollateralAsset(owner, vaultId, index) == collateral;
    // uint256 collateralVaultBefore = getProceed(owner, vaultId);
    // uint256 supplyBefore = shortOtoken.totalSupply();
    // // uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);

    // sinvoke settleVault(e, owner, vaultId, to);
    // uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    // uint256 supplyAfter = shortOtoken.totalSupply();
    // // uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);
    // assert shortVaultAfter == 0;
    // assert supplyAfter == supplyBefore;
    // // assert collateralBalanceBefore - collateralBalanceAfter == collateralVaultBefore;
    
    // 1. in a single tx only 1 vault can be modified 
    // 
// }
","This rule ensures that the balance of a specific collateral asset remains valid before and after certain operations are performed on a vault, taking into account the changes in the pool's balance.",5
"rule validBalanceTotalCollateral(address owner, uint256 vaultId, uint256 index, address asset, method f, address from, uint256 amount)
description ""$f breaks the validity of stored balance of collateral asset""
{
    links();
    env e;
    require asset == collateralToken;
    require getVaultCollateralAsset(owner, vaultId, index) == asset;
    require !isVaultExpired(e, owner, vaultId);
    uint256 collateralVaultBefore = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = pool.getStoredBalance(asset);
    if (f.selector == settleVault(address,uint256,address).selector 
        || f.selector == redeemB(address,uint256).selector
        || f.selector == redeemA(address,uint256).selector) {
        assert true;
	} else if (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector) {
	    // have to require array lengths <= small const here
	    require smallVault(owner, vaultId, 1);
		address whoever;
		uint256 whatever;
		sinvoke withdrawCollateral(e, owner, vaultId, whoever, index, whatever);
    } else if (f.selector == depositCollateral(address,uint256,address,uint256,uint256).selector) {
        require (e.msg.sender != pool);
        require (owner != pool);
        sinvoke depositCollateral(e, owner, vaultId, from, index, amount);
    } else {
		callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 collateralVaultAfter = getVaultCollateralAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = pool.getStoredBalance(asset);
    assert collateralVaultBefore != collateralVaultAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
    assert poolBalanceBefore != poolBalanceAfter => (poolBalanceAfter - poolBalanceBefore ==  collateralVaultAfter - collateralVaultBefore);
}
",This rule needs to verify that changes to the stored balance of a collateral asset in a vault are consistent with the actions taken by different functions to ensure the overall balance remains valid.,5
"rule validBalanceTotalShort(address owner, uint256 vaultId, uint256 index, address secondAddress, address oToken, method f, uint256 amount)
description ""$f breaks the validity of stored balance of short asset""
{
    links();
    env e;
    calldataarg arg;
    require oToken == shortOtoken;
    require !isVaultExpired(e, owner, vaultId);
    require getVaultShortOtoken(owner, vaultId, index) == oToken;
    uint256 shortVaultBefore = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyBefore = shortOtoken.totalSupply();
    // only test the cases before expiry
    if (f.selector == settleVault(address,uint256,address).selector) ||  (f.selector == redeemA(address,uint256).selector) {
        assert true;
    } else if (f.selector == mintOtokenA(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenA(e, owner, vaultId, secondAddress, index, amount);
	} else {
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    uint256 shortVaultAfter = getVaultShortAmount(owner, vaultId, index);
    uint256 supplyAfter = shortOtoken.totalSupply();
    assert shortVaultBefore != shortVaultAfter => (supplyAfter - supplyBefore ==  shortVaultAfter - shortVaultBefore);
    assert supplyAfter != supplyBefore => ( supplyAfter - supplyBefore  ==  shortVaultAfter - shortVaultBefore);
}
",This rule needs to verify that the validity of the stored balance of a short asset is maintained after executing a specified method.,5
"rule validState(address owner, uint256 vaultId, uint256 index,  method f) 
{
    links();
    /* TODO: Redeem */
    require f.selector != redeemA(address,uint256).selector && f.selector != redeemB(address,uint256).selector;
    /* TODO: depositLongB */
    require f.selector != depositLongB(address,uint256,address,uint256,uint256).selector;
    
    require smallVault(owner, vaultId, 1);
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index) &&
            longOtoken == getVaultLongOtoken(owner, vaultId, index) &&
            collateralToken == getVaultCollateralAsset(owner, vaultId, index) 
    ;
    require assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
            assetTotalSupply(longOtoken) >= pool.getStoredBalance(longOtoken) &&
            pool.getStoredBalance(longOtoken) >= getVaultLongAmount(owner, vaultId, index) &&
            pool.getStoredBalance(collateralToken) >= getVaultCollateralAmount(owner, vaultId, index) 
    callFunctionWithParameters(f, owner, vaultId, index);
    assert  assetTotalSupply(shortOtoken) >= (pool.getStoredBalance(shortOtoken) + getVaultShortAmount(owner, vaultId, index)) &&
}
","This rule verifies that the assets in the vault are valid and sufficient for the specified actions, taking into account the balances and types of assets involved.",5
"rule validBalanceTotalLong(address owner, uint256 vaultId, uint256 index, method f, address secondAddress, uint256 amount, address asset)
description ""$f breaks the validity of stored balance of long asset""
{
    links();
    env e;
    require asset == longOtoken;
    require getVaultLongOtoken(owner, vaultId, index) == asset;
    uint256 longVaultBefore = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceBefore = longOtoken.balanceOf(pool);
    // the margin pool can neither be the owner nor the msg sender since it is a contract. 
    require (owner != pool);
    require (e.msg.sender != pool);

    if (f.selector == depositLongB(address,uint256,address,uint256,uint256).selector) {
        sinvoke depositLongB(e, owner, vaultId, secondAddress, index, amount);
	} else if (f.selector == mintOtokenB(address,uint256,address,uint256,uint256).selector) {
        // ignore the case where you can mint otokens directly to the margin pool
        require (secondAddress != pool);
        sinvoke mintOtokenB(e, owner, vaultId, secondAddress, index, amount);
	} else {
        require smallVault(owner, vaultId, 1);
        require longOtoken.collateralAsset() == collateralToken;
        callFunctionWithParameters(f, owner, vaultId, index);
    }
    
    uint256 longVaultAfter = getVaultLongAmount(owner, vaultId, index);
    uint256 poolBalanceAfter = longOtoken.balanceOf(pool);
    assert longVaultBefore != longVaultAfter => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
    assert poolBalanceAfter != poolBalanceBefore => ( poolBalanceAfter - poolBalanceBefore ==  longVaultAfter - longVaultBefore);
}
",This rule verifies that a method does not break the validity of stored balance of a long asset by ensuring that the pool balance and vault balance are updated correctly after certain transactions.,5
"rule putOptionsPreExpiryCase3StartingWithAllCasesNoCode(
rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
     require shortPrice != longPrice; // <============= make sure this is a valid requirement ADD rule
    //everything changed beside:
    // 1. total supply of long (it changes only when minting - adding as short) 
    require totalSupplyLongOtoken_ == _totalSupplyLongOtoken;
    // 2.  pool holding of short (it changes only when adding as long) 
    require poolShortOtokenBalance_  == _poolShortOtokenBalance;
",This rule/invariant needs to be verified to ensure that the collateral and debt calculation in the vault system is correct and that the changes in vault balances and system balances are coherent and consistent in different cases of valid vault configurations.,5
"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
function links() {
    require anOtokenA() == shortOtoken;
    require anOtokenB() == longOtoken;
    require dummyERC20C() == collateralToken;
}",This rule needs to be verified to ensure that the vault is in a valid state and that the balances and calculations related to the vault are coherent and consistent.,5
"rule putOptionsPreExpiryCase2StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","This rule/invariant needs to be verified to ensure that the collateral, debt, and asset balances of a vault are correctly updated and maintained according to the valid conditions for different vault cases.",5
"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase3StartingWithAllCases(
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
","This rule/invariant needs to be verified to ensure that the vault is in a valid state where the debt computation is correct and the balances of the system are maintained properly for the ""Case 3"" scenario.",5
"This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
","This rule/invariant needs to be verified against the validity of vault states before and after certain operations, ensuring that the collateral amount is sufficient to cover the debt and all relevant balances are maintained correctly.",0
"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
/** For put options before expiry (strong bound): 
  obligation(o) 閳  (o.totalSupply() - storedBalance(o)) 
  The debt computation is also different 
rule callOptionsPreExpiry(
   // assume before expiry
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
",This rule needs to be verified to ensure that the vault is in a valid state and that the debt computation is accurate for put options before expiry.,0
"rule putOptionsPreExpiryCase3StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
    require( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )); // {
    /*} else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
    }*/
    //assume isValid vault case 3
    require !( (longAmount_ > shortAmount_ && longPrice < shortPrice) 
            || (longAmount_ <= shortAmount_ && ( longAmount_ * longPrice <= shortAmount_ * shortPrice )));
    
            
    mathint debt_ = 0;
",This rule needs to be verified that the vault is in a valid state and that the collateral held in the vault is sufficient to cover any potential debt obligations based on the amount and prices of the options held in the vault.,0
"    // valid state - need to prove this as in invariant also when the vault is not valid should hold
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes

Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;
    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
    // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
",This rule/invariant needs to be verified by ensuring that the changes in vault amounts and collateral are coherent and that the vault remains in a valid state with respect to the balances of the system.,5
"rule callOptionsPreExpiry(
    address owner,
    uint256 vaultId,
    uint256 index,
    address asset,
    uint256 _shortAmount,
    uint256 _longAmount,
    uint256 _collateral,
    uint256 _poolAssetBalance,
    uint256 _poolShortOtokenBalance,
    uint256 _poolLongOtokenBalance,
    uint256 _totalSupplyShortOtoken,
    uint256 _totalSupplyLongOtoken,
    uint256 shortPrice,
    uint256 longPrice,
    uint256 shortAmount_,
    uint256 longAmount_,
    uint256 collateral_,
    uint256 poolAssetBalance_,
    uint256 poolShortOtokenBalance_,
    uint256 poolLongOtokenBalance_,
    uint256 totalSupplyShortOtoken_,
    uint256 totalSupplyLongOtoken_
) {
    links();
    env e;
    require shortOtoken == getVaultShortOtoken(owner, vaultId, index);
    require longOtoken == getVaultLongOtoken(owner, vaultId, index);
    require collateralToken == getVaultCollateralAsset(owner, vaultId, index);
    require asset == collateralToken;

    require _shortAmount == getVaultShortAmount(owner, vaultId, index);
    require _longAmount == getVaultLongAmount(owner, vaultId, index);
    require _collateral == getVaultCollateralAmount(owner, vaultId, index);
    require _poolAssetBalance == pool.getStoredBalance(asset);
    require _poolShortOtokenBalance == pool.getStoredBalance(shortOtoken);
    require _poolLongOtokenBalance == pool.getStoredBalance(longOtoken);
    require _totalSupplyShortOtoken == assetTotalSupply(shortOtoken);
    require _totalSupplyLongOtoken == assetTotalSupply(longOtoken);
    require shortPrice == shortOtoken.strikePrice();
    require longPrice == longOtoken.strikePrice();
   // assume before expiry
    require !isVaultExpired(e, owner, vaultId);
This rule is proven relaying on:
1. a proof with Mathemtic minValue to compute the debt a vault
2. a rule that shows that one vault is changed at a time
3. rules that show valid balances of the system with respect to vault changes
Due to complexity for the SMT solver the rules is split to three cases of a valid vault:
    if( longAmount <= shortAmount && longAmount * longPrice <=  shortAmount * shortPrice )  //case 1
         debt =  shortAmount * shortPrice  -  longAmount *  longPrice ; 
    else if ( longAmount > shortAmount_ && longPrice < shortPrice)  //case 2
          debt =   shortAmount * (shortPrice - longPrice) ;
    else //case 3
        debt = 0;
*/
rule putOptionsPreExpiryCase1StartingWithAllCases(
    // assume before expiry
    // assume no bankruptcy
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance ) * shortPrice
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance ) * longPrice;
    require _poolAssetBalance >= _obligation ;
    // based on Mathematica proof:
    mathint _debt = 0;
    if( _longAmount <= _shortAmount && ( _longAmount * longPrice <= _shortAmount * shortPrice )) {
            _debt = _shortAmount * shortPrice  -  _longAmount *  longPrice ;
    } else if ( _longAmount > _shortAmount && longPrice < shortPrice) {
            _debt = _shortAmount * (shortPrice - longPrice) ;
    }
    //assume vault is in a valid state
    require _collateral >= _debt ;
    //assume valid state based on  valid balances rules
    require ( _totalSupplyShortOtoken >= _poolShortOtokenBalance + _shortAmount) &&
              _totalSupplyLongOtoken >= _poolLongOtokenBalance &&
              _poolLongOtokenBalance >= _longAmount &&
              _poolAssetBalance >= _collateral ;
	//compute excess collateral of other vaults
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount) * shortPrice
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount ) * longPrice  ;
    // assume excess collateral of other vaults is not cover by this vault's collateral
    require ( _poolAssetBalance - _collateral >= _obligationWithoutThisVault );
	
    // simulate many operations in one step
    uint256 newShortAmount;
    uint256 newLongAmount;
    uint256 newcollateralAmount;
    uint256 newTotalSupply;
    sinvoke havocVault(owner, vaultId, index, newShortAmount, newLongAmount, newcollateralAmount); 
    sinvoke pool.havocSystemBalance(longOtoken);
    sinvoke pool.havocSystemBalance(asset);
    sinvoke shortOtoken.havocTotalSupply(newTotalSupply);
    require shortAmount_ == getVaultShortAmount(owner, vaultId, index);
    require longAmount_ == getVaultLongAmount(owner, vaultId, index);
    require collateral_ == getVaultCollateralAmount(owner, vaultId, index);
    require poolAssetBalance_ == pool.getStoredBalance(asset);
    require poolShortOtokenBalance_ == pool.getStoredBalance(shortOtoken);
    require poolLongOtokenBalance_ == pool.getStoredBalance(longOtoken);
    require totalSupplyShortOtoken_ == assetTotalSupply(shortOtoken);
    require totalSupplyLongOtoken_ == assetTotalSupply(longOtoken);
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ ) * shortPrice
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ ) * longPrice  ;
    //assume isValid vault case 1
    require longAmount_ <= shortAmount_ && longAmount_ * longPrice <=  shortAmount_ * shortPrice ;
    mathint debt_ =  shortAmount_ * shortPrice  -  longAmount_ *  longPrice ;
   
    require collateral_ >= debt_ ;
    // valid state - need to prove this as in invariant also when the vault is not valid should hold
    require  (totalSupplyShortOtoken_ >=  poolShortOtokenBalance_ + shortAmount_) &&
             totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
             poolLongOtokenBalance_ >= longAmount_ &&
             poolAssetBalance_ >= collateral_ ;
    // assume changes are coherent based on total required rules
    require collateral_ - _collateral ==  poolAssetBalance_-  _poolAssetBalance;
    require longAmount_ - _longAmount == poolLongOtokenBalance_ -  _poolLongOtokenBalance;
    require shortAmount_ - _shortAmount ==  totalSupplyShortOtoken_ - _totalSupplyShortOtoken;
    //verify no bankruptchy 
    assert poolAssetBalance_ >= obligation_ ;
}
rule putOptionsPreExpiryCase2StartingWithAllCases(
    //assume isValid vault case 2
    require longAmount_ > shortAmount_ && longPrice < shortPrice ;
	mathint _obligation = (_totalSupplyShortOtoken - _poolShortOtokenBalance )
                                         +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance )   ;
    require (_poolAssetBalance >= _obligation) ;
    mathint temp = _shortAmount - _longAmount;
    if temp > 0 {
        _debt = temp;
    /**
     *             (long strike - short strike) * short amount
     * calculate  ----------------------------------------------
     *                             long strike
     */
    mathint temp2 = (longPrice - shortPrice) * _shortAmount / longPrice;
    mathint _debt2;
    if temp2 > _debt {
        _debt2 = temp2;
    } else {
        _debt2 = _debt;
    require _collateral >= _debt2 ;
    ////assume valid state based on  valid balances rules
              _totalSupplyLongOtoken >=  _poolLongOtokenBalance &&
              _poolAssetBalance >= _collateral;
	//compute excess collateral of other vaults.
	mathint _obligationWithoutThisVault = (_totalSupplyShortOtoken - _poolShortOtokenBalance - _shortAmount)
                                             +  (_totalSupplyLongOtoken -  _poolLongOtokenBalance +_longAmount )   ;
    //assume vault is in a vaild state
    mathint obligation_ = (totalSupplyShortOtoken_ - poolShortOtokenBalance_ )
                                                 +  (totalSupplyLongOtoken_ -  poolLongOtokenBalance_ )  ;
    mathint debt_ = 0;
    mathint temp3 = shortAmount_ - longAmount_;
    if temp3 > 0 {
         debt_ = temp3;
       /**
        *             (long strike - short strike) * short amount
        * calculate  ----------------------------------------------
        *                             long strike
        */
    mathint temp4 = (longPrice - shortPrice) * shortAmount_ / longPrice;
    mathint debt_2;
    if temp4 > debt_ {
      debt_2 = temp4;
        debt_2 = debt_;
    require ( collateral_ >= debt_2 );
    // valid state 
        totalSupplyLongOtoken_  >=  poolLongOtokenBalance_  &&
        poolLongOtokenBalance_ >= longAmount_  &&
        poolAssetBalance_ >= collateral_ ;
 
","This rule checks the validity of a vault scenario before expiry, ensuring that the collateral covers the debt obligations and that the system balances remain consistent after simulating multiple operations.",0
"rule successOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	require x > 0;
	require index < MAXINT();
	// require index <= collateralAmountLength();
	if (index < collateralAmountLength()) {
		require asset == getCollateralAsset(index);
		require getCollateralAmount(index) + x < MAXINT();

		invoke addCollateral(asset, x, index);
		assert !lastReverted, ""addCollateral may revert when precondition holds"";
	else if ((index == collateralAmountLength())) {
	else {
		assert lastReverted, ""addCollateral may not revert when precondition not holds"";
","This rule needs to be verified to ensure that adding collateral with a valid asset, amount, and index does not cause a revert and follows the required conditions for the collateral assets in the system.",0
"rule additiveAddLong(address longOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addLong(longOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addLong(longOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 longAmountScenario1 = totalLongAmount();
	invoke addLong(longOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 longAmountScenario2 = totalLongAmount();
	assert (call1 && call2) <=> call3, ""addLong is not additive, one scenario reverts"" ;
	assert call3 => longAmountScenario1 == longAmountScenario2, ""addLong is not additive"" ;
","This rule verifies if adding two amounts and then adding their sum separately to a long position in the vault yields the same result, ensuring the addLong function is additive.",0
"rule inverseAddRemoveLong(address longOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	invoke removeLong(longOtoken, x, index);
	assert !lastReverted && totalLongAmount() == longAmountBefore, ""removeLong is not inverse of addLong""; 
",This rule needs to verify that adding and removing long positions in a vault is done correctly and maintains the integrity of the vault's data structure.,0
"rule additiveAddShort(address shortOtoken, uint256 x, uint256 y, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	require index < MAXINT(); // no violation when limiting index
	require x > 0 && y > 0 ;
	uint256 t = x + y ;
    require( t >= x && t >= y); //no overflow
    storage initialStorage = lastStorage;
	invoke addShort(shortOtoken, x, index);
	bool call1 = !lastReverted;
	invoke addShort(shortOtoken, y, index);
	bool call2 = !lastReverted;
	uint256 shortAmountScenario1 = totalShortAmount();
	invoke addShort(shortOtoken, t, index) at initialStorage;
	bool call3 = !lastReverted;
	uint256 shortAmountScenario2 = totalShortAmount();
	assert (call1 && call2) <=> call3, ""addShort is not additive, one scenario reverts"" ;
	assert call3 => shortAmountScenario1 == shortAmountScenario2, ""addShort is not additive"" ;
",This rule needs to be verified to ensure that the function addShort is additive and maintains consistency in the total short amount when adding individual amounts separately and together.,0
"invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
","This rule ensures that the lengths of the various types of asset amounts and corresponding assets are consistent in the vault, and that each entity index in the vault is associated with the correct types of assets and amounts. It also enforces that adding assets to the vault maintains the integrity of the entity indexes.",0
"rule integrityOfAddCollateral(address asset, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require asset != ADDRESSZERO();
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	assert totalCollateral() == collateralBefore + x, ""integirty break of addCollateral"";
",This rule/invariant needs to verify that adding collateral to a specific entity at a certain index maintains the integrity of the total collateral amount in the system.,0
"rule integrityOfAddLong(address longOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require longOtoken != ADDRESSZERO();
	uint256 longAmountBefore = totalLongAmount();
	sinvoke addLong(longOtoken, x, index);
	assert totalLongAmount() == longAmountBefore + x &&
		getLongOtoken(index) == longOtoken, ""integirty break of addLong"";
","This rule needs to verify the integrity of adding a long position (option token) to the vault, ensuring that the total long amount increases by the specified amount and that the corresponding option token is correctly stored at the specified index.",0
"rule additiveAddCollateral(address asset, uint256 x, uint256 y, uint256 index)
{
		requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
    	require index < MAXINT(); // no violation when limiting index
    	require x > 0 && y > 0 ;
    	uint256 t = x + y ;
        require( t >= x && t >= y); //no overflow
        storage initialStorage = lastStorage;
    	invoke addCollateral(asset, x, index);
    	bool call1 = !lastReverted;
    	invoke addCollateral(asset, y, index);
    	bool call2 = !lastReverted;
    	uint256 collateralAmountScenario1 = totalCollateral();
    	invoke addCollateral(asset, t, index) at initialStorage;
    	bool call3 = !lastReverted;
    	uint256 collateralAmountScenario2 = totalCollateral();
    	assert (call1 && call2) <=> call3, ""addCollateral is not additive, one scenario reverts"" ;
    	assert call3 => collateralAmountScenario1 == collateralAmountScenario2, ""addCollateral is not additive"" ;
",This rule needs to be verified to ensure that the function for adding collateral to a vault is additive and does not result in reversion or non-additive behavior in different scenarios.,5
"rule inverseAddRemoveCollateral(address asset, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 collateralBefore = totalCollateral();
	sinvoke addCollateral(asset, x, index);
	invoke removeCollateral(asset, x, index);
	assert !lastReverted && totalCollateral() == collateralBefore, ""removeCollateral is not inverse of addCollateral""; 
",This rule needs to be verified to ensure that removing collateral is the inverse operation of adding collateral for a specific asset and index in the vaults system.,0
"rule integrityOfAddShort(address shortOtoken, uint256 x, uint256 index)
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	require shortOtoken != ADDRESSZERO();
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	assert  totalShortAmount() == shortAmountBefore + x &&
		    getShortOtoken(index) == shortOtoken, ""integrity break of addShort"";
","This rule ensures that when adding a short position, the total short amount is correctly updated and the short otoken is associated with the correct index.",0
"rule inverseAddRemoveShort(address shortOtoken, uint256 x, uint256 index) 
{
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 shortAmountBefore = totalShortAmount();
	sinvoke addShort(shortOtoken, x, index);
	invoke removeShort(shortOtoken, x, index);
	assert !lastReverted && totalShortAmount() == shortAmountBefore, ""removeShort is not inverse of addShort""; 
",This rule/invariant needs to be verified to ensure that adding and removing a short option with a specific amount and index in the vault does not result in any unexpected changes to the total short amount in the vault.,0
"This is a parametic rule where f is any of the external/public functions of the contract
*/
rule changeToOneEntity(uint256 shortIndex, uint256 longIndex, uint256 collateralIndex, method f ) {
	
	requireInvariant validVault();
invariant validVault() 	longAmountLength() == longOtokensLength() &&  
						shortAmountLength() == shortOtokensLength() &&
						collateralAmountLength() == collateralAssetsLength() 
						
invariant validEntityIndex(uint256 index)
						(getLongAmount(index) > 0 <=> getLongOtoken(index) != 0) &&
						(getShortAmount(index) > 0 <=> getShortOtoken(index) != 0) &&
						(getCollateralAmount(index) > 0 <=> getCollateralAsset(index) != 0)
{
	preserved addLong(address asset, uint256 amt, uint256 _index)
	{
		requireInvariant validEntityIndex(_index);
		requireInvariant validEntityIndex(index);
		require asset != ADDRESSZERO();
	}
	preserved addShort(address asset, uint256 amt, uint256 _index)
	preserved addCollateral(address asset, uint256 amt, uint256 _index)
}
	uint256 longAmountBefore = getLongAmount(longIndex);
	uint256 shortAmountBefore = getShortAmount(shortIndex);
	uint256 collateralAmountBefore = getCollateralAmount(collateralIndex);
	calldataarg args;
	env e;
	sinvoke f(e,args);
	uint256 longAmountAfter = getLongAmount(longIndex);
	uint256 shortAmountAfter = getShortAmount(shortIndex);
	uint256 collateralAmountAfter = getCollateralAmount(collateralIndex);

	assert (longAmountBefore != longAmountAfter => (shortAmountBefore == shortAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (shortAmountBefore != shortAmountAfter  => (longAmountBefore == longAmountAfter && collateralAmountBefore == collateralAmountAfter)) &&
		   (collateralAmountBefore != collateralAmountAfter  => (longAmountBefore == longAmountAfter && shortAmountBefore == shortAmountAfter)); 
","This rule needs to be verified to ensure that when one entity is changed, the amounts of the other entities remain the same in order to maintain balance in the system.",5
"rule redeem (address oToken, address to, address collateral, uint256 amount) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;

    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
}
","This rule/invariant needs to be verified to ensure that the correct amount of collateral is redeemed to the correct address when a specific oToken is redeemed, with accurate calculations and balance adjustments.",5
"rule collateralWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, method f) {
    env e;
    uint256 collateralBalanceBefore = collateralToken.balanceOf(pool);
    calldataarg arg;
    sinvoke f(e, arg);
    uint256 collateralBalanceAfter = collateralToken.balanceOf(pool);

    assert collateralBalanceAfter < collateralBalanceBefore => (f.selector == settleVault(address,uint256,address).selector) 
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 
    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
                                                            || (f.selector == redeemB(address,uint256).selector)
rule redeem (address oToken, address to, address collateral, uint256 amount) {
    uint256 amountRemoved = getPayout(oToken, amount);
    uint256 amount1 = getPayout(oToken, 1);
    uint256 toBalanceBefore =  collateralToken.balanceOf(to);
    sinvoke redeemA(e, to, amount);
    uint256 toBalanceAfter =  collateralToken.balanceOf(to);
    //assert supplyAfter != supplyBefore => ((supplyBefore - supplyAfter) * amount1 == amountRemoved);
    //assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
    assert supplyBefore - supplyAfter == amount;
    assert poolBalanceBefore - poolBalanceAfter == amountRemoved;
    assert toBalanceAfter - toBalanceBefore == amountRemoved;
                                                            || (f.selector == redeemA(address,uint256).selector)
                                                            || (f.selector == withdrawCollateral(address,uint256,address,uint256,uint256).selector);
",This rule needs to verify that the amount of collateral withdrawn is accurate and that the balances of the collateral token and relevant entities are updated correctly.,5
"rule optionWithdrawsRestricted(address owner, uint256 vaultId, uint256 index, address from, address amount, method f) {
    env e;
    // The pool cannot really call any of these functions
    require (e.msg.sender != pool);
    require (!whitelist.isWhitelistedCollateral(longOtoken));
    uint256 otokenBalanceBefore = longOtoken.balanceOf(pool);
    if (f.selector == burnOtokenB(address,uint256,address,uint256,uint256).selector) {
        require(owner != pool);
        sinvoke burnOtokenB(e, owner, vaultId, from, index, amount);
    } else {
        calldataarg arg;
        sinvoke f(e, arg);
    }
    uint256 otokenBalanceAfter = longOtoken.balanceOf(pool);
    // or settle vault 
    assert otokenBalanceAfter < otokenBalanceBefore => (f.selector == withdrawLongB(address, uint256, address, uint256, uint256).selector) 
                                                    || (f.selector == settleVault(address,uint256,address).selector);
rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","The rule/invariant needs to verify that certain conditions are met before allowing a withdrawal or settlement action to occur, and that the actions taken result in the expected changes in token balances.",5
"// rule inverse (address owner, uint256 vaultId, address from, uint256 index, uint256 amount) { 
//     require(isValidVault(owner, vaultId));

//     storage initialStorage = lastStorage;
//     env e1; 
//     calldataarg arg1;
//     sinvoke f1(e1, arg1);
//     env e2;
//     calldataarg arg2;
//     sinvoke f2(e2, arg2);
//     function depositLongA(
//     address owner,
//     uint256 vaultId,
//     address from,
//     uint256 index,
//     uint256 amount
//   ) 
    
//     uint256 vaultCollateralAmount1 = getVaultCollateralAmount(owner, vaultId,0);
//     sinvoke f2(e2, arg2) at initialStorage;
//     sinvoke f2(e1, arg1);
//     uint256 vaultCollateralAmount2 = getVaultCollateralAmount(owner, vaultId,0);
//     assert vaultCollateralAmount1 == vaultCollateralAmount1;
//     // run first method and then second method and store the result 
//     // run the second method then first method and compare result 
// }
",This rule/invariant needs to verify that the collateral amount in a vault remains the same regardless of the order in which two specific functions are invoked.,5
"rule settleVault (address owner, uint256 vaultId, uint256 index, address oToken, address to, address collateral) {
    env e;
    require oToken == shortOtoken;
    require collateral == collateralToken;
    require getVaultShortOtoken(owner, vaultId, 0) == oToken;
    require getVaultCollateralAsset(owner, vaultId, 0) == collateral;
    require to != pool; 

    uint256 supplyBefore = shortOtoken.totalSupply();
    uint256 amountRemoved = getProceed(owner, vaultId);
    uint256 poolBalanceBefore = collateralToken.balanceOf(pool);
    sinvoke settleVault(e, owner, vaultId, to);
    uint256 supplyAfter = shortOtoken.totalSupply();
    uint256 poolBalanceAfter = collateralToken.balanceOf(pool);
    assert supplyAfter == supplyBefore;
    assert poolBalanceAfter != poolBalanceBefore => (poolBalanceBefore - poolBalanceAfter == amountRemoved);
}
","This rule verifies that the total supply of a specific token and the balance of a specific token in a pool remain unchanged after settling a vault, while ensuring that the amount removed from the vault matches the balance change in the pool.",5
"rule cooldown(method f, env e, env e2){
    bytes32 id;
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    uint256 minDelay = getMinDelay();

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    calldataarg args;
    f(e, args);
    assert isOperationReady(e2, id) => (e2.block.timestamp - e.block.timestamp >= minDelay), ""No rush! When I'm ready, I'm ready"";
}
",This rule verifies that a certain time delay has passed before an operation can be performed in a smart contract system.,2
"rule unsetPendingTransitionMethods(method f, env e){
    bytes32 id;

    require !isOperation(id);
    calldataarg args;
    f(e, args);
    assert isOperationPending(id) => (f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector 
                                || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector), ""Why do we need to follow the schedule?"";
}
","This rule ensures that certain methods are only called if there is no pending operation, unless they are specific scheduling methods.",2
"rule executeChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt;
    uint256 otherIdTimestampBefore = getTimestamp(otherId);

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    execute(e, target, value, data, predecessor, salt);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","This rule ensures that when a specific change is executed, the corresponding id has a different timestamp compared to another id that is not related to the change.",2
"rule pendingCancelledTransition(method f, env e){
    bytes32 id;

    require isOperationPending(id);
    calldataarg args;
    f(e, args);
    assert !isOperation(id) => f.selector == cancel(bytes32).selector, ""How you dare to cancel me?"";
}
",This rule needs to verify that a specific transition can only be canceled when the operation is pending.,2
"rule cancelChange(env e){
    bytes32 id;  bytes32 otherId; 

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    cancel(e, id);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
","This rule verifies that after canceling an item, the timestamp of a different item remains unchanged, ensuring no unauthorized changes are made during the cancellation process.",2
"invariant readyCheck(env e, bytes32 id)
    (e.block.timestamp >= getTimestamp(id) && getTimestamp(id) > 1) <=> isOperationReady(e, id)
filtered { f -> !f.isView }
",This rule needs to be verified to confirm that the current timestamp is greater than a specific timestamp value and that a certain operation is ready to be performed.,2
"rule onlyProposer(method f, env e) filtered { f -> f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector
                                                    || f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector } {
",This rule needs to be verified for functions that schedule transactions or batches of transactions in a contract.,3
"rule cannotCallExecute(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    assert lastReverted, ""you go against execution nature"";
}
",This rule checks if a specific operation is pending and not yet ready for execution before attempting to execute it.,2
"rule readyDoneTransition(method f, env e){
    bytes32 id;

    require isOperationReady(e, id);
    calldataarg args;
    f(e, args);
    assert isOperationDone(id) => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector , ""It's not isOperationDone yet!"";
}
",This rule verifies that an operation can only transition from being ready to being done if the specified method has been called and the operation has completed successfully.,2
"rule scheduleCheck(method f, env e){
    bytes32 id;

    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert getTimestamp(id) == to_uint256(e.block.timestamp + delay), ""Time doesn't obey to mortal souls"";
}
",This rule verifies that a scheduled transaction will be executed at the correct time as determined by the delay provided in the function call.,2
"rule scheduleChange(env e){
    bytes32 id;  bytes32 otherId; 
    address target; uint256 value; bytes data ;bytes32 predecessor; bytes32 salt; uint256 delay;

    uint256 otherIdTimestampBefore = getTimestamp(otherId);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    schedule(e, target, value, data, predecessor, salt, delay);
    assert id != otherId => otherIdTimestampBefore == getTimestamp(otherId), ""Master of puppets, I'm pulling your strings"";
}
",This rule verifies that a change in schedule with a new id does not affect the timestamp of a different id before the change.,2
"rule executeRevertsEffectCheck(method f, env e){
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;
    bytes32 id;

    hashIdCorrelation(id, target, value, data, predecessor, salt);
    require isOperationPending(id) && !isOperationReady(e, id);
    execute@withrevert(e, target, value, data, predecessor, salt);
    bool reverted = lastReverted;
    assert lastReverted => isOperationPending(id) && !isOperationReady(e, id), ""you go against execution nature"";
}
","This rule verifies that a specific action has been executed with the potential for a revert effect, and checks if the operation is still pending and not ready for further actions in the environment.",2
"rule possibleTotalVotes(uint256 pId, uint8 sup, env e, method f) {

    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));
    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
",This rule verifies that the total votes for a proposal are within the limit of the total supply of ERC20 votes and that the weight of a participant's votes does not exceed the total supply of ERC20 votes at the time of the proposal snapshot.,3
"    // add requireinvariant  for all i, j. i = i - 1 && i < j => checkpointlookup[i] < checkpointlookup[j];
    require tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId));

    uint256 againstB;
    uint256 forB;
    uint256 absatinB;
    againstB, forB, absatinB = proposalVotes(pId);
    calldataarg args;
    //f(e, args);
    castVote(e, pId, sup);
    uint256 against;
    uint256 for;
    uint256 absatin;
    against, for, absatin = proposalVotes(pId);
    uint256 ps = proposalSnapshot(pId);
    assert tracked_weight(pId) <= erc20votes.getPastTotalSupply(e, proposalSnapshot(pId)), ""bla bla bla"";
}
/////////////////// 2nd iteration with OZ ////////////////////////// 
function executionsCall(method f, env e, address target, uint256 value, bytes data, 
                                    bytes32 predecessor, bytes32 salt, uint256 delay, 
                                    address[] targets, uint256[] values, bytes[] datas) {
    if  (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {
        execute(e, target, value, data, predecessor, salt);
	} else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {
        executeBatch(e, targets, values, datas, predecessor, salt);
	} else {
        calldataarg args;
        f(e, args);
    }
",This rule/invariant needs to be verified to ensure that the tracked weight of a proposal is less than or equal to the total supply of tokens at a specific snapshot.,5
"rule getTimestampOnlyChange(method f, env e){
    bytes32 id;
    address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt; uint256 delay;
    address[] targets; uint256[] values; bytes[] datas;

    require (targets[0] == target && values[0] == value && datas[0] == data)
                || (targets[1] == target && values[1] == value && datas[1] == data)
                || (targets[2] == target && values[2] == value && datas[2] == data);
    hashIdCorrelation(id, target, value, data, predecessor, salt);
    executionsCall(f, e, target, value, data, predecessor, salt, delay, targets, values, datas);
    assert getTimestamp(id) == 1 => f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector  
                                        || f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector, ""Did you find a way to break the system?"";
}
","This rule verifies that the timestamp returned by a specific function is equal to 1 only if certain conditions regarding target, value, and data match in the function call.",2
"rule reinitVersionCheckGrandchild {
/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
    uint8 n;
    returnsBVN(n);
    assert initialized() == n, ""gransdchild contract's version n functions must only be callable in version n"";
",This rule needs to verify that the grandchild contract's version-specific functions can only be called in the corresponding version of the contract.,2
"/// @note We assume initialize() and reinitialize(1) are equivalent if this rule and the above rule, reinitalizeEffects, both pass.
rule initalizeEffects {
    uint256 val; uint256 a; uint256 b;

    initialize(val, a, b);
    assert isInitializedOnce(), ""initialize() must set _initialized to 1"";
}
",This rule is verifying that a certain function is correctly initializing variables and setting a flag to indicate that initialization has occurred.,2
" // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","This rule verifies that only the execute() function can change the executed attribute of a proposal, and that the attribute will always change when execute() is called.",2
"rule noStartBeforeCreation(uint256 pId) {
    uint256 previousStart = proposalSnapshot(pId);
    // This line makes sure that we see only cases where start date is changed from 0, i.e. creation of proposal
 // In this rule we show that if a function is executed, i.e. execute() was called on the proposal ID,
 // non of the proposal specific functions can make changes again. In executedOnlyAfterExecuteFunc 
rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
 // we connected the executed attribute to the execute() function, showing that only execute() can
 // change it, and that it will always change it.
rule allFunctionsRevertIfExecuted(method f) filtered { f ->
    !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
    // We proved in immutableFieldsAfterProposalCreation that once dates set for proposal, it cannot be changed
rule immutableFieldsAfterProposalCreation(uint256 pId, method f) {
    uint256 _voteStart = proposalSnapshot(pId);
    uint256 _voteEnd = proposalDeadline(pId);
    require proposalCreated(pId); // startDate > 0
    
    env e; calldataarg arg;
    f(e, arg);
    uint256 voteStart_ = proposalSnapshot(pId);
    uint256 voteEnd_ = proposalDeadline(pId);
    assert _voteStart == voteStart_, ""Start date was changed"";
    assert _voteEnd == voteEnd_, ""End date was changed"";
    require !proposalCreated(pId); // previousStart == 0;
    propose(e, args);
    uint256 newStart = proposalSnapshot(pId);
    // if created, start is after current block number (creation block)
    assert(newStart != previousStart => newStart >= e.block.number);
","This rule verifies that once a proposal is created, the start and end dates cannot be changed, and that any attempt to change them should revert the transaction.",2
"rule allFunctionsRevertIfCanceled(method f) filtered {
    f -> !f.isView && !f.isFallback
      && f.selector != updateTimelock(address).selector
      && f.selector != updateQuorumNumerator(uint256).selector
      && f.selector != queue(address[],uint256[],bytes[],bytes32).selector
      && f.selector != relay(address,uint256,bytes).selector
      && f.selector != 0xb9a61961 // __acceptAdmin()
      && f.selector != setLateQuorumVoteExtension(uint64).selector
} {
","This rule verifies that all non-view and non-fallback functions should revert if the transaction is canceled, with specific exceptions for certain function selectors.",2
"rule executedOnlyAfterExecuteFunc(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash, method f) {
    env e; calldataarg args;
    uint256 pId;
    bool executedBefore = isExecuted(pId);
    require(!executedBefore);

    helperFunctionsWithRevert(pId, f, e);
    bool executedAfter = isExecuted(pId);
    assert(executedAfter != executedBefore => f.selector == execute(address[], uint256[], bytes[], bytes32).selector, ""isExecuted only changes in the execute method"");
}
",This rule verifies that a certain function is only executed after another specific function has been called.,2
"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
}","This rule needs to be verified to ensure that when a delegator delegates their votes to a new delegatee, the delegatee receives the correct number of votes, the previous delegatee loses their delegated votes, and the total number of votes remains consistent.",3
"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","This rule needs to be verified to ensure that when a delegator changes their delegatee, the votes are removed from the previous delegatee and assigned to the new one correctly.",2
"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require numCheckpoints(delegatee) < 1000000;
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","This rule needs to be verified to ensure that when a delegator delegates their voting power to a delegatee, the delegatee receives the correct amount of votes based on the delegator's balance.",3
"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
",This rule needs to be verified to ensure that delegate methods are safe and that certain constraints on the fromBlock parameter are being followed.,3
"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes but fails rule sanity from hash on delegate by sig
invariant timestamp_constrains_fromBlock(address account, uint32 index, env e)
    ckptFromBlock(account, index) < e.block.number
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
    // this assert fails consistently
    // assert !doubleFromBlock(account) => ckpts_ != _ckpts, ""new fromBlock but total checkpoints not being increased"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","This rule needs to verify that when a delegator delegates to a delegatee, the delegatee cannot be someone else and the votes of the delegator remain contained after the delegation.",2
"rule depositForSpecBasic(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    depositFor(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert wrapperTotalBefore == wrapperTotalAfter - amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
    assert underlyingThisBalanceBefore == underlyingThisBalanceAfter - amount, ""underlying this balance wrong update"";
}
","This rule needs to verify that the total supply of a token, the total supply of the underlying asset, and the balance of the underlying asset held by a contract are updated correctly when a deposit is made for a specific account.",5
"rule recoverSpec(env e){
    address account; uint256 amount;

    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    mathint value = underlyingThisBalanceBefore - wrapperTotalBefore;
    _recover(e, account);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert wrapperTotalBefore == wrapperTotalAfter - value, ""wrapper total wrong update"";
    assert e.msg.sender == account => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - value, ""wrapper balances wrong update"";
    assert e.msg.sender != account => wrapperUserBalanceBefore == wrapperUserBalanceAfter - value
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}",This rule/invariant needs to be verified to ensure that the total supply and individual balances of tokens are properly updated after a specific action is performed on the contract.,5
"rule depositForSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    depositFor(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore 
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter 
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount, ""wrapper balances wrong update"";
    assert account != e.msg.sender => wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount
                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, ""wrapper balances wrong update"";
}
",This rule needs to verify that the wrapper contract balances are correctly updated after a deposit is made for a specific account.,5
"rule depositForSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    depositFor(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount, ""underlying balances wrong update"";
    
    assert account != e.msg.sender && account == currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update"";
    assert account != e.msg.sender && account != currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter, ""underlying balances wrong update"";
}
",This rule needs to verify that the underlying balances are correctly updated when a deposit is made for a specific underlying asset.,5
"rule withdrawToSpecBasic(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperTotalBefore = totalSupply(e);
    uint256 underlyingTotalBefore = underlyingTotalSupply();
    withdrawTo(e, account, amount);
    uint256 wrapperTotalAfter = totalSupply(e);
    uint256 underlyingTotalAfter = underlyingTotalSupply();
    assert wrapperTotalBefore == wrapperTotalAfter + amount, ""wrapper total wrong update"";
    assert underlyingTotalBefore == underlyingTotalAfter, ""underlying total was updated"";
}
","This rule needs to verify that the total supply of the wrapped token decreases by the withdrawn amount, and the total supply of the underlying token remains constant after a withdrawal operation.",5
"rule withdrawToSpecUnderlying(env e){
    address account; uint256 amount;

    require e.msg.sender != currentContract;
    require underlying() != currentContract;
    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);
    withdrawTo(e, account, amount);
    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);
    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);
    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);
    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore 
                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter 
                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, ""underlying balances wrong update (acc == sender)"";
    
    assert account != e.msg.sender && account == currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter, ""underlying balances wrong update (acc == contract)""; 
    assert account != e.msg.sender && account != currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount
                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter
                && underlyingThisBalanceBefore == underlyingThisBalanceAfter + amount, ""underlying balances wrong update (acc != contract)"";   
}
",This rule needs to be verified to ensure that the underlying balances are correctly updated when withdrawing funds to a specified account.,5
"rule withdrawToSpecWrapper(env e){
    address account; uint256 amount;

    require underlying() != currentContract;
    uint256 wrapperUserBalanceBefore = balanceOf(e, account);
    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);
    withdrawTo(e, account, amount);
    uint256 wrapperUserBalanceAfter = balanceOf(e, account);
    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);
    
    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore
                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter + amount, ""wrapper user balance wrong update"";
    assert account != e.msg.sender => wrapperSenderBalanceBefore == wrapperSenderBalanceAfter + amount
                && wrapperUserBalanceBefore == wrapperUserBalanceAfter, ""wrapper user balance wrong update"";
}
",This rule verifies that the user balance is correctly updated when withdrawing funds to a specific address in the wrapper contract.,5
"rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
                                                f.selector != _delegate(address, address).selector &&
                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }
",This rule verifies that certain functions are not delegated to specific addresses to ensure the safety and uniqueness of the checkpoints within the contract.,3
"// passes with rule sanity
rule delegate_contained() {
    env e;
    address delegator; address delegatee; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require other != delegatee;
    require other != delegates(delegator); 
    uint256 votes_ = getVotes(other);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(other);
    assert votes_ == _votes, ""votes not contained"";
","This rule needs to be verified to ensure that when a delegate is changed, the votes of another address remain the same.",3
"// passes + rule sanity
rule previous_delegatee_votes_removed() {
    env e;
    address delegator; address delegatee; address third;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require third != delegatee;
    require delegates(delegator) == third;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_ = getVotes(third);
    _delegate(e, delegator, delegatee);
    uint256 _votes = getVotes(third);
    assert third != 0x0 => _votes == votes_ - delegator_bal, ""votes not removed from the previous delegatee"";
","This rule verifies that when a delegator changes their delegatee to a new address, the votes from the previous delegatee are removed and the number of checkpoints reflecting the delegation change accordingly.",2
"invariant votes_solvency()
    totalSupply() >= to_uint256(totalVotes())
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
filtered { f -> f.selector != _burn(address, uint256).selector}
","This rule/invariant needs to be verified to ensure that the number of checkpoints increases when a new fromBlock is used, and stays the same when the fromBlock is the same as before.",2
"// passes + rule sanity
rule delegatee_receives_votes() {
    env e; 
    address delegator; address delegatee;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    env e; calldataarg args;
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require delegates(delegator) != delegatee;
    require delegatee != 0x0;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 votes_= getVotes(delegatee);
    _delegate(e, delegator, delegatee);
    require lastIndex(delegatee) < 1000000;
    uint256 _votes = getVotes(delegatee);
    assert _votes == votes_ + delegator_bal, ""delegatee did not receive votes"";
","This rule/invariant needs to verify that when a delegator delegates their tokens to a delegatee, the delegatee correctly receives the votes from the delegator, and that the delegatee does not already have a large number of previous delegations.",3
"rule delegate_no_frontrunning(method f) {
    env e; calldataarg args;
    address delegator; address delegatee; address third; address other;
// converted from an invariant to a rule to slightly change the logic
// if the fromBlock is the same as before, then the number of checkpoints stays the same
// however if the fromBlock is new than the number of checkpoints increases
// passes, fails rule sanity because tautology check seems to be bugged
// passes + rule sanity
invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)
    ckptFromBlock(account, pos) >= pos
    filtered { f -> !f.isView }
rule unique_checkpoints_rule(method f) {
    address account;
    uint32 num_ckpts_ = numCheckpoints(account); 
    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);

    f(e, args);
    uint32 _num_ckpts = numCheckpoints(account);
    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);
    
    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, ""same fromBlock, new checkpoint"";
}
    require numCheckpoints(delegatee) < 1000000;
    require numCheckpoints(third) < 1000000;
    uint256 delegator_bal = balanceOf(e, delegator);
    uint256 delegatee_votes_ = getVotes(delegatee);
    uint256 third_votes_ = getVotes(third);
    uint256 other_votes_ = getVotes(other);
    require delegates(delegator) == third;
    require third != delegatee;
    require other != third;
    require other != delegatee;
    require delegatee != 0x0;
    _delegate(e, delegator, delegatee);
    uint256 _delegatee_votes = getVotes(delegatee);
    uint256 _third_votes = getVotes(third);
    uint256 _other_votes = getVotes(other);
    // previous delegatee loses all of their votes
    // delegatee gains that many votes
    // third loses any votes delegated to them
    assert _delegatee_votes == delegatee_votes_ + delegator_bal, ""delegatee did not receive votes"";
    assert third != 0 => _third_votes == third_votes_ - delegator_bal, ""votes not removed from third"";
    assert other_votes_ == _other_votes, ""delegate not contained"";
","This rule/invariant needs to be verified to ensure that when a delegator delegates their votes from one delegatee to another, the correct number of votes are transferred and the previous delegatee loses all of their votes.",3
"invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","This rule/invariant needs to be verified to ensure that the total supply of a token is equal to the sum of all individual balances of that token, and that if a user holds a token, the token exists.",1
"rule held_tokens_should_exist {
    address user; uint256 token;

    requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0
/// If a user has a token, then the token should exist.
    // This assumption is safe because of total_supply_is_sum_of_balances
invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
",This rule needs to be verified to ensure that every token held by a user actually exists and that the balance of the zero address for a token is zero.,1
"rule token_totalSupply_independence(method f)
filtered {
    f -> f.selector != safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
",This rule needs to verify that the total token supply of a contract is not affected by a specific method that involves transferring tokens in batches.,1
"invariant total_supply_is_sum_of_balances(uint256 token)
    sumOfBalances[token] == totalSupply(token)
    {
        preserved {
            requireInvariant balanceOfZeroAddressIsZero(token);
invariant balanceOfZeroAddressIsZero(uint256 token)
    balanceOf(0, token) == 0

/// If a user has a token, then the token should exist.
rule held_tokens_should_exist {
    address user; uint256 token;
    requireInvariant balanceOfZeroAddressIsZero(token);
    // This assumption is safe because of total_supply_is_sum_of_balances
    require balanceOf(user, token) <= totalSupply(token);
    // note: `exists_wrapper` just calls `exists`
    assert balanceOf(user, token) > 0 => exists_wrapper(token),
        ""if a user's balance for a token is positive, the token must exist"";
}
        }
    }
","This rule/invariant needs to be verified to ensure that the total supply of a token is equal to the sum of all individual token balances, and that the balance of the zero address for a token is always zero. Additionally, it checks that if a user has a positive balance of a token, then that token must exist.",1
"rule transferMethodsRevertWhenPaused (method f)
filtered {
    f -> f.selector == safeTransferFrom(address,address,uint256,uint256,bytes).selector
      || f.selector == safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector
}
","This rule ensures that specific transfer methods are reverted when the contract is paused, preventing transfers from occurring when the contract is not in an active state.",2
"rule balancesUnchangedWhenPaused() {
    address user; uint256 token;
    uint256 balanceBefore = balanceOf(user, token);

    require paused();
    method f; calldataarg arg; env e;
    f(e, arg);
    uint256 balanceAfter = balanceOf(user, token);
    assert balanceBefore == balanceAfter, 
        ""Token balance for a user must not change in a paused contract"";
}
","This rule verifies that the token balance of a user remains unchanged when the contract is paused, regardless of any method calls or external interactions.",5
"/// This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule sequentialBurnsEquivalentToSingleBurnOfSum {
    storage beforeBurns = lastStorage;
    env e;

    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;
    require sumBurn == firstBurn + secondBurn;
    // sequential burns
    burn(e, holder, token, firstBurn) at beforeBurns;
    burn(e, holder, token, secondBurn);
    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);
    // burn of sum of sequential burns
    burn(e, holder, token, sumBurn) at beforeBurns;
    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, 
        ""Sequential burns must be equivalent to a burn of their sum"";
}
",This rule/invariant needs to verify that the sequential burns of tokens from a holder's balance are equivalent to a single burn of the total sum of tokens burned.,1
"rule onlyHolderOrApprovedCanReduceBalance(method f) 
{
    address holder; uint256 token; uint256 amount;
    uint256 balanceBefore = balanceOf(holder, token);

    env e; calldataarg args;
    f(e, args);
    uint256 balanceAfter = balanceOf(holder, token);
    assert balanceAfter < balanceBefore => e.msg.sender == holder || isApprovedForAll(holder, e.msg.sender), 
        ""An account balance may only be reduced by the holder or a holder-approved agent"";
}
",This rule needs to be verified to ensure that only the account holder or an approved agent can reduce the balance of a specific token for a given address.,1
"rule burnBatchOnEmptyArraysChangesNothing {
    uint256 token; address nonHolderA; address nonHolderB;

    uint256 startingBalance = balanceOf(nonHolderA, token);
    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;
    require noTokens.length == 0; require noBurnAmounts.length == 0;
    burnBatch(e, holder, noTokens, noBurnAmounts);
    
    uint256 endingBalance = balanceOf(nonHolderA, token);
    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);
    assert startingBalance == endingBalance, 
        ""burnBatch must not change token balances if passed empty arrays"";
    assert startingPermission == endingPermission, 
        ""burnBatch must not change account permissions if passed empty arrays"";
}
",This rule verifies that calling a specific function with empty arrays does not have any effect on token balances or account permissions.,3
"rule multipleTokenBurnBurnBatchEquivalence {
    storage beforeBurns = lastStorage;
    env e;

    address holder;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalanceA = balanceOf(holder, tokenA);
    mathint startingBalanceB = balanceOf(holder, tokenB);
    mathint startingBalanceC = balanceOf(holder, tokenC);
    require tokens.length == 3; require burnAmounts.length == 3;
    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;
    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;
    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;
    // burning via burn
    burn(e, holder, tokenA, burnAmountA) at beforeBurns;
    burn(e, holder, tokenB, burnAmountB);
    burn(e, holder, tokenC, burnAmountC);
    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;
    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);
    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);
    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);
    assert burnBalanceChangeA == burnBatchBalanceChangeA
        && burnBalanceChangeB == burnBatchBalanceChangeB
        && burnBalanceChangeC == burnBatchBalanceChangeC, 
        ""Burning multiple tokens via burn or burnBatch must be equivalent"";
}
",This rule verifies that the result of burning multiple tokens individually through `burn` is equivalent to burning the same tokens collectively through `burnBatch`.,1
"rule singleTokenBurnBurnBatchEquivalence {
    storage beforeBurn = lastStorage;
    env e;

    address holder;
    uint256 token; uint256 burnAmount;
    uint256[] tokens; uint256[] burnAmounts;
    mathint startingBalance = balanceOf(holder, token);
    require tokens.length == 1; require burnAmounts.length == 1;
    require tokens[0] == token; require burnAmounts[0] == burnAmount;
    // burning via burn
    burn(e, holder, token, burnAmount) at beforeBurn;
    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);
    // burning via burnBatch
    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;
    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);
    assert burnBalanceChange == burnBatchBalanceChange, 
        ""Burning a single token via burn or burnBatch must be equivalent"";
}   
",This rule needs to verify that burning a single token with a specific amount either individually or in a batch operation has the same effect on the token balance of a specified holder.,1
"/// n.b. This rule holds for `burnBatch` as well due to rules establishing 
/// appropriate equivance between `burn` and `burnBatch` methods.
rule burnAmountProportionalToBalanceReduction {
    storage beforeBurn = lastStorage;
    env e;
    
    address holder; uint256 token;
    mathint startingBalance = balanceOf(holder, token);
    uint256 smallBurn; uint256 largeBurn;
    require smallBurn < largeBurn;

    // smaller burn amount
    burn(e, holder, token, smallBurn) at beforeBurn;
    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);
    // larger burn amount
    burn(e, holder, token, largeBurn) at beforeBurn;
    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);
    assert smallBurnBalanceChange < largeBurnBalanceChange, 
        ""A larger burn must lead to a larger decrease in balance"";
}
","This rule needs to be verified to ensure that the reduction in token balance is proportional to the amount burned, with a larger burn leading to a larger decrease in balance.",1
"rule noTransferEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256 id; uint256 amount; 
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeTransferFrom(e, from, to, id, amount, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
",This rule needs to be verified to ensure that the approval status remains unchanged after a transfer operation.,2
"rule transfersHaveSameLengthInputArrays {
    env e;

    address recipient; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    uint max_int = 0xffffffffffffffffffffffffffffffff;
    require tokens.length >= 0 && tokens.length <= max_int;
    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;
    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);
    uint256 tokensLength = tokens.length;
    uint256 transferAmountsLength = transferAmounts.length;
    assert tokens.length == transferAmounts.length, 
        ""If transfer methods do not revert, the input arrays must be the same length"";
}
","This rule verifies that when transferring tokens in batches, the input arrays containing token IDs and corresponding transfer amounts must be of the same length to avoid inconsistencies and errors in the transfer process.",3
"rule transferBatchBalanceFromEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != to;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert from != other => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","This rule needs to verify that when a batch transfer is made from one address to another, the balances of specific tokens belonging to a third address remain unchanged.",1
"rule transferBatchBalanceToEffect(env e){
    address from; address to; address other;
    uint256[] ids; uint256[] amounts;
    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;
    bytes data;

    require other != from;
    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3), ""Don't touch my money!"";
}
","This rule needs to verify that when batch transferring balances from one address to another, the balances of specific tokens for a third address remain unchanged.",1
"rule burnAdditivity(env e){
    address from; uint256 id; uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    burn(e, from, id, amount);
    uint256 balanceAfterSingleTransaction = balanceOf(from, id);
    burn(e, from, id, amount1) at initialStorage;
    burn(e, from, id, amount2);
    uint256 balanceAfterDoubleTransaction = balanceOf(from, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
",This rule verifies that the balance of a specific token for an address remains additive after performing multiple burn transactions.,1
"rule noTransferBatchEffectOnApproval(env e){
    address from; address to;
    address owner; address operator;
    uint256[] ids; uint256[] amounts;
    bytes data;

    bool approveBefore = isApprovedForAll(owner, operator);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    bool approveAfter = isApprovedForAll(owner, operator);
    assert approveBefore == approveAfter, ""Something was effected"";
}
",This rule verifies that a batch transfer action does not affect the approval status between the owner and the operator.,2
"rule cannotTransferMoreSingle(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;
    uint256 balanceBefore = balanceOf(from, id);

    safeTransferFrom@withrevert(e, from, to, id, amount, data);
    assert amount > balanceBefore => lastReverted, ""Achtung! Scammer!"";
}
",This rule needs to verify that the amount transferred in a single transfer is not greater than the balance held by the sender's address before the transfer.,1
"rule mintAdditivity(env e){
    address to; uint256 id; uint256 amount; uint256 amount1; uint256 amount2; bytes data;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    mint(e, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    mint(e, to, id, amount1, data) at initialStorage;
    mint(e, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
",This rule verifies that the total balance of a token after two separate mint transactions is equal to the balance after a single mint transaction with the sum of the amounts.,1
"rule mintBatchCorrectWork(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    bytes data;

    require ids.length == 3; 
    require amounts.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(to, id1);
    uint256 otherBalanceBefore2 = balanceOf(to, id2);
    uint256 otherBalanceBefore3 = balanceOf(to, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(to, id1);
    uint256 otherBalanceAfter2 = balanceOf(to, id2);
    uint256 otherBalanceAfter3 = balanceOf(to, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 - amount1
            && otherBalanceBefore2 == otherBalanceAfter2 - amount2
            && otherBalanceBefore3 == otherBalanceAfter3 - amount3
            , ""Something is wrong"";
}
","This rule verifies that when minting multiple tokens in a batch, the correct amount of each token is added to the recipient's balance.",1
"rule transferBalanceIncreaseEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require from != other;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
",This rule needs to be verified to ensure that transferring a balance from one address to another does not inadvertently affect the balance of a third address.,5
"rule cantMintOtherBalances(env e){
    address to; uint256 id; uint256 amount; bytes data;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != to => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
",This rule needs to be verified to ensure that minting tokens for a specific address does not affect the token balances of other addresses.,1
"rule cannotTransferMoreBatch(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    uint256 balanceBefore1 = balanceOf(from, idToCheck1);
    uint256 balanceBefore2 = balanceOf(from, idToCheck2);
    uint256 balanceBefore3 = balanceOf(from, idToCheck3);
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    safeBatchTransferFrom@withrevert(e, from, to, ids, amounts, data);
    assert (amountToCheck1 > balanceBefore1 || amountToCheck2 > balanceBefore2 || amountToCheck3 > balanceBefore3) => lastReverted, ""Achtung! Scammer!"";
}
","This rule needs to verify that a specific batch transfer of three items occurs with the correct amounts and to the correct recipient, preventing any potential scamming behavior.",3
"rule cantBurnOtherBalances(env e){
    address from; uint256 id; uint256 amount;
    address other;

    uint256 otherBalanceBefore = balanceOf(other, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(other, id);
    
    assert other != from => otherBalanceBefore == otherBalanceAfter, ""I like to see your money disappearing"";
}
",This rule needs to be verified to ensure that one address cannot burn tokens from another address's balance.,1
"rule transferAdditivity(env e){
    address from; address to; uint256 id; bytes data;
    uint256 amount; uint256 amount1; uint256 amount2;
    require amount == amount1 + amount2;

    storage initialStorage = lastStorage;
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 balanceAfterSingleTransaction = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount1, data) at initialStorage;
    safeTransferFrom(e, from, to, id, amount2, data);
    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);
    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, ""Not additive"";
}
",This rule needs to be verified to ensure that transferring a total amount in two separate transactions yields the same result as transferring the total amount in a single transaction.,5
"rule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfers = lastStorage;
    env e;

    address holder; address recipient; bytes data;
    uint256 tokenA; uint256 tokenB; uint256 tokenC;
    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalanceA = balanceOf(holder, tokenA);
    mathint holderStartingBalanceB = balanceOf(holder, tokenB);
    mathint holderStartingBalanceC = balanceOf(holder, tokenC);
    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);
    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);
    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);
    require tokens.length == 3; require transferAmounts.length == 3;
    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;
    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;
    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;
    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);
    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);
    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;
    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);
    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);
    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);
    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;
    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;
    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;
    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA
        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB
        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC
        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA
        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB
        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, 
        ""Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}
",This rule needs to verify that transferring multiple tokens via both safeTransferFrom and safeBatchTransferFrom yield equivalent results in terms of changes in balances for both the holder and recipient.,1
"rule cantMintMoreBatch(env e){
    address to; bytes data;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require amounts.length == 3;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(to, id1) + amount1) > max_uint256 
                || to_mathint(balanceOf(to, id2) + amount2) > max_uint256
                || to_mathint(balanceOf(to, id3) + amount3) > max_uint256;
    mintBatch@withrevert(e, to, ids, amounts, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
",This rule ensures that a batch minting operation does not exceed the maximum token balance for the recipient address.,1
"rule transferBatchCorrectness(env e){
    address from; address to; uint256[] ids; uint256[] amounts; bytes data;
    uint256 idToCheck1; uint256 amountToCheck1;
    uint256 idToCheck2; uint256 amountToCheck2;
    uint256 idToCheck3; uint256 amountToCheck3;

    require to != from;
    require idToCheck1 != idToCheck2 && idToCheck3 != idToCheck2 && idToCheck1 != idToCheck3;
    
    require ids.length == 3;        
    require amounts.length == 3;    
    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;
    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;
    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;
    uint256 fromBalanceBefore1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceBefore2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceBefore3 = balanceOf(from, idToCheck3);
    uint256 toBalanceBefore1 = balanceOf(to, idToCheck1);
    uint256 toBalanceBefore2 = balanceOf(to, idToCheck2);
    uint256 toBalanceBefore3 = balanceOf(to, idToCheck3);
    safeBatchTransferFrom(e, from, to, ids, amounts, data);
    uint256 fromBalanceAfter1 = balanceOf(from, idToCheck1);
    uint256 fromBalanceAfter2 = balanceOf(from, idToCheck2);
    uint256 fromBalanceAfter3 = balanceOf(from, idToCheck3);
    uint256 toBalanceAfter1 = balanceOf(to, idToCheck1);
    uint256 toBalanceAfter2 = balanceOf(to, idToCheck2);
    uint256 toBalanceAfter3 = balanceOf(to, idToCheck3);
    assert (fromBalanceBefore1 == fromBalanceAfter1 + amountToCheck1)
                && (fromBalanceBefore2 == fromBalanceAfter2 + amountToCheck2)
                && (fromBalanceBefore3 == fromBalanceAfter3 + amountToCheck3), ""Something wet wrong"";
    assert (toBalanceBefore1 == toBalanceAfter1 - amountToCheck1)
                && (toBalanceBefore2 == toBalanceAfter2 - amountToCheck2)
                && (toBalanceBefore3 == toBalanceAfter3 - amountToCheck3), ""Something wet wrong"";
}
","This rule needs to be verified to ensure that a batch transfer of multiple tokens between two addresses is correctly executed, with the correct amounts for each token being transferred from the sender to the recipient.",1
"rule cantBurnBatchOtherBalances(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;
    address other;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != from => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","This rule ensures that when one address burns tokens belonging to another address, the balances of the other address do not change.",1
"rule burnBatchCorrectWork(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require id1 != id2 && id2 != id3 && id3 != id1;
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    uint256 otherBalanceBefore1 = balanceOf(from, id1);
    uint256 otherBalanceBefore2 = balanceOf(from, id2);
    uint256 otherBalanceBefore3 = balanceOf(from, id3);
    burnBatch(e, from, ids, amounts);
    uint256 otherBalanceAfter1 = balanceOf(from, id1);
    uint256 otherBalanceAfter2 = balanceOf(from, id2);
    uint256 otherBalanceAfter3 = balanceOf(from, id3);
    
    assert otherBalanceBefore1 == otherBalanceAfter1 + amount1
            && otherBalanceBefore2 == otherBalanceAfter2 + amount2
            && otherBalanceBefore3 == otherBalanceAfter3 + amount3
            , ""Something is wrong"";
}
","This rule verifies that when burning multiple tokens in a batch, the correct tokens with the correct amounts are burned from the sender's balance.",1
"rule mintCorrectWork(env e){
    address to; uint256 id; uint256 amount; bytes data;

    uint256 otherBalanceBefore = balanceOf(to, id);
    mint(e, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(to, id);
    
    assert otherBalanceBefore == otherBalanceAfter - amount, ""Something is wrong"";
}
",This rule verifies that a specific operation correctly increases the balance of a certain address for a specific token ID by the expected amount.,1
"rule transferBalanceReduceEffect(env e){
    address from; address to; address other;
    uint256 id; uint256 amount; 
    bytes data;

    require other != to;
    uint256 otherBalanceBefore = balanceOf(other, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 otherBalanceAfter = balanceOf(other, id);
    assert from != other => otherBalanceBefore == otherBalanceAfter, ""Don't touch my money!"";
}
",This rule needs to be verified to ensure that transferring balances between addresses does not mistakenly affect the balance of a third party.,5
"rule cantMintBatchOtherBalances(env e){
    address to;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256[] ids; uint256[] amounts;
    address other;
    bytes data;

    uint256 otherBalanceBefore1 = balanceOf(other, id1);
    uint256 otherBalanceBefore2 = balanceOf(other, id2);
    uint256 otherBalanceBefore3 = balanceOf(other, id3);
    mintBatch(e, to, ids, amounts, data);
    uint256 otherBalanceAfter1 = balanceOf(other, id1);
    uint256 otherBalanceAfter2 = balanceOf(other, id2);
    uint256 otherBalanceAfter3 = balanceOf(other, id3);
    
    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 
                                && otherBalanceBefore2 == otherBalanceAfter2 
                                && otherBalanceBefore3 == otherBalanceAfter3)
                                , ""I like to see your money disappearing"";
}
","This rule verifies that when minting tokens in a batch, the balances of tokens for addresses other than the recipient should remain unchanged.",1
"rule cantBurnMoreSingle(env e){
    address from; uint256 id; uint256 amount;

    require to_mathint(balanceOf(from, id) - amount) < 0;
    burn@withrevert(e, from, id, amount);
    
    assert lastReverted, ""Don't be too greedy!"";
}
",This rule needs to verify that a user cannot burn more of a specific token than they own in their balance.,1
"rule cantBurnMoreBatch(env e){
    address from;
    uint256 id1; uint256 id2; uint256 id3; 
    uint256 amount1; uint256 amount2; uint256 amount3;
    uint256[] ids; uint256[] amounts;

    require ids.length == 3; 
    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;
    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;
    require to_mathint(balanceOf(from, id1) - amount1) < 0 
                || to_mathint(balanceOf(from, id2) - amount2) < 0 
                || to_mathint(balanceOf(from, id3) - amount3) < 0 ;
    burnBatch@withrevert(e, from, ids, amounts);
    
    assert lastReverted, ""Don't be too greedy!"";
}
",This rule needs to be verified to ensure that a user cannot burn more tokens of multiple IDs than they own in a batch transaction.,1
"rule burnCorrectWork(env e){
    address from; uint256 id; uint256 amount;

    uint256 otherBalanceBefore = balanceOf(from, id);
    burn(e, from, id, amount);
    uint256 otherBalanceAfter = balanceOf(from, id);
    
    assert otherBalanceBefore == otherBalanceAfter + amount, ""Something is wrong"";
}
",This rule verifies that burning a certain amount of a specific token decreases the balance of the token holder accordingly.,1
"rule cantMintMoreSingle(env e){
    address to; uint256 id; uint256 amount; bytes data;

    require to_mathint(balanceOf(to, id) + amount) > max_uint256;
    mint@withrevert(e, to, id, amount, data);
    
    assert lastReverted, ""Don't be too greedy!"";
}
",This rule needs to verify that the total amount of a specific token held by an address does not exceed the maximum allowed value.,1
"rule transferCorrectness(env e){
    address from; address to; uint256 id; uint256 amount; bytes data;

    require to != from;
    uint256 fromBalanceBefore = balanceOf(from, id);
    uint256 toBalanceBefore = balanceOf(to, id);
    safeTransferFrom(e, from, to, id, amount, data);
    uint256 fromBalanceAfter = balanceOf(from, id);
    uint256 toBalanceAfter = balanceOf(to, id);
    assert fromBalanceBefore == fromBalanceAfter + amount, ""Something wet wrong"";
    assert toBalanceBefore == toBalanceAfter - amount, ""Something wet wrong"";
}
",This rule needs to verify that transferring tokens between two addresses results in the correct balance adjustments for both addresses.,1
"rule unexpectedBalanceChange(method f, env e) 
    filtered { f -> f.selector != safeTransferFrom(address, address, uint256, uint256, bytes).selector
                        && f.selector != safeBatchTransferFrom(address, address, uint256[], uint256[], bytes).selector 
                        && f.selector != mint(address, uint256, uint256, bytes).selector 
                        && f.selector != mintBatch(address, uint256[], uint256[], bytes).selector  
                        && f.selector != burn(address, uint256, uint256).selector 
                        && f.selector != burnBatch(address, uint256[], uint256[]).selector } {
",This rule verifies that unexpected balance changes are prevented for certain specific functions.,5
"rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {
    storage beforeTransfer = lastStorage;
    env e;

    address holder; address recipient;
    uint256 token; uint256 transferAmount; bytes data;
    uint256[] tokens; uint256[] transferAmounts;
    mathint holderStartingBalance = balanceOf(holder, token);
    mathint recipientStartingBalance = balanceOf(recipient, token);
    require tokens.length == 1; require transferAmounts.length == 1;
    require tokens[0] == token; require transferAmounts[0] == transferAmount;
    // transferring via safeTransferFrom
    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;
    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    // transferring via safeBatchTransferFrom
    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;
    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);
    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;
    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange
        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, 
        ""Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent"";
}   
",This rule verifies that transferring a single token between two addresses using either safeTransferFrom or safeBatchTransferFrom results in equivalent changes in balances for the token holder and recipient.,1
"rule updateDepositParametersSetsProperly(
    uint16 currencyId,
    uint32[] _depositShares,
    uint32[] _leverageThresholds
) {
    env e;
    require getMaxMarketIndex() <= MAX_MARKET_INDEX();
    require _depositShares.length == getMaxMarketIndex();
    require _depositShares.length == _leverageThresholds.length;
    updateDepositParameters(currencyId, _depositShares, _leverageThresholds);
    // TODO: move the checking into solidity and return a bool on success.
    int256[] depositShares, int256[] leverageThresholds = getDepositParameters(currencyId)
}
",This rule needs to verify that the provided deposit shares and leverage thresholds are set properly for a specific currency by updating the deposit parameters.,0
"// rule updateInitializationParametersSetsProperly;

rule updateIncentiveEmissionRateSetsProperly(
    uint16 currencyId,
    uint32 newEmissionRate,
    address nTokenAddress
) {
    env e;
    require nTokenAddress(currencyId) == nTokenAddress;
    updateIncentiveEmissionRate(currencyId, newEmissionRate);
    _, uint256 incentiveEmissionRate = getNTokenAccount(nTokenAddress);
    assert incentiveEmissionRate == newEmissionRate;
}
","This rule verifies that when updating the emission rate for a specific currency, the new emission rate is set properly in the corresponding nToken account.",3
"rule cashGroupGetterSetters(
    uint256 currencyId,
    uint8 maxMarketIndex,
    uint8 rateOracleTimeWindowMin,
    uint8 totalFeeBPS,
    uint8 reserveFeeShare,
    uint8 debtBuffer5BPS,
    uint8 fCashHaircut5BPS,
    uint8 settlementPenaltyRate5BPS,
    uint8 liquidationfCashHaircut5BPS,
    uint8 liquidationDebtBuffer5BPS,
    uint8[] liquidityTokenHaircuts,
    uint8[] rateScalars,
    uint256 assetType
) {
    env e;
    require MIN_CURRENCY_ID() <= currencyId && currencyId <= MAX_CURRENCY_ID();
    require MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX();
    require MIN_MARKET_INDEX() + 1 <= assetType && assetType <= marketIndex + 1;

    setCashGroupStorage(
        e,
        currencyId,
        maxMarketIndex,
        rateOracleTimeWindowMin,
        totalFeeBPS,
        reserveFeeShare,
        debtBuffer5BPS,
        fCashHaircut5BPS,
        settlementPenaltyRate5BPS,
        liquidationfCashHaircut5BPS,
        liquidationDebtBuffer5BPS,
        liquidityTokenHaircuts,
        rateScalars
    );
    assert maxMarketIndex == getMaxMarketIndex(currencyId), ""max market index does not match"";
    assert rateOracleTimeWindowMin * 60 == getRateOracleTimeWindow(currencyId), ""rate oracle not returned in seconds"";
    assert totalFeeBPS * BASIS_POINTS() == getTotalFee(currencyId), ""total fee does not match""
    assert reserveFeeShare == getReserveFeeShare(currencyId), ""reserve fee share does not match""
    assert debtBuffer5BPS * 5 * BASIS_POINTS() == getDebtBuffer(currencyId), ""debt buffer does not match""
    assert fCashHaircut5BPS * 5 * BASIS_POINTS() == getfCashHaircut(currencyId), ""fCash haircut does not match""
    assert settlementPenaltyRate5BPS * 5 * BASIS_POINTS() == getSettlementPenalty(currencyId), ""settlement penalty does not match""
    assert liquidationfCashHaircut5BPS * 5 * BASIS_POINTS() == getLiquidationfCashHaircut(currencyId), ""liquidation fcash haircut does not match""
    assert liquidationDebtBuffer5BPS * 5 * BASIS_POINTS() == getLiquidationDebtBuffer(currencyId), ""liquidation debt buffer does not match""
    assert liquidityTokenHaircuts[assetType - 1] == getLiquidityHaircut(currencyId, assetType), ""liquidity token haircut does not match"";
    // rate scalars, todo, what do we want to test here?
}
",This rule verifies that the parameters set in the cash group getter and setter functions match the expected values for a given currency id and asset type within the specified ranges and calculations.,0
"invariant portfolioIsAlwaysSorted (address account)
    // Get portfolio from harness and test if assets are sorted, do this
    // inside a harness
    checkPortfolioSorted(account)

// TODO: below here I'm not sure how we actually do this
// Set up a portfolio such that every asset's value is equal to 1e8 and then assert
rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02
    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
",This rule/invariant needs to be verified to ensure that the net cash group value accurately reflects the value of all assets in a portfolio where each asset has a value of 1e8 and follows specific conversion rate requirements.,0
"rule netCashGroupValueAccountsForAllAssets(
    address account,
    uint256 portfolioIndex
) {
    env e;
    // TODO: need to make these asumptions in the code
    // require getLiquidityTokenValue == 1
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;
    // require assetRate == 0.02

    uint256 currencyId = getPortfolioCurrencyIdAtIndex(account, portfolioIndex);
    // Ensure that the portfolio index starts at a border between assets
    require portfolioIndex == 0 || getPortfolioCurrencyIdAtIndex(account, portfolioIndex - 1) != currencyId;
    int assetPV;
    uint newIndex;
    
    assetPV, newIndex = getNetCashGroupValue(account, portfolioIndex, e.block.timestamp);
    assert portfolioIndex < newIndex;
    assert getPortfolioCurrencyIdAtIndex(account, newIndex) != currencyId;
    // Every asset should be valued at 1 and the asset cash to pv conversion rate should be 50:1
    // so therefore the assetPV should equal the number of assets multiplied by 50
    assert to_mathint(assetPV) == (newIndex - portfolioIndex) * 50;
}
",This rule verifies that the net cash value of assets in a portfolio is calculated correctly based on the number of assets and the conversion rate from asset cash to present value.,0
"rule riskAdjustedPresentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturity,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getRiskAdjustedPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);

    // PV cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","This rule needs to be verified to ensure that the risk-adjusted present value decreases for longer maturities compared to shorter maturities, maintaining consistent signs and ordering.",2
"rule ifCashNetPresentValueAccountsForAllAssets(address account) {
    env e;
    // TODO: need to make these asumptions in the code
    // require calculateOracleRate == 0;
    // require getRiskAdjustedPresentValue == 1;

    // If each asset is valued at 1 then the total value should be the number of assets
    int256 underlyingPV = getifCashNetPresentValue(account, e.block.timestamp, true);
    assert underlyingPV == getNumBitmapAssets(account);
}
",This rule verifies that the net present value of all assets owned by an account accurately reflects the total number of assets owned by the account.,0
"rule riskAdjustedPresentValueIsLessThanPresentValue(
    int256 notional,
    uint256 maturity,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 pv = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 riskAdjustedPV = getRiskAdjustedPresentValue(notional, maturity, e.block.timestamp, oracleRate);

    assert riskAdjustedPV <= pv;
}
","This rule needs to be verified to ensure that the risk-adjusted present value of an asset is less than or equal to its regular present value, indicating that the additional risk taken into account does not increase the overall value.",0
"rule riskAdjustedLiquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 tokenHaircut;
    tokenHaircut = getLiquidityHaircut(assetType);
    require tokenHaircut <= 100;
    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        true // risk adjusted
    );
    mathint netfCash = (totalfCash * tokens * tokenHaircut) / (100 * totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens * tokenHaircut) / (100 * totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getRiskAdjustedPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","This rule verifies that the risk-adjusted liquidity token value matches the claims based on the total fCash, asset cash, liquidity, maturity, liquidity haircut, and oracle rate.",0
"rule liquidityTokenValueMatchesClaims(int256 fCashNotional, uint256 tokens, uint256 assetType) {
    env e;
    uint256 totalfCash;
    uint256 totalAssetCash;
    uint256 totalLiquidity;
    uint256 maturity;
    totalfCash, totalAssetCash, totalLiquidity, maturity = getMarketValues();
    require (totalLiquidity >= tokens);

    uint256 oracleRate;
    oracleRate = calculateOracleRate(maturity, e.block.timestamp);
    int assetCashClaim;
    int pv;
    assetCashClaim, pv = getLiquidityTokenValue(
        fCashNotional,
        tokens,
        assetType,
        e.block.timestamp,
        false // non risk adjusted
    );
    mathint netfCash = (totalfCash * tokens) / (totalLiquidity) + to_mathint(fCashNotional);
    mathint assetCash = (totalAssetCash * tokens) / (totalLiquidity);
    // TODO: need to convert to int somehow
    // assert pv == getPresentValue(netfCash, maturity, e.block.timestamp, oracleRate);
    assert to_mathint(assetCashClaim) == assetCash;
}
","This rule verifies that the value of liquidity tokens matches the corresponding claims on fCash and asset cash, taking into account the market values and maturity period.",0
"invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )

// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","This rule needs to be verified to ensure that the present value of a shorter-dated asset is always lower than the present value of a longer-dated asset, based on the given formula and conditions.",0
"// rule oracleRatesAreBlendedIntoTheRateWindow will cover `getOracleRate`

// This should show that the oracle rate is the linear interpolation between two on chain rates.
invariant calculateOracleRateIsBetweenOnChainRates(
    uint256 currencyId,
    uint256 maturity,
    uint256 shortMarketIndex,
    uint256 longMarketIndex,
    uint256 blockTime
)
    isBetween(
        maturity,
        getMaturityAtMarketIndex(shortMarketIndex, blockTime),
        getMaturityAtMarketIndex(longMarketIndex, blockTime)
    ) => 
        calculateOracleRate(currencyId, maturity),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(shortMarketIndex, blockTime)),
        calculateOracleRate(currencyId, getMaturityAtMarketIndex(longMarketIndex, blockTime))
    )
// For any given asset and oracle rate, the absolute present value of a shorted dated asset will
// always be less than the absolute present value of a longer dated asset. The formula is:
// pv = notional * e ^ (-oracleRate * time)
rule presentValueDecreasesForLongerMaturities(
    int256 notional,
    uint256 maturityDelta,
    uint256 oracleRate
) {
    require notional != 0;
    env e;
    int256 shorterPV = getPresentValue(notional, maturity, e.block.timestamp, oracleRate);
    int256 longerPV = getPresentValue(notional, maturity + maturityDelta, e.block.timestamp, oracleRate);
    // Present value cannot change signs as a result of this calculation
    assert notional > 0 => shorterPV > 0 && longerPV > 0 && shorterPV <= longerPV;
    assert notional < 0 => shorterPV < 0 && longerPV < 0 && longerPV <= shorterPV;
}
","This rule/invariant needs to be verified to ensure that the oracle rate is calculated as a linear interpolation between two on-chain rates, and that the present value of a shorter-dated asset is always less than the present value of a longer-dated asset for any given asset and oracle rate.",0
"// The intent of a rule like this is to ensure that when we settle fCash or liquidity tokens
// we do the correct calculation to return the settlement balance. The settlement balance for fCash
// will simply be an asset cash amount based on the settlement rate. The settlement logic for liquidity
// tokens has two potential outcomes. We may want to have three separate rules for this.
// rule assetsConvertToCashAtSettlementRate(address account, uint256 currencyId) {
//     env e;
//     int256 cashBefore = getCashBalance(currencyId, account);
//     // This should get the amount of cash back, would we really be proving anything
//     // with this approach? It's quite circular if we need to write another harness...
//     int256 amountToSettle = getAmountToSettle(currencyId, account, e.block.timestamp);
//     settleAccount(e, account);
//     int256 cashAfter = getCashBalance(currencyId, account);
//     assert cashAfter - cashBefore == amountToSettle;
// }
",This rule needs to verify that the correct calculation is performed to return the settlement balance for fCash or liquidity tokens when settling.,5
"rule settleAssetsDeletesSettleableAssets(address account) {
    env e;
    settleAccount(e, account);
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}
","This rule needs to verify that after settling an account, there are no settleable assets remaining for that account at the current timestamp.",0
"rule settlingBitmapAssetsDoesNotLoseTrack(address account) {
    env e;
    // This is only true for bitmap currencies, it's mostly true for array portfolios but there
    // is an edge case where liquidity tokens net off against fCash exactly.
    require getBitmapCurrencyId(account) != 0;
    uint256 numAssets;
    uint256 numSettleAssets;
    numAssets = getNumAssets(account);
    numSettleAssets = getNumSettleableAssets(account, e.block.timestamp);

    settleAccount(e, account);
    assert getNumAssets(account) == numAssets - numSettleAssets;
    assert getNumSettleableAssets(account, e.block.timestamp) == 0;
}",This rule ensures that settling bitmap assets does not cause the account to lose track of its settled assets and that all settleable assets are correctly updated to zero after settlement.,0
"rule settlementRatesAreNeverReset(address account, uint256 currencyId, uint256 maturity) {
    env e;
    require maturity < e.block.timestamp;
    // TODO: need to specify that the asset that is being settled exists at the maturity provided here.
    int256 settlementRateBefore = getSettlementRate(currencyId, maturity);
    settleAccount(e, account);
    int256 settlementRateAfter = getSettlementRate(currencyId, maturity);

    // Settlement rates must always be set after settling accounts
    assert settlementRateAfter > 0;
    // If settlement rates were set before, then they must not change after
    assert settlementRateBefore == 0 => settlementRateBefore == settlementRateAfter;
}
","This rule ensures that settlement rates for a specific currency at a certain maturity are not reset after account settlements have occurred, and that settlement rates remain consistent before and after settlements.",2
"rule impliedRateSlippageDoesNotChangeWithTime(
    int256 fCashToAccount,
    uint256 timeDelta
) {
    env e;
    // Ensure that the block time is within the tradeable region
    require timeDelta <= QUARTER() && e.block.timestamp + timeDelta < MATURITY();
    require fCashToAccount != 0;
    uint256 timeToMaturity_first = MATURITY() - e.block.timestamp;
    uint256 timeToMaturity_second = MATURITY() - e.block.timestamp - timeDelta;
    require getRateScalar(timeToMaturity_first) > 0;
    require getRateScalar(timeToMaturity_second) > 0;

    storage initStorage = lastStorage;
    executeTrade(timeToMaturity_first, fCashToAccount);
    uint256 lastImpliedRate_first = getLastImpliedRate();
    executeTrade(timeToMaturity_second, fCashToAccount) at initStorage;
    uint256 lastImpliedRate_second = getLastImpliedRate();
    require lastImpliedRate_first < 1000000 && lastImpliedRate_second < 1000000;
    assert absDiff(lastImpliedRate_first, lastImpliedRate_second) < basisPoint(),
        ""Last implied rate slippage increases with time"";
}
","This rule checks whether the implied rate slippage remains constant over time when executing trades, ensuring that the rate does not change as the time to maturity decreases.",2
"invariant oracleRatesAreBlendedIntoTheRateWindow(env e)
    (e.block.timestamp - getPreviousTradeTime() > getRateOracleTimeWindow()) ?
        getMarketOracleRate() == getLastImpliedRate() :
        isBetween(
            getStoredOracleRate(e),
            getMarketOracleRate(),
            getLastImpliedRate()
        )

rule oracleRatesBlandedIntoRateWindow(method f){
env e;
uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
","This rule checks if the oracle rates are correctly blended into the rate window based on the market oracle rate, last implied rate, and stored oracle rate within a specified time window.",2
"rule testAssetCash(int256 fCashToAccount, uint256 timeToMaturity){
    // require timeToMaturity <= 2^255-1;
    // require timeToMaturity > 0;
    // require fCashToAccount != 0;
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    assetCashToAccount, assetCashToReserve = executeTrade(timeToMaturity, fCashToAccount);
    // require (assetCashToReserve > 0, ""asset cash to reserve cannot be negative"");
    int256 marketAssetCashAfter = getMarketAssetCash();
    assert marketAssetCashAfter > marketAssetCashBefore;
}
","This rule ensures that the asset cash balance increases after executing a trade, with a portion allocated to the account and the remainder to the reserve.",0
"rule impliedRatesDoNotChangeOnAddLiquidity(
    int256 cashAmount
) {
    env e;
    require cashAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    int256 liquidityTokens;
    int256 fCashToAccount;
    liquidityTokens, fCashToAccount = addLiquidity(e, cashAmount);
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
   assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    // assert getLastImpliedRate() == lastImpliedRate, ""last trade rate did update"";
    // assert to_mathint(marketAssetCashBefore) + to_mathint(cashAmount) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    // assert to_mathint(liquidityTokens) + to_mathint(marketLiquidityBefore) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    // assert getPreviousTradeTime() == previousTradeTime, ""previous trade time did update "";
}
",This rule needs to verify that the rates do not change when adding liquidity to the market.,0
"rule impliedRatesDoNotChangeOnRemoveLiquidity(
    int256 tokenAmount
) {
    env e;
    require tokenAmount > 0;
    uint256 previousTradeTime = getPreviousTradeTime();
    uint256 oracleRate = getStoredOracleRate(e);
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 marketLiquidityBefore = getMarketLiquidity();
    require marketfCashBefore >= 0 && marketfCashBefore <= to_int256(2^80 - 1);
    require marketAssetCashBefore >= 0 && marketAssetCashBefore <= to_int256(2^80 - 1);
    require marketLiquidityBefore >= 0 && marketLiquidityBefore <= to_int256(2^80 - 1);
    require previousTradeTime >= 0 && previousTradeTime <= 2^32 - 1;
    require lastImpliedRate >= 0 && lastImpliedRate <= 2^32 - 1;
    require oracleRate >= 0 && oracleRate <= 2^32 - 1;

    require marketLiquidityBefore >= tokenAmount;
    int256 assetCash;
    int256 fCashToAccount;
    assetCash, fCashToAccount = removeLiquidity(e, tokenAmount);
    require fCashToAccount != 0;
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    int256 marketLiquidityAfter = getMarketLiquidity();
    uint256 previousTradeTimeAfter = getPreviousTradeTime();
    uint256 lastImpliedRateAfter = getLastImpliedRate();
    assert to_mathint(marketAssetCashBefore) - to_mathint(assetCash) == to_mathint(marketAssetCashAfter), ""market asset cash imbalance"";
    assert to_mathint(marketfCashBefore) - to_mathint(fCashToAccount) == to_mathint(marketfCashAfter), ""fCash imbalance"";
    assert to_mathint(marketLiquidityBefore) - to_mathint(tokenAmount) == to_mathint(marketLiquidityAfter), ""liquidity token imbalance"";
    assert previousTradeTimeAfter == previousTradeTime, ""previous trade time did update"";
    assert lastImpliedRateAfter == lastImpliedRate, ""last trade rate did update"";
}
","This rule ensures that the implied rates do not change when liquidity is removed from the market, maintaining the integrity of the market's pricing mechanism.",2
"rule executeTradeMovesImpliedRates(
    int256 fCashToAccount,
    uint256 timeToMaturity
) {
    env e;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    uint256 lastImpliedRate = getLastImpliedRate();
    int256 marketfCashBefore = getMarketfCash();
    int256 marketAssetCashBefore = getMarketAssetCash();
    int256 assetCashToAccount;
    int256 assetCashToReserve;

    assetCashToAccount, assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require assetCashToAccount != 0 && assetCashToReserve != 0;
    require (fCashToAccount < 0 => lastImpliedRate > getLastImpliedRate(),""last trade rate did not move in correct direction"");
    
    // assert fCashToAccount > 0 ? 
    //     // When fCashToAccount > 0 then lending, implied rates should decrease
    //     lastImpliedRate > getLastImpliedRate() :
    //     // When fCashToAccount < 0 then borrowing, implied rates should increase
    //     lastImpliedRate < getLastImpliedRate(),
    //     ""last trade rate did not move in correct direction"";
    require (fCashToAccount > 0 ? assetCashToAccount < 0 : assetCashToAccount > 0, ""incorrect asset cash for fCash"");
    int256 marketfCashAfter = getMarketfCash();
    int256 marketAssetCashAfter = getMarketAssetCash();
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
    require (getPreviousTradeTime() < e.block.timestamp, ""previous trade time did not update"");
    // assert  to_mathint(marketfCashBefore) ==  to_mathint(fCashToAccount) + to_mathint(marketfCashAfter), ""Market fCash does not net out"";
   
    // require marketfCashBefore < 1000 &&
    //         marketAssetCashBefore < 1000 &&
    //         assetCashToAccount < 1000 &&
    //         assetCashToReserve < 1000 &&
    //         marketfCashAfter < 1000 &&
    //         marketAssetCashAfter < 1000;
            
    // Jeff's NEW VERSION assert getMarketAssetCash() == marketAssetCashBefore - assetCashToAccount - assetCashToReserve;
    // int256 a_minus_b_minus_c = to_int256(marketAssetCashBefore - assetCashToAccount - assetCashToReserve);
    // int256 a_minus_b_minus_c = to_int256(to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve));
    // require a_minus_b_minus_c >= 0;
    // assert a_minus_b_minus_c == marketAssetCashAfter, //marketAssetCashBefore,
    //     ""Market asset cash does not net out"";
    assert to_mathint(marketAssetCashAfter) == to_mathint(marketAssetCashBefore) - to_mathint(assetCashToAccount) - to_mathint(assetCashToReserve), //marketAssetCashBefore,
        ""Market asset cash does not net out"";
}
","This rule is verifying that the implied rates move in the correct direction after executing trade moves, the asset cash amounts are correctly adjusted, and the market cash balances net out properly before and after the trade.",0
"rule oracleRatesBlandedIntoRateWindow(method f){
env e;

uint marketOracleRate_1 = getMarketOracleRate();
uint lastImpliedRate_1 = getLastImpliedRate();
uint previousTradeTime_1 = getPreviousTradeTime();
uint rateOracleTimeWindow_1 = getRateOracleTimeWindow();
uint storedOracleRate_1 = getStoredOracleRate(e);
require e.block.timestamp > previousTradeTime_1;
// require (e.block.timestamp - previousTradeTime_1 > rateOracleTimeWindow_1 =>
        // marketOracleRate_1 == lastImpliedRate_1, ""require 1_"");
// require (e.block.timestamp - previousTradeTime_1 <= rateOracleTimeWindow_1 =>
        // isBetween(storedOracleRate_1,marketOracleRate_1,lastImpliedRate_1), ""require 2_"");
// calldataarg args;
// f(e,args);
    int256 fCashToAccount;
    uint256 timeToMaturity;
    int256 assetCashToAccount;
    int256 assetCashToReserve;
    require fCashToAccount != 0;
    require getRateScalar(timeToMaturity) > 0;
    assetCashToAccount,assetCashToReserve = executeTrade( timeToMaturity, fCashToAccount);
    require (assetCashToReserve >= 0, ""asset cash to reserve cannot be negative"");
uint marketOracleRate_2 = getMarketOracleRate();
uint lastImpliedRate_2 = getLastImpliedRate();
uint previousTradeTime_2 = getPreviousTradeTime();
uint rateOracleTimeWindow_2 = getRateOracleTimeWindow();
uint storedOracleRate_2 = getStoredOracleRate(e);
require (fCashToAccount < 0 => lastImpliedRate_1 > lastImpliedRate_2,""last trade rate did not move in correct direction"");
// require 
//         lastImpliedRate_1 > 0 && lastImpliedRate_2 > 0 &&
//         marketOracleRate_1 > 0 && marketOracleRate_2 > 0 &&
//         previousTradeTime_1 > 0 && previousTradeTime_2 > 0 &&
//         rateOracleTimeWindow_1 > 0 && rateOracleTimeWindow_2 > 0 &&
//         storedOracleRate_1 > 0 && storedOracleRate_2 > 0;
require (e.block.timestamp > previousTradeTime_2, ""previous trade time did not update"");
require lastImpliedRate_2 != 0;
assert (e.block.timestamp - previousTradeTime_2 > rateOracleTimeWindow_2 =>
        marketOracleRate_2 == lastImpliedRate_2, ""assert 1_"");
// assert (e.block.timestamp - previousTradeTime_2 <= rateOracleTimeWindow_2 =>
        // isBetween(storedOracleRate_2,marketOracleRate_2,lastImpliedRate_2), ""assert 2_"");
}
",This rule verifies that the market oracle rates are blended into the rate window properly and that the last trade rate moves in the correct direction. It also ensures that the previous trade time is updated and that the asset cash to reserve cannot be negative.,0
"rule bitNumAndMaturitiesMustMatch(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    uint256 bitNum;
    bool isExact;
    bitNum, isExact = getBitNumFromMaturity(blockTime, maturity);
    uint256 calculatedMaturity = getMaturityFromBitNum(blockTime, bitNum);

    // If the bitnum is not exact then the calculated maturity will not match
    assert isExact => maturity == calculatedMaturity, ""maturity does not match calculated maturity"";
}
",This rule ensures that the bit number and maturities must match in order to maintain consistency between the values calculated based on the block time and maturity parameters.,2
"rule validMarketMaturitesHaveAnIndex(
    uint256 maxMarketIndex,
    uint256 maturity,
    uint256 blockTime
) {
    // Respect time boundaries
    uint256 marketIndex;
    bool isIdiosyncratic;
    marketIndex, isIdiosyncratic = getMarketIndex(maxMarketIndex, maturity, blockTime);
    bool isValidMarket = isValidMarketMaturity(maxMarketIndex, maturity, blockTime);

    // If a market is a valid market maturity then the getMarketIndex should agree
    assert isValidMarket <=> !isIdiosyncratic, ""is valid market does not imply a market index"";
    assert MIN_MARKET_INDEX() <= marketIndex && marketIndex <= MAX_MARKET_INDEX(), ""market index out of boundaries"";
}",This rule needs to verify that valid market maturities correspond to a market index within specified boundaries.,2
"rule bitNumValidMaturitiesMustBeExact(
    uint256 blockTime,
    uint256 maturity
) {
    // Respect time boundaries
    require MIN_TIMESTAMP() <= blockTime && blockTime <= MAX_TIMESTAMP();
    require MIN_TIMESTAMP() <= maturity && maturity <= MAX_TIMESTAMP();
    require isValidMaturity(MAX_MARKET_INDEX(), maturity, blockTime);
    bool isExact;
    _, isExact = getBitNumFromMaturity(blockTime, maturity);

    // BitNums go out a bit past the max 20 year maturity, those bits are not valid
    assert isExact && maturity <= MAX_MARKET_MATURITY(blockTime), ""bitnum is valid does not match is valid maturity"";
}
",This rule ensures that the maturity provided is within valid time boundaries and matches a valid maturity based on the given block time. It also verifies that the bit number derived from the maturity is exact and within the allowed range.,2
"rule noChangeToOther(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    address accountOther;
    require accountOther != account;
    require account != 0 && accountOther != 0;
    uint40 nextSettleTimeOther = getNextSettleTime(accountOther);
    uint8 hasDebtOther = getHasDebt(accountOther);
    uint8 assetArrayLengthOther = getAssetArrayLength(accountOther);
    uint16 bitmapCurrencyIdOther = getBitmapCurrency(accountOther);
    uint144 activeCurrenciesOther = getActiveCurrencies(accountOther);
        
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    
    assert getNextSettleTime(accountOther) == nextSettleTimeOther, ""next settle time does not match"";
    assert getHasDebt(accountOther) == hasDebtOther, ""has debt does not match"";
    assert getAssetArrayLength(accountOther) == assetArrayLengthOther, ""asset array length does not match"";
    assert getBitmapCurrency(accountOther) == bitmapCurrencyIdOther, ""bitmap currency id does not match"";
    assert getActiveCurrencies(accountOther) == activeCurrenciesOther, ""active currencies does not match"";
}
",This rule verifies that the account context attributes of another address remain unchanged when compared to the current account's attributes.,2
"rule getAndSetAccountContext(
    address account,
    uint40 nextSettleTime,
    uint8 hasDebt,
    uint8 assetArrayLength,
    uint16 bitmapCurrencyId,
    uint144 activeCurrencies
) {
    env e;
    setAccountContext(e, account, nextSettleTime, hasDebt, assetArrayLength, bitmapCurrencyId, activeCurrencies);
    assert getNextSettleTime(account) == nextSettleTime, ""next settle time does not match"";
    assert getHasDebt(account) == hasDebt, ""has debt does not match"";
    assert getAssetArrayLength(account) == assetArrayLength, ""asset array length does not match"";
    assert getBitmapCurrency(account) == bitmapCurrencyId, ""bitmap currency id does not match"";
    assert getActiveCurrencies(account) == activeCurrencies, ""active currencies does not match"";
}
",This rule verifies that the account context values set for a specific account match the expected values.,2
"rule depositsMustIncreaseCashBalance(address account, uint256 depositAmount) {
    env e;
    int256 cashBalance = getCashBalance(account);
    deposit(e, account, depositAmount);
    // check balanceOf ERC20 on account and contract

    assert cashBalance + depositAmount == getCashBalance(account);
}
",This rule needs to be verified to ensure that a deposit increases the cash balance of an account by the deposited amount.,5
"rule withdrawsMustDecreaseCashBalance {
    env e;
    int256 cashBalance = getCashBalance(account);

}
",This rule needs to verify that withdrawing funds reduces the cash balance in the account.,5
"rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
",This rule/invariant needs to be verified to ensure that withdrawals are additive and do not result in unexpected changes to the total assets of an operator.,5
"rule assetsLessThanEverDepositedAsRule(address operator, method f, mathint t, address holder, uint256 referenceID ) {
    env e;
    calldataarg args;
    require t == totalLockedBonds(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require totalLockedBonds(operator) >= bondAmount(operator, e.msg.sender, referenceID);
    require safeAdd(unbondedValue(operator), totalLockedBonds(operator));
    require everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
    require f.selector==init_state().selector => totalLockedBonds(operator)==0;
    uint256 before = bondAmount(operator, e.msg.sender, referenceID);
    f(e, args);
    require (f.selector==freeBond(address,uint256).selector                             ||
             f.selector==seizeBond(address,uint256,uint256,address).selector            ||
             f.selector==createBond(address,address,uint256,uint256,address).selector   ||
             f.selector==reassignBond(address, uint256, address, uint256).selector )    =>
             before != bondAmount(operator, e.msg.sender, referenceID);
    assert safeAdd(unbondedValue(operator), totalLockedBonds(operator)) &&
            everDeposited(operator) >= unbondedValue(operator) + totalLockedBonds(operator);
   }
",This rule/invariant needs to be verified to ensure that the total assets locked by the operator are always less than or equal to the amount ever deposited by the holder.,5
"rule inverseOfDepositAndWithdraw(address operator, address owner, address beneficiary, uint256 x) {
    require (ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary);
    require (beneficiary != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 u = unbondedValue(operator);
    uint256 b = balanceOf(currentContract);
    // successful deposit
    env eDeposit;
    require eDeposit.msg.value == x;
    require (eDeposit.msg.sender != currentContract);
    deposit(eDeposit, operator);
    env eWithdraw;
    require eWithdraw.msg.sender == operator || eWithdraw.msg.sender == owner;
    require eWithdraw.msg.value == 0;
    require _hasDelegationLockPassed(eWithdraw, operator);
    require safeAdd(balanceOf(beneficiary), x);
    invoke withdraw(eWithdraw, x, operator);
    bool success = !lastReverted;
    // verify that succeeded and the the value is as expected
    assert success &&  u  == unbondedValue(operator) && b == balanceOf(currentContract);
","This rule verifies the additive property of withdrawals, ensuring that the total amount withdrawn is the same regardless of whether it is done separately or simultaneously.",3
"rule totalAssetsPreservedOnWithdraw(address operator, address owner, address beneficiary, uint256 amount) {
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
     env e;
     require beneficiaryOf(operator) == beneficiary;
     require beneficiary != currentContract;
     mathint totalAssets = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary);
     withdraw(e, amount, operator);
     assert totalAssets == totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(beneficiary),
     ""withdraw can change the total assets of an operator in an unexpected way"";
",This rule verifies that the total assets of an operator are preserved when a withdrawal is made by checking if the total assets before and after the withdrawal remain the same.,5
"rule validChangeToEverDeposited(address o,  method f) {
    env e;
    calldataarg args;
    uint256 before = everDeposited(o);
    f(e, args);
    uint256 after = everDeposited(o);
    assert after == before ||
           ( ( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
               f.selector==delegate(address, address, address).selector ) &&
               after == before + e.msg.value );
}
","This rule verifies that the amount ever deposited by an address remains unchanged after executing a specified function, except in cases where the function involves topping up or depositing funds.",5
"rule totalAssetsPreservedOnSeizeBond(address operator, address owner, uint256 referenceID,
rule totalAssetsPreserved(address operator, address owner, address beneficiary,  method f) {
    env e;
    calldataarg args;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    require f.selector != seizeBond(address,uint256,uint256,address).selector &&
             f.selector != withdraw(uint256,address).selector;
    f(e, args);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator);
    assert totalAssetsAfter == totalAssetsBefore ||  totalAssetsAfter == totalAssetsBefore + e.msg.value,
    ""$f can change the total assets of an operator in an unexpected way"";
            uint256 amount, address destination) {
    require destination == otherBeneficiary;
    mathint totalAssetsBefore = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    seizeBond(e, operator, referenceID, amount, destination);
    mathint totalAssetsAfter = totalLockedBonds(operator) + unbondedValue(operator) + balanceOf(destination);
    assert  totalAssetsBefore == totalAssetsAfter,
        ""seizeBond can change the total assets of operator in an unexpected way"";
","This rule needs to be verified to ensure that the total assets of an operator, including locked bonds, unbonded value, and balance of beneficiaries, remain preserved during a seizure or withdrawal process.",0
"invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )

/**
    @title Valid state of an operator 閴.
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 閴
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();
    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
            ( ownerOf(o) 閳 0 閳 beneficiaryOf(o) 閳 0 閳 authorizerOf(o) 閳 0 )
rule validState(address operator, uint unbonded, uint totalLocked) {
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","This rule/invariant needs to be verified to ensure that operators with assets have an owner, a beneficiary, and an authorizer, and that the withdraw function is additive for operators with assets.",5
"rule noFrontRunningOnWithdraw(address operator, address owner, address beneficiary, address otherOperator, uint256 x,
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
        method f) {
    env eF;
    calldataarg args;
    uint256 referenceID;
    require otherOperator != operator;
    require safeAdd(unbondedValue(operator), unbondedValue(otherOperator)) &&
            allUnbonded()  >= unbondedValue(operator) + unbondedValue(otherOperator);
    require safeAdd(totalLockedBonds(operator), totalLockedBonds(otherOperator)) &&
            allLockedBond()  >= totalLockedBonds(operator) + totalLockedBonds(otherOperator);
    require safeAdd(allUnbonded(), allLockedBond()) &&
            balanceOf(currentContract) >= allUnbonded() + allLockedBond();
    require totalLockedBonds(otherOperator) >= bondAmount(otherOperator, eF.msg.sender, referenceID);
    uint256 allUserAssets = allUnbonded() + allLockedBond();
    require safeAdd(balanceOf(currentContract), allUserAssets);
    uint256 allAssets = balanceOf(currentContract) + allUserAssets;
    require safeAdd(balanceOf(beneficiary), allAssets);
    storage init_storage = lastStorage;
    env eWithdraw;
    withdraw(eWithdraw, x, operator);
    bool succSceanrio1 = !lastReverted;
    // f should only change other operator and if changed totalLocked than the specific bondID used in the require
    uint256 u = unbondedValue(otherOperator) at init_storage;
    uint256 l = totalLockedBonds(otherOperator);
    uint256 bondBefore = bondAmount(otherOperator, eF.msg.sender, referenceID);
    f(eF, args);
    require u != unbondedValue(otherOperator) || l != totalLockedBonds(otherOperator);
    require f.selector==seizeBond(address,uint256,uint256,address).selector =>
                bondBefore != bondAmount(otherOperator, eF.msg.sender, referenceID);
    invoke withdraw(eWithdraw, x, operator);
    bool succSceanrio2 = !lastReverted;
    assert succSceanrio2;
",This rule/invariant needs to be verified to ensure that simultaneous withdraw operations do not result in front running and that the withdraw function is additive.,5
"rule validChangeToBalanceOf(address o, method f) {
    env e;
    calldataarg args;
    require (o != currentContract);
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 before = balanceOf(o);
    f(e, args);
    uint256 after = balanceOf(o);
    assert before == after ||
        // depositing case
        ( (f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           after == before - e.msg.value ) ||
        // withdrawing case
           ( ( f.selector==seizeBond(address,uint256,uint256,address).selector ||
                f.selector==withdraw(uint256,address).selector) &&
           after >= before );
","This rule needs to be verified to ensure that the balance of an address remains consistent after a method invocation, taking into account depositing and withdrawing scenarios.",5
"rule validChangeToTotalBondAmount(address o, method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 lockedBondsBefore = totalLockedBonds(o) ;
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 lockedBondsAfter = totalLockedBonds(o);
    assert lockedBondsBefore == lockedBondsAfter ||
           // case of unlocking
           ( (f.selector==freeBond(address,uint256).selector ||
              f.selector==seizeBond(address,uint256,uint256,address).selector ) &&
              lockedBondsAfter <= lockedBondsBefore )
           ||
           // case of locking
           ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
             lockedBondsAfter >= lockedBondsBefore && lockedBondsAfter <= lockedBondsBefore + unbondedBefore )
           ;
",This rule needs to be verified to ensure that the `withdraw` function is additive and that the total locked bonds and unbonded value are properly updated when a withdrawal operation is performed.,5
"rule validState(address operator, uint unbonded, uint totalLocked) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
     env e;
     require unbondedValue(operator) == unbonded;
     require totalLockedBonds(operator) == totalLocked;
     require safeAdd(unbonded, totalLocked);
     uint sum_before = unbonded + totalLocked;
     require safeAdd(sum_before, e.msg.value);
     require sum_before > 0 => beneficiaryOf(operator) != 0 ;
     require e.msg.sender != 0;
     require operator != 0;
     requireInvariant validOperator(operator);
invariant validOperator(address operator)
        beneficiaryOf(operator) != 0  <=>  ( operator != 0 && ownerOf(operator) != 0 && authorizerOf(operator) != 0 )
/**
    @title Valid state of an operator 閴.
    @notice Operators with assets must have an owner, a beneficiary, and an authorizer.
        (unbondedValue(o) + lockedBonds(o)) > 0 閴
            ( ownerOf(o) 閳 0 閳 beneficiaryOf(o) 閳 0 閳 authorizerOf(o) 閳 0 )
     method f;
     if (f.selector != seizeBond(address, uint256, uint256, address).selector) {
        calldataarg args;
        f(e, args);
     } else {
        address seizeAddress;
        uint refID;
        uint amount;
        address destination;
        uint256 before = bondAmount(operator, e.msg.sender, refID);
        require totalLocked >= before;
        seizeBond(e, seizeAddress, refID, amount, destination);
     }
     uint sum_after = unbondedValue(operator) + totalLockedBonds(operator);
     assert sum_after > 0 =>
                ( ownerOf(operator) != 0 && beneficiaryOf(operator) != 0 );
","This rule/invariant needs to be verified to ensure that operators with assets have a valid owner, beneficiary, and authorizer.",0
"invariant noBankruptcy()
    (allUnbonded() + allLockedBond()) <= balanceOf(currentContract) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    preserved deposit(env e, address operator) {
        require e.msg.sender != currentContract;
        require (allUnbonded() + allLockedBond()) <= balanceOf(currentContract);
    }
    preserved topUp(env e, address _) {
    preserved delegate(env e, address _1 ,address _2, address _3) {
",This rule needs to be verified to ensure that the protocol maintains solvency by not allowing the total amount of unbonded and locked bond tokens to exceed the balance held by the current contract.,5
"rule validChangeToUnbondedValue(address o, address owner,  method f) {
    simultaneously. The correctness of this rule on all inputs increases the confidence that the protocol is less
    fragile, e.g., to rounding errors.
*/
rule additiveWithdraw(address operator, address owner, address beneficiary, uint256 x, uint y) {
    env e;
    require ownerOf(operator) == owner && beneficiaryOf(operator) == beneficiary;
    require beneficiary != currentContract;
    require x + y < MAXINT();
    require balanceOf(beneficiary) + x + y <= MAXINT();

    storage init_storage = lastStorage; // store the current state
    invoke withdraw(e, x, operator);
    bool successX = !lastReverted;
    invoke withdraw(e, y, operator);
    bool successY = !lastReverted;
    uint256 uScenario1 = unbondedValue(operator);
    uint256 bScenario1 = balanceOf(beneficiary);
    invoke withdraw(e, x + y, operator) at init_storage; // back to the initial state
    bool successXY = !lastReverted;
    uint256 uScenario2 = unbondedValue(operator);
    uint256 bScenario2 = balanceOf(beneficiary);
    assert (successX && successY) <=> successXY, ""withdraw is not additive"";
    assert successXY => (uScenario1 == uScenario2 && bScenario1 == bScenario2),
        ""withdraw is not additive"";
}
    uint256 unbondedBefore = unbondedValue(o);
    calldataarg args;
    f(e, args);
    uint256 unbondedAfter = unbondedValue(o);
    assert  unbondedAfter  == unbondedBefore ||
        //cases for deposit
        (( f.selector==topUp(address).selector || f.selector==deposit(address).selector ||
           f.selector==delegate(address, address, address).selector  ) &&
           unbondedAfter == unbondedBefore + e.msg.value ) ||
        //cases for withdraw
        ( f.selector==withdraw(uint256,address).selector && (e.msg.sender==o || e.msg.sender == ownerOf(o)) &&
          unbondedAfter <= unbondedBefore) ||
        // cases for holder free
        ( f.selector==freeBond(address,uint256).selector &&  unbondedAfter >= unbondedBefore ) ||
        // case for holder locking
        ( f.selector==createBond(address,address,uint256,uint256,address).selector &&
           unbondedAfter <= unbondedBefore );
","This rule needs to be verified to ensure that changes to the unbonded value of an address are valid and additive under different scenarios, including deposits, withdrawals, free bonding, and locking.",5
"use rule disallowedFunctionalities

/**
* @title proves that a user's discount rate can be updated only by calling rebalanceUserDiscountPercent
* This rule fails since updateDiscountDistribution, mint and burn can recalculate and update the user discount rate
**/
// rule onlyRebalanceCanUpdateUserDiscountRate(method f) {
// 	address user;
// 	uint256 discRateBefore = getUserDiscountRate(user);
// 	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	env e;
// 	calldataarg args;
// 	f(e,args);
// 	uint256 discRateAfter = getUserDiscountRate(user);
// 	assert(discRateAfter != discRateBefore => f.selector == rebalanceUserDiscountPercent(address).selector);
// }
",This rule verifies that the user's discount rate can only be updated by calling a specific function and that other functions cannot recalculate and update the discount rate.,3
"rule onlyCertainFunctionsCanModifyScaledBalance(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = scaledBalanceOf(user);
	uint256 balanceAfterOp = scaledBalanceOf(user);
	assert(balanceAfterOp != balanceBeforeOp => (
		(f.selector == mint(address ,address ,uint256 ,uint256).selector) ||
		(f.selector == burn(address ,uint256 ,uint256).selector) ||
		(f.selector == updateDiscountDistribution(address ,address ,uint256 ,uint256 ,uint256).selector) ||
		(f.selector == rebalanceUserDiscountPercent(address).selector)));
","This rule needs to be verified to ensure that only certain functions are allowed to modify the scaled balance of a user, and that a call to a non-mint operation won't increase the user's balance of the actual debt tokens.",5
"invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
",This rule verifies that a discount for a user cannot exceed 100% and that a call to a non-mint operation will not increase the user's balance of debt tokens.,3
"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	env e = envAtTimestamp(ts2);
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
}
/**
* @title proves that a user can't decrease the ovelall interest of his position by taking more loans, compared to another user with the same initial position.
* This rule times out.
**/
// rule integrityOfMint_cantDecreaseInterestWithMint() {
// 	address user1;
// 	uint256 ts1;
// 	env e1 = envAtTimestamp(ts1);
// 	uint256 ts2;
// 	require(ts2 >= ts1);
// 	env e2 = envAtTimestamp(ts2);
// 	uint256 ts3;
// 	require(ts3 >= ts2);
// 	env e3 = envAtTimestamp(ts3);
// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));
// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
",This rule/invariant needs to be verified to ensure that a user cannot decrease the overall interest of their position by taking more loans compared to another user with the same initial position.,3
"rule integrityOfRebalanceUserDiscountPercent_updateIndex() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	assert(getUserCurrentIndex(user) == index);
",This rule/invariant needs to be verified to ensure that the discount rate for a user does not exceed 100%.,0
"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));

	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
/***************************************************************
* Integrity of Mint
***************************************************************/
* @title proves that after calling mint, the user's discount rate is up to date
rule integrityOfMint_updateDiscountRate() {
	address user1;
	address user2;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	mint(e, user1, user2, amount, index);
	uint256 debtBalance = balanceOf(e, user2);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user2);
	uint256 discountRate = getUserDiscountRate(user2);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
","This rule/invariant needs to be verified to ensure that after calling the mint function, the user's discount rate is updated correctly based on the current debt and discount token balances.",5
"rule integrityOfBalanceOf_fullDiscount() {
	address user;
	uint256 fullDiscountRate = 10000; //100%
	require(getUserDiscountRate(user) == fullDiscountRate);
	env e1;
	env e2;
	uint256 index1 = indexAtTimestamp(e1.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 index2 = indexAtTimestamp(e2.block.timestamp);
	assert(balanceOf(e1, user) == balanceOf(e2, user));
",This rule verifies that the full discount rate is applied correctly to the balance of the user and does not exceed 100%. It also ensures that a non-mint operation does not increase the user's balance of debt tokens and that the user's balance remains the same across different timestamps.,5
"// 	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
// 	require((indexAtTimestamp(ts1) >= ray()) && 
// 			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)) &&
// 			(indexAtTimestamp(ts3) >= indexAtTimestamp(ts2)));

// 	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
// 	uint256 amount;
// 	storage initialStorage = lastStorage;
// 	mint(e2, user1, user1, amount, indexAtTimestamp(ts2));
// 	rebalanceUserDiscountPercent(e3, user1);
// 	uint256 balanceFromInterestAfterMint = getBalanceFromInterest(user1);
// 	rebalanceUserDiscountPercent(e3, user1) at initialStorage;
// 	uint256 balanceFromInterestWithoutMint = getBalanceFromInterest(user1);
// 	assert(balanceFromInterestAfterMint >= balanceFromInterestWithoutMint);
// }
//pass
use rule integrityMint_atoken
/***************************************************************
* Integrity of Burn
***************************************************************/
/**
* @title proves that after calling burn, the user's discount rate is up to date
**/
rule integrityOfBurn_updateDiscountRate() {
	address user;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	burn(e, user, amount, index);
	uint256 debtBalance = balanceOf(e, user);
	uint256 discountBalance = getBalanceOfDiscountToken(e, user);
	uint256 discountRate = getUserDiscountRate(user);
	assert(discStrategy.calculateDiscountRate(debtBalance, discountBalance) == discountRate);
}
","This rule verifies that after a user burns tokens, their discount rate is updated correctly based on their debt balance and discount token balance.",1
"// rule integrityOfUpdateDiscountDistribution_discountRate() {
// 	address sender;
//     address recipient;
//     uint256 senderDiscountTokenBalanceBefore;
//     uint256 recipientDiscountTokenBalanceBefore;
//     uint256 amount;
// 	uint256 senderDiscountTokenBalanceAfter = senderDiscountTokenBalanceBefore - amount;
//     uint256 recipientDiscountTokenBalanceAfter = recipientDiscountTokenBalanceBefore + amount;
// 	env e0;
// 	env e;
// 	require(e.block.timestamp > e0.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
// 	require(indexAtTimestamp(e.block.timestamp) >= indexAtTimestamp(e0.block.timestamp));
// 	require(indexAtTimestamp(e0.block.timestamp) == ray()); // reduces execution time
// 	require(getUserCurrentIndex(sender) == indexAtTimestamp(e0.block.timestamp));
// 	require(getUserCurrentIndex(recipient) == indexAtTimestamp(e0.block.timestamp));
// 	require(getBalanceOfDiscountToken(e0, sender) == senderDiscountTokenBalanceBefore);
// 	require(getBalanceOfDiscountToken(e0, recipient) == recipientDiscountTokenBalanceBefore);
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, sender), senderDiscountTokenBalanceBefore) == getUserDiscountRate(sender));
// 	require(discStrategy.calculateDiscountRate(balanceOf(e0, recipient), recipientDiscountTokenBalanceBefore) == getUserDiscountRate(recipient));
	
// 	require(getBalanceOfDiscountToken(e, sender) == senderDiscountTokenBalanceAfter);
// 	require(getBalanceOfDiscountToken(e, recipient) == recipientDiscountTokenBalanceAfter);
// 	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalanceBefore, recipientDiscountTokenBalanceBefore, amount);
// 	uint256 senderBalance = balanceOf(e, sender);
// 	uint256 recipientBalance = balanceOf(e, recipient);
// 	assert(discStrategy.calculateDiscountRate(senderBalance, senderDiscountTokenBalanceAfter) == getUserDiscountRate(sender));
// 	assert(discStrategy.calculateDiscountRate(recipientBalance, recipientDiscountTokenBalanceAfter) == getUserDiscountRate(recipient));
// }
","This rule verifies the integrity of updating the distribution of discount tokens between sender and recipient addresses, ensuring that the sender's balance decreases by the specified amount and the recipient's balance increases by the same amount, while also checking that the discount rate does not exceed 100%.",1
"rule integrityOfBurn_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	burn(e, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore - scaledAmount);
","This rule/integrity needs to be verified to ensure that burning tokens does not result in an increase in the user's scaled balance of debt tokens, and that the discount rate does not exceed 100%.",1
"rule integrityOfUpdateDiscountDistribution_updateIndex() {
	address sender;
	address recipient;
	uint256 senderDiscountTokenBalance;
    uint256 recipientDiscountTokenBalance;
	env e;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	assert(scaledBalanceOf(sender) > 0 => getUserCurrentIndex(sender) == index);
	assert(scaledBalanceOf(recipient) > 0 => getUserCurrentIndex(recipient) == index);
",This rule/invariant needs to be verified to ensure that the update of discount distribution between sender and recipient does not exceed 100% discount and that a call to a non-mint operation does not increase the user's balance of the actual debt tokens.,5
"rule integrityOfBalanceOf_noDiscount() {
	address user;
	require(getUserDiscountRate(user) == 0);
	env e;
	uint256 scaledBalance = scaledBalanceOf(user);
	uint256 currentIndex = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 expectedBalance = rayMulCVL(scaledBalance, currentIndex);
	assert(balanceOf(e, user) == expectedBalance);
","This rule verifies that the balance of a user's scaled tokens remains unchanged when no discount is applied, ensuring the integrity of the balance calculation.",5
"rule onlyMintForUserCanIncreaseUsersBalance() {
	address user1;
	address user2;
	address user3;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	
	require(getUserCurrentIndex(user1) == indexAtTimestamp(ts1));
	uint256 finBalanceBeforeMint = balanceOf(e, user1);
	uint256 amount;
	uint256 index = indexAtTimestamp(ts2);
	mint(e,user2, user3, amount, index);
	uint256 finBalanceAfterMint = balanceOf(e, user1);
	assert(user3 == user1 => finBalanceAfterMint != finBalanceBeforeMint);
","This rule/invariant needs to be verified to ensure that only mint operations can increase a user's balance, and that non-mint operations do not have an impact on the user's scaled balance.",5
"	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
","This rule/invariant needs to be verified to ensure that a non-mint operation does not increase a user's balance of debt tokens beyond a certain allowed difference, as determined by the discount rate and current index.",5
"rule userAccumulatedDebtInterestWontDecrease(method f) {
	address user;
	uint256 ts1;
	uint256 ts2;
	require(ts2 >= ts1);
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) >= indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	uint256 initAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	env e2 = envAtTimestamp(ts2);
	f(e2,args);
	uint256 finAccumulatedInterest = getUserAccumulatedDebtInterest(user);
	assert(initAccumulatedInterest > finAccumulatedInterest => f.selector == decreaseBalanceFromInterest(address, uint256).selector);
",This rule needs to verify that the accumulated debt interest of a user won't decrease when a specified method is called.,3
"use rule burnZeroDoesntChangeBalance

/**
* @title proves a concrete case of repaying the full debt that ends with a zero balance
**/
rule integrityOfBurn_fullRepay_concrete() {
	env e;
	address user;
	uint256 currentDebt = balanceOf(e, user);
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));
	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == ray());
	require(index == 2*ray());
	require(scaledBalanceOf(user) == 4*ray());
	burn(e, user, currentDebt, index);
	uint256 scaled = scaledBalanceOf(user);
	assert(scaled == 0);
","This rule/invariant needs to be verified to ensure that repaying the full debt results in a zero balance for the user, in accordance with the rule burnZeroDoesntChangeBalance.",5
"rule integrityOfRebalanceUserDiscountPercent_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	address targetUser;
	rebalanceUserDiscountPercent(e, targetUser);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => otherUser == targetUser);
}
","This rule is verifying that the discount percent of one user does not affect the scaled balance of another user in an isolated manner, ensuring the integrity of the system.",3
"rule userCantNullifyItsDebt(method f) {
	address user;
	uint256 ts1;
	env e1 = envAtTimestamp(ts1);
	uint256 ts2;
	require(ts2 >= ts1);
	env e2 = envAtTimestamp(ts2);
	uint256 ts3;
	require(ts3 >= ts2);
	env e3 = envAtTimestamp(ts3);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)) &&
			(indexAtTimestamp(ts3) == indexAtTimestamp(ts2)));
	uint256 i1 = indexAtTimestamp(ts1);
	uint256 i3 = indexAtTimestamp(ts3);
	uint256 balanceBeforeOp = balanceOf(e1, user);
	uint256 initScaledBalance = scaledBalanceOf(user);
	f(e2,args);
	
	uint256 balanceAfterOp = balanceOf(e3, user);
	uint256 balanceIncrease = balanceAfterOp - balanceBeforeOp;
	assert((balanceBeforeOp > 0 && balanceAfterOp == 0) => (f.selector == burn(address, uint256, uint256).selector));
",This rule/invariant needs to be verified to ensure that a user cannot nullify its debt by conducting certain operations and that the scaled balance of debt tokens remains unchanged during non-mint operations.,5
"rule integrityOfUpdateDiscountDistribution_userIsolation() {
	address otherUser;
	uint256 scaledBalanceBefore = scaledBalanceOf(otherUser);
	env e;
	uint256 amount;
	uint256 senderDiscountTokenBalance;
	uint256 recipientDiscountTokenBalance;
	address sender;
	address recipient;
	updateDiscountDistribution(e, sender, recipient, senderDiscountTokenBalance, recipientDiscountTokenBalance, amount);
	uint256 scaledBalanceAfter = scaledBalanceOf(otherUser);
	assert(scaledBalanceAfter != scaledBalanceBefore => (otherUser == sender || otherUser == recipient));
}
","This rule verifies that when a discount distribution update occurs between two users, only the sender or the recipient is affected in terms of their scaled balance, ensuring isolation of the update between the two parties.",3
"rule integrityOfRebalanceUserDiscountPercent_updateDiscountRate() {
	address user;
	env e;
	rebalanceUserDiscountPercent(e, user);
	assert(discStrategy.calculateDiscountRate(balanceOf(e, user), getBalanceOfDiscountToken(e, user)) == getUserDiscountRate(user));
}
",This rule verifies that the discount rate calculated based on the user's balance and discount token balance matches the discount rate assigned to the user during rebalancing.,3
"rule integrityOfMint_updateScaledBalance_fixedIndex() {
	address user;
	env e;
	uint256 balanceBefore = balanceOf(e, user);
	uint256 scaledBalanceBefore = scaledBalanceOf(user);
	address caller;
	uint256 amount;
	uint256 index = indexAtTimestamp(e.block.timestamp);
	// Forcing the index to be fixed (otherwise the rule times out). For non-fixed index replace `==` with `>=`
	require((indexAtTimestamp(ts1) >= ray()) && 
			(indexAtTimestamp(ts2) == indexAtTimestamp(ts1)));

	require(getUserCurrentIndex(user) == indexAtTimestamp(ts1));
	requireInvariant discountCantExceed100Percent(user);
invariant discountCantExceed100Percent(address user)
	getUserDiscountRate(user) <= MAX_DISCOUNT()
	{
		preserved updateDiscountDistribution(address sender,address recipient,uint256 senderDiscountTokenBalance,uint256 recipientDiscountTokenBalance,uint256 amount) with (env e) {
			require(indexAtTimestamp(e.block.timestamp) >= ray());
	env e = envAtTimestamp(ts2);
	uint256 balanceBeforeOp = balanceOf(e, user);
	calldataarg args;
	f(e,args);
	uint256 balanceAfterOp = balanceOf(e, user);
	uint256 allowedDiff = indexAtTimestamp(ts2) / ray();
	// assert(balanceAfterOp != balanceBeforeOp + allowedDiff + 1);
	assert(balanceAfterOp <= balanceBeforeOp + allowedDiff);
}
/**
* @title proves that a call to a non-mint operation won't increase the user's balance of the actual debt tokens (i.e. it's scaled balance)
**/
// pass
rule nonMintFunctionCantIncreaseScaledBalance(method f) filtered { f-> f.selector != mint(address, address, uint256, uint256).selector } {
		}
	}
	require(getUserCurrentIndex(user) == index);
	mint(e, caller, user, amount, index);
	uint256 balanceAfter = balanceOf(e, user);
	uint256 scaledBalanceAfter = scaledBalanceOf(user);
	uint256 scaledAmount = rayDivCVL(amount, index);
	assert(scaledBalanceAfter == scaledBalanceBefore + scaledAmount);
","This rule verifies that the scaled balance of a user is correctly updated when they receive a minted amount of tokens, ensuring that the calculation of scaled balances is accurate and consistent with the minted amount.",1
"rule getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	assert getFacilitatorBucketCapacity(facilitator) == newCapacity;
}
",This rule needs to be verified to ensure that setting a new capacity for a facilitator's bucket is reflected correctly in the system.,2
"rule address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address(address facilitator){
rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
	require facilitator == 0;
	
","This rule needs to be verified to ensure that after removing a facilitator with address zero, the address is not present in the facilitator list.",2
"rule facilitator_in_list_after_setFacilitatorBucketCapacity(){

	env e;
	address facilitator;
	uint128 newCapacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant addr_in_set_list_iff_in_map(facilitator);
invariant addr_in_set_list_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)
		requireInvariant addressSetInvariant();
		requireInvariant length_leq_max_uint160();
	setFacilitatorBucketCapacity(e, facilitator, newCapacity);
	
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
",This rule needs to be verified to ensure that the facilitator set maintains consistency and that the bucket capacity for a facilitator is updated correctly.,2
"rule address_not_in_list_after_removeFacilitator(address facilitator){
	env e;
	requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()

// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	requireInvariant length_leq_max_uint160();
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
	removeFacilitator(e, facilitator);
	assert !is_in_facilitator_set_array(facilitator);
}
","This rule needs to be verified to ensure that after a facilitator is removed, their address is no longer present in the facilitator set.",2
"rule facilitator_in_list_after_addFacilitator(){

	env e;
	address facilitator;
	string label;
	uint128 capacity;
	requireInvariant addr_in_set_iff_in_map(facilitator);
invariant addr_in_set_iff_in_map(address facilitator)
	is_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)
	{preserved{
 		requireInvariant addressSetInvariant();
invariant addressSetInvariant()
    ADDRESS_SET_INVARIANT()
	{
		preserved{
			requireInvariant length_leq_max_uint160();
invariant length_leq_max_uint160()
	getFacilitatorsListLen() < TWO_TO_160()
// INV #2
/**
* @title User's balance not greater than totalSupply()
*/
invariant inv_balanceOf_leq_totalSupply(address user)
	balanceOf(user) <= totalSupply()
		preserved {
			requireInvariant sumAllBalance_eq_totalSupply();
invariant sumAllBalance_eq_totalSupply()
	sumAllBalance() == totalSupply()
			requireInvariant sumAllLevel_eq_sumAllBalance();
		}
	}
	
	addFacilitator(e,facilitator, label, capacity);
	assert is_in_facilitator_set_map(facilitator);
	assert is_in_facilitator_set_array(facilitator);
}
",This rule needs to be verified to ensure that a facilitator is successfully added to the facilitator mapping and set after calling the addFacilitator function.,2
"// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;

// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
","This rule ensures that the amount transferred to a target address is repaid by the user or on behalf of a specific address, and the balance of the underlying asset is sufficient for the repayment.",5
"rule level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment()
{
	env e;
	calldataarg arg;
	uint256 amount;
	address target;
	address user;
    address onBehalfOf;

	uint256 levelBefore = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	transferUnderlyingTo(e, target, amount);
	handleRepayment(e, user, onBehalfOf, amount);
	uint256 levelAfter = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);
	assert levelBefore <= levelAfter;
}
",This rule verifies that the level of a certain bucket does not decrease after a transfer operation followed by a repayment handling operation.,3
"invariant userBalanceAlwaysZero(address user)
	scaledBalanceOf(user) == 0

// /**
// * @title first handleRepayment(amount) after transferUnderlyingTo(amount) succeeds.
// * @dev assumption of sufficient balanceOf(msg.sender) is justified because BorrowLogic.executeRepay()
// * @dev executes: IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);
// * @dev before invocation of handleRepayment()
// * OBSOLETE - GhoToken has other rules to validate the behavior of the facilitator level maintenance
// */
// rule handleRepayment_after_transferUnderlyingTo()
// {
// 	env e;
// 	calldataarg arg;
// 	uint256 amount;
// 	address target;
// 	address user;
//     address onBehalfOf;
// 	transferUnderlyingTo(e, target, amount);
// 	require _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset
// 	require e.msg.sender == currentContract;
// 	handleRepayment@withrevert(e, user, onBehalfOf, amount);
// 	assert !lastReverted, ""handleRepayment failed"";
// }
",This rule/invariant needs to verify that a user's balance is always zero after certain actions have been performed.,5
"rule feeSimulationEqualsActualFee(address receiver, address token, uint256 amount, bytes data){
    env e;
    uint256 feeSimulationResult = flashFee(e, token, amount);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    
    flashLoanReqs(e);
    require atoken.getGhoTreasury() != currentContract;
    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, e.msg.sender, atoken);
    // Excluding call to distributeFeesToTreasury & calling another flashloan (which will generate another fee in recursion)
    require flashBorrower.action() != 1 && flashBorrower.action() != 0;
    // Because we calculate the actual fee by balance difference of the minter, we assume no extra money is being sent to the minter.
    require flashBorrower._transferTo() != currentContract;
    flashLoan(e, receiver, token, amount, data);

    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 actualFee = facilitatorBalance_ - _facilitatorBalance;
    assert feeSimulationResult == actualFee;
}
","This rule verifies that the actual fee charged for a flash loan transaction is equal to the fee simulated before the transaction, taking into account the facilitator's balance difference.",0
"rule integrityOfFeeSet(uint256 new_fee){
    env e;
    updateFee(e, new_fee);
    uint256 fee_ = getFee(e);
    assert fee_ == new_fee;
}
",This rule needs to verify that the updated fee set in the environment matches the new fee value that was passed in.,2
"rule integrityOfDistributeFeesToTreasury(){
    env e;
    address treasury = getGhoTreasury(e);
    uint256 _facilitatorBalance = gho.balanceOf(currentContract);
    uint256 _treasuryBalance = gho.balanceOf(treasury);

    // No overflow of gho is possible
    ghoBalanceOfTwoUsersLETotalSupply(currentContract, treasury, atoken);
    distributeFeesToTreasury(e);
    uint256 facilitatorBalance_ = gho.balanceOf(currentContract);
    uint256 treasuryBalance_ = gho.balanceOf(treasury);
    assert treasury != currentContract => facilitatorBalance_ == 0;
    assert treasuryBalance_ - _treasuryBalance == _facilitatorBalance - facilitatorBalance_;
}
",This rule verifies that fees collected by a contract are correctly distributed to the treasury address without any loss or gain of tokens.,3
"rule balanceOfFlashMinterGrows(method f, env e, calldataarg args) 
    filtered { f -> f.selector != distributeFeesToTreasury().selector }{
","This rule verifies that the balance of a specific address increases when a certain method is called, except when it is distributing fees to the treasury.",5
"rule integrityOfTreasurySet(address token){
    env e;
    updateGhoTreasury(e, token);
    address treasury_ = getGhoTreasury(e);
    assert treasury_ == token;
}
",This rule needs to be verified to ensure that the address representing the treasury in the system matches the designated token address accurately.,0
"rule availableLiquidityDoesntChange(method f, address token){
    env e; calldataarg args;
    uint256 _liquidity = maxFlashLoan(e, token);

    f(e, args);
    uint256 liquidity_ = maxFlashLoan(e, token);
    assert liquidity_ == _liquidity;
}
",This rule needs to verify that the available liquidity for a token remains unchanged before and after the execution of a specified method.,5
"rule banningIsReversible(address agent, method f) {
    require owner() != 0;
    env e;
    ban(e, agent);

    // call some function for covering more cases
    require f.selector != unban(address).selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    unban@withrevert(e2, agent);
    assert !lastReverted, ""Unbanning should succeed"";
}
",This rule needs to be verified to ensure that the banning of an agent is reversible and that unbanning is successful without any issues.,2
"rule unregisterHandlerIsPermanent2(method f, address handler) {
rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
    require handlers(handler) == deprecated();
","This rule verifies that a handler's status is set to ""deprecated"" after being unregistered.",2
"rule changesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != registerCaller(address,bytes32).selector && f.selector != unregisterCaller(address).selector) 
        => _regState == regState_, ""method unexpectedly changes caller info"";
}
","This rule needs to be verified to ensure that certain methods do not unexpectedly change caller information, as this could potentially impact the security and functionality of the system.",2
"rule unregisterCallerIsPermanent2(method f, address caller) {
rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
    require callers(caller) == deprecated();
",This rule needs to verify that a caller has been permanently unregistered from a system after a specific action is performed.,2
"rule deprecatesCaller(method f, address caller) {
    bytes32 _regState;
    bytes32 regState_;
    callerTransition(caller, _regState, regState_, f);
    assert (f.selector != unregisterCaller(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates caller"";
}
","This rule verifies that a certain method should not unexpectedly deprecate a caller, based on their registration state transitions.",2
"rule deprecatesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != unregister(address).selector) 
        => _regState != deprecated() /* non deprecated */ => regState_ != deprecated(), ""method unexpectedly deprecates handler"";
}
",This rule needs to verify that a method does not unexpectedly deprecate a handler when called.,2
"rule haltingIsReversible(method f) {
    require owner() != 0;
    env e;
    halt(e);

    // call some function for covering more cases
    require f.selector != unhalt().selector;
    callArbitrary(f);
    env e2;
    require e2.msg.value == 0;
    require e2.msg.sender == e.msg.sender;
    assert e.msg.sender != 0, ""Cannot send transactions from 0 address"";
    unhalt@withrevert(e2);
    assert !lastReverted, ""Unhalting should succeed"";
}
","This rule verifies that a specific method is reversible and can be halted and then unhalted successfully, ensuring that the owner is not set to 0 and transactions can be sent from a non-zero address.",3
"rule unregisterHandlerIsPermanent(method f, address handler) {
    env e;
    unregister(e, handler);

    callArbitrary(f);
    assert handlers(handler) == deprecated(), ""unexpected handler info after unregister"";
}
",This rule needs to verify that unregistering a handler permanently removes it from the list of active handlers in the system.,2
"rule changesHandler(method f, address handler) {
    bytes32 _regState;
    bytes32 regState_;
    handlerTransition(handler, _regState, regState_, f);
    assert (f.selector != register(address,bytes32).selector && f.selector != unregister(address).selector) 
        => _regState == regState_, ""method unexpectedly changes handler info"";
}
",This rule ensures that certain methods do not inadvertently change handler information.,2
"rule unregisterCallerIsPermanent(method f, address caller) {
    env e;
    unregisterCaller(e, caller);

    callArbitrary(f);
    assert callers(caller) == deprecated(), ""unexpected caller info after unregister"";
}
","This rule verifies that after unregistering a caller, the caller's information should be changed to ""deprecated"" in the system.",2
"rule nonExecutableWithInitializedSender(method f) {
    require !isHandler();
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;

    arbitrary(f);
    assert ethBalance(currentContract) == 0;
}
    require !f.isView; // only non-view functions, that may modify the state, are interesting.
    require getSender() != 0; // sender is initialized
    env e;
    bool isGoodCaller = registry.isValidCaller(e, e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    assert (f.isFallback && !isGoodCaller) => lastReverted; // only valid callers should execute in fallback successfully (would violate since certora prover cannot distinguish between receive and fallback for now)
    assert (f.selector == execs(address[],bytes32[],bytes[]).selector && e.msg.sender != currentContract) => lastReverted; // `execs` is allowed to be called by proxy itself after initialized
    assert (!f.isFallback && f.selector != execs(address[],bytes32[],bytes[]).selector) => lastReverted; // all non-view functions other than above ones should revert if sender is already initialized
",This invariant needs to be verified to ensure that non-executable functions with an initialized sender do not allow unauthorized callers to modify the state and that the contract's ether balance remains unchanged during execution.,3
"// the rule is usually expected to fail, because handler functions do not check who calls them (it's usually the sender via the proxy delegatecall).
rule onlyValidCaller(method f) {
    env e;
    bool isGoodCaller = registry.isValidCaller(e.msg.sender);
    calldataarg arg;
    f@withrevert(e, arg);
    bool succeeded = !lastReverted;

    assert !isGoodCaller => !succeeded, ""function can be called even if the sender is not an allowed caller"";
}
",This rule needs to verify that only allowed callers can successfully execute the specified function.,2
"rule noOverwrite(method f, uint slot) {
    require getStackLength() < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthBefore = getStackLength();

    arbitrary(f);
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
}
    uint oldValue = getSlot(slot);
    uint newValue = getSlot(slot);
    
    // slot 0 is stack length, postProcess() may nullify it and it's fine, and execs() can increase it
// the rule is usually expected to fail, because handler functions are payable.
rule holdNoEth(method f) {
    require ethBalance(currentContract) == 0;
    assert ethBalance(currentContract) == 0;
    assert oldValue != 0 => (newValue == oldValue 
            || slot == getStackLengthSlot()), ""Slot $slot changd during this execution"";
","This rule verifies that a specific slot in a contract's storage cannot be overwritten, as well as ensuring that the contract's balance remains zero throughout the execution.",3
"rule transferredTokensMeanThatStackIsUpdated(method f) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someToken.allowance(currentContract, summaryInstance) == 0; // to make sure we're starting clean as implied by approvedTokensAreTemporary
rule approvedTokensAreTemporary(method f, address someAllowed) {
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
    uint256 balanceBefore = someToken.balanceOf(currentContract);
    uint256 stackLengthBefore = getStackLength();
    require stackLengthBefore < MAX_UINT256() - STACK_INCREASE_BOUND(); // see stackLengthIncreaseIsBounded
rule stackLengthIncreaseIsBounded(method f) {
    uint256 stackLengthAfter = getStackLength();
    assert stackLengthAfter <= stackLengthBefore + STACK_INCREASE_BOUND(), ""Found a way to increase stack length by more than 1 million"";
    uint256 balanceAfter = someToken.balanceOf(currentContract);
    assert (balanceAfter > balanceBefore) => stackLengthAfter > stackLengthBefore, 
        ""must push an entry to postprocess stack if transferring funds into proxy which are not eth"";
","This rule/invariant needs to be verified to ensure that the stack is updated and maintained correctly when transferring tokens, and that token allowances are nullified before and after the transfer.",5
"rule approvedTokensAreTemporary(method f, address someAllowed) {
    require summaryInstance.getEthAddress(currentContract) != someToken; // not an eth transfer
    require someToken != 0; // not an eth transfer
    require someAllowed == summaryInstance; // narrowing down
    uint256 allowanceBefore = someToken.allowance(currentContract, someAllowed);

    arbitrary(f);
    
    uint256 allowanceAfter = someToken.allowance(currentContract, someAllowed);
    assert allowanceBefore == 0 => allowanceAfter == 0, ""Allowances must be nullified"";
}
",This rule checks that approved tokens are temporary and are nullified after a specific operation is performed. It ensures that allowances for tokens are reset following a particular action.,3
"rule noThrow(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		bytes32 x;
		require !isStatic(x);
		require getNumOfReferences(x) > 0;
		getParams@withrevert(e, x);
	} else {
		f@withrevert(e, arg);
	}
	assert !lastHasThrown;
}
","This rule needs to be verified to ensure that a method does not throw any exceptions when called with specified conditions, such as having a value of 0 sent with the message and validating arguments before invoking the method.",2
"rule noRevert(method f) {
	env e;
	require e.msg.value == 0;
	calldataarg arg;
	if (f.selector == getParams(bytes32).selector) {
		require false;
	} else {
		f@withrevert(e, arg);
	}
	assert !lastReverted; // only fallback may revert
}",This rule enforces that a specific method cannot be reverted under certain conditions and validates that only the fallback function is allowed to revert within a contract.,2
"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(FCOMPOUND_ACTIONS()), ""not all delegated are allowed"";
}
",This rule needs to verify that only a certain number of delegates are allowed to execute a specific method and that no more than the specified number of delegates have been delegated.,2
"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(getProxyActions()), ""not all delegated are allowed"";
}
",This rule needs to be verified to ensure that only a certain number of method calls are made and that these calls are only delegated to allowed addresses.,3
"rule executeDelegatesOnlyToAllowedAddresses(method f) {
    require summaryInstance.lenDelegated() == 0;

    arbitrary(f);
    uint pushed = summaryInstance.lenDelegated();
    assert pushed <= 3, ""not expected to call execute more than 3 times"";
    assert summaryInstance.checkDelegated(BACTIONS()), ""not all delegated are allowed"";
}
","This rule ensures that certain functions are only called from specific addresses and within a limited number of times, while also verifying that all delegated actions are allowed.",3
" * This rule verifies the Certora Prover is correctly modeling the behavior of GoldToken._transfer.
 */
rule withdraw(uint256 index) {
	env e;
	uint256 _balance = sinvoke ercBalanceOf(e.msg.sender);
	uint256 val = sinvoke getPendingWithdrawalsIndex(e.msg.sender, index);
	sinvoke withdraw(e, index);
	require (e.msg.sender != currentContract);
	uint256 balance_ = sinvoke ercBalanceOf(e.msg.sender);
	assert(
    _balance + val == balance_,
    ""Withdraw balance not updated""
  );
}
",This rule needs to be verified to ensure that withdrawals are correctly updating the balance of the user in the smart contract.,5
"rule totalNonVotingGEAccountNonVoting(address a, method f) {
	require(sinvoke getNonvotingLockedGold()  >= sinvoke getAccountNonvotingLockedGold(a));
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector
  );
	env eF; 
    (f.selector != unlock(uint256).selector || eF.msg.sender == a) &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
	calldataarg arg;
	sinvoke f(eF,arg);
	assert(sinvoke getNonvotingLockedGold() >= sinvoke getAccountNonvotingLockedGold(a));
}
","This rule ensures that the total non-voting locked gold amount is always greater than or equal to the non-voting locked gold amount for a specific account after executing a method, excluding certain specific methods.",3
"rule totalPreserved(address account, method f) {
	// We assume the sender is not the currentContract
	require(account != currentContract);
	uint256 _ercBalance = sinvoke ercBalanceOf(account); 
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(account);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(account);
	// We limit the amount of pending records due to loop handling 
	require sinvoke getPendingWithdrawalsLength(account) <= 1;
	env eF;
	require(eF.msg.sender == account);
	// These three function are exceptions to the rule (they are designed to affect total)
	require(
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	calldataarg arg;
	sinvoke f(eF,arg);
	uint length = sinvoke getPendingWithdrawalsLength(account);
	require(length <= 1);
	uint256 ercBalance_ = sinvoke ercBalanceOf(account);
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(account);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(account);
  assert(
    _ercBalance + _accountNonVoting + _accountTotalPendingWithdrawals ==
    ercBalance_ + accountNonVoting_ + accountTotalPendingWithdrawals_,
    ""Total of tokens not preserved""
}
","This rule needs to be verified to ensure that the total balance of tokens held by an account (including non-voting locked gold and pending withdrawals) remains unchanged after certain function calls, excluding specific exceptional functions.",5
"rule noChangeByOther(address a, address b, method f) {
	require(a != b);
	// We assume the sender is not the currentContract
	require(
    a != currentContract &&
    (a == sinvoke getGoldTokenExt() => f.selector != withdraw(uint256).selector));
	uint256 _ercBalance = sinvoke ercBalanceOf(a);
	uint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(a);
	uint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(a);
	// We limit the amount of pending records due to loop handling 
	uint length = sinvoke getPendingWithdrawalsLength(a);
	require(length <= 1);
	env eF;
	require(eF.msg.sender == b);
	calldataarg arg;
    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&
    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector
  );
	sinvoke f(eF,arg);
	uint256 ercBalance_ = sinvoke ercBalanceOf(a); 
	uint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(a);
	uint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(a);
	assert(f.selector != withdraw(uint256).selector => _ercBalance == ercBalance_, ""Unexpected change to erc tokens"");
	assert(_accountTotalPendingWithdrawals == accountTotalPendingWithdrawals_, ""Unexpected change to total pending"");
	assert(_accountNonVoting == accountNonVoting_, ""Unexpected change to account nonvoting"");
}
","This rule is verifying that certain values related to a user's account balance and pending withdrawals should not be changed by calls made by another address, except under specific conditions.",5
"rule noWithdrawBeforeUnlocking(address account, uint256 value, method f) {
	// We must make sure the length of pending withdrawals is not MAX_UINT, since then the `push` will make the length 0.
	// (this should have been checked by the solidity compiler)
	require(sinvoke pendingWithdrawalsNotFull(account), ""Pending withdrawals are full"");
	
	// Unlock a value and add it to pending withdrawals
	env _e;
	require(_e.msg.sender == account);
	sinvoke unlock(_e,value);

	// Try to run any function - adversary's goal is to succeed in unlocking before time
	env eF;
	require(eF.block.timestamp > _e.block.timestamp);
	calldataarg arg;
	sinvoke f(eF,arg);
	// We check if adversary succeeded
	uint256 totalPendingWithdrawals_ = sinvoke getTotalPendingWithdrawals(account);
	assert(
    eF.block.timestamp < _e.block.timestamp + sinvoke getunlockingPeriod() =>
    sinvoke getAccountNonvotingLockedGold(account) + totalPendingWithdrawals_ >= value,
    ""If we are before the unlock period passed, we cannot transfer the value outside the locked balance or pending balance""
  );
}
",This rule ensures that a certain value cannot be withdrawn before it has been unlocked and added to pending withdrawals within a specified timeframe.,3
"rule no_weight_changing_when_voting(method f, address account) {
	env _e;
	uint256 _accountWeight = sinvoke _weight(_e,account);
	
	bool isAccountVoting = sinvoke isVoting(_e,account);
	env eF;
	calldataarg arg;
	invoke f(eF,arg);
	env e_;
	uint256 accountWeight_ = sinvoke _weight(e_,account);
	assert(
    isAccountVoting => _accountWeight == accountWeight_,
    ""Method changed weight of account if voting""
  );
}",This rule needs to verify that the weight of an account does not change when the account is voting.,3
"rule no_vote_delegation_when_voting {
	env _e;
	env eF;
	
	address account = eF.msg.sender;
	bool _isAccountVoting = sinvoke isVoting(_e,account);

	calldataarg arg;
	invoke delegateVoting(eF,arg);
	bool succeededDelegate = !lastReverted;
	assert(
    _isAccountVoting => !succeededDelegate,
    ""Account successfully delegated voting even though it is already a voter""
  );
} 
",This rule ensures that a voting delegation cannot be made when the account is already participating in voting.,4
"rule no_double_vote_referendum_vote(address account, uint256 deqIndex) {
	/* A user that already has a vote record for a dequeued index, cannot make a transaction that will increase the weight of that choice */
	env eF; 
	env eFTime; // same time as eF;
	env e_;
	
	uint256 NONE_ENUM = getNoneVoteEnum();
	uint256 ABSTAIN = getAbstainVoteEnum();
	uint256 YES = getYesVoteEnum();
	uint256 NO = getNoVoteEnum();
	uint256 p; // a proposal - let's assume it already exists (required for propose() verification)
	uint256 recordValue;
	p, recordValue, _ = getVoteRecord(account,deqIndex);
	uint256 currentProposalCount = proposalCount();
	require currentProposalCount >= p;
	uint256 _yes; uint256 _no; uint256 _abstain;
	_yes,_no,_abstain = getVoteTotals(p);
	// if can't vote for NONE_ENUM, then necessarily if record vote is NONE_ENUM, all votes are zero currently
	require recordValue == NONE_ENUM => (_yes == 0 && _no == 0 && _abstain == 0);
	require accounts.voteSignerToAccount(eF.msg.sender) == account;
	uint256 someP; uint256 someIndex; uint8 someValue;
	uint256 pOfSomeIndex;
	pOfSomeIndex, _, _ = getVoteRecord(account,someIndex);
	require pOfSomeIndex == p => someIndex == deqIndex; // no duplicates in the dequeued array
	require someP == p => someIndex == deqIndex;
	vote(eF,someP,someIndex,someValue);
	uint256 yes_; uint256 no_; uint256 abstain_;
	yes_,no_,abstain_ = getVoteTotals(p);
	bool doesProposalExist_ = proposalExists(e_,p);
	// if p expires, then sum of votes is no longer relevant - happens in approve, vote, execute
	assert (recordValue != NONE_ENUM && doesProposalExist_) => (yes_ + no_ + abstain_) == (_yes + _no + _abstain), ""Total votes could not have changed if already voted"";
	assert recordValue == YES => yes_ <= _yes, ""Yes votes could not have increased if voted yes already"";
	assert recordValue == NO => no_ <= _no, ""No votes could not have increased if voted no already"";
	assert recordValue == ABSTAIN => abstain_ <= _abstain, ""Abstain votes could not have increased if voted abstain already"";
	assert recordValue == NONE_ENUM => (!doesProposalExist_ && yes_ == 0 && no_ == 0 && abstain_ == 0)// proposal no longer exists so everything is 0
									// or just one out of (yes,no,abstain) changed
									|| (yes_ == _yes && no_ == _no)
									|| (yes_ == _yes && abstain_ == _abstain)
									|| (no_ == _no && abstain_ == _abstain),
									""If previously did not vote, either this proposal was deleted, or only one kind of vote may change, and the other two are the same"";
}
","This rule ensures that a user cannot vote multiple times on the same proposal in a referendum, preventing the manipulation of voting outcomes by a single user.",4
"rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","This rule/invariant needs to be verified to ensure that a user cannot double upvote a proposal, as it should only be allowed to upvote once per proposal.",4
"rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
",This rule verifies that a user cannot upvote the same proposal more than once by checking the user's previous upvote record before allowing a new upvote.,4
"rule cant_unvote(uint256 deqIndex, uint8 voteValue) {	
    env eF;
	uint256 NONE_ENUM = getNoneVoteEnum();
	// get the voting delegate
	address voterDelegate = accounts.getVoteSigner(eF.msg.sender);
	
	// check if voted
    uint256 p;
	uint256 recordValue;
    uint256 weight;
	p, recordValue, weight = getVoteRecord(voterDelegate,deqIndex);
	bool result = vote(eF,p,deqIndex,voteValue);
	uint256 recordValue_;
    uint256 weight_;
	_, recordValue_, weight_ = getVoteRecord(voterDelegate,deqIndex);
	assert voteValue == NONE_ENUM => (!result && recordValue_ == recordValue && weight_ == weight), ""Cannot vote for none: function either returns false and did not update the vote, or it reverted""; // not voting none. reverting is fine and is encoded by the safe invoke
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
",This rule/invariant ensures that a user cannot upvote the same proposal multiple times.,4
"    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
",This rule verifies that a user cannot upvote the same proposal more than once.,4
"invariant referendumVoteIDIsLessThanOrEqCounter(address v, uint p) votedFor(v,p) => p <= proposalCount() {
    preserved vote(uint256 _, uint256 indx, uint8 vr) with (env e) {
        requireInvariant dequeuedIsWithinRange(indx); 
invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    }
",This rule/invariant needs to be verified for ensuring that upvoting a proposal does not lead to an increase in the total number of upvotes if the user has already upvoted another proposal.,4
"rule check_initializer {
	env _e;
	env eF;
	env e_;
	
	bool _isInitialized = initialized(_e);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	calldataarg arg;
	initialize@withrevert(eF,arg);
	bool successInit = !lastReverted;
	bool isInitialized_ = initialized(e_);
	assert _isInitialized => !successInit, ""initialize() must revert if already initialized"";
	assert successInit => isInitialized_, ""When initialize() succeeds, must set initialization field to true"";
","This rule checks that the initialization of a contract is properly handled, ensuring that it reverts if already initialized and sets the initialization field to true if successful.",2
"rule only_initializer_changes_initialized_field(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","This rule checks that a user cannot upvote the same proposal multiple times, ensuring that the upvote count for a proposal does not increase when the user has already upvoted it.",4
"rule constitution_change(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
        && f.selector != setConstitution(address,bytes4,uint256).selector
} {
",This rule checks that a user can only upvote a proposal once and that the number of upvotes does not increase if a user has already upvoted a proposal.,4
"rule proposal_count_monotonic_increasing(method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","This rule verifies that a user cannot upvote the same proposal more than once, ensuring that the number of upvotes on a proposal only increases when a user who has not previously upvoted it does so.",4
"rule can_add_to_queue(method f) filtered { f -> 
    !f.isView
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != propose(uint256[],address[],bytes,uint256[],string).selector
} {
","This rule checks that a user cannot upvote the same proposal more than once, ensuring that each user can only contribute one upvote per proposal.",4
"rule approved_proposals_invariants(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
",This rule/invariant ensures that a user can only upvote a proposal once and that the total number of upvotes for a proposal remains consistent when a user who has already upvoted the proposal tries to upvote it again.,4
"rule approval_only_if_promoted_and_allowed(uint256 p, uint256 index) {
	// A proposal should never be able to be approved unless it was promoted from the queue
	env eF;
    env eGet;
    require eF.block.timestamp == eGet.block.timestamp;
    require eF.block.number == eGet.block.number;
	
	bool _isProposalApproved = isApproved(p);
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
	bool _isDequeued = getFromDequeued(index) == p;
	bool _isExpired = isDequeuedProposalExpired(eGet, p);
	address _approver = approver();
	require !_isProposalApproved; // we assume not approved yet
	require !_isExpired; // we also assume it did not expire
		
	approve(eF,p,index);
	// should check if dequeued right during approve
	bool isDequeued_ = getFromDequeued(index) == p;
	bool isProposalApproved_ = isApproved(p);
	assert isProposalApproved_ => _isDequeued || (!_isDequeued && isDequeued_), ""Cannot approve proposal $p unless $index points to it before approve or during it""; // index has p
	assert isProposalApproved_ => eF.msg.sender == _approver, ""Only approver ${_approver} can approve"";
",This rule verifies that a proposal can only be approved if it was promoted from the queue and the approval is done by the designated approver. It also checks that a user can only upvote a proposal once.,4
"rule no_referendum_votes_unless_approved(method f, uint256 p) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","This rule verifies that a user cannot upvote the same proposal more than once, ensuring that upvotes are unique for each user and proposal.",4
"rule no_double_vote_referendum_all_but_vote(method f, address account, uint256 deqIndex) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
",This rule/invariant needs to verify that a user cannot upvote the same proposal more than once.,4
"invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()

// upvoting
rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {
    // the invariant is upvoteInv, defined here
} 
definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
","This rule/invariant needs to be verified to ensure that a user cannot upvote a proposal multiple times, and that the total upvotes for a proposal do not increase when the same user upvotes it again.",4
"rule modifying_stageDuration(method f) filtered { f -> 
    !f.isView 
    // the invariant is upvoteInv, defined here
} 

definition upvoteInv(uint p, uint w) returns bool 
    = (p != 0 && w > 0) || (p == 0 && w == 0)
    ;
rule no_double_upvote(uint256 p, address u) {
	uint256 _upvotes = getUpvotes(p);
	uint256 _usersUpvotedProposal = getUpvotedProposal(u);
	env e;
	require e.msg.sender == u && u != 0; // note that the sender is the signer here
    require accounts.voteSignerToAccount(u) == u;
	uint256 lesser; 
    uint256 greater;
	upvote(e, p, lesser, greater);
	uint256 upvotes_ = getUpvotes(p);
	
    uint voteRecordP;
    uint voteRecordW;
    voteRecordP, voteRecordW = getUpvoteRecord(u);
    require upvoteInv(voteRecordP, voteRecordW);
	assert _usersUpvotedProposal == p => upvotes_ <= _upvotes, 
		""Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p"";
}
    && f.selector != initialize(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256).selector
    && f.selector != setApprovalStageDuration(uint256).selector
    && f.selector != setExecutionStageDuration(uint256).selector
    && f.selector != setReferendumStageDuration(uint256).selector
} {
","This rule ensures that a user cannot upvote a proposal more than once, maintaining that each user can only have one upvote per proposal.",4
"rule no_promoting_without_upvotes(uint256 p, uint256 index) {
	// Can a proposal be promoted with 0 votes? 
	env _e;
	env eF;
	env e_;
	
	/* would actually want forall index. inrange(index) => dequeued[index] != p but here its suffice to 'pre-guess' the index of the proposal we dequeue */
	// a utility rule for figuring out which methods could dequeue and whether it's all due to dequeueProposalsIfReady calls.

	// require index to be valid and to be empty
	require index >= 0;
	uint256 queueLength = getDequeuedLength();
	require index <= queueLength || index == queueLength+1; // either an empty index or the next one we push
	// if it's an empty index in the range, then it's empty
	require index <= queueLength => getFromDequeued(index) == 0;
	callArbitrary(f);
	uint256 newValueInDequeued = getFromDequeued(index);
	assert newValueInDequeued == 0, ""Method caused a dequeue of proposal $newValueInDequeued to index $index"";	
}
rule promote_proposal(method f, uint256 p, uint256 index) filtered { f -> !f.isView } {
	require p > 0; // proposal 0 is not legal, and cannot happen (we check it)
	uint256 _upvotes = getUpvotes(p);
	dequeueProposalsIfReady(eF);
	assert getFromDequeued(index) == p => _upvotes > 0, ""Cannot dequeue (promote) proposal $p to index $index unless had some upvotes"";
}",This rule ensures that a proposal cannot be promoted to a specific index in the dequeued list without having received any upvotes.,4
"rule cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
} {
","This rule ensures that a specific method cannot transition directly from a state of no authorization to completed status in one step, unless a particular role is designated as ""Legacy."" This prevents unauthorized completion of certain actions without the appropriate authorization.",2
"rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
","This rule verifies that a specific address can successfully authorize two different addresses with distinct roles, while ensuring the authorization is only initiated by the original address.",2
"rule gettersInAgreement() {
	address account;
	require account != 0;
	bytes32 role;
	address indexedSigner = getIndexedSigner(account, role);
	address defaultSigner = getDefaultSigner(account, role);
	address legacySigner = getLegacySigner(account, role);
	address voteSigner = getVoteSigner(account);
	address validatorSigner = getValidatorSigner(account);
	address attestationSigner = getAttestationSigner(account);

	if (role == _getVoteRole()) {
		assert indexedSigner == legacySigner && indexedSigner == voteSigner, ""indexed signer agrees with legacy signer for vote role"";
	} else if (role == _getValidatorRole()) {
		assert indexedSigner == legacySigner && indexedSigner == validatorSigner, ""indexed signer agrees with legacy signer for validator role"";
	} else if (role == _getAttestationRole()) {
		assert indexedSigner == legacySigner && indexedSigner == attestationSigner, ""indexed signer agrees with legacy signer for attestation role"";
	} else {
		assert indexedSigner == defaultSigner, ""for any non legacy role indexed signer is default signer"";
	}
	assert indexedSigner != 0 && defaultSigner != 0 && legacySigner != 0 
		&& voteSigner != 0 && validatorSigner != 0 && attestationSigner != 0, ""signer is never address 0"";
	// original assertion is wrong
	//assert indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
	assert !isLegacyRole(role) && indexedSigner != account => defaultSigner != account, ""If indexed signer is a distinct address then default signer for this role is also a distinct address"";
}
","This rule ensures that different types of signers associated with a role agree with each other, and that none of the signers are the zero address. Additionally, it mandates that if the indexed signer is a distinct address, then the default signer for that role must also be a distinct address.",2
"rule createsAccount(method f, address a) filtered { f ->
	!f.isView
		&& f.selector != createAccount().selector
		&& f.selector != setAccount(string,bytes,address,uint8,bytes32,bytes32).selector
} {
",This rule needs to be verified to ensure that only non-view methods related to creating or setting up accounts are allowed in the contract.,3
"rule address_can_authorize_two_addresses_legacy(address x, address d1, address d2)
rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)
{ 
	require x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); 
	env e;
	require e.msg.sender == x;
  	
	storage init = lastStorage;
	// first, authorizing d2 as a validation signer should succeed
	uint8 v2;
	bytes32 r2;
	bytes32 s2;
	authorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  

	// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)
	uint8 v1;
	bytes32 r1;
	bytes32 s1;
	authorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;
	
	// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed
		
	// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x
	assert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, ""Authorizedby should both be x"";
}
	authorizeValidatorSigner(e, d2, v2, r2, s2);  
	authorizeVoteSigner(e, d1, v1, r1, s1) at init;
",This rule needs to be verified to ensure that a specific address can successfully authorize two other addresses with different roles while maintaining the correct authorization relationships.,2
"invariant legacyRolesAreNotUsedInNewRoles(address account, bytes32 role) 
	isLegacyRole(role) => _getDefaultSigner(account, role) == 0

/**
 * view functions in general should not revert.
 * Some exceptions and more refined revert-characteristics are provided.
 */
rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match
  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","This rule ensures that legacy roles are not used in new roles, preventing unexpected behavior and maintaining system integrity.",2
"rule cannotSetAuthorizedByWithoutSignatures(method f) filtered { f -> 
	!f.isView 
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeAttestationSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSigner(address,uint8,bytes32,bytes32).selector
		&& f.selector != authorizeValidatorSignerWithKeys(address,uint8,bytes32,bytes32,bytes,bytes,bytes).selector
		&& f.selector != authorizeValidatorSignerWithPublicKey(address,uint8,bytes32,bytes32,bytes).selector
		&& f.selector != authorizeVoteSigner(address,uint8,bytes32,bytes32).selector
} {
",This rule ensures that certain types of methods cannot be authorized without the required signatures.,2
"invariant accountToSignerAndInverseNewRoles(address a, address s, bytes32 r)	
	getIndexedSigner(a, r) == s => signerToAccount(s) == a 
{
		preserved {
			require a != s;
		}
}
","This rule must be verified to ensure that a certain relationship between a specific account, signer, and role is maintained and consistent.",3
"rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> 
	!f.isView 
		// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option
		&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector	
} {
","This rule ensures that only legacy roles can create signers without approval from a signer, excluding the authorization process for creating signers with a signature.",2
"rule viewFunctionsDoNotRevert(method f) filtered { f -> 
	f.isView 
	// some functions we ignore, and the reasons:
	&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match
	&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match

  // These require an account to exist
	&& f.selector != getOffchainStorageRoots(address).selector
	&& f.selector != offchainStorageRoots(address,uint256).selector
} {
","This rule filters out view functions that may potentially revert due to inconsistencies in calldatasize or require an existing account for operation, ensuring that only safe view functions are considered for analysis.",2
"rule positiveSupply_imply_positiveAssets_other(method f) filtered {f ->
        f.selector != initialize(address,uint256,string,string,uint256).selector &&
        !harnessOnlyMethods(f) &&
        !f.isView &&
        !is_deposit_method(f) &&
        !is_mint_method(f) &&
        !is_withdraw_method(f) &&
        !is_redeem_method(f) 
        }
","This rule needs to be verified to ensure that whenever a method increases the supply of a certain asset, it also increases the assets held by the contract in a positive manner.",5
"rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","This rule needs to be verified to ensure that the balance of the last vault is less than or equal to the balance of the aToken when calling a method, excluding certain specialized methods.",5
"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
    
// ******************************************************************************
// The main invariant of this file:
// _s.lastVaultBalance <= ATOKEN.balanceOf(theVault).
//
// Status: pass for all methods.
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
rule lastVaultBalance_LEQ_ATokenBalThis(env e, method f) filtered {f ->
    f.selector != initialize(address,uint256,string,string,uint256).selector &&
    !harnessOnlyMethods(f) &&
    !f.isView
    //    f.selector != havoc_all().selector
}
","This rule verifies that the last recorded vault balance in the system is less than or equal to the balance of the aToken held by the vault, ensuring consistency and correct operation of the system.",5
"rule getCLMFees_LEQ_ATokenBAL_RW(method f) filtered {f ->
        !harnessOnlyMethods(f) &&
        !f.isView &&
        (is_withdraw_method(f) || is_redeem_method(f) ||
         f.selector == withdrawFees(address,uint256).selector
        )
}
","This rule needs to be verified for methods that involve withdrawing assets or redeeming tokens, as well as for the method that allows withdrawing fees from a specific address. The rule excludes read-only methods and harness-only methods for verification.",3
"invariant inv_sumAllBalance_eq_totalSupply__underline()
    sumAllBalance_underline() == Underlying.totalSupply()

invariant inv_sumAllBalance_eq_totalSupply__atoken()
    sumAllBalance_atoken() == _AToken.scaledTotalSupply()
invariant inv_sumAllBalance_eq_totalSupply()
    sumAllBalance() == totalSupply()
// ******************************************************************************
// The following invariant is proved in lastVaultBalance_OK.spec
invariant lastVaultBalance_OK()
    getLastVaultBalance() <= _AToken.balanceOf(currentContract)
    
// Proving the solvency rule:
//           getClaimableFees() <= ATOKEN.balanceOf(theVault).
// We do it by proving the stronger invariant:
//           max_possible_fees() <= _AToken.balanceOf(currentContract)
// 
// In this file we prove all method exept the following
// withraw*\redeem*\withdrawFees. (those methods are treated in fee_LEQ_ATokenBal-RW.spec
// Note: the reason for the seperation is that different methods require different summarizations.
//
// Status: pass for all methods that are checked in this file, but FAIL of the others.
//         See in fee_LEQ_ATokenBal-RW.spec
// Note: We require that the totalSupply of currentContract, AToken, Underlying to be
//       less than maxUint128() to avoid failures due to overflows.
function getCLMFees_LEQ_ATokenBAL_1(method f) {
    env e;
    require e.msg.sender != currentContract;
    require getFee() <= SCALE();  // SCALE is 10^18
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require totalSupply() <= maxUint128();
    require Underlying.totalSupply() <= maxUint128();
    require _AToken.scaledTotalSupply() <= maxUint128();
    requireInvariant inv_sumAllBalance_eq_totalSupply__underline(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply__atoken(); 
    requireInvariant inv_sumAllBalance_eq_totalSupply();
    requireInvariant lastVaultBalance_OK();
    uint256 ind = _SymbolicLendingPoolL1.getLiquidityIndex();
    uint256 s_bal = _AToken.scaledBalanceOf(currentContract);
    // The following require means: (s_bal - ass/ind)*ind == s_bal*ind - ass
    require (forall uint256 ass.
             rayMul_g(to_uint256(s_bal-rayDiv_g(ass,ind)),ind) == to_uint256(rayMul_g(s_bal,ind)-ass)
            );
    // The following require means: (x/ind+z)*ind == x+z*ind 
    require (forall uint256 x. forall uint256 ind. forall uint256 z.
             rayMul_g(to_uint256(rayDiv_g(x,ind)+z),ind) == to_uint256(x+rayMul_g(z,ind))
    require(max_possible_fees() <= _AToken.balanceOf(currentContract));
    if (f.selector == depositATokensWithSig(uint256,address,address,
                                            (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 assets; address receiver; address depositor;
        _ATokenVaultHarness.EIP712Signature sig;
        
        require depositor != currentContract;
        depositATokensWithSig(e,assets,receiver,depositor,sig);
    }
    else if (f.selector == mintWithATokensWithSig(uint256,address,address,
                                             (uint8,bytes32,bytes32,uint256)).selector) {
        uint256 shares; address receiver; address depositor;
        mintWithATokensWithSig(e, shares, receiver, depositor, sig);
    else {
        calldataarg args;
        f(e,args);
    //    require Underlying.totalSupply() <= maxUint128();
    //require _AToken.scaledTotalSupply() <= maxUint128();
    assert(max_possible_fees() <= _AToken.balanceOf(currentContract));
}
","This rule/invariant needs to be verified to ensure that the sum of all balances equal the total supply of the underlying asset and AToken, and to check that the claimable fees do not exceed the balance of the AToken contract.",5
"rule getCLMFees_LEQ_ATokenBAL_DM_other(method f) filtered {f ->
    !harnessOnlyMethods(f) &&
    !f.isView &&
    !is_withdraw_method(f) &&
    !is_redeem_method(f) &&
    f.selector != withdrawFees(address,uint256).selector
}
","This rule filters out methods that are not view functions, withdraw or redeem methods, or the withdrawFees method to ensure that only relevant methods related to getting CLM fees for a specific token balance are considered for verification.",2
"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewDeposit_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewDeposit(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewDeposit(e2, assets);
    assert (previewShares1 == previewShares2);
",This rule/invariant needs to verify that the value returned by a specific function depends only on the total supply and total assets of the contract.,5
"rule must_not_revert_unless_large_input__convertToAssets() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 shares;
    require (shares <= maxUint128());
    
    convertToAssets@withrevert(e, shares);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
",This rule ensures that the amount of shares returned by the previewWithdraw function is either equal to or less than the amount of shares returned by the withdraw function in the same transaction.,3
"// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
","This rule checks that the amount of Vault shares returned by the previewWithdraw function is identical or less than the amount returned by the withdraw function in the same transaction, ensuring consistency in share calculations.",3
"  The following rule checks that the value returned by the previewDeposit depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the value returned by _maxAssetsSuppliableToAave().
*/
rule previewMint_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewMint(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewMint(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
",This rule needs to verify that the value returned by previewMint does not depend on a specific threshold value.,2
"rule must_not_revert_unless_large_input__convertToShares() {
rule must_not_revert(method f) {
    env e;
    calldataarg args;

    require f_must_NOT_revert(f);
    require e.msg.value == 0;
    f@withrevert(e, args); 
    bool reverted = lastReverted;
    assert !reverted, ""A function that should not revert has reverted"";
}
    uint256 assets;
    require (assets <= maxUint128());
    
    convertToShares@withrevert(e, assets);
    assert !reverted, ""Conversion to shares reverted"";
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
",This rule verifies that the amount of shares returned by the previewWithdraw function is equal to or greater than the amount returned by the withdraw function in the same transaction.,3
"rule previewMint_amount_check() {
    env e1;
    env e2;
    uint256 shares;
    address receiver;
    uint256 previewAssets;
    uint256 assets;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address owner;
    uint256 previewShares;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
        
    previewAssets = previewMint(e1,shares);
    require (shares <= convertToShares(e2,maxDeposit(receiver)) => convertToAssets(e2,shares) <= maxDeposit(receiver));
    assets = mint(e2, shares, receiver);
    assert previewAssets == assets || previewAssets == assets+1 || previewAssets+1 == assets, ""preview should be equal to actual - mint"";
",This rule verifies that the amount of assets returned by the previewMint function is equal to or very close to the amount of assets returned by the mint function when called in the same transaction.,3
"  The following rule checks that the value returned by the previewWithdraw depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewWithdraw_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 previewShares1 = previewWithdraw(e1, assets);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 previewShares2 = previewWithdraw(e2, assets);
    assert (previewShares1 == previewShares2);
",This rule needs to be verified to ensure that the value returned by previewWithdraw function is independent of the user's status.,3
"  The following rule checks that the value returned by the previewRedeem depends only on
  totalSupply() and totalAssets().
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.

// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    uint256 assets;
    address receiver;
    address owner;
    uint256 shares;
    uint256 previewShares;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
  STATUS: fail
  The value depends on the status of the user.
*/
rule previewRedeem_has_NO_threshold(env e1, env e2) {
    uint256 total_supply_1 = totalSupply();
    uint256 total_assets_1 = totalAssets(e1);   
    uint256 preview_assets_1 = previewRedeem(e1, shares);
    havoc_all();
    require (total_supply_1 == totalSupply());
    require (total_assets_1 == totalAssets(e2));
    uint256 preview_assets_2 = previewRedeem(e2, shares);
    assert (preview_assets_1 == preview_assets_2);
",This rule/invariant needs to verify that the value returned by the previewRedeem function depends only on totalSupply() and totalAssets().,3
"// rule to check the following for the previewRedeem function:
// 1. MUST return as CLOSE to and no more than the exact amount of assets that would be
//    withdrawn in a redeem call in the same transaction.
// I.e. redeem should return the same or more assets as previewRedeem if called in the
// same transaction.

// STATUS: pass
// The amount returned by previewRedeem is exactly equal to that returned by the redeem function.
rule previewRedeem_amount_check(env e1, env e2){
    uint256 shares;
    address receiver;
    address owner;
    uint256 previewAssets;
    uint256 assets;
    
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
    require (getFee() <= SCALE());  // SCALE is 10^18
    previewAssets = previewRedeem(e1, shares);
    require (shares <= convertToShares(e2,maxAssetsWithdrawableFromAave()) =>
                     convertToAssets(e2,shares) <= maxAssetsWithdrawableFromAave());
    assets = redeem(e2, shares, receiver, owner);
    assert previewAssets == assets 
        || previewAssets + 1 == assets
        //        || previewAssets + 2 == assets        
        ,""preview should the same as the actual assets received"";
}
",This rule verifies that the amount returned by the previewRedeem function is equal to or very close to the amount returned by the redeem function when called in the same transaction.,3
"rule previewDeposit_amount_check() {
    env e1;
    env e2;
    uint256 assets;
    address receiver;   
    uint256 previewShares;
    uint256 shares;

    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp <= 0xffffff;
    require _AToken.balanceOf(currentContract) <= maxUint128();
    require getAccumulatedFees() <= maxUint128();
    require getLastVaultBalance() <= maxUint128();
    require totalSupply() <= maxUint128();
// rule to check the following for the previewWithdraw function:
// 1. MUST return as close to and no fewer than the exact amount of Vault shares that
//    would be burned in a withdraw call in the same transaction.
// I.e. withdraw should return the same or fewer shares as previewWithdraw if called in
// the same transaction.
// STATUS: pass
// The amount returned by previewWithdraw is exactly equal to that returned by the withdraw function.
rule previewWithdraw_amount_check(env e1, env e2) {
    address receiver;
    address owner;
    require(getFee() <= SCALE());  // SCALE is 10^18
    previewShares = previewWithdraw(e1, assets);
    shares = withdraw(e2, assets, receiver, owner);
    
    assert previewShares == shares,""preview should be equal to actual - withdraw"";
}
    previewShares = previewDeposit(e1, assets);
    shares = deposit(e2, assets, receiver);
    assert previewShares == shares, ""preview shares should be equal to actual shares"";
","This rule verifies that the amount of shares returned by a preview function is as close to, or fewer than, the exact amount of shares that would be processed in the corresponding function call within the same transaction.",3
"rule burnNoChangeToOther(address user, uint256 amount, uint256 index, address other) {
  
	require other != user;
	
	env e;
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, amount, index);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherBalanceBefore == otherBalanceAfter;
}
","This rule needs to be verified to ensure that when a user burns tokens, it does not affect the balance of another specified address in the system.",1
"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	uint256 index = gRNVB();
	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e, delegatedUser, a, x, index);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);

	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
    assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
    // assert balanceAfter == balancebefore+x;
}
",This rule ensures that the total scaled balance of users is correctly updated and that the underlying balance matches the minted amount with a small margin of error.,5
"rule integrityDelegationWithSig(address delegator, address delegatee, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) {
    env e;
    uint256 oldNonce = nonces(e, delegator);
    delegationWithSig(e, delegator, delegatee, value, deadline, v, r, s);
    assert nonces(e, delegator) == oldNonce + 1 && borrowAllowance(e, delegator, delegatee) == value;
}
","This rule verifies that after a delegation transaction is completed with a signature, the nonce of the delegator increases by 1 and the borrow allowance between the delegator and delegatee is set to the specified value.",3
"rule burnZeroDoesntChangeBalance(address u, uint256 index) {
	env e;
	uint256 balanceBefore = balanceOf(u);
	invoke burn(e, u, 0, index);
	uint256 balanceAfter = balanceOf(u);
	assert balanceBefore == balanceAfter;
}
",This rule needs to verify that burning zero tokens does not change the balance of a specific address at a specific index.,1
"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 index) {
	env e;
	uint256 balancebefore = balanceOf(a);
	mint(e, delegatedUser, a, amount, index);
	burn(e, a, amount, index);
	uint256 balanceAfter = balanceOf(a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
",This rule needs to be verified to ensure that the minting and burning operations are functioning correctly and that the balance of a specific address remains unchanged after both operations occur.,1
"rule integrityOfBurn(address u, uint256 amount) {
	env e;
	uint256 index = gRNVB();
	uint256 balanceBeforeUser = balanceOf(u);
	uint256 totalSupplyBefore = totalSupply(e); 

	burn(e, u, amount, index);
	
	uint256 balanceAfterUser = balanceOf(u);
	uint256 totalSupplyAfter = totalSupply(e);
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
",This rule verifies the integrity of the burn function by ensuring that the total supply is reduced by the correct amount and the user's balance is reduced accordingly when ATokens are burned for underlying assets.,1
"rule additiveBurn(address user1, address user2, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));
	require user1 != currentContract && user2 != currentContract;

    burn(e, user1, x, index);
	burn(e, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	burn(e, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
",This rule needs to verify that burning tokens from two different users with the same balance results in the same final balance as burning the sum of the tokens from the two users.,1
"rule additiveMint(address user1, address user2, address user3, uint256 x, uint256 y) {
	env e;
	uint256 index = gRNVB();
    require (user1 != user2  && balanceOf(user1) == balanceOf(user2));

    mint(e, user3, user1, x, index);
	mint(e, user3, user1, y, index);
	uint256 balanceScenario1 = balanceOf(user1);
	mint(e, user3, user2, x+y, index);
	uint256 balanceScenario2 = balanceOf(user2);
    assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""burn is not additive"";
	// assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
",This rule needs to be verified to ensure that the minting of tokens is additive regardless of which user's tokens are minted.,1
"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 index, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint256 userBalanceBefore = balanceOf(user);
	uint256 otherBalanceBefore = balanceOf(other);
	mint(e, user, onBehalfOf, amount, index);
  	uint256 userBalanceAfter = balanceOf(user);
	uint256 otherBalanceAfter = balanceOf(other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter ; 
	}
	assert otherBalanceBefore == otherBalanceAfter ;
}
",This rule ensures that minting tokens for a user does not result in any change to the balance of a specified address other than the user or the onBehalfOf address.,1
"invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule needs to be verified to ensure that the state of borrowing, collateral, isolation, and siloed borrowing within the system is correctly maintained and consistent with the defined constraints and requirements.",0
"invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex

// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule needs to be verified to ensure that assets are being used consistently as collateral or for borrowing, and to check if isolation and siloed borrowing state requirements are met.",0
"// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
// }
","This rule needs to be verified to ensure that only one reserve can be borrowed at a time, and if a reserve is borrowed, it should not be possible to borrow another reserve concurrently.",0
"invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()

// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule needs to verify that only one asset is used as collateral or for borrowing when Isolation Mode State is active, and that there is at least one asset being used for borrowing or as collateral when checking for Siloed Borrowing State.",0
"// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// }
","This rule needs to verify that if one reserve is being used as collateral, then another reserve should either not be used as collateral or should be the same reserve.",0
"// rule integrityOfEmpty(uint256 reserveIndex){
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule/invariant needs to verify that when user data is empty, neither borrowing nor collateral is set for any index.",0
"invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule/invariant needs to be verified to ensure the correct usage of assets as collateral or for borrowing in the system, as well as to maintain the integrity of the isolation mode state where only one asset can act as collateral and siloed borrowing state where only one asset can be borrowed.",0
"// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
// }
","This rule needs to verify that if a specific reserve is being used as collateral, then at least one reserve is being used as collateral.",0
"rule setBorrowingNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool borrowing)
rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
",This rule verifies that changing the borrowing status of one reserve does not affect the borrowing status or collateral usage of another reserve.,0
"rule setCollateralNoChangeToOther(uint256 reserveIndex, uint256 reserveIndexOther, bool usingAsCollateral)
{
    // reserveIndexOther info
	bool otherReserveBorrowingBefore =  isBorrowing(reserveIndexOther);
	bool otherReserveCollateralBefore = isUsingAsCollateral(reserveIndexOther);

	setUsingAsCollateral(reserveIndex, usingAsCollateral);
rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
	
    // reserveIndex info
    bool ReserveBorrowingAfter =  isBorrowing(reserveIndex);
    bool otherReserveBorrowingAfter = isBorrowing(reserveIndexOther);
	bool otherReserveCollateralAfter = isUsingAsCollateral(reserveIndexOther);
    assert (reserveIndex != reserveIndexOther => 
                (otherReserveBorrowingAfter == otherReserveBorrowingBefore && 
                otherReserveCollateralAfter == otherReserveCollateralBefore));
",This rule needs to be verified to ensure that changing the collateral status of one reserve does not affect the borrowing or collateral status of another reserve.,0
"// rule IntegrityOfisUsingAsCollateralOrBorrowing(uint256 reserveIndex, bool borrowing, bool usingAsCollateral){
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
// 	bool reserveBorrowing =  isBorrowing(reserveIndex);
// 	bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert ((reserveBorrowing || reserveCollateral) <=> borrowingOrCollateral);
","This rule needs to verify that assets are either being used as collateral or for borrowing, but not both simultaneously. It also ensures that in Isolation Mode, there is exactly one asset registered as collateral, and in Siloed Borrowing Mode, there is exactly one asset being borrowed.",0
"invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()

// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 
// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This rule/invariant needs to be verified to ensure the integrity of borrowing and collateral usage across different assets, as well as to enforce requirements related to isolation mode and siloed borrowing states.",5
"// rule integrityOfisBorrowingAny(uint256 reserveIndex){
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
// }
","This rule needs to verify that if a specific reserve is currently being borrowed from, then at least one reserve must be currently being borrowed from in the system.",0
"rule  setUsingAsCollateral(uint256 reserveIndex, bool usingAsCollateral)
{
	setUsingAsCollateral(reserveIndex, usingAsCollateral);
	assert isUsingAsCollateral(reserveIndex) == usingAsCollateral;
}
",This rule needs to verify that the current setting of using a specific reserve index as collateral is accurately reflected after it has been updated.,0
"rule setBorrowing(uint256 reserveIndex, bool borrowing)
{	
	setBorrowing(reserveIndex, borrowing);
	assert isBorrowing(reserveIndex) == borrowing, ""unexpected result"";
}
",This rule/invariant needs to verify that the borrowing status for a specific reserve has been successfully updated according to the input parameter.,0
"invariant integrityOfEmpty(uint256 reserveIndex) 
	 isEmpty() => !isBorrowingAny() && !isUsingAsCollateralOrBorrowing(reserveIndex)
invariant isUsingAsCollateralOrBorrowing(uint256 reserveIndex ) 
	(isUsingAsCollateral(reserveIndex) || isBorrowing(reserveIndex)) <=>  isUsingAsCollateralOrBorrowing(reserveIndex) 

// // if at 1 asset is used as collateral and isUsingAsCollateralOne, then any other asset is not used as collateral
// rule integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisUsingAsCollateralOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isUsingAsCollateral(reserveIndex) && isUsingAsCollateralOne() => 
        !isUsingAsCollateral(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is used as collateral, isUsingAsCollateralAny is true
// // ** not implmented yet - if isUsingAsCollateralAny is true then there exist at least 1 asset that is being used as collateral
// rule integrityOfisUsingAsCollateralAny(uint256 reserveIndex){
invariant integrityOfisUsingAsCollateralAny(uint256 reserveIndex)
    isUsingAsCollateral(reserveIndex) => isUsingAsCollateralAny()
// // if at 1 asset is used for borrowing and isBorrowingOne, then any other asset is not used for borrowing
// rule integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther){
invariant integrityOfisBorrowingOne(uint256 reserveIndex, uint256 reserveIndexOther)
    isBorrowing(reserveIndex) && isBorrowingOne() => !isBorrowing(reserveIndexOther) || reserveIndexOther == reserveIndex
// // if at least 1 asset is borrowed, isBorrowing is true
// // ** not implmented yet - if isBorrowingAny is true then there exist at least 1 asset that is being used for borrowing
// rule integrityOfisBorrowingAny(uint256 reserveIndex){
invariant integrityOfisBorrowingAny(uint256 reserveIndex)
    isBorrowing(reserveIndex) => isBorrowingAny()
// // if user data is empty then for any index neither borrowing nor collateral is set
// rule integrityOfEmpty(uint256 reserveIndex){
// invariant notEmpty(uint256 reserveIndex) 
// 	(isBorrowingAny() ||  isUsingAsCollateral(reserveIndex)) => !isEmpty()
// if IsolationModeState is active then there must be exactly one asset register as collateral.
// note that this is a necessary requirement, but it is not sufficient.
rule integrityOfIsolationModeState(){
// invariant integrityOfIsolationModeState(calldataarg args)
//     !isUsingAsCollateralOne() => !isIsolated()
rule integrityOfSiloedBorrowingState(){
    bool existExactlyOneBorrow = isBorrowingOne();
    bool answer; address asset;
    answer, asset = getSiloedBorrowingState();
    assert answer => existExactlyOneBorrow;
}
    bool existExactlyOneCollateral = isUsingAsCollateralOne();
    bool answer; address asset; uint256 ceiling;
    answer, asset, ceiling = getIsolationModeState();
    assert answer => existExactlyOneCollateral;
//     bool borrowingOrCollateral = isUsingAsCollateralOrBorrowing(reserveIndex);
//     bool anyBorrowed = isBorrowingAny();
//     assert isEmpty() => !borrowingOrCollateral;
// }
//     bool reserveBorrowing = isBorrowing(reserveIndex);
//     assert reserveBorrowing => isBorrowingAny();
//     // assert exists uint256 index. isBorrowingAny() => isBorrowing(index);
//     bool reserveBorrowingOther = isBorrowing(reserveIndexOther);
//     assert reserveBorrowing && isBorrowingOne() => !reserveBorrowingOther || reserveIndexOther == reserveIndex;
//     bool reserveCollateral = isUsingAsCollateral(reserveIndex);
//     assert reserveCollateral => isUsingAsCollateralAny();
//     // assert exists uint256 index. isUsingAsCollateralAny() => isUsingAsCollateral(index);
//     bool reserveCollateralOther = isUsingAsCollateral(reserveIndexOther);
//     assert reserveCollateral && isUsingAsCollateralOne() => !reserveCollateralOther || reserveIndexOther == reserveIndex;
","This invariant needs to be verified to ensure that the state of assets being used as collateral or for borrowing is consistent and follows the specified rules, such as only one asset being used as collateral in isolation mode or only one asset being borrowed at a time.",0
"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e,a);
	mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
",This rule needs to be verified to ensure that minting a specified amount of tokens for a specific address results in the expected increase in the address's balance.,1
"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	mint(e, delegatedUser, a, x, index);
	mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	
	uint256 t = x + y;
	mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","This rule verifies that the mint function is additive, meaning that when tokens are minted separately or together, the resulting balance remains the same.",1
"rule mintNoChangeToOther(address user, address onBehalfOf, uint256 amount, uint256 rate, address other) {
	require other != user && other != onBehalfOf;

	env e;
	uint128 userDataBefore = additionalData(user);
	uint128 otherDataBefore = additionalData(other);
	uint256 userBalanceBefore = balanceOf(e, user);
	uint256 otherBalanceBefore = balanceOf(e, other);
	mint(e, user, onBehalfOf, amount, rate);
  uint128 userDataAfter = additionalData(user);
	uint128 otherDataAfter = additionalData(other);
	uint256 userBalanceAfter = balanceOf(e, user);
	uint256 otherBalanceAfter = balanceOf(e, other);
	if (user != onBehalfOf) {
		assert userBalanceBefore == userBalanceAfter && userDataBefore == userDataAfter; 
	}
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
",This rule verifies that minting tokens for a user does not affect the balances or additional data of any other address.,1
"rule integrityBurn(address a, uint256 x) {
	env e;
	require getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = balanceOf(e, a);
	burn(e,a,x);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
",This rule needs to verify that the balance of a specific address decreases by the amount specified after a burn operation is executed.,1
"rule burnNoChangeToOther(address user, uint256 amount, address other) {
  
	require other != user;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(e, other);
	burn(e, user, amount);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(e, other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
",This rule/invariant needs to be verified to ensure that burning tokens from one address does not affect the data or balance of another address.,1
"invariant principalLessThanBalance(env e, address user)
    principalBalanceOf(e, user) <= balanceOf(e, user)
    filtered { f -> !disAllowedFunctions(f) }
",This rule needs to be verified to ensure that a user's principal balance in the environment is always less than or equal to their total balance.,5
"rule burnZeroDoesntChangeBalance(address u) {
	env e;
	uint256 balanceBefore = balanceOf(e, u);
	burn(e, u, 0);
	uint256 balanceAfter = balanceOf(e, u);
	assert balanceBefore == balanceAfter;
}
",This rule verifies that burning zero tokens does not change the balance of a specific address.,1
"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	storage initialStorage = lastStorage;
	burn(e, a, x);
	burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
",This rule verifies that the total amount burned from an address is the same regardless of whether the burning is done separately for each amount or as a single combined transaction.,1
"rule inverseMintBurn(address a, address delegatedUser, uint256 amount, uint256 rate) {
	env e;
	uint256 balancebefore = balanceOf(e, a);
	mint(e, delegatedUser, a, amount, rate);
	burn(e, a, amount);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}
",This rule needs to be verified to ensure that minting tokens for a delegated user and subsequently burning the same amount results in no change in the balance of the original account.,1
"By finding a violation, this rule checks that one can burn when there totalSupply is zero.
It is commented out since it should fail 
rule canBurnAtZero() {
	env e;
	address user;
	require totalSupply(e) == 0;
	uint256 userRate = additionalData(user);
	uint256 previousPrincipalBalance;
    uint256 newPrincipalBalance;
    uint256 diff;
	previousPrincipalBalance, newPrincipalBalance, diff =  _calculateBalanceIncrease(e,user);
	uint256 amount; 
	invoke burn(e,user,amount);
	assert amount>0 => lastReverted;
}
",This rule needs to be verified to ensure that burning tokens is not allowed when the total token supply is zero.,1
"rule setSiloedBorrowingIntegrity(bool siloed) {
    setSiloedBorrowing(siloed);
    assert getSiloedBorrowing() == siloed;
}
","This rule needs to be verified to ensure that the siloed borrowing integrity setting is correctly enabled or disabled within the system, helping to maintain the integrity and security of borrowing activities.",0
"rule setBorrowCapIntegrity(uint256 borrowCap) {
    setBorrowCap(borrowCap);
    assert getBorrowCap() == borrowCap;
}
",This rule needs to be verified to ensure that the borrow cap value set in the contract matches the value provided as an input parameter.,0
"rule setUnbackedMintCapIntegrity(uint256 unbackedMintCap) {
    setUnbackedMintCap(unbackedMintCap);
    assert getUnbackedMintCap() == unbackedMintCap;
}
",This rule ensures that the value of the unbacked mint cap is set correctly and remains unchanged after being set.,3
"rule setDebtCeilingIntegrity(uint256 ceiling) {
    setDebtCeiling(ceiling);
    assert getDebtCeiling() == ceiling;
}
",This rule verifies that setting the debt ceiling to a specific value maintains integrity by ensuring that the debt ceiling value matches the newly set value.,0
"rule setLtvIntegrity(uint256 ltv) {
    setLtv(ltv);
    assert getLtv() == ltv;
}
",This rule/invariant needs to be verified to ensure that the value set for a specific parameter remains unchanged throughout the execution of the smart contract.,3
"rule setEModeCategoryIntegrity(uint256 category) {
    setEModeCategory(category);
    assert getEModeCategory() == category;
}
",This rule/invariant needs to verify that the EMode category value is set correctly and maintained without being altered.,2
"rule setBorrowableInIsolationIntegrity(bool borrowable) {
    setBorrowableInIsolation(borrowable);
    assert getBorrowableInIsolation() == borrowable;
}
","This rule needs to be verified in order to ensure that the function correctly sets and retrieves the value indicating whether an item can be borrowed in isolation, maintaining the integrity of this specific property.",2
"rule setSupplyCapIntegrity(uint256 supplyCap) {
    setSupplyCap(supplyCap);
    assert getSupplyCap() == supplyCap;
}
",This rule needs to verify that the supply cap of a certain amount is correctly set and maintained within the system.,0
"rule setReserveFactorIntegrity(uint256 reserveFactor) {
    setReserveFactor(reserveFactor);
    assert getReserveFactor() == reserveFactor;
}
",This rule needs to verify that the reserve factor set in the system remains consistent and correct after it has been modified.,0
"rule setLiquidationProtocolFeeIntegrity(uint256 liquidationProtocolFee) {
    setLiquidationProtocolFee(liquidationProtocolFee);
    assert getLiquidationProtocolFee() == liquidationProtocolFee;
}
","This rule ensures that when setting a liquidation protocol fee, the fee value remains unchanged after the operation is completed, maintaining the integrity of the fee value.",3
"// rule accruToTreasury()
// {
// 	env e;
// 	calldataarg args;
// 	calldataarg args2;
// 	calldataarg args3;
// 	storage init = lastStorage;
// 	mintToTreasury(e, args);
// 	flashLoan(e, args2);
// 	//mintToTreasury(e, args);
// 	uint256 withMintBefore = getReserveNormalizedIncome(e, args3);
// 	flashLoan(e, args2) at init;
// 	uint256 withoutMintBefore = getReserveNormalizedIncome(e, args3);
// 	assert withoutMintBefore == withMintBefore;
// }",This rule verifies that the treasury receives the correct amount of funds after minting and repaying a flash loan within the same transaction.,5
"rule getReserveNormalizedVariableDebtCheck()
{
	env e1;
	calldataarg args;
	calldataarg args2;
    address asset; uint256 amount; address onBehalfOf; uint16 referralCode;
    require asset != _aToken;
	uint256 oldIndex = getReserveNormalizedVariableDebt(e1, args);
    uint256 totalDebtBefore = getCurrScaledVariableDebt(asset);
	supply(e1, asset, amount, onBehalfOf, referralCode);
	uint256 newIndex = getReserveNormalizedVariableDebt(e1, args);
	assert totalDebtBefore != 0 => newIndex >= oldIndex;
}
","This rule verifies that the normalized variable debt of a reserve increases after supplying an asset, unless the total variable debt before supplying was zero.",0
"// rule withdrawCheck()
// {
// 	env e;
// 	address to;
// 	address asset;
// 	uint256 part1;
// 	uint256 part2;
// 	storage init = lastStorage;
// 	withdraw(e, asset, part1, to);
// 	withdraw(e, asset, part2, to);
// 	withdraw@withrevert(e, asset, part1 + part2, to) at init;
// 	assert !lastReverted;
// }
",This rule verifies that a user is unable to withdraw more than their total balance of a specific asset from a contract by making multiple withdrawal requests.,5
"rule burnNoChangeToOther(address user, address recieverOfUnderlying, uint256 amount, uint256 index, address other) 
{
  
	require other != user && other != recieverOfUnderlying;
	
	env e;
	uint256 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	burn(e, user, recieverOfUnderlying, amount, index);
	uint256 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);

	assert otherDataBefore == otherDataAfter && 
	       otherBalanceBefore == otherBalanceAfter;
}
",This rule needs to be verified to ensure that burning tokens from one address does not affect the data or balance of another address or recipient of the underlying asset.,1
"rule mintNoChangeToOther(address user, uint256 amount, uint256 index, address other)
{
	require other != user;

	env e;
	uint128 otherDataBefore = additionalData(other);
	uint256 otherBalanceBefore = balanceOf(other);
	address caller; 
	mint(e, caller, user, amount, index);
	uint128 otherDataAfter = additionalData(other);
	uint256 otherBalanceAfter = balanceOf(other);
	assert otherBalanceBefore == otherBalanceAfter && otherDataBefore == otherDataAfter;
}
",This rule needs to verify that minting tokens for one user does not change the balance or additional data of another user.,1
"// rule integrityBalanceOfTotalSupply(address a, address b, method f)
// {
// 	env e;
// 	require a!=b;
// 	uint256 balanceABefore = balanceOf(e,a);
// 	uint256 balanceBBefore = balanceOf(e,b);
// 	uint256 totalSupplyBefore = totalSupply(e);
	 
// 	calldataarg arg;
// 	sinvoke f(e, arg); 

// 	uint256 balanceAAfter = balanceOf(e,a);
// 	uint256 balanceBAfter = balanceOf(e,b);
// 	uint256 totalSupplyAfter = totalSupply(e);
// 	assert (balanceAAfter != balanceABefore && balanceBAfter != balanceBBefore) =>
// 	    ( (balanceAAfter - balanceABefore) + (balanceBAfter - balanceBBefore)  == totalSupplyAfter - totalSupplyBefore);
// 	require f.selector != transferFrom(address,address,uint256).selector &&
// 	        f.selector != transfer(address,uint256).selector &&
// 	        f.selector != transferOnLiquidation(address,address,uint256).selector;
// 	assert (balanceAAfter != balanceABefore &&  balanceBAfter == balanceBBefore ) =>
// 	    ( (balanceAAfter - balanceABefore)   == totalSupplyAfter - totalSupplyBefore);
		
// }
","This rule needs to be verified to ensure that the balance changes after a method invocation align with the total supply changes, and certain transfer methods are not used within the method being tested.",5
"rule additiveTransfer(address from1, address from2, address to1, address to2, uint256 x, uint256 y)
{
	env e1;
	env e2;
    uint256 indexRay = gRNI();
	require (from1 != from2 && to1 != to2 && from1 != to2 && from2 != to1 && 
	        (from1 == to1 <=> from2 == to2) &&
			 balanceOf(from1) == balanceOf(from2) && balanceOf(to1) == balanceOf(to2));

	require e1.msg.sender == from1;
	require e2.msg.sender == from2;
	transfer(e1, to1, x);
	transfer(e1, to1, y);
	uint256 balanceFromScenario1 = balanceOf(from1);
	uint256 balanceToScenario1 = balanceOf(to1);
	transfer(e2, to2, x+y);
	
	uint256 balanceFromScenario2 = balanceOf(from2);
	uint256 balanceToScenario2 = balanceOf(to2);
	assert 	bounded_error_eq(balanceFromScenario1, balanceFromScenario2, 3)  &&
	 		bounded_error_eq(balanceToScenario1, balanceToScenario2, 3), ""transfer is not additive"";
}
","This rule needs to be verified to ensure that the transfer of tokens is additive, meaning that the total amount of tokens transferred is consistent across different scenarios involving multiple addresses.",1
"rule integrityBurn(address user, address to, uint256 amount)
{
	env e;
	uint256 indexRay = gRNI();

	require user != currentContract;
	uint256 balanceBeforeUser = balanceOf(user);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingBeforeUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingBeforeSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyBefore = totalSupply(e); 
	burn(e, user, to, amount, indexRay);
	
	uint256 balanceAfterUser = balanceOf(user);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterTo =  _underlyingAsset.balanceOf(e, to);
	uint256 underlyingAfterUser =  _underlyingAsset.balanceOf(e, user);
	uint256 underlyingAfterSystem =  _underlyingAsset.balanceOf(e, currentContract);
	uint256 totalSupplyAfter = totalSupply(e);
	if (user != to) {
		assert balanceAfterTo == balanceBeforeTo && // balanceOf To should not change
		bounded_error_eq(underlyingBeforeUser, underlyingAfterUser, 1), ""integrity break on user!=to"";
	}
	if (to != currentContract) {
		assert bounded_error_eq(underlyingAfterSystem, underlyingBeforeSystem - amount, 1) && // system transfer underlying_asset
		bounded_error_eq(underlyingAfterTo,  underlyingBeforeTo + amount, 1) , ""integrity break on to!=currentContract"";
	} else {
		assert underlyingAfterSystem == underlyingBeforeSystem, ""integrity break on to==currentContract"";
	} 
    assert bounded_error_eq(totalSupplyAfter, totalSupplyBefore - amount, 1), ""total supply integrity""; // total supply reduced
    assert bounded_error_eq(balanceAfterUser, balanceBeforeUser - amount, 1), ""integrity break"";  // user burns ATokens to recieve underlying
}
","This rule needs to be verified to ensure the integrity of token balances, underlying asset balances, and total supply when a user burns tokens.",1
"rule additiveBurn(address user1, address user2, address to1, address to2, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require (user1 != user2 && to1 != to2 && user1 != to2 && user2 != to1 && 
	        (user1 == to1 <=> user2 == to2) &&
			 balanceOf(user1) == balanceOf(user2) && balanceOf(to1) == balanceOf(to2));
	require user1 != currentContract && user2 != currentContract;

	sinvoke burn(e, user1, to1, x, indexRay);
	sinvoke burn(e, user1, to1, y, indexRay);
	uint256 balanceUserScenario1 = balanceOf(user1);
	
	sinvoke burn(e, user2, to2, x+y, indexRay);
	uint256 balanceUserScenario2 = balanceOf(user2);
	assert 	bounded_error_eq(balanceUserScenario1, balanceUserScenario2, 3), ""burn is not additive"";
}
","This rule verifies that the balance after burning tokens from different users and sending them to different recipients is additive, meaning the total balance remains the same regardless of the order in which the burns are executed.",1
"rule integrityTransfer(address from, address to, uint256 amount)
{
	env e;
	require e.msg.sender == from;
	address other; // for any address including from, to, currentContract the underlying asset balance should stay the same
	
	uint256 balanceBeforeFrom = balanceOf(from);
	uint256 balanceBeforeTo = balanceOf(to);
	uint256 underlyingBeforeOther =  _underlyingAsset.balanceOf(e, other);
	transfer(e, to, amount);
	uint256 balanceAfterFrom = balanceOf(from);
	uint256 balanceAfterTo = balanceOf(to);
	uint256 underlyingAfterOther =  _underlyingAsset.balanceOf(e, other);
	assert underlyingAfterOther == underlyingBeforeOther, ""unexpected change in underlying asserts"";
	if (from != to) {
		assert bounded_error_eq(balanceAfterFrom, balanceBeforeFrom - amount, 1) &&
	 		bounded_error_eq(balanceAfterTo, balanceBeforeTo + amount, 1), ""unexpected balance of from/to, when from!=to"";
	} else {
		assert balanceAfterFrom == balanceAfterTo , ""unexpected balance of from/to, when from==to"";
	}
}
","This rule/invariant needs to verify that the underlying asset balance remains the same after a transfer between two addresses, and that the balances of both addresses are updated correctly.",5
"rule permitIntegrity(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) 
{
    env e;
    uint256 nonceBefore = nonces(owner);
    permit(e, owner, spender, value, deadline, v, r, s);
    assert allowance(owner, spender) == value;
    assert nonces(owner) == nonceBefore + 1;
}
","This rule verifies that after permitting a spender to spend tokens on behalf of the owner, the allowance value is set correctly and the nonce value for the owner is incremented by one.",3
"rule integrityMint(address a, address b, uint256 x) 
{
	env e;
	uint256 indexRay = gRNI();

	uint256 underlyingBalanceBefore = balanceOf(a);
	uint256 atokenBlanceBefore = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyBefore = scaledTotalSupply(e);
	mint(e,b,a,x,indexRay);
	
	uint256 underlyingBalanceAfter = balanceOf(a);
	uint256 atokenBlanceAfter = scaledBalanceOf(e, a);
	uint256 totalATokenSupplyAfter = scaledTotalSupply(e);
	assert atokenBlanceAfter - atokenBlanceBefore == totalATokenSupplyAfter - totalATokenSupplyBefore;
	assert totalATokenSupplyAfter > totalATokenSupplyBefore;
	assert bounded_error_eq(underlyingBalanceAfter, underlyingBalanceBefore+x, 1);
}
",This rule verifies that minting a certain amount of tokens for a specific address results in the correct changes in balances and total token supply.,1
"rule additiveMint(address a, address b, address c, uint256 x, uint256 y) 
{
	env e;
	uint256 indexRay = gRNI();
	require(balanceOf(a) == balanceOf(b) && a != b);
	uint256 balanceScenario0 = balanceOf(a);
	// storage initialStorage = lastStorage;
	mint(e,c,a,x,indexRay);
	mint(e,c,a,y,indexRay);
	uint256 balanceScenario1 = balanceOf(a);
	// mint(e,c, a, x+y ,indexRay) at initialStorage;
	mint(e, c, b, x+y ,indexRay);

	uint256 balanceScenario2 = balanceOf(b);
	assert bounded_error_eq(balanceScenario1, balanceScenario2, 3), ""mint is not additive"";
}
","This rule verifies that the mint operation is additive, meaning that minting tokens to two different addresses and then minting the same total amount to a single address should result in the same final balance for that address.",1
"rule integirtyBalanceOfTotalSupplyOnBurn(address a)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke burn(e, a, x, index); 
	assert (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
","This rule verifies that the balance of a specific address remains proportional to the total supply after a burn operation, ensuring integrity in the token balance calculations.",1
"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a != b;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter);
}
","This rule needs to verify that after a certain method is invoked by two different addresses, the balances of the two addresses remain the same or change in a way that maintains overall balance consistency.",5
"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x, index);
	sinvoke burn(e, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
",This rule verifies that the balance after burning two separate amounts of a token is equal to the balance after burning the total sum of those amounts.,1
"rule additiveMint(address a, address delegatedUser, uint256 x, uint256 y) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","This rule needs to verify that the mint function is additive, meaning that if two separate mint transactions are executed, the resulting balance should be the same as if a single mint transaction for the combined amount was executed.",1
"rule integrityMint(address u, address delegatedUser, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e,asset);
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 balanceDelegatedUBefore = balanceOf(e, delegatedUser);
	sinvoke mint(e, delegatedUser, u, x, index);
	
	uint256 balanceUAfter = balanceOf(e, u);
	uint256 balanceDelegatedUAfter = balanceOf(e, delegatedUser);
	assert balanceUAfter == balanceUBefore + x && (u != delegatedUser => (balanceDelegatedUAfter == balanceDelegatedUBefore));
}
","This rule verifies that the balance of a user remains accurate after minting tokens to themselves or to a delegated user, preventing any unauthorized changes to the user's balances.",1
"rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","This rule verifies that the balance of a specific address plus the total supply remain consistent after executing a certain method, excluding specific types of methods.",5
"rule integrityBurn(address a, uint256 x) {
	env e;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke burn(e, a, x, index);
	
	uint256 balanceAfter = balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","This rule verifies that after burning a certain amount of a specific asset, the balance of the address decreases by the same amount.",1
"rule integirtyBalanceOfTotalSupplyOnMint(address u, address delegatedUser)
rule integirtyBalanceOfTotalSupply(address a, method f)
{
	env e;
	
	uint256 balanceABefore = balanceOf(e, a);
	uint256 totalSupplyBefore = totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256, uint256).selector  &&
		f.selector != mint(address, address, uint256, uint256).selector);
	uint256 balanceAAfter = balanceOf(e, a);
	uint256 totalSupplyAfter = totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => ( balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	uint256 balanceUBefore = balanceOf(e, u);
	uint256 x;
	address asset;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	sinvoke mint(e, delegatedUser, u, x, index); 
	uint256 balanceUAfter = balanceOf(e, u);
	assert (balanceUAfter != balanceUBefore  => (balanceUAfter - balanceUBefore  == totalSupplyAfter - totalSupplyBefore));
","This rule needs to be verified to ensure that upon minting tokens or changing balances, the total supply remains consistent with the individual balances across all accounts.",5
"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address asset;
	address delegatedUser;
	uint256 index = POOL.getReserveNormalizedVariableDebt(e, asset);
	uint256 balancebefore = balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x, index);
	uint256 balanceAfter = balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}",This rule needs to be verified to ensure that the balance of an address remains unchanged after minting and burning a specific amount of tokens.,1
"rule integirtyBalanceOfTotalSupplyOnBurn(address a, uint256 x)
rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
	
	uint256 averageStableRateBefore = sinvoke getAverageStableRate(e);
	uint256 debtSupplyBefore = sinvoke rayWadMul(e, averageStableRateBefore, totalSupplyBefore);
	uint256 stableRateA = sinvoke getUserStableRate(e, a);
	uint256 repaidDebtA = sinvoke rayWadMul(e, stableRateA, x);
	sinvoke burn(e, a, x); 
	if(totalSupplyBefore > x) {
	    /* The amount being burned (x) is smaller than the total supply */
		if(repaidDebtA >= debtSupplyBefore) {
			/*
			The user debt being repaid is at least the debt supply.
			The total supply becomes 0.
			*/
			assert(totalSupplyAfter == 0);
		}
		else {
			assert(balanceAAfter != balanceABefore  =>
			(balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
	}
	else {
	/* The amount being burned (x) is at least the total supply.
	   The total supply becomes 0.
	*/
		assert (totalSupplyAfter == 0);
","This rule needs to be verified to ensure that the balance and total supply are accurately adjusted after a burn operation, taking into account the user's stable rate and debt supply.",1
"rule additiveBurn(address a, uint256 x,  uint256 y) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	storage initialStorage = lastStorage;
	sinvoke burn(e, a, x);
	sinvoke burn(e, a, y);
	uint256 balanceScenario1 = balanceOf(e, a);
	uint256 t = x + y;
	sinvoke burn(e, a, t) at initialStorage;

	uint256 balanceScenario2 = balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""burn is not additive"";
}
",This rule verifies that the burn function is additive by checking the balance of an address after multiple burns are performed.,1
"rule balanceOfChange(address a, address b, method f)
{
	env e;
	require a!=b;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 balanceBBefore = sinvoke balanceOf(e, b);
	 
	calldataarg arg;
	sinvoke f(e, arg); 

	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 balanceBAfter = sinvoke balanceOf(e, b);
	
	assert (balanceABefore == balanceAAfter || balanceBBefore == balanceBAfter );
}
",This rule ensures that the balance of two different addresses remains balanced after a specific method function is called.,5
"rule integirtyBalanceOfTotalSupply(address a, method f )
{
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 balanceABefore = sinvoke balanceOf(e, a);
	uint256 totalSupplyBefore = sinvoke totalSupply(e);
	 
	calldataarg arg;
	sinvoke f(e, arg); 
	require (f.selector != burn(address, uint256).selector);
	uint256 balanceAAfter = sinvoke balanceOf(e, a);
	uint256 totalSupplyAfter = sinvoke totalSupply(e);

	assert  (balanceAAfter != balanceABefore  => (balanceAAfter - balanceABefore  == totalSupplyAfter - totalSupplyBefore));
}
","This rule verifies that the balance of an address and the total supply remain consistent after a specific function call, except in the case of a burn operation.",1
"rule additiveMint(address a, uint256 x, uint256 y) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	require getUserStableRate(e, a) == 0;
	uint256 index;
	storage initialStorage = lastStorage;
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke mint(e, delegatedUser, a, y, index);
	uint256 balanceScenario1 = sinvoke balanceOf(e, a);
	
	uint256 t = x + y;
	sinvoke mint(e, delegatedUser, a, t ,index) at initialStorage;
	uint256 balanceScenario2 = sinvoke balanceOf(e, a);
	assert balanceScenario1 == balanceScenario2, ""mint is not additive"";
}
","This rule needs to be verified to ensure that minting tokens is an additive operation, meaning that minting tokens individually and then together should result in the same final balance.",1
"rule integrityBurn(address a, uint256 x) {
	env e;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke burn(e,a,x);
	
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balanceAfter == balancebefore - x;
}
","This rule verifies that the balance of an address decreases by a specific amount after a burn operation is executed, ensuring the integrity and consistency of the token balance.",1
"rule inverseMintBurn(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e, a);
	sinvoke mint(e, delegatedUser, a, x, index);
	sinvoke burn(e, a, x);
	uint256 balanceAfter = sinvoke balanceOf(e, a);
	assert balancebefore == balanceAfter, ""burn is not the inverse of mint"";
}",This rule needs to be verified to ensure that the balance of an address remains the same after minting and burning tokens in a decentralized system.,1
"rule integrityMint(address a, uint256 x) {
	env e;
	address delegatedUser;
	require sinvoke getIncentivesController(e) == 0;
	uint256 index;
	uint256 balancebefore = sinvoke balanceOf(e,a);
	sinvoke mint(e, delegatedUser, a, x, index);
	
	uint256 balanceAfter = sinvoke balanceOf(e,a);
	assert balanceAfter == balancebefore+x;
}
",This rule needs to be verified to ensure that the minting of tokens by a delegated user results in the correct increase in the balance of the specified address.,1
"rule getClaimableRewards_stable_after_atoken_transferFrom()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
",This rule verifies that the claimable rewards of a user do not change after transferring a certain amount of tokens to the current contract.,5
"rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
","This rule needs to be verified to ensure that only eligible non-view and non-claim functions, excluding the initialize function, are allowed to claim total claimable rewards.",3
"rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
",This rule verifies that only non-view functions that are not related to claimable rewards or specific contract initialization or deposit functions are allowed to be called.,3
"invariant inv_atoken_balanceOf_leq_totalSupply_redeem(address user)
invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
    filtered { f -> f.selector == redeem(uint256,address,address,bool).selector}
","This rule needs to be verified to ensure that the balance of a user remains less than or equal to the total supply of a token, except when a specific function is being called.",5
"rule getClaimableRewardsBefore_leq_claimed_claimRewardsOnBehalf(method f)
{   
    env e;
    address onBehalfOf;
    address receiver; 
    address my_reward;
    address[] rewards;
    //setup(e, onBehalfOf, receiver);   
    
    mathint balanceBefore = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint claimableRewardsBefore = getClaimableRewards(e, onBehalfOf, my_reward);
    claimRewardsOnBehalf(e, onBehalfOf, receiver, rewards);
    mathint balanceAfter = _DummyERC20_rewardToken.balanceOf(onBehalfOf);
    mathint deltaBalance = balanceAfter - balanceBefore;
   
    assert deltaBalance <= claimableRewardsBefore;
}
",This rule needs to verify that the amount of rewards claimed on behalf of a user is less than or equal to the total claimable rewards for that user before claiming.,3
"rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
",This rule verifies that the total assets held by the contract remain stable when certain functions related to claiming rewards are called.,5
"invariant inv_atoken_balanceOf_leq_totalSupply(address user)
	_AToken.balanceOf(user) <= _AToken.totalSupply()
     filtered { f -> !f.isView && f.selector != redeem(uint256,address,address,bool).selector}
",This rule needs to be verified to ensure that the token balance of a user never exceeds the total supply of the token.,1
"rule getClaimableRewards_stable_after_atoken_transferFrom_1()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
rule getClaimableRewards_stable_after_atoken_transferFrom()
{
    env e;
    calldataarg args;
    address user;
    address reward;

    address sender;
    uint256 amount;
    
    require user != 0;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    _AToken.transferFrom(e, sender, currentContract, amount);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
   // require isRegisteredRewardToken(reward); //todo: review the assumption
    setup(e, user);
",This rule verifies that the claimable rewards for a user remain stable after an AToken transferFrom operation within a smart contract.,5
"rule getClaimableRewards_stable_after_metaWithdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    metaWithdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","This rule verifies that after calling a specific function to withdraw funds, the user's claimable rewards in a stablecoin remain unchanged.",5
"rule getClaimableRewards_stable_after_withdraw(){
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }

    env e;
    calldataarg args;
    address user;
    address reward;
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    withdraw(e, args);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
",This rule verifies that the claimable rewards for a user remain stable after they withdraw from a specific contract.,5
"invariant inv_atoken_balanceOf_2users_leq_totalSupply(address user1, address user2)
	(_AToken.balanceOf(user1) + _AToken.balanceOf(user2))<= _AToken.totalSupply()
    {
		preserved with (env e1){
            setup(e1, user1);
		    setup(e1, user2);
		}
        preserved redeem(uint256 shares, address receiver, address owner) with (env e2){
            require user1 != user2;
            require _AToken.balanceOf(currentContract) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        }
        preserved redeem(uint256 shares, address receiver, address owner, bool toUnderlying) with (env e3){
        	requireInvariant sumAllATokenScaledBalance_eq_totalSupply();
            require _AToken.balanceOf(e3.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
        preserved withdraw(uint256 assets, address receiver,address owner) with (env e4){
            require _AToken.balanceOf(e4.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();

        preserved metaWithdraw(address owner, address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 deadline,_StaticATokenLM.SignatureParams sigParams)
        with (env e5){
            require _AToken.balanceOf(e5.msg.sender) + _AToken.balanceOf(user1) + _AToken.balanceOf(user2) <= _AToken.totalSupply();
	}
",This rule ensures that the sum of the balances of two specified users for a specific token does not exceed the total supply of that token.,1
"rule totalAssets_stable_after_collectAndUpdateRewards()
rule totalAssets_stable(method f)
    filtered { f -> (f.selector == claimRewardsToSelf(address[]).selector ||
                    f.selector == claimRewards(address, address[]).selector ||
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector) }
{
    env e;
    require _RewardsController.getRewardsByAsset(_AToken, 0) != _AToken;
    require _RewardsController.getUserAccruedReward(currentContract, _AToken, _AToken) ==0;
    address reward;
    mathint totalAssetBefore = totalAssets(e);
    collectAndUpdateRewards(e, reward); 
    mathint totalAssetAfter = totalAssets(e);
    assert totalAssetAfter == totalAssetBefore;
}
",This rule verifies that the total assets remain stable after collecting and updating rewards from the Rewards Controller.,5
"rule reward_balance_stable_after_collectAndUpdateRewards()
{
    env e;
    address reward;
    address sender;
    uint256 amount;

    storage initial = lastStorage;
    collectAndUpdateRewards(e, reward); 
    mathint reward_balance_before = _DummyERC20_rewardToken.balanceOf(currentContract);
    _AToken.transferFrom(e, sender, currentContract, amount) at initial;
    mathint reward_balance_after = _DummyERC20_rewardToken.balanceOf(currentContract);
    assert reward_balance_before == reward_balance_after;
}
",This rule verifies that the reward balance remains stable after collecting and updating rewards and transferring tokens to the contract.,5
"rule getClaimableRewards_stable_after_deposit()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{
    env e;
    address user;
    address reward;
    
    uint256 assets;
    address recipient;
    uint16 referralCode;
    bool fromUnderlying = true;

    require user != 0;
    require getRewardTokensLength() == 1;
    require _RewardsController.getAvailableRewardsCount(_AToken)  > 0;
    require _RewardsController.getRewardsByAsset(_AToken, 0) == _DummyERC20_rewardToken;
    require currentContract != user;
    require _AToken != user;
    require _RewardsController !=  user;
    require _DummyERC20_aTokenUnderlying  != user;
    require _DummyERC20_rewardToken != user;
    require _SymbolicLendingPoolL1 != user;
    require _TransferStrategy != user;
    require _ScaledBalanceToken != user;
    //assume a single reward
    require reward == _DummyERC20_rewardToken;
    require getRewardToken(0) == _DummyERC20_rewardToken;
    //require isRegisteredRewardToken(reward); //todo: review the assumption
 
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    deposit(e, assets, recipient,referralCode,fromUnderlying);
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
","This rule needs to verify that the claimable rewards remain the same after a deposit is made in the protocol, ensuring the stability of rewards for users.",5
"rule sanity_metaDeposit    ()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaDeposit(e,args);
",This rule needs to be verified to ensure that the deposit function is functioning correctly and in accordance with the specified meta-transaction parameters.,5
"rule getClaimableRewards_stable_after_refreshRewardTokens()
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
{

    env e;
    address user;
    address reward;
    //require isRegisteredRewardToken(reward); //todo: review assumption
    mathint claimableRewardsBefore = getClaimableRewards(e, user, reward);
    refreshRewardTokens(e);
    setup(e, user);    
    mathint claimableRewardsAfter = getClaimableRewards(e, user, reward);
    assert claimableRewardsAfter == claimableRewardsBefore;
}
",This rule needs to verify that the claimable rewards for a user remain stable after refreshing the reward tokens.,3
"/// @title special case of rule getClaimableRewards_stable for initialize
//fail
//todo: consider removing this rule. no method is called before initialize()
/// @title getClaimableRewards() is stable after initialize()
/// @dev case splitting
rule getClaimableRewards_stable_after_initialize(method f)
    filtered { f -> !f.isView && !claimFunctions(f) }{
",This rule needs to verify that the getClaimableRewards function remains stable after the initialize function has been called.,3
"rule totalClaimableRewards_stable_after_initialized()
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
{
    env e;
    require e.msg.sender != currentContract;
    setup(e, 0);
    calldataarg args;
    address reward;

    require e.msg.sender != reward;
 
    require currentContract != e.msg.sender;
    require _AToken != e.msg.sender;
    require _RewardsController != e.msg.sender;
    require _DummyERC20_aTokenUnderlying  != e.msg.sender;
    require _DummyERC20_rewardToken != e.msg.sender;
    require _SymbolicLendingPoolL1 != e.msg.sender;
    require _TransferStrategy != e.msg.sender;
    require _ScaledBalanceToken != e.msg.sender;
    require currentContract != reward;
    require _AToken != reward;
    require _RewardsController !=  reward;
    require _DummyERC20_aTokenUnderlying  != reward;
    require _SymbolicLendingPoolL1 != reward;
    require _TransferStrategy != reward;
    require _ScaledBalanceToken != reward;
    address newAToken;
    string staticATokenName;
    string staticATokenSymbol;
    mathint totalClaimableRewardsBefore = getTotalClaimableRewards(e, reward);
    initialize(e, newAToken, staticATokenName, staticATokenSymbol);
    mathint totalClaimableRewardsAfter = getTotalClaimableRewards(e, reward);
    assert totalClaimableRewardsAfter == totalClaimableRewardsBefore;
}
","This rule ensures that the total claimable rewards remain stable after the contract has been initialized with new parameters, for methods that are not related to claim functions or initialization.",3
"rule totalClaimableRewards_stable_SANITY(method f)
rule totalClaimableRewards_stable(method f)
    filtered { f -> !f.isView && !claimFunctions(f)  && f.selector != initialize(address,string,string).selector  }
    filtered { f -> f.selector == claimSingleRewardOnBehalf(address, address,address).selector   }
",This rule needs to verify that functions related to claiming rewards have been properly implemented without any unnecessary or unintended functionalities or interactions. It also ensures that certain functions are excluded from the filtering process.,3
"rule sanity_metaWithdraw()
rule sanity(method f)
{
	env e;
	calldataarg args;
	f(e,args);
	assert false;
}
	metaWithdraw(e,args);
","This rule/invariant needs to be verified to ensure that the withdrawal functionality in the smart contract is functioning correctly and securely, without any unexpected behaviors or vulnerabilities.",5
"rule getClaimableRewards_stable_SANITY(method f)
rule getClaimableRewards_stable(method f)
    filtered { f -> !f.isView
                    && !claimFunctions(f)
                    && f.selector != initialize(address,string,string).selector
                    && f.selector != deposit(uint256,address,uint16,bool).selector
    }
    filtered { f -> //claimFunctions(f)
                    f.selector == claimRewardsOnBehalf(address, address,address[]).selector   
","This rule needs to be verified to ensure that only specific types of functions related to claiming rewards are included, while excluding functions related to initialization and deposits.",3
"rule rewardsTotalDoesNotDeclineByDeposit(uint256 assets) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	deposit(e, assets, e.msg.sender);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by deposit"";
}
",This rule needs to verify that the total claimable rewards do not decrease when a deposit is made by an address other than the current contract.,5
"rule rewardsTotalDoesNotDeclineByWithdraw() {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	uint256 preTotal = getTotalClaimableRewards(e);
	calldataarg args;
	withdraw(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	assert (postTotal >= preTotal), ""Total rewards declines by withdraw"";
}
",This rule verifies that the total amount of rewards available for claiming does not decrease when a user withdraws rewards from the incentives controller.,5
"rule rewardsTotalDeclinesOnlyByClaim(method f) {
	require aRewardsController == incentivesController();

	env e;
	require e.msg.sender != currentContract;
	require f.selector != initialize(address, address, string, string).selector;
	uint256 preTotal = getTotalClaimableRewards(e);
	uint256 preRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	calldataarg args;
	f(e, args);
	uint256 postTotal = getTotalClaimableRewards(e);
	uint256 postRewards = aRewardsController.getUserAccruedRewards(e, currentContract, aRewardToken);
	require preRewards == postRewards;
	assert (postTotal < preTotal) => (
		(f.selector == claimRewardsOnBehalf(address, address).selector) ||
		(f.selector == claimRewards(address).selector) ||
		(f.selector == claimRewardsToSelf().selector)
	), ""Total rewards decline not due to claim"";
}
","This rule verifies that the total claimable rewards can only decline when a rewards claim method is called, and not for any other reason.",3
"    // If any rule that count on the reward token balance, calls this method a `require RewardsVault != to` make sense to add
    //claimRewards(address[], uint256, address) returns (uint256) => DISPATCHER(true)
    getRewardsBalance(address[], address) returns (uint256) => DISPATCHER(true)

/***************************
 *     BridgeL2Harness     *
 ***************************/
    BRIDGE_L2.l2RewardsIndexSetter(uint256)
    BRIDGE_L2.deposit(address, uint256, address) 
    BRIDGE_L2.initiateWithdraw(address, uint256, address, address, bool)
    BRIDGE_L2.bridgeRewards(address, address, uint256)
    BRIDGE_L2.claimRewards(address, address)
    BRIDGE_L2.l2RewardsIndex() returns (uint256) envfree
    BRIDGE_L2.getStaticATokenAddress(address) returns (address) envfree
    BRIDGE_L2.address2uint256(address) returns (uint256) envfree
    l1ToL2MessageNonce() returns (uint256) => NONDET
/******************
 *     Tokens     *
 ******************/
    UNDERLYING_ASSET_ADDRESS() returns (address) => DISPATCHER(true)
    ATOKEN_A.UNDERLYING_ASSET_ADDRESS() returns (address) envfree
    ATOKEN_B.UNDERLYING_ASSET_ADDRESS() returns (address) envfree  
    claimRewards(address) returns (uint256) => DISPATCHER(true)
    getRewTokenAddress() returns (address) => rewardToken()
 *     Ray Math   *
 // See also notes at bottom of file (under ""Summarizations"")
 // Comment out the next two lines to remove the simplification,
 // and let the prover use the original library functions.
   // rayMul(uint256 a, uint256 b) returns (uint256) => rayMulConst(a, b)
   // rayDiv(uint256 a, uint256 b) returns (uint256) => rayDivConst(a, b)
}
////////////////////////////////////////////////////////////////////////////
//                       Definitions                                      //
// Definition of RAY unit
definition RAY() returns uint256 = 10^27;
definition MAX_ARRAY_LENGTH() returns uint256 = max_uint;
// Used for the Ray math summarization.
// Effectively sets the liquidity index in L1 to be a constant, given
// by the following value.
// Note: if the summarization is not used, i.e. they are commented out,
// this value has no use.
definition myConstRayValue() returns uint256 = (10*RAY())/2;
// The following definition shall be used later in some invariants,
// by filtering out the 'initialize' function.
definition excludeInitialize(method f) returns bool =
    f.selector != 
    initialize(uint256, address, address, address[], uint256[], uint256[]).selector; 
// A filter for parametric rules.
// The functions receiveRewards and withdraw should not be called by an external user
// Unless a message was already sent, which we mock through the additional functions that
// call the L2 interface.
// Using this filter via:
// filtered{f -> messageSentFilter(f)} will reduce running time, by skipping the analysis
",This rule/invariant needs to be verified to ensure that certain functions are not called by external users without a message being sent through additional functions that call the L2 interface.,3
"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceBefore - senderATokenBalanceAfter - amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","This rule verifies that when depositing from either the underlying asset or aToken, the balances of the sender and recipient are updated correctly, according to whether the deposit is made from the underlying asset or the aToken.",5
"use invariant alwaysUnSent // Imports the invariant alwaysUnSent
use invariant ATokenAssetPair // Imports the invariant ATokenAssetPair

////////////////////////////////////////////////////////////////////////////
//                       Rules                                            //
// A call to deposit and a subsequent call to withdraw with the same amount of 
// staticATokens received, should yield the same original balance for the user.
// For underlying tokens, the condition is modified by a bound, since staticToDynamic is not inversible with dyanmicToStatic.
rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset
    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","This rule needs to be verified to ensure that a call to deposit followed by a call to withdraw with the same amount of staticATokens results in the same original balance for the user, while also considering the constraints on the underlying asset balance due to the non-inversibility of staticToDynamic and dynamicToStatic conversions.",5
"rule depositWithdrawReversed(uint256 amount)
{
    env eB; env eF;
    address Atoken; // AAVE Token
    address asset;  // underlying asset
    address static; // staticAToken
    uint256 l2Recipient = BRIDGE_L2.address2uint256(eF.msg.sender);
    uint16 referralCode;
    bool fromUA; // (deposit) from underlying asset
    bool toUA; // (withdraw) to underlying asset

    setupTokens(asset, Atoken, static);
    setupUser(eB.msg.sender);
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(asset);
    require indexL1 >= RAY() && indexL1 <= 2*RAY();
    uint256 balanceU1 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA1 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS1 = tokenBalanceOf(eB, static, eB.msg.sender);
        uint256 staticAmount = deposit(eB, Atoken, l2Recipient, amount, referralCode, fromUA);
    /////////////////////////
    /*
    One can use these values (post-deposit pre-withdrawal) for debugging.
    uint256 balanceU2 = tokenBalanceOf(eB, asset, eB.msg.sender);
    uint256 balanceA2 = tokenBalanceOf(eB, Atoken, eB.msg.sender);
    uint256 balanceS2 = tokenBalanceOf(eB, static, eB.msg.sender);
    */
        initiateWithdraw_L2(eF, Atoken, staticAmount, eB.msg.sender, toUA);
    uint256 balanceU3 = tokenBalanceOf(eF, asset, eB.msg.sender);
    uint256 balanceA3 = tokenBalanceOf(eF, Atoken, eB.msg.sender);
    uint256 balanceS3 = tokenBalanceOf(eF, static, eB.msg.sender);
    
    assert balanceS1 == balanceS3;
    assert fromUA == toUA => balanceU3 - balanceU1 <= (indexL1/RAY()+1)/2;
    assert fromUA == toUA => balanceA3 == balanceA1;
}
","This rule verifies that the amount deposited is withdrawn in the same asset type without any discrepancy in balances, and ensures that the static asset balance remains consistent throughout the deposit and withdrawal process.",5
"        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 

        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address aToken;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
","This rule ensures that when depositing funds, the sender's balances are updated correctly based on whether the deposit is made from the underlying asset or the aToken, and the recipient's balance is also updated accordingly.",5
"rule afterCancellationStartMustSucceed(uint256 amount, address user) {
    env e1; env e2;
    address asset;
    address aToken;
    address static;
    setupTokens(asset, aToken, static);
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    uint256 dynamic = _staticToDynamicAmount_Wrapper(amount, asset, LENDINGPOOL_L1);
    require amount < 2^127;
    require tokenBalanceOf(e2, aToken, currentContract) >= dynamic;
    require tokenBalanceOf(e2, asset, currentContract) >= amount;
    require e1.block.timestamp > 0;
    require e2.block.timestamp > e1.block.timestamp;
    startDepositCancellation(e1, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit@withrevert(e2, aToken, amount, recipient, rewardsIndex, blockNumber, nonce);
    bool cancelReverted = lastReverted;
    assert cancelReverted <=> !readyToCancel(e2, nonce);
}
","This rule verifies that a deposit cancellation can only succeed if certain conditions are met, including the availability of the specified amount in the contract's token balances and a temporal ordering of steps.",3
"rule cannotCancelDepositAndGainBothTokens(address user, uint256 amount) {
    env e1; env e2; env e3;
    calldataarg args1;
    address asset;
    address aToken;
    address static;
    uint256 recipient = BRIDGE_L2.address2uint256(user);
    uint16 code;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;

    setupTokens(asset, aToken, static);
    setupUser(user);
    require user == e1.msg.sender;
    require user == e2.msg.sender;
    require user == e3.msg.sender;
    
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance1 = tokenBalanceOf(e1, static, user);
    uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
    uint256 ATokenBalance2 = tokenBalanceOf(e1, aToken, user);
    uint256 staticBalance2 = tokenBalanceOf(e1, static, user);
    startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance3 = tokenBalanceOf(e3, aToken, user);
    uint256 staticBalance3 = tokenBalanceOf(e3, static, user);
    // If static tokens were minted, no deposit cancellation should succeed.
        Expands on integrityOfDeposit rule 
        If depositing from underlying asset, then:
        (1) Sender's underlying asset should decrease by amount deposited
        (2) Sender's aToken balance should remain the same
        (3) Recipient's staticAToken balance should increase by (static) amount deposited 
        If depositing from aToken, then:
        (1) Sender's underlying asset should remain the same
        (2) Sender's aToken balance should decrease by amount deposited (according to bound)
        (3) Recipient's staticAToken balance should increased by (static) amount deposited
    @Methods:
        deposit
    @Sanity:
        PASSES
    @Outcome:
        PASSES (after Cerotra fix)
*/
rule integrityOfDepositExpanded(){
    env e; 
    address recipient;
    uint256 amount;
    address underlyingAsset; 
    address staticAToken;
    uint256 l2Recipient = BRIDGE_L2.address2uint256(recipient);
    uint16 referralCode;
    bool fromUnderlyingAsset; 
    uint256 indexL1 = LENDINGPOOL_L1.liquidityIndexByAsset(underlyingAsset);
    setupTokens(underlyingAsset, aToken, staticAToken);
    setupUser(e.msg.sender);
    setupUser(recipient);
    requireRayIndex(underlyingAsset);
    // Recipient balances before
    uint256 recipientUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceBefore = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances before
    uint256 senderUnderlyingAssetBalanceBefore = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceBefore = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceBefore = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceBefore = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
    uint256 staticAmount = deposit(e, aToken, l2Recipient, amount, referralCode, fromUnderlyingAsset);
    // Recipient balances after
    uint256 recipientUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, recipient);
    uint256 recipientATokenBalanceAfter = tokenBalanceOf(e, aToken, recipient);
    uint256 recipientStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, recipient);
    uint256 recipientRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, recipient);
    // Sender balances after
    uint256 senderUnderlyingAssetBalanceAfter = tokenBalanceOf(e, underlyingAsset, e.msg.sender);
    uint256 senderATokenBalanceAfter = tokenBalanceOf(e, aToken, e.msg.sender);
    uint256 senderStaticATokenBalanceAfter = tokenBalanceOf(e, staticAToken, e.msg.sender);
    uint256 senderRewardTokenBalanceAfter = tokenBalanceOf(e, REWARD_TOKEN, e.msg.sender); 
           
    if (fromUnderlyingAsset){
        assert 
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore - amount) &&
        (senderATokenBalanceAfter == senderATokenBalanceBefore) &&
        (recipientStaticATokenBalanceAfter == recipientStaticATokenBalanceBefore + staticAmount);
    }
    else {
        (senderUnderlyingAssetBalanceAfter == senderUnderlyingAssetBalanceBefore) &&
        (senderATokenBalanceAfter - senderATokenBalanceBefore + amount <= (indexL1/RAY() + 1)/2) &&
    if (e.msg.sender != recipient) {
        (senderStaticATokenBalanceAfter == senderStaticATokenBalanceBefore) &&
        (recipientUnderlyingAssetBalanceAfter == recipientUnderlyingAssetBalanceBefore) &&
        (recipientATokenBalanceAfter == recipientATokenBalanceBefore);
    assert senderRewardTokenBalanceAfter == senderRewardTokenBalanceBefore &&
           recipientRewardTokenBalanceAfter == recipientRewardTokenBalanceBefore;
}
    assert staticBalance2 > staticBalance1 => ATokenBalance3 == ATokenBalance2;
","This rule needs to verify that when a deposit is canceled, the user's balances of underlying asset, aToken, and staticAToken are adjusted correctly based on whether the deposit was made from underlying asset or aToken.",5
"rule initializeIntegrity(address AToken, address asset)
{
    env e;
    calldataarg args;

    // Post-constructor conditions
    require getUnderlyingAssetHelper(AToken) == 0;
    require getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == 0;
    
    initialize(e, args);
    assert (asset !=0 && AToken !=0) => (
        getUnderlyingAssetHelper(AToken) == asset 
        <=>
        getATokenOfUnderlyingAsset(LENDINGPOOL_L1, asset) == AToken);
}
",This rule verifies that the underlying asset and AToken are correctly initialized in relation to each other.,0
"rule cancelAfterDepositGivesBackExactAmount(uint256 amount) {
    
    env e1;
    env e2;
    env e3;
    address user = e1.msg.sender;
    address asset ;
    address aToken;
    address static ;
    address recipient;
    bool fromUA;
    uint256 rewardsIndex;
    uint256 blockNumber;
    uint256 nonce;
    uint16 code;

    setupTokens(asset, aToken, static);
    requireValidUser(user);
    requireRayIndex(asset);
    require e1.msg.sender == e2.msg.sender;
    require e2.msg.sender == e3.msg.sender;
    require e1.block.timestamp <= e2.block.timestamp;
    require e2.block.timestamp < e3.block.timestamp;
    uint256 ATokenBalance1 = tokenBalanceOf(e1, aToken, user);
    uint256 assetBalance1 = tokenBalanceOf(e1, asset, user);
        uint256 staticAmount = deposit(e1, aToken, recipient, amount, code, fromUA);
        startDepositCancellation(e2, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
        cancelDeposit(e3, aToken, staticAmount, recipient, rewardsIndex, blockNumber, nonce);
    uint256 ATokenBalance2 = tokenBalanceOf(e3, aToken, user);
    uint256 assetBalance2 = tokenBalanceOf(e3, asset, user);
    if(fromUA){
        assert assetBalance1 == assetBalance2 + amount;
        assert ATokenBalance2 == ATokenBalance1 + amount;  
    }
    else {
        assert assetBalance1 == assetBalance2;
        assert ATokenBalance1 == ATokenBalance2;
}
",This rule/invariant needs to be verified to ensure that cancelling a deposit returns the exact amount of assets deposited to the user.,5
"                  summarization is because the invariant does not claim anything about rewards.
    @Link: https://prover.certora.com/output/40577/370f63ee225743daba41087449111d8b/?anonymousKey=717499ff4fdcce2c8131025b4e00ade0e3a14200
*/
invariant allSharesAreBacked()
    previewRedeem(totalSupply()) <= stake_token.balanceOf(currentContract)
    {
        preserved stake(address to, uint256 amount) with (env e2)
        {
            require e2.msg.sender != currentContract;
        }
        preserved stakeWithPermit(address from, uint256 amount, uint256 deadline,
            uint8 v, bytes32 r, bytes32 s) with (env e3)
            require from != currentContract;
        preserved returnFunds(uint256 amount) with (env e4)
            require e4.msg.sender != currentContract;
        preserved initialize(address slashingAdmin, address cooldownPauseAdmin, address claimHelper,
                            uint256 maxSlashablePercentage, uint256 cooldownSeconds) with (env e5)
            require getExchangeRate() == INITIAL_EXCHANGE_RATE();
    }
",This invariant needs to be verified to ensure that all shares are backed by the stake token balance in the contract. It does not involve claims about rewards.,3
"invariant cooldownAmountNotGreaterThanBalance(address user)
    balanceOf(user) >= cooldownAmount(user)
    {
        preserved with (env e1)
        {
            requireInvariant cooldownDataCorrectness(user, e1);
            requireInvariant totalSupplyGreaterThanUserBalance(user);
invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
            requireInvariant cooldownDataCorrectness(user, e2);
            requireInvariant cooldownDataCorrectness(user, e3);
","This invariant needs to be verified to ensure that the cooldown amount for a user is not greater than their balance, and that the total supply is always greater than or equal to the user's balance.",3
"invariant totalSupplyGreaterThanUserBalance(address user)
    totalSupply() >= balanceOf(user)
    {
        preserved transferFrom(address from, address to, uint256 amount) with (env e2)
        {
            require balanceOf(from) + balanceOf(to) <= totalSupply();
        }
        preserved transfer(address to, uint256 amount) with (env e3)
            require balanceOf(e3.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeem(address to, uint256 amount) with (env e4)
            require to == user;
            require balanceOf(e4.msg.sender) + balanceOf(to) <= totalSupply();
        preserved redeemOnBehalf(address from, address to, uint256 amount) with (env e5)
        preserved claimRewardsAndRedeem(address to, uint256 claimAmount, uint256 redeemAmount) with (env e6)
            require balanceOf(e6.msg.sender) + balanceOf(to) <= totalSupply();
        preserved claimRewardsAndRedeemOnBehalf(address from, address to, uint256 claimAmount, uint256 redeemAmount) with (env e7)
    }
",This rule needs to be verified to ensure that the total supply of tokens is always greater than or equal to the balance of any user.,5
"rule integrityOfReturnFunds(uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract);

    uint256 balanceStakeTokenSenderBefore = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenSenderBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    returnFunds(e, amount);
    uint256 balanceStakeTokenSenderAfter = stake_token.balanceOf(e.msg.sender);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenVaultAfter > 0);
    assert balanceStakeTokenSenderAfter == balanceStakeTokenSenderBefore - amount;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore + amount;
}
","This rule verifies that the return of funds should decrease the balance of the sender and increase the balance of the contract by the specified amount, while ensuring that the maximum supply limits are not exceeded.",5
"rule returnFundsDecreaseExchangeRate(address receiver, uint256 amount) {
    env e;
    uint216 _ExchangeRate = getExchangeRate();

    // Currently, in the constructor, LOWER_BOUND = 10**decimals
    requireInvariant lowerBoundNotZero();
    returnFunds(e, amount);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ <= _ExchangeRate;
}
","This rule verifies that the exchange rate decreases after returning funds to a receiver, while ensuring that a specified minimum value is not zero.",0
"rule slashAndReturnFundsOfZeroDoesntChangeExchangeRate() {
    env e;
    address dest; uint256 amt = 0;
    uint216 _ER = getExchangeRate();
    storage initialStorage = lastStorage;

    slash(e, dest, amt);
    uint216 ER_AfterSlash = getExchangeRate();
    returnFunds(e, amt) at initialStorage;
    uint216 ER_AfterReturnFunds = getExchangeRate();
    assert(ER_AfterSlash == ER_AfterReturnFunds);
    assert(ER_AfterReturnFunds == _ER);
}
","This rule verifies that when funds are slashed and then returned back with a value of zero, it does not have any impact on the exchange rate in the system.",0
"    @Notes: We used the following require to prove, that violation of this rule happened
            when totalSupply() == 0:
            require f.selector == returnFunds(uint256).selector => totalSupply() != 0;
            This has been solved by Lukas in this commit:
            https://github.com/Certora/aave-stk-slashing-mgmt/pull/1/commits/8336dc0747965a06c7dc39b4f89273c4ef7ed18a
    @Link: https://prover.certora.com/output/40577/3fdb151c46c84b1ab323b99c80890273/?anonymousKey=68e37ada870b7b91c68a5eadaf6030f3989002a6
*/
rule exchangeRateNeverZero(method f) {
    env e; calldataarg args;
    uint216 _ER = getExchangeRate();
    require _ER != 0;

    f(e, args);
    uint216 ER_ = getExchangeRate();
    assert ER_ != 0;
}
",This rule verifies the invariant that the exchange rate should never be zero before and after a specific function is executed in the contract.,3
"rule slashingIncreaseExchangeRate(address receiver, uint256 amount) {
    env e; calldataarg args;

    uint216 _ExchangeRate = getExchangeRate();
    slash(e, args);
    uint216 ExchangeRate_ = getExchangeRate();
    assert ExchangeRate_ >= _ExchangeRate;
}
",This rule needs to be verified to ensure that the exchange rate does not decrease after slashing an amount of tokens for a receiver.,5
"rule airdropNotMutualized(uint256 amount){
    env e;
    uint216 exchangeRateBefore = getExchangeRate();
    stake_token.transfer(e, currentContract, amount);
    uint216 exchangeRateAfter = getExchangeRate();
    assert exchangeRateBefore == exchangeRateAfter;
}
","This rule needs to verify that when a certain amount of tokens are transferred to a contract, the exchange rate remains unchanged before and after the transfer.",5
"rule noSlashingMoreThanMax(uint256 amount, address recipient){
    env e;
    uint vaultBalanceBefore = stake_token.balanceOf(currentContract);
    require(vaultBalanceBefore < AAVE_MAX_SUPPLY());
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());
    uint256 maxSlashable = vaultBalanceBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();

    require (amount > maxSlashable);
    require (recipient != currentContract);
    slash(e, recipient, amount);
    uint vaultBalanceAfter = stake_token.balanceOf(currentContract);
    assert vaultBalanceBefore - vaultBalanceAfter == maxSlashable;
}
","This rule needs to verify that the amount being slashed does not exceed the maximum slashable percentage of the vault balance, and that the recipient is not the current contract.",3
"rule integrityOfSlashing(address to, uint256 amount){
    env e;
    require(amount < AAVE_MAX_SUPPLY());
    require(e.msg.sender != currentContract && to != currentContract);
    require(getMaxSlashablePercentage() >= PERCENTAGE_FACTOR() &&
        getMaxSlashablePercentage() <= MAX_PERCENTAGE());

    require(totalSupply() > 0 && totalSupply() < AAVE_MAX_SUPPLY());
    uint256 total = totalSupply();
    uint256 balanceStakeTokenToBefore = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultBefore = stake_token.balanceOf(currentContract);
    require(balanceStakeTokenToBefore < AAVE_MAX_SUPPLY());
    require(balanceStakeTokenVaultBefore < AAVE_MAX_SUPPLY());
    slash(e, to, amount);
    uint256 balanceStakeTokenToAfter = stake_token.balanceOf(to);
    uint256 balanceStakeTokenVaultAfter = stake_token.balanceOf(currentContract);
    uint256 maxSlashable = balanceStakeTokenVaultBefore * getMaxSlashablePercentage() / PERCENTAGE_FACTOR();
    uint256 amountToSlash;
    if (amount > maxSlashable) {
        amountToSlash = maxSlashable;
    } else {
        amountToSlash = amount;
    }
    assert balanceStakeTokenToAfter == balanceStakeTokenToBefore + amountToSlash;
    assert balanceStakeTokenVaultAfter == balanceStakeTokenVaultBefore - amountToSlash;
    assert inPostSlashingPeriod();
}
",This rule needs to be verified to ensure the integrity of slashing mechanics and that the correct amount is being slashed from the appropriate balances during the slashing process.,5
"rule LendIsBackedByAaveIncInitialize(env e, method f){
invariant LendIsBackedByAave()
    ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract)
    {
        preserved with (env e){
            require e.msg.sender != LEND1;
            require e.msg.sender != AAVE1;
        }
    }
    require e.msg.sender != LEND1;
    require e.msg.sender != AAVE1;
    require ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
    
    if (f.selector == initialize(address, uint256, uint256, uint256).selector){
        address aaveMerkleDistributor; uint256 lendToMigratorAmount; uint256 lendToLendAmount; uint256 lendToAaveAmount;
        initialize(e, aaveMerkleDistributor, lendToMigratorAmount, lendToLendAmount, lendToAaveAmount);
        address lendToken = LEND1;
        address[] tokens; uint256[] amounts;
        env e2;
        AAVE_ORIG.initialize(e, tokens, amounts, aaveMerkleDistributor, lendToken, lendToAaveAmount);   
    else {
        calldataarg args;
        f(e, args);

    assert ( (LEND1.totalSupply() - LEND1.balanceOf(LEND1)) ) / LEND_AAVE_RATIO() <= AAVE1.balanceOf(currentContract);
}",This rule/invariant needs to be verified to ensure that the amount of LEND tokens that can be converted to AAVE tokens does not exceed the available AAVE token balance in the contract.,0
"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     aggregator.initFlags(rand);
//     require configurator.freezeWasCalled() == false;
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool freezeReserveWasCalled = configurator.freezeWasCalled();
//     assert !allReservesBacked => freezeReserveWasCalled;
//     assert allReservesBacked => !freezeReserveWasCalled;
// }
","This rule/invariant needs to verify if an emergency action can only be executed if certain conditions are met, and the system state changes accordingly after the action is executed.",2
"// rule integrityOfExecuteEmergencyAction(bool rand) {
//     require _disableBorrowingCalled() == false;
//     aggregator.initFlags(rand);
//     bool allReservesBacked = areAllReservesBacked();

//     executeEmergencyAction();
//     bool disableBorrowingCalled = _disableBorrowingCalled();
//     assert !allReservesBacked => disableBorrowingCalled;
//     assert allReservesBacked => !disableBorrowingCalled;
// }
","This rule needs to verify that executing an emergency action will disable borrowing if all reserves are not backed, and enable borrowing if all reserves are backed.",0
"rule PoRFeedChange(address asset, address PoRFeed, address wrapper){
    
    address feedBefore = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperBefore = getBridgeWrapperForAsset(asset);
    method f; env e;
    call_f_with_params(f, e, asset, PoRFeed, wrapper);

    address feedAfter = getProofOfReserveFeedForAsset(asset);
    address bridgeWrapperAfter = getBridgeWrapperForAsset(asset);
    assert f.selector == enableProofOfReserveFeed(address, address).selector => (feedAfter != 0 && feedAfter == PoRFeed);
    assert f.selector == enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector => 
                        (feedAfter != 0 && feedAfter == PoRFeed && bridgeWrapperAfter != 0 && bridgeWrapperAfter == wrapper);
    assert f.selector == disableProofOfReserveFeed(address).selector => feedAfter == 0 && bridgeWrapperAfter == 0;
    assert (f.selector != enableProofOfReserveFeed(address, address).selector && 
            f.selector != disableProofOfReserveFeed(address).selector &&
            f.selector != enableProofOfReserveFeedWithBridgeWrapper(address, address, address).selector) => 
                        feedBefore == feedAfter && bridgeWrapperBefore == bridgeWrapperAfter;
}
","This rule verifies that when changing the Proof of Reserve feed for an asset, the new feed and optional bridge wrapper are correctly updated according to the specified parameters.",0
"rule noIncarnations2(uint256 actionsSetId)
{
	env e;
	execute(e, actionsSetId);
	assert getCurrentState(e, actionsSetId) != 0;
}
","This rule verifies that after executing a set of actions, the current state is not equal to zero.",3
"rule executeCannotCancel()
{
	env e;
	calldataarg args;
	uint256 calledSet;
	uint256 canceledSet;

	require getCurrentState(e, canceledSet) != 2;
	require getGuardian() != _mock(e);
	
	execute(e, calledSet);
	assert getCurrentState(e, canceledSet) != 2;
}
","This rule ensures that a specific action cannot be canceled once it has been executed, as verified by the state before and after the execution.",2
"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
",This rule/invariant needs to be verified to ensure that the cancellation of a queue is not allowed under certain conditions.,2
"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, id) == 0;
}
",This rule verifies that the queued state consistency of a certain action set is maintained by ensuring that the action has not been canceled or executed and that the current state is set to 0 after processing the message from the root.,2
"rule processMessageFromRootReachability()
{
	env e; calldataarg args;

	processMessageFromRoot(e, args);
	assert false;
}
",This rule needs to be verified to ensure that the function correctly processes a message from a root account and reaches a specific state of unreachability.,2
"rule holdYourHorses()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	
	uint256 delay = getDelay();
	processMessageFromRoot(e, args);
	execute@withrevert(e, actionsSetId);
	assert delay > 0 => lastReverted;
}
",This rule/invariant verifies that a certain delay must be greater than 0 if a specific condition is met after executing actions set in a specific environment.,2
"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
",This rule needs to be verified to ensure that an action set ID is not queued twice after being executed once.,2
"rule cancelExclusive(uint actionsSetId1, uint actionsSetId2)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId2);
		cancel(e, actionsSetId1);
	uint8 stateAfter = getCurrentState(e, actionsSetId2);

	assert actionsSetId1 != actionsSetId2 => stateBefore == stateAfter;
}
","This rule needs to be verified to ensure that cancelling actions in one set does not affect the state of another set, unless they are the same set.",2
"rule executedForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 1;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 1;
} 
",This rule ensures that a specified method is executed and results in the same state being maintained before and after the execution.,2
"rule cancelPriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	cancel(e1, args1);
	cancel@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
",This rule needs to verify that cancelling a privileged action without reverting resolves in a different message sender compared to cancelling with a revert.,2
"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","This rule/invariant needs to be verified to ensure that only the current contract can change its variables, and that actions set IDs are not queued twice after being executed once.",3
"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
","This rule needs to verify that a certain condition is met before and after processing a message, based on the current state and the set of actions performed.",2
"rule queuePriviliged()
{
	env e1;
	env e2;
	calldataarg args1;
	calldataarg args2;
	processMessageFromRoot(e1, args1);
	processMessageFromRoot@withrevert(e2, args2);
	assert e1.msg.sender != e2.msg.sender => lastReverted;
}
",This rule checks that privileged and non-privileged users cannot have the same access to a specific functionality when processing messages from the root. It ensures that a certain condition holds true when comparing the message senders between two different environments.,2
"rule executeFailsIfExpired(uint256 actionsSetId)
{
	env e;
	uint8 stateBefore = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	bool executeReverted = lastReverted;
	assert stateBefore == 3 => executeReverted;
}
","This rule checks whether an action set fails to execute if it is expired, by comparing the state before execution to the revert status after execution.",2
"rule executedValidTransition2(uint256 actionsSetId)
{
	env e;
	uint actionsSetId2;
	uint8 state1 = getCurrentState(e, actionsSetId);
		execute(e, actionsSetId2);
	uint8 state2 = getCurrentState(e, actionsSetId);

	assert actionsSetId2 == actionsSetId <=> state1 == 0 && state2 == 1;
}
",This rule verifies that executing a set of actions results in a valid transition between two states based on the current state of the environment.,2
"rule actionDuplicate()
{
	env e; 
	calldataarg args;

	processMessageFromRoot(e, args);
	processMessageFromRoot@withrevert(e, args);
	assert lastReverted;
}
","This rule checks that a specific action results in a reverted transaction when processed by a smart contract, thereby ensuring that the action is not executed successfully.",2
"rule afterQueueHashQueued(bytes32 actionHash)
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();

	bool queueBefore = isActionQueued(e, actionHash);
		processMessageFromRoot(e, args);
	bool queuedAfter = isActionQueued(e, actionHash);
		
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1))
			<=> !queueBefore && queuedAfter;
}
","This rule needs to verify that a specific actionHash is only queued after a certain condition is met, as determined by the processMessageFromRoot function.",2
"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
",This rule verifies that an action set ID cannot be queued twice after being executed once.,2
"rule onlyQueuedAreExecuted(bytes32 actionHash, uint256 actionsSetId)
{
	env e2; env e;
	calldataarg args;

	require isActionQueued(e, actionHash);
	// This is true in general, guardian is not a contract (is EOA).
	require getGuardian() != _mock(e);
		execute(e2, actionsSetId);
	bool queuedAfter = isActionQueued(e2, actionHash);
	
	assert (actionHash == ID2actionHash(actionsSetId, 0) ||
			actionHash == ID2actionHash(actionsSetId, 1)) 
			<=> !queuedAfter;
}
","This rule verifies that only actions that are in the queued state are executed, and enforces that actions must be executed in the order they were queued.",2
"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
",This rule needs to be verified to ensure that an action set is marked as 'queued' after processing a message from the root.,2
"rule queuedChangedCounter()
{
	env e;
	calldataarg args;
	uint256 count1 = getActionsSetCount();
		processMessageFromRoot(e, args);
	uint256 count2 = getActionsSetCount();

	assert count1 < max_uint => count2 == count1+1;
}
",This rule verifies that the counter for queued changes is incremented correctly after processing a message from the root and does not exceed the maximum possible value.,2
"rule canceledForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 2;
		f(e, args);
	assert getCurrentState(e2, actionsSetId) == 2;
}
",This rule needs to verify that a method is canceled forever in a specific state within a given actions set.,2
"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	processMessageFromRoot(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking processMessageFromRoot.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	processMessageFromRoot(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	processMessageFromRoot@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
","This rule/invariant needs to be verified to ensure that the same set of actions is not executed multiple times within the same time period, based on the delay set for each execution.",2
"rule queueDoesntModifyStateVariables()
{
	env e;
	calldataarg args;
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();

	// Call queue with one action in the set.
	processMessageFromRoot(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateIntact =  delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2;
	assert stateIntact,
		""_queue changed state variables unexpectedly"";
}
","This rule verifies that invoking a queue function does not modify state variables related to delay, grace period, minimum delay, maximum delay, or guardian address.",2
"// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
",This rule needs to be verified to ensure that an actions set is properly marked as 'queued' after invoking a specific function.,2
"rule gracePeriodChangedAffectsExecution(uint256 actionsSetId)
{
	env e; env e2;
	uint period;
	// Assume queued action set.
	require getCurrentState(e, actionsSetId) == 0;
	
	storage initialStorage = lastStorage;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	// Allow execution (assume does not revert)
	execute(e, actionsSetId);
	// Now check whether changing the grace period could lead to revert.
	updateGracePeriod(e, period) at initialStorage;
	uint8 stateAfterUpdate = getCurrentState(e, actionsSetId);
	execute@withrevert(e, actionsSetId);
	assert lastReverted <=> stateAfterUpdate == 3;
}*/",This rule needs to verify that changing the grace period does not lead to a revert during the execution of a queued action set.,2
"invariant minDelayLtMaxDelay()
	getMinimumDelay() <= getMaximumDelay()

// Only the current contract (executor) can change its variables.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
{
	env e;
	calldataarg args;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
rule whoChangedStateVariables(method f)
	// State variables before
	uint256 delay1 = getDelay();
	uint256 period1 = getGracePeriod();
	uint256 minDelay1 = getMinimumDelay();
	uint256 maxDelay1 = getMaximumDelay();
	address guardian1 = getGuardian();
	// Call function
	f(e, args);
	// State variables after
	uint256 delay2 = getDelay();
	uint256 period2 = getGracePeriod();
	uint256 minDelay2 = getMinimumDelay();
	uint256 maxDelay2 = getMaximumDelay();
	address guardian2 = getGuardian();
	bool stateChanged = !( delay1 == delay2 &&
		 period1 == period2 &&
		 minDelay1 == minDelay2 &&
		 maxDelay1 == maxDelay2 &&
		 guardian1 == guardian2);
	assert stateChanged => e.msg.sender == currentContract,
		""Someone else changed state variables"";
","This rule verifies that only the current contract can change its state variables, by requiring that any changes to the state variables must be made by the contract itself.",2
"rule noIncarnations3(uint256 actionsSetId)
{
	env e;
	calldataarg args;
	require actionsSetId <= getActionsSetCount();
	require getCurrentState(e, actionsSetId) != 0;
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 0;
}
",This rule verifies that a certain condition is met before and after a set of actions are performed within a smart contract function.,3
"rule queuedStateConsistency()
{
	env e;
	calldataarg args;
	uint256 id = getActionsSetCount();
	requireInvariant notCanceledNotExecuted(id);
	queue2(e, args);
	assert getCurrentState(e, id) == 0;
}
","This rule needs to be verified to ensure that when an action is queued, the state consistency remains intact and the current state remains unchanged.",2
"rule queueCannotCancel()
{
	env e;
	calldataarg args;
	uint256 actionsSetId;

	require getCurrentState(e, actionsSetId) != 2;
		queue2(e, args);
	assert getCurrentState(e, actionsSetId) != 2;
}
",This rule ensures that a certain action cannot be canceled if the contract is in a specific state.,2
"rule onlyCancelCanCancel(method f, uint actionsSetId)
{
	env e;
	calldataarg args;
	require getGuardian() != _mock(e);
	// Replace by !=2
	require getCurrentState(e, actionsSetId) != 2;

		f(e, args);
	assert getCurrentState(e, actionsSetId) == 2
			=> f.selector == cancel(uint256).selector;
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
",This rule needs to be verified to ensure that an action set ID is not queued twice after being executed once.,2
"rule expiredForever(method f, uint256 actionsSetId)
{
	env e; env e2;
	calldataarg args;
	require getCurrentState(e, actionsSetId) == 3;
	require e.block.timestamp <= e2.block.timestamp;
	 
	if (f.selector == updateGracePeriod(uint256).selector) {
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.

// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
		uint256 oldPeriod = getGracePeriod();
		updateGracePeriod(e, args);
		uint256 newPeriod = getGracePeriod();
		assert newPeriod <= oldPeriod =>
		getCurrentState(e2, actionsSetId) == 3;
	}
	else {
		f(e, args);
		assert getCurrentState(e2, actionsSetId) == 3;
	}	
} 
",This rule needs to be verified to ensure that an actions set ID is never queued twice after being executed once.,2
"rule sameExecutionTimesReverts()
{
	env e1; env e2;
	calldataarg args;
	uint256 delay;
	uint256 t1 = e1.block.timestamp;
	uint256 t2 = e2.block.timestamp;

	// Assume different blocks (block2 later than block1)
	require t1 < t2;
	// queue first set.
	queue2(e1, args);
	// Change the delay period.
	uint256 delay1 = getDelay();
		updateDelay(e1, delay);
	uint256 delay2 = getDelay();
	// Try to queue second set, with same arguments.
// A three-part rule to prove that:
// An action set ID is never queued twice, after being executed once.
// First part:
// Prove that an actions set is marked as 'queued'
// After invoking queue2.
rule noIncarnations1()
	env e;
	uint256 actionsSetId = getActionsSetCount();
	require actionsSetId < max_uint;
	requireInvariant notCanceledNotExecuted(actionsSetId);
	queue2(e, args);
	assert getCurrentState(e, actionsSetId) == 0
	&& actionsSetId < getActionsSetCount();
}
	queue2@withrevert(e2, args);
	assert t1 + delay1 == t2 + delay2 => lastReverted;
",This rule needs to be verified to ensure that an action set is not queued twice with the same arguments and that it is marked as 'queued' after the first invocation.,2
